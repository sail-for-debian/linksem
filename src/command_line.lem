open import Basic_classes
open import Function
open import String
open import String_extra
open import Tuple
open import Bool
open import List
open import List_extra
import Set
import Set_extra
open import Sorting
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show

(* Here we try to model the command line of GNU ld.bfd.
 * 
 * Some options are global modifiers affecting the link output. 
 * Others have effect only for some subset of input files.
 * Typically some mutually-exclusive possibilities exist
 * whereby each argument selects one such possibility for all subsequent input files, 
 * until a different argument selects another possibility for ensuring inputs.
 *)

type input_file_spec = Filename of string    (* /path/to/file.{o,a,so,...} -- might be script! *)
                     | Libname of string     (* -llib *)

val string_of_input_file_spec : input_file_spec -> string
let string_of_input_file_spec spec = 
    match spec with
        Filename(s) -> "file `" ^ s ^ "'"
        | Libname(s) -> "library `" ^ s ^ "'"
    end

instance (Show input_file_spec)
    let show = string_of_input_file_spec
end

type input_file_options = <| input_fmt : string
                           ; input_libpath : list string
                           ; input_link_sharedlibs : bool      (* -Bstatic *)
                           ; input_check_sections : bool
                           ; input_copy_dt_needed : bool
                           ; input_whole_archive : bool
                           ; input_as_needed : bool
                           |>
   
val null_input_file_options : input_file_options
let null_input_file_options = 
                      <| input_fmt = ""
                       ; input_libpath = []
                       ; input_link_sharedlibs = false
                       ; input_check_sections = false
                       ; input_copy_dt_needed = false
                       ; input_whole_archive = false
                       ; input_as_needed = false
                       |>

type output_kind = Executable
                 | SharedLibrary

type link_option = OutputFilename of string
                 | OutputKind of output_kind
                 | ForceCommonDefined of bool        (* -d, -dc, -dp *)
                 | Soname of string                  (* -soname *)
                 | EntryAddress of natural
                 | TextSegmentStart of natural
                 | RodataSegmentStart of natural
                 | LdataSegmentStart of natural
                 | BindFunctionsEarly                (* -Bsymbolic-functions *)
                 | BindNonFunctionsEarly              (* the remainder of -Bsymbolic *)
                 (* more here! *) 

val tagEqual : link_option -> link_option -> bool
let tagEqual opt1 opt2 = match (opt1, opt2) with
    (* FIXME: Lem BUG here! says "duplicate binding" *)
    (OutputFilename(_), OutputFilename(_)) -> true
    | (OutputKind(_), OutputKind(_)) -> true
    (* | (ForceCommonDefined, ForceCommonDefined) -> true *)
    | (Soname(_), Soname(_)) -> true
    (* | (EntryAddress, EntryAddress) -> true *)
    | (TextSegmentStart(_), TextSegmentStart(_)) -> true
    | (RodataSegmentStart(_), RodataSegmentStart(_)) -> true
    | (LdataSegmentStart(_), LdataSegmentStart(_)) -> true
    (* | (BindFunctionsEarly, BindFunctionsEarly) -> true *)
    (* | (BindNonFunctionsEarly, BindNonFunctionsEarly) -> true *)
    | _ -> false
end

(* To allow filtering out a previous setting for a given option, we define
 * an equality relation that is true if options are of the same constructor.
 * Seems like a bit of a HACK. *)
instance (Eq link_option)
    let (=) = fun opt1 -> 
        (fun opt2 -> 
            match (opt1, opt2) with 
                | (OutputFilename(_), OutputFilename(_))        -> true
                | (ForceCommonDefined(_), ForceCommonDefined(_)) -> true
                | (Soname(_), Soname(_)) -> true
                | (EntryAddress(_), EntryAddress(_)) -> true
                | _ -> false
            end
        )
    let (<>) = fun opt1 -> (fun opt2 -> not (opt1 = opt2))
end

type input_file_and_options = input_file_spec * input_file_options
type input_unit = File of input_file_and_options
                | Group of list (input_file_and_options)   (* NOT recursive *)
                | BuiltinControlScript (* for uniformity when processing script defs *)

val string_of_input_unit : input_unit -> string
let string_of_input_unit u = 
    match u with
        File(spec, opts) -> 
            "single " ^ (show spec)
       | Group(spec_opt_list) -> 
            "group: [" ^ (show (List.map (fun (spec, opts) -> spec) spec_opt_list)) ^ "]"
       | BuiltinControlScript -> "(built-in control script)"
    end

instance (Show input_unit)
    let show = string_of_input_unit
end

(* Reading the command-line: 
 * we encode the meaning of a linker command token 
 * using a reader function interpreting a list of argument definitions.
 * Lookahead is necessary: sometimes the interpretation of an option
 * depends on the next argument (e.g. whether it's a file, directory or another option).
 * The list of argument definitions is from lists of strings to constructor function invocations.
 * We use lists of strings since many options have synonyms.
 * The strings are interpreted as regular expressions and any matched groups are collected together
 * as a second argument list; this is because some arguments are of the form --blah=NUM or similar. *)
 
(* As we read the command line, we keep a current state which is the collection
 * of seen input files, seen whole-link options, and input file options that will
 * apply to any input files we add subsequently. *)
type command_state = <| input_units           : list input_unit
                      ; link_options          : set  link_option
                      ; current_input_options : input_file_options
                      ; current_group         : maybe (list input_file_and_options)
                      |>
                      
(* This is the "default state" when we start reading input options *)
val initial_state : list command_state (* the stack *)
let initial_state = [<| input_units = []
                     ; link_options = {OutputFilename("a.out"); OutputKind(Executable)}
                     ; current_input_options = <| input_fmt = "elf64-x86-64"   (* FIXME *)
                                                ; input_libpath = ["/usr/lib"] (* FIXME: this probably isn't the right place to supply the default search path *)
                                                ; input_link_sharedlibs = true
                                                ; input_check_sections = true
                                                ; input_copy_dt_needed = false
                                                ; input_whole_archive = false
                                                ; input_as_needed = true (* FIXME *)
                                                |>
                     ; current_group = Nothing
                     |>]

type interpreted_command_line = list input_unit * set link_option

val add_input_file : list command_state -> string -> list command_state
let add_input_file (state :: more) s = 
    let chars = toCharList s 
    in
    let spec = match chars with 
        #'-' :: #'l' :: more -> Libname(toString more)
        | #'-' :: more -> failwith ("not a valid option or input file: " ^ s)
        | _ -> Filename(s)
    end
    in
    if state.current_group = Nothing 
    then
        <| input_units = state.input_units ++ [File(spec, state.current_input_options)]
         ; link_options = state.link_options
         ; current_input_options = state.current_input_options
         ; current_group = state.current_group
         |> :: more
    else 
        <| input_units = state.input_units
         ; link_options = state.link_options
         ; current_input_options = state.current_input_options
         ; current_group = let toAppend = [(spec, state.current_input_options)] in 
            match state.current_group with Just l -> Just(l ++ toAppend) | Nothing -> Just(toAppend) 
            end
         |> :: more

val start_group : list command_state -> list command_state
let start_group (state :: more) = <|
           input_units = state.input_units
         ; link_options = state.link_options
         ; current_input_options = state.current_input_options
         ; current_group = match state.current_group with
                Nothing -> Just []
                | _ -> failwith "cannot nest groups"
            end
         |> :: more

val end_group : list command_state -> list command_state
let end_group (state :: more) = <|
           input_units = state.input_units ++ (match state.current_group with 
                Just l -> [Group(l)]
                | Nothing -> failwith "end group without start group"
            end)
         ; link_options = state.link_options
         ; current_input_options = state.current_input_options
         ; current_group = Nothing
         |> :: more

type option_token = string
type option_argspecs = list string * list string
type option_argvals = list string * list string

val set_or_replace_option : link_option -> list command_state -> list command_state
let set_or_replace_option opt state_list = 
    match state_list with
        [] -> failwith "error: no state"
        | state :: more -> 
            <| input_units = state.input_units
             ; link_options = Set.insert opt (Set.filter (fun existing -> existing <> opt) state.link_options)
             ; current_input_options = state.current_input_options
             ; current_group = state.current_group
             |> :: more
    end

val find_option_matching_tag : link_option -> set link_option -> maybe link_option
let rec find_option_matching_tag tag options = 
    List.find (tagEqual tag) (Set_extra.toList options)

val extract_hex_addend : char -> maybe natural
let extract_hex_addend x =
  if x = #'0' then
    Just 0
  else if x = #'1' then
    Just 1
  else if x = #'2' then
    Just 2
  else if x = #'3' then
    Just 3
  else if x = #'4' then
    Just 4
  else if x = #'5' then
    Just 5
  else if x = #'6' then
    Just 6
  else if x = #'7' then
    Just 7
  else if x = #'8' then
    Just 8
  else if x = #'9' then
    Just 9
  else if x = #'a' then
    Just 10
  else if x = #'b' then
    Just 11
  else if x = #'c' then
    Just 12
  else if x = #'d' then
    Just 13
  else if x = #'e' then
    Just 14
  else if x = #'f' then
    Just 15
  else
    Nothing

val accumulate_hex_chars : natural -> list char -> natural
let rec accumulate_hex_chars acc chars =
  match chars with
    | [] -> acc
    | x::xs ->
      match extract_hex_addend x with
        | Nothing     -> acc
        | Just addend ->
            accumulate_hex_chars (acc * 16 + addend) xs
      end
  end

val extract_dec_addend : char -> maybe natural
let extract_dec_addend x =
  if x = #'0' then
    Just 0
  else if x = #'1' then
    Just 1
  else if x = #'2' then
    Just 2
  else if x = #'3' then
    Just 3
  else if x = #'4' then
    Just 4
  else if x = #'5' then
    Just 5
  else if x = #'6' then
    Just 6
  else if x = #'7' then
    Just 7
  else if x = #'8' then
    Just 8
  else if x = #'9' then
    Just 9
  else
    Nothing

val accumulate_dec_chars : natural -> list char -> natural
let rec accumulate_dec_chars acc chars =
  match chars with
    | [] -> acc
    | x::xs ->
      match extract_dec_addend x with
        | Nothing     -> acc
        | Just addend ->
            accumulate_hex_chars (acc * 16 + addend) xs
      end
  end

val parse_address : string -> natural
let parse_address s = match toCharList s with
    #'0' :: #'x' :: more -> accumulate_hex_chars 0 more
    | chars -> accumulate_dec_chars 0 chars
end

type option_def = (list option_token) * option_argspecs * (option_argvals -> list command_state -> list command_state) * string

(* the table is a list of: ... options    and their arg names ... and the option's meaning as a function... and a help string *)
val command_line_table : list option_def
let command_line_table = [
  (* per-input options *) 
  (["-b"; "--format"],                            (["TARGET"], []),    fun args -> (fun state -> state), "Specify target for following input files");
  (["-L"; "--library-path"],                      (["DIRECTORY"], []), fun args -> (fun state -> state), "Add DIRECTORY to library search path");
  (["--as-needed"],                               ([], []),            fun _    -> (fun state -> state), "Only set DT_NEEDED for following dynamic libs if used");
  (["--no-as-needed"],                            ([], []),            fun _    -> (fun state -> state), "Always set DT_NEEDED for dynamic libraries mentioned on the command line");
  (["-Bdynamic"; "-dy"; "-call_shared"],          ([], []),            fun _    -> (fun state -> state), "Link against shared libraries");
  (["-Bstatic"; "-dn"; "-non_shared"; "-static"], ([], []),            fun _    -> (fun state -> state), "Do not link against shared libraries");
  (["--check-sections"],                          ([], []),            fun _    -> (fun state -> state), "Check section addresses for overlaps (default)  **srk** not sure it's per-input!");
  (["--no-check-sections"],                       ([], []),            fun _    -> (fun state -> state), "Do not check section addresses for overlaps     **srk** not sure it's per-input!");
  (["--copy-dt-needed-entries"],                  ([], []),            fun _    -> (fun state -> state), "Copy DT_NEEDED links mentioned inside DSOs that follow");
  (["--no-copy-dt-needed-entries"],               ([], []),            fun _    -> (fun state -> state), "Do not copy DT_NEEDED links mentioned inside DSOs that follow");
  (["--no-whole-archive"],                        ([], []),            fun _    -> (fun state -> state), "Turn off --whole-archive");
  (["-rpath-link"],                               (["PATH"], []),      fun _    -> (fun state -> state), "Set link time shared library search path        **srk** not sure it's per-input!");
  (["--whole-archive"],                           ([], []),            fun _    -> (fun state -> state), "Include all objects from following archives");
  (* linker plugin control *)
  (["-plugin"],                                   (["PLUGIN"], []),    fun _    -> (fun state -> state), "Load named plugin");
  (["-plugin-opt"],                               (["ARG"], []),       fun _    -> (fun state -> state), "Send arg to last-loaded plugin");
  (* output / whole-job options (some may be repeated with different args, but most not): *)
  (["-A"; "--architecture"],                      (["ARCH"], []),      fun _ -> (fun state -> state), "Set architecture");
  (["-EB"],                                       ([], []),            fun _ -> (fun state -> state), "Link big-endian objects");
  (["-EL"],                                       ([], []),            fun _ -> (fun state -> state), "Link little-endian objects");
  (["-R"; "--just-symbols"],                      (["DIR"], []),       fun _ -> (fun state -> state), "**srk** (if directory, same as --rpath)");
  (["-d"; "-dc"; "-dp"],                          ([], []),            fun _ -> (fun state -> state), "Force common symbols to be defined");
  (["-e"; "--entry"],                             (["ADDRESS"], []),   fun _ -> (fun state -> state), "Set start address");
  (["-E"; "--export-dynamic"],                    ([], []),            fun _ -> (fun state -> state), "Export all dynamic symbols");
  (["--no-export-dynamic"],                       ([], []),            fun _ -> (fun state -> state), "Undo the effect of --export-dynamic");
  (["-f"; "--auxiliary"],                         (["SHLIB"], []),     fun _ -> (fun state -> state), "Auxiliary filter for shared object symbol table");
  (["-F"; "--filter"],                            (["SHLIB"], []),     fun _ -> (fun state -> state), "Filter for shared object symbol table");
  (["-G"; "--gpsize"],                            (["SIZE"], []),      fun _ -> (fun state -> state), "Small data size (if no size, same as --shared) **srk NOTE this quirk!**");
  (["-h"; "-soname"],                             (["FILENAME"], []),  fun _ -> (fun state -> state), "Set internal name of shared library");
  (["-I"; "--dynamic-linker"],                    (["PROGRAM"], []),   fun _ -> (fun state -> state), "Set PROGRAM as the dynamic linker to use");
  (["--sysroot="],                                ([], ["DIRECTORY"]), fun _ -> (fun state -> state), "Override the default sysroot location");
  (["-m"],                                        (["EMULATION"], []), fun _ -> (fun state -> state), "Set emulation");
  (["-n"; "--nmagic"],                            ([], []),            fun _ -> (fun state -> state), "Do not page align data");
  (["-N"; "--omagic"],                            ([], []),            fun _ -> (fun state -> state), "Do not page align data, do not make text readonly");
  (["--no-omagic"],                               ([], []),            fun _ -> (fun state -> state), "Page align data, make text readonly");
  (["-o"; "--output"],                            (["FILE"], []),      fun argvals -> set_or_replace_option (OutputFilename(head (fst argvals))), "Set output file name");
  (["-O"],                                        ([], []),            fun _ -> (fun state -> state), "Optimise output file");
  (["-q"; "--emit-relocs"],                       ([], []),            fun _ -> (fun state -> state), "Generate relocations in final output");
  (["-r"; "-i"; "--relocatable"],                 ([], []),            fun _ -> (fun state -> state), "Generate relocatable output");
  (["-s"; "--strip-all"],                         ([], []),            fun _ -> (fun state -> state), "Strip all symbols");
  (["-S"; "--strip-debug"],                       ([], []),            fun _ -> (fun state -> state), "Strip debugging symbols");
  (["--strip-discarded"],                         ([], []),            fun _ -> (fun state -> state), "Strip symbols in discarded sections");
  (["--no-strip-discarded"],                      ([], []),            fun _ -> (fun state -> state), "Do not strip symbols in discarded sections");
  (["--default-script"; "-dT"],                   (["FILE"], []),      fun _ -> (fun state -> state), "Read default linker script");
  (["--unique="],                                 ([], ["SECTION"]),   fun _ -> (fun state -> state), "Don't merge input [SECTION | orphan] sections");
  (["-Ur"],                                       ([], []),            fun _ -> (fun state -> state), "Build global constructor/destructor tables ( **srk**: like -r, but... )");
  (["-x"; "--discard-all"],                       ([], []),            fun _ -> (fun state -> state), "Discard all local symbols");
  (["-X"; "--discard-locals"],                    ([], []),            fun _ -> (fun state -> state), "Discard temporary local symbols (default)");
  (["--discard-none"],                            ([], []),            fun _ -> (fun state -> state), "Don't discard any local symbols");
  (["-Bsymbolic"],                                ([], []),            fun argvals -> (fun state -> set_or_replace_option BindFunctionsEarly (set_or_replace_option BindNonFunctionsEarly state)), "Bind global references locally");
  (["-Bsymbolic-functions"],                      ([], []),            fun argvals -> set_or_replace_option (BindFunctionsEarly), "Bind global function references locally");
  (["--force-exe-suffix"],                        ([], []),            fun _ -> (fun state -> state), "Force generation of file with .exe suffix");
  (["--gc-sections"],                             ([], []),            fun _ -> (fun state -> state), "**srk: uncertain: can repeat?** Remove unused sections (on some targets)");
  (["--no-gc-sections"],                          ([], []),            fun _ -> (fun state -> state), "**srk: uncertain: can repeat?** Don't remove unused sections (default)");
  (["--hash-size="],                              ([], ["NUMBER"]),    fun _ -> (fun state -> state), "Set default hash table size close to <NUMBER>");
  (["--no-define-common"],                        ([], []),            fun _ -> (fun state -> state), "Do not define Common storage");
  (["--no-undefined"],                            ([], []),            fun _ -> (fun state -> state), "Do not allow unresolved references in object files");
  (["--allow-shlib-undefined"],                   ([], []),            fun _ -> (fun state -> state), "Allow unresolved references in shared libraries");
  (["--no-allow-shlib-undefined"],                ([], []),            fun _ -> (fun state -> state), "Do not allow unresolved references in shared libs");
  (["--default-symver"],                          ([], []),            fun _ -> (fun state -> state), "Create default symbol version");
  (["--default-imported-symver"],                 ([], []),            fun _ -> (fun state -> state), "Create default symbol version for imported symbols");
  (["-nostdlib"],                                 ([], []),            fun _ -> (fun state -> state), "Only use library directories specified on the command line");
  (["--oformat"],                                 (["TARGET"], []),    fun _ -> (fun state -> state), "Specify target of output file");
  (["--relax"],                                   ([], []),            fun _ -> (fun state -> state), "Reduce code size by using target specific optimisations");
  (["--no-relax"],                                ([], []),            fun _ -> (fun state -> state), "Do not use relaxation techniques to reduce code size");
  (["--retain-symbols-file"],                     (["FILE"], []),      fun _ -> (fun state -> state), "Keep only symbols listed in FILE");
  (["-rpath"],                                    (["PATH"], []),      fun _ -> (fun state -> state), "Set runtime shared library search path");
  (["-shared"; "-Bshareable"],                    ([], []),            fun argvals -> set_or_replace_option (OutputKind(SharedLibrary)), "Create a shared library");
  (["-pie"; "--pic-executable"],                  ([], []),            fun _ -> (fun state -> state), "Create a position independent executable");
  (["--sort-common="],(* (ascending|descending) *)([], ["order"]),     fun _ -> (fun state -> state), "Sort common symbols by alignment [in specified order]");
  (["--sort-section="],(* (name|alignment) *)     ([], ["key"]),       fun _ -> (fun state -> state), "Sort sections by name or maximum alignment");
  (["--spare-dynamic-tags"],                      (["COUNT"], []),     fun _ -> (fun state -> state), "How many tags to reserve in .dynamic section");
  (["--split-by-file="],                          ([], ["SIZE"]),      fun _ -> (fun state -> state), "Split output sections every SIZE octets");
  (["--split-by-reloc="],                         ([], ["COUNT"]),     fun _ -> (fun state -> state), "Split output sections every COUNT relocs");
  (["--traditional-format"],                      ([], []),            fun _ -> (fun state -> state), "Use same format as native linker");
  (["--unresolved-symbols="],                     ([], ["method"]),    fun _ -> (fun state -> state), "How to handle unresolved symbols.  <method> is: ignore-all, report-all, ignore-in-object-files, ignore-in-shared-libs");
  (["--dynamic-list-data"],                       ([], []),            fun _ -> (fun state -> state), "Add data symbols to dynamic list");
  (["--dynamic-list-cpp-new"],                    ([], []),            fun _ -> (fun state -> state), "Use C++ operator new/delete dynamic list");
  (["--dynamic-list-cpp-typeinfo "],              ([], []),            fun _ -> (fun state -> state), "Use C++ typeinfo dynamic list");
  (["--dynamic-list"],                            (["FILE"], []),      fun _ -> (fun state -> state), "Read dynamic list");
  (["--wrap"],                                    (["SYMBOL"], []),    fun _ -> (fun state -> state), "Use wrapper functions for SYMBOL");
  (* the following are specific to ELF emulations *)
  (["--audit=(.*)"],                              ([], ["AUDITLIB"]),  fun _ -> (fun state -> state), "Specify a library to use for auditing");
  (["-Bgroup"],                                   ([], []),            fun _ -> (fun state -> state), "Selects group name lookup rules for DSO");
  (["--build-id="],                               ([], ["STYLE"]),     fun _ -> (fun state -> state), "Generate build ID note");
  (["-P"],                                        (["AUDITLIB"], []),  fun _ -> (fun state -> state), "Specify a library to use for auditing dependencies");
  (["--depaudit="],                               ([], ["AUDITLIB"]),  fun _ -> (fun state -> state), "Specify a library to use for auditing dependencies");
  (["--disable-new-dtags"],                       ([], []),            fun _ -> (fun state -> state), "Disable new dynamic tags");
  (["--enable-new-dtags"],                        ([], []),            fun _ -> (fun state -> state), "Enable new dynamic tags");
  (["--eh-frame-hdr"],                            ([], []),            fun _ -> (fun state -> state), "Create .eh_frame_hdr section");
  (["--exclude-libs="],                           ([], ["LIBS"]),      fun _ -> (fun state -> state), "Make all symbols in LIBS hidden");
  (["--hash-style="],                             ([], ["STYLE"]),     fun _ -> (fun state -> state), "Set hash style to sysv, gnu or both");
  (* NOTE: for these to work, we hack our word-splitter to merge -z options into a single word with a single space in *)
  (["-z combreloc"],                              ([], []),            fun _ -> (fun state -> state), "Merge dynamic relocs into one section and sort");
  (["-z common-page-size="],                      ([], ["SIZE"]),      fun _ -> (fun state -> state), "Set common page size to SIZE");
  (["-z defs"],                                   ([], []),            fun _ -> (fun state -> state), "Report unresolved symbols in object files.");
  (["-z execstack"],                              ([], []),            fun _ -> (fun state -> state), "Mark executable as requiring executable stack");
  (["-z global"],                                 ([], []),            fun _ -> (fun state -> state), "Make symbols in DSO available for subsequently loaded objects");
  (["-z initfirst"],                              ([], []),            fun _ -> (fun state -> state), "Mark DSO to be initialized first at runtime");
  (["-z interpose"],                              ([], []),            fun _ -> (fun state -> state), "Mark object to interpose all DSOs but executable");
  (["-z lazy"],                                   ([], []),            fun _ -> (fun state -> state), "Mark object lazy runtime binding (default)");
  (["-z loadfltr"],                               ([], []),            fun _ -> (fun state -> state), "Mark object requiring immediate process");
  (["-z max-page-size="],                         ([], ["SIZE"]),      fun _ -> (fun state -> state), "Set maximum page size to SIZE");
  (["-z nocombreloc"],                            ([], []),            fun _ -> (fun state -> state), "Don't merge dynamic relocs into one section");
  (["-z nocopyreloc"],                            ([], []),            fun _ -> (fun state -> state), "Don't create copy relocs");
  (["-z nodefaultlib"],                           ([], []),            fun _ -> (fun state -> state), "Mark object not to use default search paths");
  (["-z nodelete"],                               ([], []),            fun _ -> (fun state -> state), "Mark DSO non-deletable at runtime");
  (["-z nodlopen"],                               ([], []),            fun _ -> (fun state -> state), "Mark DSO not available to dlopen");
  (["-z nodump"],                                 ([], []),            fun _ -> (fun state -> state), "Mark DSO not available to dldump");
  (["-z noexecstack"],                            ([], []),            fun _ -> (fun state -> state), "Mark executable as not requiring executable stack");
  (["-z norelro"],                                ([], []),            fun _ -> (fun state -> state), "Don't create RELRO program header");
  (["-z now"],                                    ([], []),            fun _ -> (fun state -> state), "Mark object non-lazy runtime binding");
  (["-z origin"],                                 ([], []),            fun _ -> (fun state -> state), "Mark object requiring immediate $ORIGIN processing at runtime");
  (["-z relro"],                                  ([], []),            fun _ -> (fun state -> state), "Create RELRO program header");
  (["-z stacksize="],                             ([], ["SIZE"]),      fun _ -> (fun state -> state), "Set size of stack segment");
  (["-z bndplt"],                                 ([], []),            fun _ -> (fun state -> state), "Always generate BND prefix in PLT entries");
  (["--ld-generated-unwind-info"],                ([], []),            fun _ -> (fun state -> state), "Generate exception handling info for PLT.");
  (["--no-ld-generated-unwind-info"],             ([], []),            fun _ -> (fun state -> state), "Don't do so.");
  (* quasi-input options (can be repeated): *)
  (["-c"; "--mri-script"],                        (["FILE"], []),            fun _ -> (fun state -> state), "Read MRI format linker script");
  (["-l"; "--library"],                           (["LIBNAME"], []),         fun _ -> (fun state -> state), "Search for library LIBNAME");
  (* (["-R" ,"--just-symbols"],                   (["FILE"], []),            fun _ -> (fun state -> state), "Just link symbols"), *) (* Handled above! *)
  (["-T"; "--script"],                            (["FILE"], []),            fun _ -> (fun state -> state), "Read linker script");
  (["-u"; "--undefined"],                         (["SYMBOL"], []),          fun _ -> (fun state -> state), "Start with undefined reference to SYMBOL");
  (["-("; "--start-group"],                       ([], []),                  fun _ -> (fun state -> start_group state), "Start a group");
  (["-)"; "--end-group"],                         ([], []),                  fun _ -> (fun state -> end_group state), "End a group");
  (["--defsym"],                                  (["SYMBOL=EXPRESSION"], []), fun _ -> (fun state -> state), "Define a symbol");
  (["-fini"],                                     (["SYMBOL"], []),          fun _ -> (fun state -> state), "Call SYMBOL at unload-time");
  (["-init"],                                     (["SYMBOL"], []),          fun _ -> (fun state -> state), "Call SYMBOL at load-time");
  (["--section-start"],                           (["SECTION=ADDRESS"], []), fun _ -> (fun state -> state), "Set address of named section");
  (["-Tbss"],                                     (["ADDRESS"], []),         fun _ -> (fun state -> state), "Set address of .bss section");
  (["-Tdata"],                                    (["ADDRESS"], []),         fun _ -> (fun state -> state), "Set address of .data section");
  (["-Ttext"],                                    (["ADDRESS"], []),         fun _ -> (fun state -> state), "Set address of .text section");
  (["-Ttext-segment"],                            (["ADDRESS"], []),         fun argvals -> set_or_replace_option (TextSegmentStart(parse_address (head (fst argvals)))), "Set address of text segment");
  (["-Trodata-segment"],                          (["ADDRESS"], []),         fun argvals -> set_or_replace_option (RodataSegmentStart(parse_address (head (fst argvals)))), "Set address of rodata segment");
  (["-Tldata-segment"],                           (["ADDRESS"], []),         fun argvals -> set_or_replace_option (LdataSegmentStart(parse_address (head (fst argvals)))), "Set address of ldata segment");
  (["--version-script"],                          (["FILE"], []),            fun _ -> (fun state -> state), "Read version information script");
  (["--version-exports-section"],                 (["SYMBOL"], []),          fun _ -> (fun state -> state), "Take export symbols list from .exports, using SYMBOL as the version.");
  (* linker internal debugging/diagnostics and performance tuning *)
  (["-M"; "--print-map"],                         ([], []),                  fun _ -> (fun state -> state), "Print map file on standard output");
  (["-t"; "--trace"],                             ([], []),                  fun _ -> (fun state -> state), "Trace file opens");
  (["-v"; "--version"],                           ([], []),                  fun _ -> (fun state -> state), "Print version information");
  (["-V"],                                        ([], []),                  fun _ -> (fun state -> state), "Print version and emulation information");
  (["-y"; "--trace-symbol"],                      (["SYMBOL"], []),          fun _ -> (fun state -> state), "Trace mentions of SYMBOL");
  (["--cref"],                                    ([], []),                  fun _ -> (fun state -> state), "Output cross reference table");
  (["--demangle="],                               ([], ["STYLE"]),             fun _ -> (fun state -> state), "Demangle symbol names [using STYLE]");
  (["--print-gc-sections"],                       ([], []),                  fun _ -> (fun state -> state), "List removed unused sections on stderr");
  (["--no-print-gc-sections"],                    ([], []),                  fun _ -> (fun state -> state), "Do not list removed unused sections");
  (["-Map"],                                      (["FILE"], []),            fun _ -> (fun state -> state), "Write a map file");
  (["-Map="],                                     ([], ["FILE"]),            fun _ -> (fun state -> state), "Write a map file");
  (["--help"],                                    ([], []),                  fun _ -> (fun state -> state), "Print option help");
  (["--no-keep-memory"],                          ([], []),                  fun _ -> (fun state -> state), "Use less memory and more disk I/O");
  (["--no-demangle"],                             ([], []),                  fun _ -> (fun state -> state), "Do not demangle symbol names");
  (["--print-output-format"],                     ([], []),                  fun _ -> (fun state -> state), "Print default output format");
  (["--print-sysroot"],                           ([], []),                  fun _ -> (fun state -> state), "Print current sysroot");
  (["--reduce-memory-overheads"],                 ([], []),                  fun _ -> (fun state -> state), "Reduce memory overheads, possibly taking much longer");
  (["--stats"],                                   ([], []),                  fun _ -> (fun state -> state), "Print memory usage statistics");
  (["--target-help"],                             ([], []),                  fun _ -> (fun state -> state), "Display target specific options");
  (["--verbose="],                                ([], ["NUMBER"]),          fun _ -> (fun state -> state), "Output lots of information during link");
  (* unknown *)
  (["--embedded-relocs"],                         ([], []),                  fun _ -> (fun state -> state), "Generate embedded relocs");
  (["--task-link"],                               (["SYMBOL"], []),          fun _ -> (fun state -> state), "Do task level linking");
  (* compatibility *)
  (["-a"],                                        (["KEYWORD"], []),         fun _ -> (fun state -> state), "Shared library control for HP/UX compatibility");
  (["-Y"],                                        (["PATH"], []),            fun _ -> (fun state -> state), "Default search path for Solaris compatibility");
  (* permissiveness controls (tightening/loosening) *)
  (["--accept-unknown-input-arch"],               ([], []),                  fun _ -> (fun state -> state), "Accept input files whose architecture cannot be determined");
  (["--no-accept-unknown-input-arch"],            ([], []),                  fun _ -> (fun state -> state), "Reject input files whose architecture is unknown");
  (["--fatal-warnings"],                          ([], []),                  fun _ -> (fun state -> state), "Treat warnings as errors");
  (["--no-fatal-warnings"],                       ([], []),                  fun _ -> (fun state -> state), "Do not treat warnings as errors (default)");
  (["--allow-multiple-definition"],               ([], []),                  fun _ -> (fun state -> state), "Allow multiple definitions");
  (["--no-undefined-version"],                    ([], []),                  fun _ -> (fun state -> state), "Disallow undefined version");
  (["--noinhibit-exec"],                          ([], []),                  fun _ -> (fun state -> state), "Create an output file even if errors occur");
  (["--error-unresolved-symbols"],                ([], []),                  fun _ -> (fun state -> state), "Report unresolved symbols as errors");
  (["--ignore-unresolved-symbol"],                (["SYMBOL"], []),          fun _ -> (fun state -> state), "Unresolved SYMBOL will not cause an error or warning");
  (* permissiveness, specific to ELF emulation *)
  (["-z muldefs"],                                ([], []),                  fun _ -> (fun state -> state), "Allow multiple definitions");
  (* warnings (enabling/disabling) *)
  (["--no-warn-mismatch"],                        ([], []),                  fun _ -> (fun state -> state), "Don't warn about mismatched input files");
  (["--no-warn-search-mismatch"],                 ([], []),                  fun _ -> (fun state -> state), "Don't warn on finding an incompatible library");
  (["--warn-common"],                             ([], []),                  fun _ -> (fun state -> state), "Warn about duplicate common symbols");
  (["--warn-constructors"],                       ([], []),                  fun _ -> (fun state -> state), "Warn if global constructors/destructors are seen");
  (["--warn-multiple-gp"],                        ([], []),                  fun _ -> (fun state -> state), "Warn if the multiple GP values are used");
  (["--warn-once"],                               ([], []),                  fun _ -> (fun state -> state), "Warn only once per undefined symbol");
  (["--warn-section-align"],                      ([], []),                  fun _ -> (fun state -> state), "Warn if start of section changes due to alignment");
  (["--warn-shared-textrel"],                     ([], []),                  fun _ -> (fun state -> state), "Warn if shared object has DT_TEXTREL");
  (["--warn-alternate-em"],                       ([], []),                  fun _ -> (fun state -> state), "Warn if an object has alternate ELF machine code");
  (["--warn-unresolved-symbols"],                 ([], []),                  fun _ -> (fun state -> state), "Report unresolved symbols as warnings");
  (* meta-options *)
  (["--push-state"],                              ([], []),                  fun _ -> (fun state -> state), "Push state of flags governing input file handling");
  (["--pop-state"],                               ([], []),                  fun _ -> (fun state -> state), "Pop state of flags governing input file handling")
(*(["@FILE"], [], fun _ -> (fun state -> state), "Read options from FILE") *) (* processed during word-splitting phase *);
]

val delete_trailing_equals: string -> maybe string
let delete_trailing_equals str = 
    let cs = toCharList str
    in
    if [#'='] = drop ((length cs) - 1) cs
        then Just (toString ((take ((length cs) - 1) cs)))
        else (* let _ = Missing_pervasives.errln ("No trailing equals: " ^ str)
            in *)
            Nothing

val string_following_equals_at : nat -> string -> maybe string
let string_following_equals_at pos str = 
    let (first, second) = List.splitAt pos (toCharList str)
    in match second with 
        #'=' :: rest -> Just (toString rest)
        | _ -> (* let _ = Missing_pervasives.errln ("No trailing equals at " ^ (show pos) ^ ": " ^ str)
            in *)
            Nothing
    end

val equal_modulo_trailing_equals : string -> string -> bool
let equal_modulo_trailing_equals argstr argdef = 
    (* we allow argdef to have a trailing equals; if it does, 
     * we allow the argstring to have the equals (or not) and trailing stuff,
     * which will become an arg  *)
    let result = match (delete_trailing_equals argdef) with 
        Just matched -> 
            let following_equals = string_following_equals_at (stringLength matched) argstr
            in
            match following_equals with 
                Just following -> (* okay; does the pre-equals part match? *)
                    matched = toString (List.take ((stringLength argdef) - 1) (toCharList argstr))
                | _ -> (* the argstr is allowed not to have a trailing equals *) argstr = matched
            end
        | Nothing -> (* no trailing equals *) argdef = argstr
    end
    in 
    (* let _ = Missing_pervasives.errln ("Do '" ^ argstr ^ "' and '" ^ argdef ^ "' match modulo trailing equals? " ^ (show result))
    in *) result
    

val matching_arg_and_alias : string -> list option_def -> maybe (string * option_def)
let rec matching_arg_and_alias arg options = match options with 
    [] -> Nothing
    | (aliases, argspec, meaning, doc) :: more_opts -> 
        match find (fun alias -> equal_modulo_trailing_equals arg alias) aliases with 
            Just found_alias -> Just (found_alias, (aliases, argspec, meaning, doc))
            | Nothing -> matching_arg_and_alias arg more_opts
        end
    end

(* We don't try to convert from strings to other things here; 
 * everything we record is either a bool, meaning option -A was "present", for some A,
 * or a string somearg, meaning option -A somearg was present, for some A. *)

(* The above suffices to understand each concrete argument. 
 * Now we define an "interpreted command line" that includes 
 * some useful structure. *)

val read_one_arg : list command_state -> list string -> (list command_state * list string)
let read_one_arg state_stack args =
    (* Get the first string and look it up in our table. *)
    match args with
        [] -> (state_stack, [])
    |   some_arg :: more -> match (matching_arg_and_alias some_arg command_line_table) with
            (* We need to handle argdefs that have trailing equals. This means 
             * an extra arg might follow the equals. We need some helper functions. *)
                Just (alias, (aliases, (argspec_extras, argspec_regex), meaning, doc)) ->
                    (* Return a new state, by applying the argument's meaning. 
                     * We have to supply the option's argument strings to the meaning function. *)
                    let argstrings = List.take (List.length argspec_extras) more
                    in 
                    let regex_matches = match delete_trailing_equals some_arg with
                        Just prefix -> 
                            match (string_following_equals_at ((stringLength alias) - 1) some_arg) with 
                                Just following_equals -> [following_equals]
                                | Nothing -> failwith "impossible: '=' not where it was a moment ago"
                            end
                        | Nothing -> []
                    end
                    in 
                    let new_state_stack = meaning (argstrings, regex_matches) state_stack
                    in
                    (new_state_stack, drop (length argspec_extras) more)
                | Nothing -> 
                    (* If we didn't match any args, we ought to be an input file. *)
                    (add_input_file state_stack some_arg, more)
            end
    end

(* To fold over the command-line arguments we need a fold that passes 
 * suffixes of the list, not individual elements, and gives us back
 * the continuation that we need to fold over: a pair of folded-value, new-list. *)
val foldl_suffix : forall 'a 'b. ('a -> list 'b -> ('a * list 'b)) -> 'a -> list 'b -> 'a (* originally foldl *)
let rec foldl_suffix f a l = match l with
  | []      -> a
  | x :: xs -> 
    let (new_a, new_list) = f a l
    in foldl_suffix f new_a new_list
end

(* the word-splitting in argv needs a little fixing up. *)
val cook_argv : list string -> list string -> list string
let rec cook_argv acc args = 
    match args with
        [] -> acc
      | "-z" :: more -> match more with 
         [] -> failwith "-z must be followed by another argument"
         | something :: yetmore -> cook_argv (acc ++ ["-z " ^ something]) yetmore
         end
      | something :: more -> cook_argv (acc ++ [something]) more
    end

val command_line : unit -> interpreted_command_line
let {ocaml} command_line = fun _ -> (
    let cooked_argv = cook_argv [] (tail argv)
    in
    (* Now we use our fold-alike. *)
    match foldl_suffix read_one_arg initial_state cooked_argv with
        state :: rest_of_stack -> (state.input_units, state.link_options)
        | _ -> failwith "no command state left"
    end
)
