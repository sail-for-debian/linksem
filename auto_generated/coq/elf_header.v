(* Generated by Lem from elf_header.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [elf_header] includes types, functions and other definitions for working with
  * ELF headers.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_function.
Require Export lem_function.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import lem_set.
Require Export lem_set.


Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import default_printing.
Require Export default_printing.

Require Import endianness.
Require Export endianness.


Require Import elf_types_native_uint.
Require Export elf_types_native_uint.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


(** Special section header table indices *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  * Present here instead of in elf_section_header_table.lem because a calculation
  * below requires this constant (i.e. forward reference in the ELF spec).
  *)
Definition shn_undef    :  nat :=  0.

(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears). Present here instead
  * of in elf_section_header_table.lem because a calculation below requires this
  * constant (i.e. forward reference in the ELF spec).
  *)
Definition shn_xindex    :  nat :=  S (S(16383 + 16383) + S(16383 + 16383)). (* 0xffff *)

(** ELF object file types.  Enumerates the ELF object file types specified in the
 *  System V ABI.  Values between [elf_ft_lo_os] and [elf_ft_hi_os] inclusive are
 *  reserved for operating system specific values typically defined in an
 *  addendum to the System V ABI for that operating system.  Values between
 *  [elf_ft_lo_proc] and [elf_ft_hi_proc] inclusive are processor specific and
 *  are typically defined in an addendum to the System V ABI for that processor
 *  series.
 *)

(** No file type *)
Definition elf_ft_none    :  nat :=  0.
(** Relocatable file *)
Definition elf_ft_rel    :  nat :=  1.
(** Executable file *)
Definition elf_ft_exec    :  nat :=  2.
(** Shared object file *)
Definition elf_ft_dyn    :  nat :=  3.
(** Core file *)
Definition elf_ft_core    :  nat :=  4.
(** Operating-system specific *)
Definition elf_ft_lo_os    :  nat :=  (16256 + 16256 + 16256 + 16256). (* 0xfe00 *)
(** Operating-system specific *)
Definition elf_ft_hi_os    :  nat :=  S(S(16319 + 16319) + S(16319 + 16319)). (* 0xfeff *)
(** Processor specific *)
Definition elf_ft_lo_proc    :  nat :=  16320 + 16320 + 16320 + 16320. (* 0xff00 *)
(** Processor specific *)
Definition elf_ft_hi_proc    :  nat := S (S(16383 + 16383) + S(16383 + 16383)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition is_operating_system_specific_object_file_type_value  (v : nat )  : bool :=  nat_gteb
  v elf_ft_lo_os && nat_lteb v elf_ft_hi_os.
(* [?]: removed value specification. *)

Definition is_processor_specific_object_file_type_value  (v : nat )  : bool :=  nat_gteb
  v elf_ft_lo_proc && nat_lteb v elf_ft_hi_proc.

(** ELF machine architectures *)

(** RISC-V *)
Definition elf_ma_riscv    :  nat :=  243.
(** AMD GPU architecture *)
Definition elf_ma_amdgpu    :  nat :=  224.
(** Moxie processor family *)
Definition elf_ma_moxie    :  nat :=  223.
(** FTDI Chip FT32 high performance 32-bit RISC architecture *)
Definition elf_ma_ft32    :  nat :=  222.
(** Controls and Data Services VISIUMcore processor *)
Definition elf_ma_visium    :  nat :=  221.
(** Zilog Z80 *)
Definition elf_ma_z80    :  nat :=  220.
(** CSR Kalimba architecture family *)
Definition elf_ma_kalimba    :  nat :=  219.
(** Nanoradio optimised RISC *)
Definition elf_ma_norc    :  nat :=  218.
(** iCelero CoolEngine *)
Definition elf_ma_cool    :  nat :=  217.
(** Cognitive Smart Memory Processor *)
Definition elf_ma_coge    :  nat :=  216.
(** Paneve CDP architecture family *)
Definition elf_ma_cdp    :  nat :=  215.
(** KM211 KVARC processor *)
Definition elf_ma_kvarc    :  nat :=  214.
(** KM211 KMX8 8-bit processor *)
Definition elf_ma_kmx8    :  nat :=  213.
(** KM211 KMX16 16-bit processor *)
Definition elf_ma_kmx16    :  nat :=  212.
(** KM211 KMX32 32-bit processor *)
Definition elf_ma_kmx32    :  nat :=  211.
(** KM211 KM32 32-bit processor *)
Definition elf_ma_km32    :  nat :=  210.
(** Microchip 8-bit PIC(r) family *)
Definition elf_ma_mchp_pic    :  nat :=  204.
(** XMOS xCORE processor family *)
Definition elf_ma_xcore    :  nat :=  203.
(** Beyond BA2 CPU architecture *)
Definition elf_ma_ba2    :  nat :=  202.
(** Beyond BA1 CPU architecture *)  
Definition elf_ma_ba1    :  nat :=  201.
(** Freescale 56800EX Digital Signal Controller (DSC) *)
Definition elf_ma_5600ex    :  nat :=  200.
(** 199 Renesas 78KOR family *)
Definition elf_ma_78kor    :  nat :=  199.
(** Broadcom VideoCore V processor *)
Definition elf_ma_videocore5    :  nat :=  198.
(** Renesas RL78 family *)
Definition elf_ma_rl78    :  nat :=  197.
(** Open8 8-bit RISC soft processing core *)
Definition elf_ma_open8    :  nat :=  196.
(** Synopsys ARCompact V2 *)
Definition elf_ma_arc_compact2    :  nat :=  195.
(** KIPO_KAIST Core-A 2nd generation processor family *)
Definition elf_ma_corea_2nd    :  nat :=  194.
(** KIPO_KAIST Core-A 1st generation processor family *)
Definition elf_ma_corea_1st    :  nat :=  193.
(** CloudShield architecture family *)
Definition elf_ma_cloudshield    :  nat :=  192.
(** Infineon Technologies SLE9X core *)
Definition elf_ma_sle9x    :  nat :=  179.
(** Intel L10M *)
Definition elf_ma_l10m    :  nat :=  180.
(** Intel K10M *)
Definition elf_ma_k10m    :  nat :=  181.
(** ARM 64-bit architecture (AARCH64) *)
Definition elf_ma_aarch64    :  nat :=  183.
(** Atmel Corporation 32-bit microprocessor family *)
Definition elf_ma_avr32    :  nat :=  185.
(** STMicroelectronics STM8 8-bit microcontroller *)
Definition elf_ma_stm8    :  nat :=  186.
(** Tilera TILE64 multicore architecture family *)
Definition elf_ma_tile64    :  nat :=  187.
(** Tilera TILEPro multicore architecture family *)
Definition elf_ma_tilepro    :  nat :=  188.
(** Xilinix MicroBlaze 32-bit RISC soft processor core *)
Definition elf_ma_microblaze    :  nat :=  189.
(** NVIDIA CUDA architecture *)
Definition elf_ma_cuda    :  nat :=  190.
(** Tilera TILE-Gx multicore architecture family *)
Definition elf_ma_tilegx    :  nat :=  191.
(** Cypress M8C microprocessor *)
Definition elf_ma_cypress    :  nat :=  161.
(** Renesas R32C series microprocessors *)
Definition elf_ma_r32c    :  nat :=  162.
(** NXP Semiconductors TriMedia architecture family *)
Definition elf_ma_trimedia    :  nat :=  163.
(** QUALCOMM DSP6 processor *)
Definition elf_ma_qdsp6    :  nat :=  164.
(** Intel 8051 and variants *)
Definition elf_ma_8051    :  nat :=  165.
(** STMicroelectronics STxP7x family of configurable and extensible RISC processors *)
Definition elf_ma_stxp7x    :  nat :=  166.
(** Andes Technology compact code size embedded RISC processor family *)
Definition elf_ma_nds32    :  nat :=  167.
(** Cyan Technology eCOG1X family *)
Definition elf_ma_ecog1x    :  nat :=  168.
(** Dallas Semiconductor MAXQ30 Core Micro-controllers *)
Definition elf_ma_maxq30    :  nat :=  169.
(** New Japan Radio (NJR) 16-bit DSP Processor *)
Definition elf_ma_ximo16    :  nat :=  170.
(** M2000 Reconfigurable RISC Microprocessor *)
Definition elf_ma_manik    :  nat :=  171.
(** Cray Inc. NV2 vector architecture *)
Definition elf_ma_craynv2    :  nat :=  172.
(** Renesas RX family *)
Definition elf_ma_rx    :  nat :=  173.
(** Imagination Technologies META processor architecture *)
Definition elf_ma_metag    :  nat :=  174.
(** MCST Elbrus general purpose hardware architecture *)
Definition elf_ma_mcst_elbrus    :  nat :=  175.
(** Cyan Technology eCOG16 family *)
Definition elf_ma_ecog16    :  nat :=  176.
(** National Semiconductor CompactRISC CR16 16-bit microprocessor *)
Definition elf_ma_cr16    :  nat :=  177.
(** Freescale Extended Time Processing Unit *)
Definition elf_ma_etpu    :  nat :=  178.
(** Altium TSK3000 core *)
Definition elf_ma_tsk3000    :  nat :=  131.
(** Freescale RS08 embedded processor *)
Definition elf_ma_rs08    :  nat :=  132.
(** Analog Devices SHARC family of 32-bit DSP processors *)
Definition elf_ma_sharc    :  nat :=  133.
(** Cyan Technology eCOG2 microprocessor *)
Definition elf_ma_ecog2    :  nat :=  134.
(** Sunplus S+core7 RISC processor *)
Definition elf_ma_ccore7    :  nat :=  135.
(** New Japan Radio (NJR) 24-bit DSP Processor *)
Definition elf_ma_dsp24    :  nat :=  136.
(** Broadcom VideoCore III processor *)
Definition elf_ma_videocore3    :  nat :=  137.
(** RISC processor for Lattice FPGA architecture *)
Definition elf_ma_latticemico32    :  nat :=  138.
(** Seiko Epson C17 family *)
Definition elf_ma_c17    :  nat :=  139.
(** The Texas Instruments TMS320C6000 DSP family *)
Definition elf_ma_c6000    :  nat :=  140.
(** The Texas Instruments TMS320C2000 DSP family *)
Definition elf_ma_c2000    :  nat :=  141.
(** The Texas Instruments TMS320C55x DSP family *)
Definition elf_ma_c5500    :  nat :=  142.
(** STMicroelectronics 64bit VLIW Data Signal Processor *)
Definition elf_ma_mmdsp_plus    :  nat :=  160.
(** LSI Logic 16-bit DSP Processor *)
Definition elf_ma_zsp    :  nat :=  79.
(** Donald Knuth's educational 64-bit processor *)
Definition elf_ma_mmix    :  nat :=  80.
(** Harvard University machine-independent object files *)
Definition elf_ma_huany    :  nat :=  81.
(** SiTera Prism *)
Definition elf_ma_prism    :  nat :=  82.
(** Atmel AVR 8-bit microcontroller *)
Definition elf_ma_avr    :  nat :=  83.
(** Fujitsu FR30 *)
Definition elf_ma_fr30    :  nat :=  84.
(** Mitsubishi D10V *)
Definition elf_ma_d10v    :  nat :=  85.
(** Mitsubishi D30V *)
Definition elf_ma_d30v    :  nat :=  86.
(** NEC v850 *)
Definition elf_ma_v850    :  nat :=  87.
(** Mitsubishi M32R *)
Definition elf_ma_m32r    :  nat :=  88.
(** Matsushita MN10300 *)
Definition elf_ma_mn10300    :  nat :=  89.
(** Matsushita MN10200 *)
Definition elf_ma_mn10200    :  nat :=  90.
(** picoJava *)
Definition elf_ma_pj    :  nat :=  91.
(** OpenRISC 32-bit embedded processor *)
Definition elf_ma_openrisc    :  nat :=  92.
(** ARC International ARCompact processor (old spelling/synonym: ELF_MA_ARC_A5) *)
Definition elf_ma_arc_compact    :  nat :=  93.
(** Tensilica Xtensa Architecture *)
Definition elf_ma_xtensa    :  nat :=  94.
(** Alphamosaic VideoCore processor *)
Definition elf_ma_videocore    :  nat :=  95.
(** Thompson Multimedia General Purpose Processor *)
Definition elf_ma_tmm_gpp    :  nat :=  96.
(** National Semiconductor 32000 series *)
Definition elf_ma_ns32k    :  nat :=  97.
(** Tenor Network TPC processor *)
Definition elf_ma_tpc    :  nat :=  98.
(** Trebia SNP 1000 processor *)
Definition elf_ma_snp1k    :  nat :=  99.
(** STMicroelectronics ST200 microcontroller *)
Definition elf_ma_st200    :  nat :=  100.
(** Ubicom IP2xxx microcontroller family *)
Definition elf_ma_ip2k    :  nat :=  101.
(** MAX Processor *)
Definition elf_ma_max    :  nat :=  102.
(** National Semiconductor CompactRISC microprocessor *)
Definition elf_ma_cr    :  nat :=  103.
(** Fujitsu F2MC16 *)
Definition elf_ma_f2mc16    :  nat :=  104.
(** Texas Instruments embedded microcontroller msp430 *)
Definition elf_ma_msp430    :  nat :=  105.
(** Analog Devices Blackfin (DSP) processor *)
Definition elf_ma_blackfin    :  nat :=  106.
(** S1C33 Family of Seiko Epson processors *)
Definition elf_ma_se_c33    :  nat :=  107.
(** Sharp embedded microprocessor *)
Definition elf_ma_sep    :  nat :=  108.
(** Arca RISC Microprocessor *)
Definition elf_ma_arca    :  nat :=  109.
(** Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University *)
Definition elf_ma_unicore    :  nat :=  110.
(** eXcess: 16/32/64-bit configurable embedded CPU *)
Definition elf_ma_excess    :  nat :=  111.
(** Icera Semiconductor Inc. Deep Execution Processor *)
Definition elf_ma_dxp    :  nat :=  112.
(** Altera Nios II soft-core processor *)
Definition elf_ma_altera_nios2    :  nat :=  113.
(** National Semiconductor CompactRISC CRX microprocessor *)
Definition elf_ma_crx    :  nat :=  114.
(** Motorola XGATE embedded processor *)
Definition elf_ma_xgate    :  nat :=  115.
(** Infineon C16x/XC16x processor *)
Definition elf_ma_c166    :  nat :=  116.
(** Renesas M16C series microprocessors *)
Definition elf_ma_m16c    :  nat :=  117.
(** Microchip Technology dsPIC30F Digital Signal Controller *)
Definition elf_ma_dspic30f    :  nat :=  118.
(** Freescale Communication Engine RISC core *)
Definition elf_ma_ce    :  nat :=  119.
(** Renesas M32C series microprocessors *)
Definition elf_ma_m32c    :  nat :=  120.
(** No machine *)
Definition elf_ma_none    :  nat :=  0.
(** AT&T WE 32100 *)
Definition elf_ma_m32    :  nat :=  1.
(** SPARC *)
Definition elf_ma_sparc    :  nat :=  2.
(** Intel 80386 *)
Definition elf_ma_386    :  nat :=  3.
(** Motorola 68000 *)
Definition elf_ma_68k    :  nat :=  4.
(** Motorola 88000 *)
Definition elf_ma_88k    :  nat :=  5.
(** Intel 80860 *)
Definition elf_ma_860    :  nat :=  7.
(** MIPS I Architecture *)
Definition elf_ma_mips    :  nat :=  8.
(** IBM System/370 Processor *)
Definition elf_ma_s370    :  nat :=  9.
(** MIPS RS3000 Little-endian *)
Definition elf_ma_mips_rs3_le    :  nat :=  10.
(** Hewlett-Packard PA-RISC *)
Definition elf_ma_parisc    :  nat :=  15.
(** Fujitsu VPP500 *)
Definition elf_ma_vpp500    :  nat :=  17.
(** Enhanced instruction set SPARC *)
Definition elf_ma_sparc32plus    :  nat :=  18.
(** Intel 80960 *)
Definition elf_ma_960    :  nat :=  19.
(** PowerPC *)
Definition elf_ma_ppc    :  nat :=  20.
(** 64-bit PowerPC *)
Definition elf_ma_ppc64    :  nat :=  21.
(** IBM System/390 Processor *)
Definition elf_ma_s390    :  nat :=  22.
(** IBM SPU/SPC *)
Definition elf_ma_spu    :  nat :=  23.
(** NEC V800 *)
Definition elf_ma_v800    :  nat :=  36.
(** Fujitsu FR20 *)
Definition elf_ma_fr20    :  nat :=  37.
(** TRW RH-32 *)
Definition elf_ma_rh32    :  nat :=  38.
(** Motorola RCE *)
Definition elf_ma_rce    :  nat :=  39.
(** ARM 32-bit architecture (AARCH32) *)
Definition elf_ma_arm    :  nat :=  40.
(** Digital Alpha *)
Definition elf_ma_alpha    :  nat :=  41.
(** Hitachi SH *)
Definition elf_ma_sh    :  nat :=  42.
(** SPARC Version 9 *)
Definition elf_ma_sparcv9    :  nat :=  43.
(** Siemens TriCore embedded processor *)
Definition elf_ma_tricore    :  nat :=  44.
(** Argonaut RISC Core, Argonaut Technologies Inc. *)
Definition elf_ma_arc    :  nat :=  45.
(** Hitachi H8/300 *)
Definition elf_ma_h8_300    :  nat :=  46.
(** Hitachi H8/300H *)
Definition elf_ma_h8_300h    :  nat :=  47.
(** Hitachi H8S *)
Definition elf_ma_h8s    :  nat :=  48.
(** Hitachi H8/500 *)
Definition elf_ma_h8_500    :  nat :=  49.
(** Intel IA-64 processor architecture *)
Definition elf_ma_ia_64    :  nat :=  50.
(** Stanford MIPS-X *)
Definition elf_ma_mips_x    :  nat :=  51.
(** Motorola ColdFire *)
Definition elf_ma_coldfire    :  nat :=  52.
(** Motorola M68HC12 *)
Definition elf_ma_68hc12    :  nat :=  53.
(** Fujitsu MMA Multimedia Accelerator *)
Definition elf_ma_mma    :  nat :=  54.
(** Siemens PCP *)
Definition elf_ma_pcp    :  nat :=  55.
(** Sony nCPU embedded RISC processor *)
Definition elf_ma_ncpu    :  nat :=  56.
(** Denso NDR1 microprocessor *)
Definition elf_ma_ndr1    :  nat :=  57.
(** Motorola Star*Core processor *)
Definition elf_ma_starcore    :  nat :=  58.
(** Toyota ME16 processor *)
Definition elf_ma_me16    :  nat :=  59.
(** STMicroelectronics ST100 processor *)
Definition elf_ma_st100    :  nat :=  60.
(** Advanced Logic Corp. TinyJ embedded processor family *)
Definition elf_ma_tinyj    :  nat :=  61.
(** AMD x86-64 architecture *)
Definition elf_ma_x86_64    :  nat :=  62.
(** Sony DSP Processor *)
Definition elf_ma_pdsp    :  nat :=  63.
(** Digital Equipment Corp. PDP-10 *)
Definition elf_ma_pdp10    :  nat :=  64.
(** Digital Equipment Corp. PDP-11 *)
Definition elf_ma_pdp11    :  nat :=  65.
(** Siemens FX66 microcontroller *)
Definition elf_ma_fx66    :  nat :=  66.
(** STMicroelectronics ST9+ 8/16 bit microcontroller *)
Definition elf_ma_st9plus    :  nat :=  67.
(** STMicroelectronics ST7 8-bit microcontroller *)
Definition elf_ma_st7    :  nat :=  68.
(** Motorola MC68HC16 Microcontroller *)
Definition elf_ma_68hc16    :  nat :=  69.
(** Motorola MC68HC11 Microcontroller *)
Definition elf_ma_68hc11    :  nat :=  70.
(** Motorola MC68HC08 Microcontroller *)
Definition elf_ma_68hc08    :  nat :=  71.
(** Motorola MC68HC05 Microcontroller *)
Definition elf_ma_68hc05    :  nat :=  72.
(** Silicon Graphics SVx *)
Definition elf_ma_svx    :  nat :=  73.
(** STMicroelectronics ST19 8-bit microcontroller *)
Definition elf_ma_st19    :  nat :=  74.
(** Digital VAX *)
Definition elf_ma_vax    :  nat :=  75.
(** Axis Communications 32-bit embedded processor *)
Definition elf_ma_cris    :  nat :=  76.
(** Infineon Technologies 32-bit embedded processor *)
Definition elf_ma_javelin    :  nat :=  77.
(** Element 14 64-bit DSP Processor *)
Definition elf_ma_firepath    :  nat :=  78.
(** Reserved by Intel *)
Definition elf_ma_intel209    :  nat :=  209.
(** Reserved by Intel *)
Definition elf_ma_intel208    :  nat :=  208.
(** Reserved by Intel *)
Definition elf_ma_intel207    :  nat :=  207.
(** Reserved by Intel *)
Definition elf_ma_intel206    :  nat :=  206.
(** Reserved by Intel *)
Definition elf_ma_intel205    :  nat :=  205.
(** Reserved by Intel *)
Definition elf_ma_intel182    :  nat :=  182.
(** Reserved by ARM *)
Definition elf_ma_arm184    :  nat :=  184.
(** Reserved for future use *)
Definition elf_ma_reserved6    :  nat :=  6.
(** Reserved for future use *)
Definition elf_ma_reserved11    :  nat :=  11.
(** Reserved for future use *)
Definition elf_ma_reserved12    :  nat :=  12.
(** Reserved for future use *)
Definition elf_ma_reserved13    :  nat :=  13.
(** Reserved for future use *)
Definition elf_ma_reserved14    :  nat :=  14.
(** Reserved for future use *)
Definition elf_ma_reserved16    :  nat :=  16.
(** Reserved for future use *)
Definition elf_ma_reserved24    :  nat :=  24.
(** Reserved for future use *)
Definition elf_ma_reserved25    :  nat :=  25.
(** Reserved for future use *)
Definition elf_ma_reserved26    :  nat :=  26.
(** Reserved for future use *)
Definition elf_ma_reserved27    :  nat :=  27.
(** Reserved for future use *)
Definition elf_ma_reserved28    :  nat :=  28.
(** Reserved for future use *)
Definition elf_ma_reserved29    :  nat :=  29.
(** Reserved for future use *)
Definition elf_ma_reserved30    :  nat :=  30.
(** Reserved for future use *)
Definition elf_ma_reserved31    :  nat :=  31.
(** Reserved for future use *)
Definition elf_ma_reserved32    :  nat :=  32.
(** Reserved for future use *)
Definition elf_ma_reserved33    :  nat :=  33.
(** Reserved for future use *)
Definition elf_ma_reserved34    :  nat :=  34.
(** Reserved for future use *)
Definition elf_ma_reserved35    :  nat :=  35.
(** Reserved for future use *)
Definition elf_ma_reserved121    :  nat :=  121.
(** Reserved for future use *)
Definition elf_ma_reserved122    :  nat :=  122.
(** Reserved for future use *)
Definition elf_ma_reserved123    :  nat :=  123.
(** Reserved for future use *)
Definition elf_ma_reserved124    :  nat :=  124.
(** Reserved for future use *)
Definition elf_ma_reserved125    :  nat :=  125.
(** Reserved for future use *)
Definition elf_ma_reserved126    :  nat :=  126.
(** Reserved for future use *)
Definition elf_ma_reserved127    :  nat :=  127.
(** Reserved for future use *)
Definition elf_ma_reserved128    :  nat :=  128.
(** Reserved for future use *)
Definition elf_ma_reserved129    :  nat :=  129.
(** Reserved for future use *)
Definition elf_ma_reserved130    :  nat :=  130.
(** Reserved for future use *)
Definition elf_ma_reserved143    :  nat :=  143.
(** Reserved for future use *)
Definition elf_ma_reserved144    :  nat :=  144.
(** Reserved for future use *)
Definition elf_ma_reserved145    :  nat :=  145.
(** Reserved for future use *)
Definition elf_ma_reserved146    :  nat :=  146.
(** Reserved for future use *)
Definition elf_ma_reserved147    :  nat :=  147.
(** Reserved for future use *)
Definition elf_ma_reserved148    :  nat :=  148.
(** Reserved for future use *)
Definition elf_ma_reserved149    :  nat :=  149.
(** Reserved for future use *)
Definition elf_ma_reserved150    :  nat :=  150.
(** Reserved for future use *)
Definition elf_ma_reserved151    :  nat :=  151.
(** Reserved for future use *)
Definition elf_ma_reserved152    :  nat :=  152.
(** Reserved for future use *)
Definition elf_ma_reserved153    :  nat :=  153.
(** Reserved for future use *)
Definition elf_ma_reserved154    :  nat :=  154.
(** Reserved for future use *)
Definition elf_ma_reserved155    :  nat :=  155.
(** Reserved for future use *)
Definition elf_ma_reserved156    :  nat :=  156.
(** Reserved for future use *)
Definition elf_ma_reserved157    :  nat :=  157.
(** Reserved for future use *)
Definition elf_ma_reserved158    :  nat :=  158.
(** Reserved for future use *)
Definition elf_ma_reserved159    :  nat :=  159.
(* [?]: removed value specification. *)


(** ELF version numbers.  Denotes the ELF version number of an ELF file.  Current is
  * defined to have a value of 1 with the present specification.  Extensions
  * may create versions of ELF with higher version numbers.
  *)

(** Invalid version *)
Definition elf_ev_none    :  nat :=  0.
(** Current version *)
Definition elf_ev_current    :  nat :=  1.
(* [?]: removed value specification. *)


(** Check that an extended version number is correct (i.e. greater than 1). *)
Definition is_valid_extended_version_number   (n : nat )  : bool :=  nat_gtb n( 1).

(** Identification indices.  The initial bytes of an ELF header (and an object
  * file) correspond to the e_ident member.
  *)

(** File identification *)
Definition elf_ii_mag0    :  nat :=  0.
(** File identification *)
Definition elf_ii_mag1    :  nat :=  1.
(** File identification *)
Definition elf_ii_mag2    :  nat :=  2.
(** File identification *)
Definition elf_ii_mag3    :  nat :=  3.
(** File class *)
Definition elf_ii_class    :  nat :=  4.
(** Data encoding *)
Definition elf_ii_data    :  nat :=  5.
(** File version *)
Definition elf_ii_version    :  nat :=  6.
(** Operating system/ABI identification *)
Definition elf_ii_osabi    :  nat :=  7.
(** ABI version *)
Definition elf_ii_abiversion    :  nat :=  8.
(** Start of padding bytes *)
Definition elf_ii_pad    :  nat :=  9.
(** Size of e*_ident[] *)
Definition elf_ii_nident    :  nat :=  16.

(** Magic number indices.  A file's first 4 bytes hold a ``magic number,''
  * identifying the file as an ELF object file.
  *)

(** Position: e*_ident[elf_ii_mag0], 0x7f magic number *)
Definition elf_mn_mag0    :  unsigned_char :=  unsigned_char_of_nat( 127).
(** Position: e*_ident[elf_ii_mag1], 'E' format identifier *)
Definition elf_mn_mag1    :  unsigned_char :=  unsigned_char_of_nat( 69).
(** Position: e*_ident[elf_ii_mag2], 'L' format identifier *)
Definition elf_mn_mag2    :  unsigned_char :=  unsigned_char_of_nat( 76).
(** Position: e*_ident[elf_ii_mag3], 'F' format identifier *)
Definition elf_mn_mag3    :  unsigned_char :=  unsigned_char_of_nat( 70).

(** ELf file classes.  The file format is designed to be portable among machines
  * of various sizes, without imposing the sizes of the largest machine on the
  * smallest. The class of the file defines the basic types used by the data
  * structures of the object file container itself.
  *)

(** Invalid class *)
Definition elf_class_none    :  nat :=  0.
(** 32 bit objects *)
Definition elf_class_32    :  nat :=  1.
(** 64 bit objects *)
Definition elf_class_64    :  nat :=  2.
(* [?]: removed value specification. *)


(** ELF data encodings.  Byte e_ident[elf_ei_data] specifies the encoding of both the
  * data structures used by object file container and data contained in object
  * file sections.
  *)

(** Invalid data encoding *)
Definition elf_data_none    :  nat :=  0.
(** Two's complement values, least significant byte occupying lowest address *)
Definition elf_data_2lsb    :  nat :=  1.
(** Two's complement values, most significant byte occupying lowest address *)
Definition elf_data_2msb    :  nat :=  2.
(* [?]: removed value specification. *)


(** OS and ABI versions.  Byte e_ident[elf_ei_osabi] identifies the OS- or
  * ABI-specific ELF extensions used by this file. Some fields in other ELF
  * structures have flags and values that have operating system and/or ABI
  * specific meanings; the interpretation of those fields is determined by the
  * value of this byte.
  *)

(** No extensions or unspecified *)
Definition elf_osabi_none    :  nat :=  0.
(** Hewlett-Packard HP-UX *)
Definition elf_osabi_hpux    :  nat :=  1.
(** NetBSD *)
Definition elf_osabi_netbsd    :  nat :=  2.
(** GNU *)
Definition elf_osabi_gnu    :  nat :=  3.
(** Linux, historical alias for GNU *)
Definition elf_osabi_linux    :  nat :=  3.
(** Sun Solaris *)
Definition elf_osabi_solaris    :  nat :=  6.
(** AIX *)
Definition elf_osabi_aix    :  nat :=  7.
(** IRIX *)
Definition elf_osabi_irix    :  nat :=  8.
(** FreeBSD *)
Definition elf_osabi_freebsd    :  nat :=  9.
(** Compaq Tru64 Unix *)
Definition elf_osabi_tru64    :  nat :=  10.
(** Novell Modesto *)
Definition elf_osabi_modesto    :  nat :=  11.
(** OpenBSD *)
Definition elf_osabi_openbsd    :  nat :=  12.
(** OpenVMS *)
Definition elf_osabi_openvms    :  nat :=  13.
(** Hewlett-Packard Non-stop Kernel *)
Definition elf_osabi_nsk    :  nat :=  14.
(** Amiga Research OS *)
Definition elf_osabi_aros    :  nat :=  15.
(** FenixOS highly-scalable multi-core OS *)
Definition elf_osabi_fenixos    :  nat :=  16.
(** Nuxi CloudABI *)
Definition elf_osabi_cloudabi    :  nat :=  17.
(** Stratus technologies OpenVOS *)
Definition elf_osabi_openvos    :  nat :=  18.

(** Checks an architecture defined OSABI version is correct, i.e. in the range
  * 64 to 255 inclusive.
  *)
Definition is_valid_architecture_defined_osabi_version   (n : nat )  : bool :=  nat_gteb
  n( 64) && nat_lteb n( 255).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition ei_nident   : nat :=  16.

(** [elf32_header] is the type of headers for 32-bit ELF files.
  *)
Record elf32_header : Type :=
  { elf32_ident    : list  unsigned_char  (** Identification field *)
   ; elf32_type     : elf32_half          (** The object file type *)
   ; elf32_machine  : elf32_half          (** Required machine architecture *)
   ; elf32_version  : elf32_word          (** Object file version *)
   ; elf32_entry    : elf32_addr          (** Virtual address for transfer of control *)
   ; elf32_phoff    : elf32_off           (** Program header table offset in bytes *)
   ; elf32_shoff    : elf32_off           (** Section header table offset in bytes *)
   ; elf32_flags    : elf32_word          (** Processor-specific flags *)
   ; elf32_ehsize   : elf32_half          (** ELF header size in bytes *)
   ; elf32_phentsize: elf32_half          (** Program header table entry size in bytes *)
   ; elf32_phnum    : elf32_half          (** Number of entries in program header table *)
   ; elf32_shentsize: elf32_half          (** Section header table entry size in bytes *)
   ; elf32_shnum    : elf32_half          (** Number of entries in section header table *)
   ; elf32_shstrndx : elf32_half          (** Section header table entry for section name string table *)
   }.
Notation "{[ r 'with' 'elf32_ident' := e ]}" := ({| elf32_ident := e; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_type' := e ]}" := ({| elf32_type := e; elf32_ident := elf32_ident r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_machine' := e ]}" := ({| elf32_machine := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_version' := e ]}" := ({| elf32_version := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_entry' := e ]}" := ({| elf32_entry := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_phoff' := e ]}" := ({| elf32_phoff := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_shoff' := e ]}" := ({| elf32_shoff := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_flags' := e ]}" := ({| elf32_flags := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_ehsize' := e ]}" := ({| elf32_ehsize := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_phentsize' := e ]}" := ({| elf32_phentsize := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_phnum' := e ]}" := ({| elf32_phnum := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_shentsize' := e ]}" := ({| elf32_shentsize := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shnum := elf32_shnum r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_shnum' := e ]}" := ({| elf32_shnum := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shstrndx := elf32_shstrndx r |}).
Notation "{[ r 'with' 'elf32_shstrndx' := e ]}" := ({| elf32_shstrndx := e; elf32_ident := elf32_ident r; elf32_type := elf32_type r; elf32_machine := elf32_machine r; elf32_version := elf32_version r; elf32_entry := elf32_entry r; elf32_phoff := elf32_phoff r; elf32_shoff := elf32_shoff r; elf32_flags := elf32_flags r; elf32_ehsize := elf32_ehsize r; elf32_phentsize := elf32_phentsize r; elf32_phnum := elf32_phnum r; elf32_shentsize := elf32_shentsize r; elf32_shnum := elf32_shnum r |}).
   
(** [elf64_header] is the type of headers for 64-bit ELF files.
  *)
Record elf64_header : Type :=
  { elf64_ident    : list  unsigned_char  (** Identification field *)
   ; elf64_type     : elf64_half          (** The object file type *)
   ; elf64_machine  : elf64_half          (** Required machine architecture *)
   ; elf64_version  : elf64_word          (** Object file version *)
   ; elf64_entry    : elf64_addr          (** Virtual address for transfer of control *)
   ; elf64_phoff    : elf64_off           (** Program header table offset in bytes *)
   ; elf64_shoff    : elf64_off           (** Section header table offset in bytes *)
   ; elf64_flags    : elf64_word          (** Processor-specific flags *)
   ; elf64_ehsize   : elf64_half          (** ELF header size in bytes *)
   ; elf64_phentsize: elf64_half          (** Program header table entry size in bytes *)
   ; elf64_phnum    : elf64_half          (** Number of entries in program header table *)
   ; elf64_shentsize: elf64_half          (** Section header table entry size in bytes *)
   ; elf64_shnum    : elf64_half          (** Number of entries in section header table *)
   ; elf64_shstrndx : elf64_half          (** Section header table entry for section name string table *)
   }.
Notation "{[ r 'with' 'elf64_ident' := e ]}" := ({| elf64_ident := e; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_type' := e ]}" := ({| elf64_type := e; elf64_ident := elf64_ident r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_machine' := e ]}" := ({| elf64_machine := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_version' := e ]}" := ({| elf64_version := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_entry' := e ]}" := ({| elf64_entry := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_phoff' := e ]}" := ({| elf64_phoff := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_shoff' := e ]}" := ({| elf64_shoff := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_flags' := e ]}" := ({| elf64_flags := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_ehsize' := e ]}" := ({| elf64_ehsize := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_phentsize' := e ]}" := ({| elf64_phentsize := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_phnum' := e ]}" := ({| elf64_phnum := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_shentsize' := e ]}" := ({| elf64_shentsize := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shnum := elf64_shnum r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_shnum' := e ]}" := ({| elf64_shnum := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shstrndx := elf64_shstrndx r |}).
Notation "{[ r 'with' 'elf64_shstrndx' := e ]}" := ({| elf64_shstrndx := e; elf64_ident := elf64_ident r; elf64_type := elf64_type r; elf64_machine := elf64_machine r; elf64_version := elf64_version r; elf64_entry := elf64_entry r; elf64_phoff := elf64_phoff r; elf64_shoff := elf64_shoff r; elf64_flags := elf64_flags r; elf64_ehsize := elf64_ehsize r; elf64_phentsize := elf64_phentsize r; elf64_phnum := elf64_phnum r; elf64_shentsize := elf64_shentsize r; elf64_shnum := elf64_shnum r |}).
(* [?]: removed value specification. *)

Definition is_valid_elf32_header  (hdr : elf32_header )  : bool :=  (list_equal_by unsigned_char_equal  
(lem_list.take( 4)(elf32_ident hdr)) [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]).
(* [?]: removed value specification. *)

Definition is_valid_elf64_header  (hdr : elf64_header )  : bool :=  (list_equal_by unsigned_char_equal  
(lem_list.take( 4)(elf64_ident hdr)) [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]).
(* [?]: removed value specification. *)

Definition elf32_header_compare  (h1 : elf32_header ) (h2 : elf32_header )  : ordering :=     
 (pairCompare (lexicographicCompareBy (genericCompare nat_ltb beq_nat)) (lexicographicCompareBy (genericCompare nat_ltb beq_nat)) (List.map nat_of_unsigned_char(elf32_ident h1), [nat_of_elf32_half(elf32_type h1); 
            nat_of_elf32_half(elf32_machine h1) ; nat_of_elf32_word(elf32_version h1) ; 
            nat_of_elf32_addr(elf32_entry h1) ; nat_of_elf32_off(elf32_phoff h1) ; nat_of_elf32_off(elf32_shoff h1) ; 
            nat_of_elf32_word(elf32_flags h1) ; nat_of_elf32_half(elf32_ehsize h1) ; 
            nat_of_elf32_half(elf32_phentsize h1); nat_of_elf32_half(elf32_phnum h1) ; 
            nat_of_elf32_half(elf32_shentsize h1); nat_of_elf32_half(elf32_shnum h1) ; 
            nat_of_elf32_half(elf32_shstrndx h1)])
     (List.map nat_of_unsigned_char(elf32_ident h2), [nat_of_elf32_half(elf32_type h2); 
            nat_of_elf32_half(elf32_machine h2) ; nat_of_elf32_word(elf32_version h2) ; 
            nat_of_elf32_addr(elf32_entry h2) ; nat_of_elf32_off(elf32_phoff h2) ; nat_of_elf32_off(elf32_shoff h2) ; 
            nat_of_elf32_word(elf32_flags h2) ; nat_of_elf32_half(elf32_ehsize h2) ; 
            nat_of_elf32_half(elf32_phentsize h2); nat_of_elf32_half(elf32_phnum h2) ; 
            nat_of_elf32_half(elf32_shentsize h2); nat_of_elf32_half(elf32_shnum h2) ; 
            nat_of_elf32_half(elf32_shstrndx h2)])).

Instance x49_Ord : Ord elf32_header := {
     compare  :=  elf32_header_compare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf32_header_compare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf32_header_compare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf32_header_compare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf32_header_compare f1 f2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

Definition elf64_header_compare  (h1 : elf64_header ) (h2 : elf64_header )  : ordering :=     
 (pairCompare (lexicographicCompareBy (genericCompare nat_ltb beq_nat)) (lexicographicCompareBy (genericCompare nat_ltb beq_nat)) (List.map nat_of_unsigned_char(elf64_ident h1), [nat_of_elf64_half(elf64_type h1); 
            nat_of_elf64_half(elf64_machine h1) ; nat_of_elf64_word(elf64_version h1) ; 
            nat_of_elf64_addr(elf64_entry h1) ; nat_of_elf64_off(elf64_phoff h1) ; nat_of_elf64_off(elf64_shoff h1) ; 
            nat_of_elf64_word(elf64_flags h1) ; nat_of_elf64_half(elf64_ehsize h1) ; 
            nat_of_elf64_half(elf64_phentsize h1); nat_of_elf64_half(elf64_phnum h1) ; 
            nat_of_elf64_half(elf64_shentsize h1); nat_of_elf64_half(elf64_shnum h1) ; 
            nat_of_elf64_half(elf64_shstrndx h1)])
     (List.map nat_of_unsigned_char(elf64_ident h2), [nat_of_elf64_half(elf64_type h2); 
            nat_of_elf64_half(elf64_machine h2) ; nat_of_elf64_word(elf64_version h2) ; 
            nat_of_elf64_addr(elf64_entry h2) ; nat_of_elf64_off(elf64_phoff h2) ; nat_of_elf64_off(elf64_shoff h2) ; 
            nat_of_elf64_word(elf64_flags h2) ; nat_of_elf64_half(elf64_ehsize h2) ; 
            nat_of_elf64_half(elf64_phentsize h2); nat_of_elf64_half(elf64_phnum h2) ; 
            nat_of_elf64_half(elf64_shentsize h2); nat_of_elf64_half(elf64_shnum h2) ; 
            nat_of_elf64_half(elf64_shstrndx h2)])).

Instance x48_Ord : Ord elf64_header := {
     compare  :=  elf64_header_compare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf64_header_compare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf64_header_compare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf64_header_compare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf64_header_compare f1 f2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

Definition is_elf32_executable_file  (hdr : elf32_header )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_type hdr)) elf_ft_exec.
(* [?]: removed value specification. *)

Definition is_elf64_executable_file  (hdr : elf64_header )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_type hdr)) elf_ft_exec.
(* [?]: removed value specification. *)

Definition is_elf32_shared_object_file  (hdr : elf32_header )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_type hdr)) elf_ft_dyn.
(* [?]: removed value specification. *)

Definition is_elf64_shared_object_file  (hdr : elf64_header )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_type hdr)) elf_ft_dyn.
(* [?]: removed value specification. *)

Definition is_elf32_relocatable_file  (hdr : elf32_header )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_type hdr)) elf_ft_rel.
(* [?]: removed value specification. *)

Definition is_elf64_relocatable_file  (hdr : elf64_header )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_type hdr)) elf_ft_rel.
(* [?]: removed value specification. *)

Definition is_elf32_linkable_file  (hdr : elf32_header )  : bool := 
  is_elf32_shared_object_file hdr || is_elf32_relocatable_file hdr.
(* [?]: removed value specification. *)

Definition is_elf64_linkable_file  (hdr : elf64_header )  : bool := 
  is_elf64_shared_object_file hdr || is_elf64_relocatable_file hdr.
(* [?]: removed value specification. *)

Definition get_elf32_machine_architecture  (hdr : elf32_header )  : nat := 
  nat_of_elf32_half(elf32_machine hdr).
(* [?]: removed value specification. *)

Definition get_elf64_machine_architecture  (hdr : elf64_header )  : nat := 
  nat_of_elf64_half(elf64_machine hdr).
(* [?]: removed value specification. *)

Definition get_elf32_osabi  (hdr : elf32_header )  : nat := 
  match ( lem_list.index(elf32_ident hdr) (id elf_ii_osabi)) with 
    | Some osabi => nat_of_unsigned_char osabi
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf64_osabi  (hdr : elf64_header )  : nat := 
  match ( lem_list.index(elf64_ident hdr) (id elf_ii_osabi)) with 
    | Some osabi => nat_of_unsigned_char osabi
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf32_data_encoding  (hdr : elf32_header )  : nat := 
  match ( lem_list.index(elf32_ident hdr) (id elf_ii_data)) with 
    | Some data => nat_of_unsigned_char data
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf64_data_encoding  (hdr : elf64_header )  : nat := 
  match ( lem_list.index(elf64_ident hdr) (id elf_ii_data)) with 
    | Some data => nat_of_unsigned_char data
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf32_file_class  (hdr : elf32_header )  : nat := 
  match ( lem_list.index(elf32_ident hdr) (id elf_ii_class)) with 
    | Some cls => nat_of_unsigned_char cls
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf64_file_class  (hdr : elf64_header )  : nat := 
  match ( lem_list.index(elf64_ident hdr) (id elf_ii_class)) with 
    | Some cls => nat_of_unsigned_char cls
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf32_version_number  (hdr : elf32_header )  : nat := 
  match ( lem_list.index(elf32_ident hdr) (id elf_ii_version)) with 
    | Some ver => nat_of_unsigned_char ver
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf64_version_number  (hdr : elf64_header )  : nat := 
  match ( lem_list.index(elf64_ident hdr) (id elf_ii_version)) with 
    | Some ver => nat_of_unsigned_char ver
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition is_valid_elf32_version_numer  (hdr : elf32_header )  : bool :=  beq_nat  
(get_elf32_version_number hdr) elf_ev_current.
(* [?]: removed value specification. *)

Definition is_valid_elf64_version_numer  (hdr : elf64_header )  : bool :=  beq_nat  
(get_elf64_version_number hdr) elf_ev_current.
(* [?]: removed value specification. *)

Definition get_elf32_abi_version  (hdr : elf32_header )  : nat := 
  match ( lem_list.index(elf32_ident hdr) (id elf_ii_abiversion)) with 
    | Some ver => nat_of_unsigned_char ver
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf64_abi_version  (hdr : elf64_header )  : nat := 
  match ( lem_list.index(elf64_ident hdr) (id elf_ii_abiversion)) with 
    | Some ver => nat_of_unsigned_char ver
    | None    => DAEMON
  end.
(* [?]: removed value specification. *)

Definition deduce_endianness  (id1 : list (unsigned_char ))  : endianness := 
  match ( lem_list.index id1( 5)) with 
    | None => DAEMON
    | Some v  =>
      if beq_nat (nat_of_unsigned_char v) elf_data_2lsb then
        Little
      else if beq_nat (nat_of_unsigned_char v) elf_data_2msb then
        Big
      else
        DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_elf32_header_endianness  (hdr : elf32_header )  : endianness := 
  deduce_endianness ((elf32_ident hdr)).
(* [?]: removed value specification. *)

Definition get_elf64_header_endianness  (hdr : elf64_header )  : endianness := 
  deduce_endianness ((elf64_ident hdr)).
(* [?]: removed value specification. *)

Definition has_elf32_header_associated_entry_point  (hdr : elf32_header )  : bool :=  negb (beq_nat (nat_of_elf32_addr(elf32_entry hdr))( 0)).
(* [?]: removed value specification. *)

Definition has_elf64_header_associated_entry_point  (hdr : elf64_header )  : bool :=  negb (beq_nat (nat_of_elf64_addr(elf64_entry hdr))( 0)).
(* [?]: removed value specification. *)

Definition has_elf32_header_string_table  (hdr : elf32_header )  : bool :=  negb (beq_nat (nat_of_elf32_half(elf32_shstrndx hdr)) shn_undef).
(* [?]: removed value specification. *)

Definition has_elf64_header_string_table  (hdr : elf64_header )  : bool :=  negb (beq_nat (nat_of_elf64_half(elf64_shstrndx hdr)) shn_undef).
(* [?]: removed value specification. *)

Definition is_elf32_header_section_size_in_section_header_table  (hdr : elf32_header )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_shnum hdr))( 0).
(* [?]: removed value specification. *)

Definition is_elf64_header_section_size_in_section_header_table  (hdr : elf64_header )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_shnum hdr))( 0).
(* [?]: removed value specification. *)

Definition is_elf32_header_string_table_index_in_link  (hdr : elf32_header )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_shstrndx hdr)) shn_xindex.
(* [?]: removed value specification. *)

Definition is_elf64_header_string_table_index_in_link  (hdr : elf64_header )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_shstrndx hdr)) shn_xindex.

(** The [hdr_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
Definition hdr_print_bundle : Type := ( (nat  ->  string ) * (nat  ->  string )) % type.
Definition hdr_print_bundle_default: hdr_print_bundle  := ((fun (x46 : nat ) => string_default), (fun (x47 : nat ) => string_default)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 
	
Instance x45_Show : Show elf32_header := {
	 show  :=  string_of_elf32_header_default
}.
 *)
(* 

Instance x44_Show : Show elf64_header := {
   show  :=  string_of_elf64_header_default
}.
 *)
(* [?]: removed value specification. *)

Definition read_elf_ident  (bs : byte_sequence )
  : error ((list (unsigned_char )*byte_sequence ) % type):=  repeatM' ei_nident bs (read_unsigned_char default_endianness).
(* [?]: removed value specification. *)

Definition bytes_of_elf32_header  (hdr : elf32_header )  : byte_sequence := 
  let endian := deduce_endianness(elf32_ident hdr) in
    byte_sequence.from_byte_lists [
      List.map byte_of_unsigned_char(elf32_ident hdr)
    ; bytes_of_elf32_half endian(elf32_type hdr)
    ; bytes_of_elf32_half endian(elf32_machine hdr)
    ; bytes_of_elf32_word endian(elf32_version hdr)
    ; bytes_of_elf32_addr endian(elf32_entry hdr)
    ; bytes_of_elf32_off  endian(elf32_phoff hdr)
    ; bytes_of_elf32_off  endian(elf32_shoff hdr)
    ; bytes_of_elf32_word endian(elf32_flags hdr)
    ; bytes_of_elf32_half endian(elf32_ehsize hdr)
    ; bytes_of_elf32_half endian(elf32_phentsize hdr)
    ; bytes_of_elf32_half endian(elf32_phnum hdr)
    ; bytes_of_elf32_half endian(elf32_shentsize hdr)
    ; bytes_of_elf32_half endian(elf32_shnum hdr)
    ; bytes_of_elf32_half endian(elf32_shstrndx hdr)]
    .
(* [?]: removed value specification. *)

Definition bytes_of_elf64_header  (hdr : elf64_header )  : byte_sequence := 
  let endian := deduce_endianness(elf64_ident hdr) in
    byte_sequence.from_byte_lists [
      List.map byte_of_unsigned_char(elf64_ident hdr)
    ; bytes_of_elf64_half endian(elf64_type hdr)
    ; bytes_of_elf64_half endian(elf64_machine hdr)
    ; bytes_of_elf64_word endian(elf64_version hdr)
    ; bytes_of_elf64_addr endian(elf64_entry hdr)
    ; bytes_of_elf64_off  endian(elf64_phoff hdr)
    ; bytes_of_elf64_off  endian(elf64_shoff hdr)
    ; bytes_of_elf64_word endian(elf64_flags hdr)
    ; bytes_of_elf64_half endian(elf64_ehsize hdr)
    ; bytes_of_elf64_half endian(elf64_phentsize hdr)
    ; bytes_of_elf64_half endian(elf64_phnum hdr)
    ; bytes_of_elf64_half endian(elf64_shentsize hdr)
    ; bytes_of_elf64_half endian(elf64_shnum hdr)
    ; bytes_of_elf64_half endian(elf64_shstrndx hdr)]
    .
(* [?]: removed value specification. *)

Definition is_elf32_header_padding_correct  (ehdr : elf32_header )  : bool :=   (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 9)) (Some (unsigned_char_of_nat( 0)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 10)) (Some (unsigned_char_of_nat( 0)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 11)) (Some (unsigned_char_of_nat( 0)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 12)) (Some (unsigned_char_of_nat( 0)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 13)) (Some (unsigned_char_of_nat( 0)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 14)) (Some (unsigned_char_of_nat( 0)))) && (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 15)) (Some (unsigned_char_of_nat( 0))))))))).
(* [?]: removed value specification. *)

Definition is_magic_number_correct  (ident : list (unsigned_char ))  : bool :=  (maybeEqualBy unsigned_char_equal  
(lem_list.index ident( 0)) (Some (unsigned_char_of_nat( 127)))) && ((maybeEqualBy unsigned_char_equal  
(lem_list.index ident( 1)) (Some (unsigned_char_of_nat( 69))))  && ((maybeEqualBy unsigned_char_equal  
(lem_list.index ident( 2)) (Some (unsigned_char_of_nat( 76))))  && (maybeEqualBy unsigned_char_equal  
(lem_list.index ident( 3)) (Some (unsigned_char_of_nat( 70)))))).
(* [?]: removed value specification. *)

Definition read_elf32_header  (bs : byte_sequence )  : error ((elf32_header *byte_sequence ) % type):= 
	read_elf_ident bs >>= 
  (fun (p : (list (unsigned_char )*byte_sequence ) % type) =>
     match ( (p) ) with ( (ident,  bs)) =>
       if negb (is_magic_number_correct ident) then
         fail0 "read_elf32_header: magic number incorrect" else
         let endian := deduce_endianness ident in
         read_elf32_half endian bs >>=
         (fun (p : (elf32_half *byte_sequence ) % type) =>
            match ( (p) ) with ( (typ,  bs)) =>
              read_elf32_half endian bs >>=
              (fun (p : (elf32_half *byte_sequence ) % type) =>
                 match ( (p) ) with ( (machine,  bs)) =>
                   read_elf32_word endian bs >>=
                   (fun (p : (elf32_word *byte_sequence ) % type) =>
                      match ( (p) ) with ( (version,  bs)) =>
                        read_elf32_addr endian bs >>=
                        (fun (p : (elf32_addr *byte_sequence ) % type) =>
                           match ( (p) ) with ( (entry,  bs)) =>
                             read_elf32_off endian bs >>=
                             (fun (p : (elf32_off *byte_sequence ) % type) =>
                                match ( (p) ) with ( (phoff,  bs)) =>
                                  read_elf32_off endian bs >>=
                                  (fun (p : (elf32_off *byte_sequence ) % type) =>
                                     match ( (p) ) with ( (shoff,  bs)) =>
                                       read_elf32_word endian bs >>=
                                       (fun (p : (elf32_word *byte_sequence ) % type) =>
                                          match ( (p) ) with
                                              ( (flags,  bs)) =>
                                            read_elf32_half endian bs >>=
                                            (fun (p : (elf32_half *byte_sequence ) % type) =>
                                               match ( (p) ) with
                                                   ( (ehsize,  bs)) =>
                                                 read_elf32_half endian bs
                                                 >>=
                                                 (fun (p : (elf32_half *byte_sequence ) % type) =>
                                                    match ( (p) ) with
                                                        ( (phentsize,  bs)) =>
                                                      read_elf32_half 
                                                      endian bs >>=
                                                      (fun (p : (elf32_half *byte_sequence ) % type) =>
                                                         match ( (p) ) with
                                                             ( (phnum,  bs)) =>
                                                           read_elf32_half
                                                             endian bs >>=
                                                           (fun (p : (elf32_half *byte_sequence ) % type) =>
                                                              match ( (p) ) with
                                                                  ( (shentsize,  bs)) =>
                                                                read_elf32_half
                                                                  endian 
                                                                bs >>=
                                                                (fun (p : (elf32_half *byte_sequence ) % type) =>
                                                                   match ( (p) ) with
                                                                    ( (shnum,  bs)) =>
                                                                    read_elf32_half
                                                                    endian 
                                                                    bs >>=
                                                                    (
                                                                    fun (p : (elf32_half *byte_sequence ) % type) =>
                                                                    match ( (p) ) with
                                                                    ( (shstrndx,  bs)) =>
                                                                    match ( 
                                                                    lem_list.index
                                                                    ident
                                                                    ( 4)) with
                                                                    | None =>
                                                                    fail0
                                                                    "read_elf32_header: transcription of ELF identifier failed"
                                                                    | Some c =>
                                                                    if 
                                                                    beq_nat
                                                                    (
                                                                    nat_of_unsigned_char
                                                                    c)
                                                                    elf_class_32 then
                                                                    return0
                                                                    ({|elf32_ident := ident;elf32_type := typ;elf32_machine := machine;elf32_version := version;elf32_entry := entry;elf32_phoff := phoff;elf32_shoff := shoff;elf32_flags := flags;elf32_ehsize := ehsize;elf32_phentsize := phentsize;elf32_phnum := phnum;elf32_shentsize := shentsize;elf32_shnum := shnum;elf32_shstrndx := shstrndx |}, bs)
                                                                    else
                                                                    fail0
                                                                    "read_elf32_header: not a 32-bit ELF file"
                                                                    end end)
                                                                   end) end)
                                                         end) end) end) end)
                                     end) end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition read_elf64_header  (bs : byte_sequence )  : error ((elf64_header *byte_sequence ) % type):= 
  read_elf_ident bs >>= 
  (fun (p : (list (unsigned_char )*byte_sequence ) % type) =>
     match ( (p) ) with ( (ident,  bs)) =>
       if negb (is_magic_number_correct ident) then
         fail0 "read_elf64_header: magic number incorrect" else
         let endian := deduce_endianness ident in
         read_elf64_half endian bs >>=
         (fun (p : (elf64_half *byte_sequence ) % type) =>
            match ( (p) ) with ( (typ,  bs)) =>
              read_elf64_half endian bs >>=
              (fun (p : (elf64_half *byte_sequence ) % type) =>
                 match ( (p) ) with ( (machine,  bs)) =>
                   read_elf64_word endian bs >>=
                   (fun (p : (elf64_word *byte_sequence ) % type) =>
                      match ( (p) ) with ( (version,  bs)) =>
                        read_elf64_addr endian bs >>=
                        (fun (p : (elf64_addr *byte_sequence ) % type) =>
                           match ( (p) ) with ( (entry,  bs)) =>
                             read_elf64_off endian bs >>=
                             (fun (p : (elf64_off *byte_sequence ) % type) =>
                                match ( (p) ) with ( (phoff,  bs)) =>
                                  read_elf64_off endian bs >>=
                                  (fun (p : (elf64_off *byte_sequence ) % type) =>
                                     match ( (p) ) with ( (shoff,  bs)) =>
                                       read_elf64_word endian bs >>=
                                       (fun (p : (elf64_word *byte_sequence ) % type) =>
                                          match ( (p) ) with
                                              ( (flags,  bs)) =>
                                            read_elf64_half endian bs >>=
                                            (fun (p : (elf64_half *byte_sequence ) % type) =>
                                               match ( (p) ) with
                                                   ( (ehsize,  bs)) =>
                                                 read_elf64_half endian bs
                                                 >>=
                                                 (fun (p : (elf64_half *byte_sequence ) % type) =>
                                                    match ( (p) ) with
                                                        ( (phentsize,  bs)) =>
                                                      read_elf64_half 
                                                      endian bs >>=
                                                      (fun (p : (elf64_half *byte_sequence ) % type) =>
                                                         match ( (p) ) with
                                                             ( (phnum,  bs)) =>
                                                           read_elf64_half
                                                             endian bs >>=
                                                           (fun (p : (elf64_half *byte_sequence ) % type) =>
                                                              match ( (p) ) with
                                                                  ( (shentsize,  bs)) =>
                                                                read_elf64_half
                                                                  endian 
                                                                bs >>=
                                                                (fun (p : (elf64_half *byte_sequence ) % type) =>
                                                                   match ( (p) ) with
                                                                    ( (shnum,  bs)) =>
                                                                    read_elf64_half
                                                                    endian 
                                                                    bs >>=
                                                                    (
                                                                    fun (p : (elf64_half *byte_sequence ) % type) =>
                                                                    match ( (p) ) with
                                                                    ( (shstrndx,  bs)) =>
                                                                    match ( 
                                                                    lem_list.index
                                                                    ident
                                                                    ( 4)) with
                                                                    | None =>
                                                                    fail0
                                                                    "read_elf64_header: transcription of ELF identifier failed"
                                                                    | Some c =>
                                                                    if 
                                                                    beq_nat
                                                                    (
                                                                    nat_of_unsigned_char
                                                                    c)
                                                                    elf_class_64 then
                                                                    return0
                                                                    ({|elf64_ident := ident;elf64_type := typ;elf64_machine := machine;elf64_version := version;elf64_entry := entry;elf64_phoff := phoff;elf64_shoff := shoff;elf64_flags := flags;elf64_ehsize := ehsize;elf64_phentsize := phentsize;elf64_phnum := phnum;elf64_shentsize := shentsize;elf64_shnum := shnum;elf64_shstrndx := shstrndx |}, bs)
                                                                    else
                                                                    fail0
                                                                    "read_elf64_header: not a 64-bit ELF file"
                                                                    end end)
                                                                   end) end)
                                                         end) end) end) end)
                                     end) end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition is_elf32_header_class_correct  (ehdr : elf32_header )  : bool :=  (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 4)) (Some (unsigned_char_of_nat( 1)))).
(* [?]: removed value specification. *)

Definition is_elf64_header_class_correct  (ehdr : elf64_header )  : bool :=  (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf64_ident ehdr)( 4)) (Some (unsigned_char_of_nat( 1)))).
(* [?]: removed value specification. *)

Definition is_elf32_header_version_correct  (ehdr : elf32_header )  : bool :=  (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf32_ident ehdr)( 6)) (Some (unsigned_char_of_nat( 1)))).
(* [?]: removed value specification. *)

Definition is_elf64_header_version_correct  (ehdr : elf64_header )  : bool :=  (maybeEqualBy unsigned_char_equal  
(lem_list.index(elf64_ident ehdr)( 6)) (Some (unsigned_char_of_nat( 1)))).
(* [?]: removed value specification. *)

Definition is_elf32_header_valid  (ehdr : elf32_header )  : bool :=  beq_nat  
( (List.length(elf32_ident ehdr))) ei_nident &&  
(is_magic_number_correct(elf32_ident ehdr) &&  
(is_elf32_header_padding_correct ehdr &&  
(is_elf32_header_class_correct ehdr &&
  is_elf32_header_version_correct ehdr))).
(* [?]: removed value specification. *)

Definition get_elf32_header_program_table_size  (ehdr : elf32_header )  : nat := 
  let phentsize := nat_of_elf32_half(elf32_phentsize ehdr) in
  let phnum     := nat_of_elf32_half(elf32_phnum ehdr) in Coq.Init.Peano.mult
    phentsize phnum.
(* [?]: removed value specification. *)

Definition get_elf64_header_program_table_size  (ehdr : elf64_header )  : nat := 
  let phentsize := nat_of_elf64_half(elf64_phentsize ehdr) in
  let phnum     := nat_of_elf64_half(elf64_phnum ehdr) in Coq.Init.Peano.mult
    phentsize phnum.
(* [?]: removed value specification. *)

Definition is_elf32_header_section_table_present  (ehdr : elf32_header )  : bool := 
  negb ( beq_nat(nat_of_elf32_off(elf32_shoff ehdr))( 0)).
(* [?]: removed value specification. *)

Definition is_elf64_header_section_table_present  (ehdr : elf64_header )  : bool := 
  negb ( beq_nat(nat_of_elf64_off(elf64_shoff ehdr))( 0)).
(* [?]: removed value specification. *)

Definition get_elf32_header_section_table_size  (ehdr : elf32_header )  : nat := 
  let shentsize := nat_of_elf32_half(elf32_shentsize ehdr) in
  let shnum     := nat_of_elf32_half(elf32_shnum ehdr) in Coq.Init.Peano.mult
    shentsize shnum.
(* [?]: removed value specification. *)

Definition get_elf64_header_section_table_size  (ehdr : elf64_header )  : nat := 
  let shentsize := nat_of_elf64_half(elf64_shentsize ehdr) in
  let shnum     := nat_of_elf64_half(elf64_shnum ehdr) in Coq.Init.Peano.mult
    shentsize shnum.
