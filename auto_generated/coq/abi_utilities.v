(* Generated by Lem from abis/abi_utilities.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [abi_utilities], generic utilities shared between all ABIs.
  *)

Require Import lem_map.
Require Export lem_map.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_string.
Require Export lem_string.

Require Import error.
Require Export error.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import abi_classes.
Require Export abi_classes.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import memory_image.
Require Export memory_image.

Require Import memory_image_orderings.
Require Export memory_image_orderings.



Require Import error.
Require Export error.


(** [integer_bit_width] records various bit widths for integral types, as used
  * in relocation calculations. The names are taken directly from the processor
  * supplements to keep the calculations as close as possible
  * to the specification of relocations.
  *)
Inductive integer_bit_width : Type :=
   I8: integer_bit_width         (** Signed 8 bit *)
  | I12: integer_bit_width 
  | U12: integer_bit_width        (** Unsigned 12 bit *)
  | Low14: integer_bit_width 
  | U15: integer_bit_width        (** Unsigned 15 bit *)
  | I15: integer_bit_width 
  | I16: integer_bit_width        (** Signed 16 bit *)
  | Half16ds: integer_bit_width 
  | I20: integer_bit_width        (** Signed 20 bit *)
  | Low24: integer_bit_width 
  | I27: integer_bit_width 
  | Word30: integer_bit_width 
  | I32: integer_bit_width        (** Signed 32 bit *)
  | I48: integer_bit_width        (** Signed 48 bit *)
  | I64: integer_bit_width        (** Signed 64 bit *)
  | I64X2: integer_bit_width      (** Signed 128 bit *)
  | U16: integer_bit_width        (** Unsigned 16 bit *)
  | U24: integer_bit_width        (** Unsigned 24 bit *)
  | U32: integer_bit_width        (** Unsigned 32 bit *)
  | U48: integer_bit_width        (** Unsigned 48 bit *)
  | U64: integer_bit_width .
Definition integer_bit_width_default: integer_bit_width  := I8.
(* [?]: removed value specification. *)

Definition natural_of_integer_bit_width  (i : integer_bit_width )  : nat := 
  match ( i) with 
    | I8       => 8
    | I12      => 12
    | U12      => 12
    | Low14    => 14
    | I15      => 15
    | U15      => 15
    | I16      => 16
    | Half16ds => 16
    | U16      => 16
    | I20      => 20
    | Low24    => 24
    | U24      => 24
    | I27      => 27
    | Word30   => 30
    | I32      => 32
    | U32      => 32
    | I48      => 48
    | U48      => 48
    | I64      => 64
    | U64      => 64
    | I64X2    => 128
  end.
  
(** [relocation_operator] records the operators used to calculate relocations by
  * the various ABIs.  Each ABI will only use a subset of these, and they should
  * be interpreted on a per-ABI basis.  As more ABIs are added, more operators
  * will be needed, and therefore more constructors in this type will need to
  * be added.  These are unary operators, operating on a single integral type.
  *)
Inductive relocation_operator : Type :=
   TPRel: relocation_operator 
  | LTOff: relocation_operator 
  | DTPMod: relocation_operator 
  | DTPRel: relocation_operator 
  | Page: relocation_operator 
  | GDat: relocation_operator 
  | G: relocation_operator 
  | GLDM: relocation_operator 
  | GTPRel: relocation_operator 
  | GTLSDesc: relocation_operator 
  | Delta: relocation_operator 
  | LDM: relocation_operator 
  | TLSDesc: relocation_operator 
  | Indirect: relocation_operator 
  | Lo: relocation_operator 
  | Hi: relocation_operator 
  | Ha: relocation_operator 
  | Higher: relocation_operator 
  | HigherA: relocation_operator 
  | Highest: relocation_operator 
  | HighestA: relocation_operator .
Definition relocation_operator_default: relocation_operator  := TPRel.
  
(** [relocation_operator2] is a binary relocation operator, as detailed above.
  *)
Inductive relocation_operator2 : Type := 
  | GTLSIdx: relocation_operator2 .
Definition relocation_operator2_default: relocation_operator2  := GTLSIdx.
  
(** Generalising and abstracting over relocation calculations and their return
  * types
  *)
  
Definition val_map  (k: Type) (v: Type) : Type := 
  fmap  k  v.
Definition val_map_default {k: Type} {v: Type} : val_map k v := DAEMON.
(* [?]: removed value specification. *)

Definition lookupM {k v : Type} `{MapKeyType k}  (key : k) (val_map1 : fmap k v)  : error v:= 
  match ( (fmap_lookup_by mapKeyCompare key val_map1)) with 
    | None => fail0 "lookupM: key not found in val_map"
    | Some j  => return0 j
  end.
  
(** Some relocations may fail, for example:
  * Page 58, Power ABI: relocation types whose Field column is marked with an
  * asterisk are subject to failure is the value computed does not fit in the
  * allocated bits.  [can_fail] type passes this information back to the caller
  * of the relocation application function.
  *)
Inductive can_fail (a : Type) : Type :=
   CanFail: can_fail a                       (** [CanFail] signals a potential failing relocation calculation when width constraints are invalidated *)
  | CanFailOnTest:  (a ->  bool ) -> can_fail a (** [CanFailOnTest p] signals a potentially failing relocation calculation when predicate [p] on the result of the calculation returns [false] *)
  | CannotFail: can_fail a.
Definition can_fail_default{a: Type} : can_fail a := CanFail.                    (** [CannotFail] states the relocation calculation cannot fail and bit-width constraints should be ignored *)
  
(** [relocation_operator_expression] is an AST of expressions describing a relocation
  * calculation.  An AST is used as it allows us to unify the treatment of relocation
  * calculation: rather than passing in dozens of functions to the calculation function
  * that perform the actual relocation, we can simply return a description (in the form
  * of the AST below) of the calculation to be carried out and have it interpreted
  * separately from the function that produces it.  The type parameter 'a is the
  * type of base integral type.  This AST suffices for the relocation calculations we
  * currently have implemented, but adding more ABIs may require that this type is
  * expanded.
  *)
Inductive relocation_operator_expression (a : Type) : Type :=
   Lift:    a -> relocation_operator_expression a                                                                                             (** Lift a base type into an AST *)
  | Apply:   ((relocation_operator  * relocation_operator_expression  a) % type) -> relocation_operator_expression a                                      (** Apply a unary operator to an expression *)
  | Apply2:  ((relocation_operator2  * relocation_operator_expression  a * relocation_operator_expression  a) % type) -> relocation_operator_expression a (** Apply a binary operator to two expressions *)
  | Plus:    ((relocation_operator_expression  a * relocation_operator_expression  a) % type) -> relocation_operator_expression a                        (** Add two expressions. *)
  | Minus:   ((relocation_operator_expression  a * relocation_operator_expression  a) % type) -> relocation_operator_expression a                        (** Subtract two expressions. *)
  | RShift:  ((relocation_operator_expression  a * nat ) % type) -> relocation_operator_expression a.
Definition relocation_operator_expression_default{a: Type} : relocation_operator_expression a := Lift DAEMON.                                                  (** Right shift the result of an expression [m] places. *)
  
Inductive relocation_frame (addr : Type) (res : Type) : Type := 
  | Copy: relocation_frame addr res
  | NoCopy:  (fmap  addr  ((relocation_operator_expression  res * integer_bit_width  * can_fail  res) % type)) -> relocation_frame addr res.
Definition relocation_frame_default {addr: Type} {res: Type} : relocation_frame addr res := Copy.
(* [?]: removed value specification. *)

Definition size_of_def  (rr : symbol_reference_and_reloc_site )  : nat := 
  let rf :=(ref rr) in
  let sm :=(ref_syment rf) in
    nat_of_elf64_xword(elf64_st_size sm).
(* [?]: removed value specification. *)

Definition size_of_copy_reloc {abifeature : Type}  (img3 : annotated_memory_image abifeature) (rr : symbol_reference_and_reloc_site )  : nat :=  
    (* it's the minimum of the two definition symbol sizes. FIXME: for now, just use the rr *)
    size_of_def rr.
(* [?]: removed value specification. *)

Definition reloc_site_address {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (img3 : annotated_memory_image abifeature) (rr : symbol_reference_and_reloc_site )  : nat :=  
    (* find the element range that's tagged with this reloc site *)
    let found_kvs  := multimap.lookupBy0 classical_boolean_equivalence (SymbolRef(rr))(by_tag img3)
    in
    match ( found_kvs) with 
        [] => DAEMON
        | [(_,  maybe_range)] => match ( maybe_range) with  
                None => DAEMON
                | Some (el_name,  el_range) => 
                    let element_addr := match ( (fmap_lookup_by (fun (x : string ) (y : string )=>EQ) el_name(elements img3))) with 
                        None => DAEMON
                        | Some el => match ((startpos el)) with 
                            None => DAEMON
                            | Some addr => addr
                        end
                    end
                    in
                    let site_offset := (* match rr.maybe_reloc with 
                        Just reloc -> natural_of_elf64_addr reloc.ref_relent.elf64_ra_offset
                        | Nothing -> failwith "symbol reference with range but no reloc site"
                    end*) (
  match ( el_range) with (start,  _) => start end)
                    in Coq.Init.Peano.plus
                    element_addr site_offset
            end
        | _ => DAEMON
    end.
