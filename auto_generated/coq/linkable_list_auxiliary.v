(* Generated by Lem from linkable_list.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Open Scope nat_scope.
Open Scope string_scope.



(* Rather than recursively expanding the link by searching for definitions of undefs, 
 * the GNU linker works by recursing/looping along the list of *linkables*, testing whether
 * any of the defs satisfies a currently-undef'd thing. On adding a new undef'd thing, 
 * we re-search only from the current archive, not from the beginning (i.e. the 
 * "def_is_leftmore or def_in_same_archive" logic).
 *
 * Why is this not the same as depth-first? One example is if we pull in a new object
 * which happens to have two undefs: one satisfied by the *first* element in the current archive,
 * and one satisfied by the last. 
 * 
 * In the GNU algorithm, we'll pull in the first archive element immediately afterwards, because
 * we'll re-traverse the archive and find it's needed.
 * 
 * In the depth-first algorithm, it depends entirely on the ordering of the new bindings, i.e.
 * the symtab ordering of the two undefs. If the later-in-archive def was bound *first*, we'll
 * recurse down *that* object's dependencies first.
 * 
 * So if we sort the new grey list
 * so that bindings formed in order of *current archive def pos*,
 * will we get the same behaviour?
 * We can't really do this, because we have no "current archive".
 * 
 * Need to rewrite the algorithm to fold along the list of linkables.
 *)
