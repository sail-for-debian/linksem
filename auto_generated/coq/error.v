(* Generated by Lem from error.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import show.
Require Export show.


(** [error] is a type used to represent potentially failing computations. [Success]
  * marks a successful completion of a computation, whilst [Fail err] marks a failure,
  * with [err] as the reason.
  *)
Inductive error (a : Type) : Type :=
  | Success:  a -> error a
  | Fail:  string  -> error a.
(* [?]: removed value specification. *)

Definition return0 {a : Type} (r : a)  : error a:=  Success a r.
(* [?]: removed value specification. *)

Definition with_success {a b : Type}  (err : error a) (fl : b) (suc : a -> b)  : b:= 
  match ( err) with 
    | Success s => suc s
    | Fail err  => fl
  end.
(* [?]: removed value specification. *)

Definition fail0 {a : Type}  (err : string )  : error a:=  Fail a err.
(* [?]: removed value specification. *)

Definition bind {a b : Type}  (x : error a) (f : a -> error b)  : error b:= 
	match ( x) with 
		| Success s => f s
		| Fail err  => Fail b err
	end.

Notation "f >>= x" := (bind f x) (at level 50).
(* [?]: removed value specification. *)

Definition as_maybe {a : Type}  (e : error a)  : option a := 
  match ( e) with 
    | Fail err => None
    | Success s => Some s
  end.
(* [?]: removed value specification. *)

Program Fixpoint repeatM {a : Type}  (count : nat ) (action : error a) {measure count} : error (list a) := 
  match count with
    | 0   => return0 []
    | S m =>
        action >>= fun head1 =>
        repeatM m action >>= fun tail1 =>
        return0 (head1::tail1)
  end.
(* [?]: removed value specification. *)

Program Fixpoint repeatM' {a b : Type}  (count : nat ) (seed : b) (action : b -> error ((a*b) % type))  : error ((list a*b) % type):= 
  match count with
    | 0 => return0 ([], seed)
    | S m =>
      action seed >>= fun hs =>
      let (head1, seed) := hs in
      repeatM' m seed action >>= fun ts =>
      let (tail1, seed) := ts in
      return0 ((head1::tail1), seed)
  end.

Program Fixpoint mapM {a b : Type}  (f : a -> error b) (xs : list a)  : error (list b):= 
	match ( xs) with 
		| []    => return0 []
		| x::xs =>
				f x >>= (fun (hd : b) =>
				mapM f xs >>= (fun (tl : list b) =>
				return0 (hd::tl)))
	end.
(* [?]: removed value specification. *)

Program Fixpoint foldM {a b : Type}  (f : a -> b -> error a) (e : a) (xs : list b)  : error a:= 
  match ( xs) with 
    | []    => return0 e
    | x::xs => f e x >>= (fun (res : a) => foldM f res xs)
  end.
(* [?]: removed value specification. *)

(* 

Instance x16_Show{a: Type} `{Show a}: Show (error  a):= {
	 show  :=  string_of_error
}.
 *)
