(* Generated by Lem from elf_dynamic.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [elf_dynamic] module exports types and definitions relating to the dynamic
  * section and dynamic linking functionality of an ELF file.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import endianness.
Require Export endianness.

Require Import error.
Require Export error.

Require Import show.
Require Export show.

Require Import string_table.
Require Export string_table.


Require Import elf_file.
Require Export elf_file.

Require Import elf_header.
Require Export elf_header.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

(* [?]: removed value specification. *)

Definition is_elf32_valid_program_header_table_for_dynamic_linking  (pht : list (elf32_program_header_table_entry ))  : bool :=  beq_nat  
(List.length (List.filter (fun (x : elf32_program_header_table_entry ) => beq_nat (nat_of_elf32_word(elf32_p_type x)) elf_pt_interp) pht))( 1).
(* [?]: removed value specification. *)

Definition is_elf64_valid_program_header_table_for_dynamic_linking  (pht : list (elf64_program_header_table_entry ))  : bool :=  beq_nat  
(List.length (List.filter (fun (x : elf64_program_header_table_entry ) => beq_nat (nat_of_elf64_word(elf64_p_type x)) elf_pt_interp) pht))( 1).

(** Dynamic section entry *)

(** [dyn_union] represents the C-union type used in the definition of [elf32_dyn]
  * and [elf64_dyn] types below.  Some section tags correspond to entries where
  * the fields are either unspecified or ignored, hence the presence of the
  * [D_Ignored] constructor.
  *)
Inductive dyn_union (a : Type) (b : Type) : Type :=
   D_Val:  a -> dyn_union a b
  | D_Ptr:  b -> dyn_union a b
  | D_Ignored:  byte_sequence  -> dyn_union a b.
Definition dyn_union_default {a: Type} {b: Type} : dyn_union a b := D_Val DAEMON.
  
(** [elf32_dyn] captures the notion of an ELF32 dynamic section entry.
  * Specialises the [dyn_union] type above to using [elf32_word] values and
  * [elf32_addr] pointers.
  *)
Record elf32_dyn : Type :=
  { elf32_dyn_tag  : elf32_sword                      (** The type of the entry. *)
   ; elf32_dyn_d_un : dyn_union  elf32_word   elf32_addr  (** The value of the entry, stored as a union. *)
   }.
Notation "{[ r 'with' 'elf32_dyn_tag' := e ]}" := ({| elf32_dyn_tag := e; elf32_dyn_d_un := elf32_dyn_d_un r |}).
Notation "{[ r 'with' 'elf32_dyn_d_un' := e ]}" := ({| elf32_dyn_d_un := e; elf32_dyn_tag := elf32_dyn_tag r |}).
Definition elf32_dyn_default: elf32_dyn  := {| elf32_dyn_tag := elf32_sword_default; elf32_dyn_d_un := DAEMON |}.
   
(** [elf64_dyn] captures the notion of an ELF32 dynamic section entry.
  * Specialises the [dyn_union] type above to using [elf64_xword] values and
  * [elf64_addr] pointers.
  *)
Record elf64_dyn : Type :=
  { elf64_dyn_tag  : elf64_sxword                      (** The type of the entry. *)
   ; elf64_dyn_d_un : dyn_union  elf64_xword   elf64_addr  (** The value of the entry, stored as a union. *)
   }.
Notation "{[ r 'with' 'elf64_dyn_tag' := e ]}" := ({| elf64_dyn_tag := e; elf64_dyn_d_un := elf64_dyn_d_un r |}).
Notation "{[ r 'with' 'elf64_dyn_d_un' := e ]}" := ({| elf64_dyn_d_un := e; elf64_dyn_tag := elf64_dyn_tag r |}).
Definition elf64_dyn_default: elf64_dyn  := {| elf64_dyn_tag := elf64_sxword_default; elf64_dyn_d_un := DAEMON |}.

(** Dynamic section tags *)

(** [dt_null] marks the end of the dynamic array *)
Definition dt_null    :  nat :=  0.
(** [dt_needed] holds the string table offset of a string containing the name of
  * a needed library.
  *)
Definition dt_needed    :  nat :=  1.
(** [dt_pltrelsz] holds the size in bytes of relocation entries associated with
  * the PLT.
  *)
Definition dt_pltrelsz    :  nat :=  2.
(** [dt_pltgot] holds an address associated with the PLT or GOT. *)
Definition dt_pltgot    :  nat :=  3.
(** [dt_hash] holds the address of a symbol-table hash. *)
Definition dt_hash    :  nat :=  4.
(** [dt_strtab] holds the address of the string table. *)
Definition dt_strtab    :  nat :=  5.
(** [dt_symtab] holds the address of a symbol table. *)
Definition dt_symtab    :  nat :=  6.
(** [dt_rela] holds the address of a relocation table. *)
Definition dt_rela    :  nat :=  7.
(** [dt_relasz] holds the size in bytes of the relocation table. *)
Definition dt_relasz    :  nat :=  8.
(** [dt_relaent] holds the size in bytes of a relocation table entry. *)
Definition dt_relaent    :  nat :=  9.
(** [dt_strsz] holds the size in bytes of the string table. *)
Definition dt_strsz    :  nat :=  10.
(** [dt_syment] holds the size in bytes of a symbol table entry. *)
Definition dt_syment    :  nat :=  11.
(** [dt_init] holds the address of the initialisation function. *)
Definition dt_init    :  nat :=  12.
(** [dt_fini] holds the address of the finalisation function. *)
Definition dt_fini    :  nat :=  13.
(** [dt_soname] holds the string table offset of a string containing the shared-
  * object name.
  *)
Definition dt_soname    :  nat :=  14.
(** [dt_rpath] holds the string table offset of a string containing the library
  * search path.
  *)
Definition dt_rpath    :  nat :=  15.
(** [dt_symbolic] alters the linker's symbol resolution algorithm so that names
  * are resolved first from the shared object file itself, rather than the
  * executable file.
  *)
Definition dt_symbolic    :  nat :=  16.
(** [dt_rel] is similar to [dt_rela] except its table has implicit addends. *)
Definition dt_rel    :  nat :=  17.
(** [dt_relsz] holds the size in bytes of the [dt_rel] relocation table. *)
Definition dt_relsz    :  nat :=  18.
(** [dt_relent] holds the size in bytes of a [dt_rel] relocation entry. *)
Definition dt_relent    :  nat :=  19.
(** [dt_pltrel] specifies the type of relocation entry to which the PLT refers. *)
Definition dt_pltrel    :  nat :=  20.
(** [dt_debug] is used for debugging and its purpose is not specified in the ABI.
  * Programs using this entry are not ABI-conformant.
  *)
Definition dt_debug    :  nat :=  21.
(** [dt_textrel] absence of this entry indicates that no relocation entry should
  * cause a modification to a non-writable segment.  Otherwise, if present, one
  * or more relocation entries may request modifications to a non-writable
  * segment.
  *)
Definition dt_textrel    :  nat :=  22.
(** [dt_jmprel]'s member holds the address of relocation entries associated with
  * the PLT.
  *)
Definition dt_jmprel    :  nat :=  23.
(** [dt_bindnow] instructs the linker to process all relocations for the object
  * containing the entry before transferring control to the program.
  *)
Definition dt_bindnow    :  nat :=  24.
(** [dt_init_array] holds the address to the array of pointers to initialisation
  * functions.
  *)
Definition dt_init_array    :  nat :=  25.
(** [dt_fini_array] holds the address to the array of pointers to finalisation
  * functions.
  *)
Definition dt_fini_array    :  nat :=  26.
(** [dt_init_arraysz] holds the size in bytes of the array of pointers to
  * initialisation functions.
  *)
Definition dt_init_arraysz    :  nat :=  27.
(** [dt_fini_arraysz] holds the size in bytes of the array of pointers to
  * finalisation functions.
  *)
Definition dt_fini_arraysz    :  nat :=  28.
(** [dt_runpath] holds an offset into the string table holding a string containing
  * the library search path.
  *)
Definition dt_runpath    :  nat :=  29.
(** [dt_flags] holds flag values specific to the object being loaded. *)
Definition dt_flags    :  nat :=  30.
Definition dt_encoding    :  nat :=  32.
(** [dt_preinit_array] holds the address to the array of pointers of pre-
  * initialisation functions.
  *)
Definition dt_preinit_array    :  nat :=  32.
(** [dt_preinit_arraysz] holds the size in bytes of the array of pointers of
  * pre-initialisation functions.
  *)
Definition dt_preinit_arraysz    :  nat :=  33.
(** [dt_loos] and [dt_hios]: this inclusive range is reserved for OS-specific
  * semantics.
  *)
Definition dt_loos    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 2)( 805306374))( 1). (* 0x6000000D *)
Definition dt_hios    :  nat :=  ( Coq.Init.Peano.mult( 2)( 939522048)). (* 0x6ffff000 *)
(** [dt_loproc] and [dt_hiproc]: this inclusive range is reserved for processor
  * specific semantics.
  *)
Definition dt_loproc    :  nat :=  ( Coq.Init.Peano.mult( 2)( 939524096)). (* 0x70000000 *)
Definition dt_hiproc    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 2)( 1073741823))( 1).
(* [?]: removed value specification. *)

Definition string_of_dynamic_tag  (shared_object : bool ) (tag : nat ) (os_additional_ranges : nat  -> bool ) (os : nat  -> string ) (proc : nat  -> string )  : string := 
  if beq_nat tag dt_null then
    "NULL"
  else if beq_nat tag dt_needed then
    "NEEDED"
  else if beq_nat tag dt_pltrelsz then
    "PLTRELSZ"
  else if beq_nat tag dt_pltgot then
    "PLTGOT"
  else if beq_nat tag dt_hash then
    "HASH"
  else if beq_nat tag dt_strtab then
    "STRTAB"
  else if beq_nat tag dt_symtab then
    "SYMTAB"
  else if beq_nat tag dt_rela then
    "RELA"
  else if beq_nat tag dt_relasz then
    "RELASZ"
  else if beq_nat tag dt_relaent then
    "RELAENT"
  else if beq_nat tag dt_strsz then
    "STRSZ"
  else if beq_nat tag dt_syment then
    "SYMENT"
  else if beq_nat tag dt_init then
    "INIT"
  else if beq_nat tag dt_fini then
    "FINI"
  else if beq_nat tag dt_soname then
    "SONAME"
  else if beq_nat tag dt_rpath then
    "RPATH"
  else if beq_nat tag dt_symbolic then
    "SYMBOLIC"
  else if beq_nat tag dt_rel then
    "REL"
  else if beq_nat tag dt_relsz then
    "RELSZ"
  else if beq_nat tag dt_relent then
    "RELENT"
  else if beq_nat tag dt_pltrel then
    "PLTREL"
  else if beq_nat tag dt_debug then
    "DEBUG"
  else if beq_nat tag dt_textrel then
    "TEXTREL"
  else if beq_nat tag dt_jmprel then
    "JMPREL"
  else if beq_nat tag dt_bindnow then
    "BIND_NOW"
  else if beq_nat tag dt_init_array then
    "INIT_ARRAY"
  else if beq_nat tag dt_fini_array then
    "FINI_ARRAY"
  else if beq_nat tag dt_init_arraysz then
    "INIT_ARRAYSZ"
  else if beq_nat tag dt_fini_arraysz then
    "FINI_ARRAYSZ"
  else if beq_nat tag dt_runpath then
    "RUNPATH"
  else if beq_nat tag dt_flags then
    "FLAGS"
  else if beq_nat tag dt_encoding then
    if negb shared_object then
      "ENCODING"
    else
      "PREINIT_ARRAY"
  else if beq_nat tag dt_preinit_arraysz then
    "PREINIT_ARRAYSZ"
  else if nat_gteb tag dt_loproc && nat_lteb tag dt_hiproc then
    proc tag
  else if nat_gteb tag dt_loos && nat_lteb tag dt_hios then
    os tag
  else if os_additional_ranges tag then
    os tag
  else
    "Invalid dynamic section tag".
    
(** [tag_correspondence] is a type used to emulate the functionality of a C-union
  * in Lem.  The type records whether the union should be interpreted as a value,
  * a pointer, or a "do not care" value.  An accompanying function will map a
  * dynamic section tag to a [tag_correspondence], so that transcription functions
  * know how to properly use the [dyn_union] value in a dynamic section entry.
  *)
Inductive tag_correspondence : Type :=
   C_Val: tag_correspondence      (** [dyn_union] should be interpreted as a value. *)
  | C_Ptr: tag_correspondence      (** [dyn_union] should be interpreted as a pointer. *)
  | C_Ignored: tag_correspondence .
Definition tag_correspondence_default: tag_correspondence  := C_Val.
(* [?]: removed value specification. *)

Definition tag_correspondence_of_tag  (shared_object : bool ) (tag : nat ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence ))  : error (tag_correspondence ):= 
  if beq_nat tag dt_null then
    return0 C_Ignored
  else if beq_nat tag dt_needed then
    return0 C_Val
  else if beq_nat tag dt_pltrelsz then
    return0 C_Val
  else if beq_nat tag dt_pltgot then
    return0 C_Ptr
  else if beq_nat tag dt_hash then
    return0 C_Ptr
  else if beq_nat tag dt_strtab then
    return0 C_Ptr
  else if beq_nat tag dt_symtab then
    return0 C_Ptr
  else if beq_nat tag dt_rela then
    return0 C_Ptr
  else if beq_nat tag dt_relasz then
    return0 C_Val
  else if beq_nat tag dt_relaent then
    return0 C_Val
  else if beq_nat tag dt_strsz then
    return0 C_Val
  else if beq_nat tag dt_syment then
    return0 C_Val
  else if beq_nat tag dt_init then
    return0 C_Ptr
  else if beq_nat tag dt_fini then
    return0 C_Ptr
  else if beq_nat tag dt_soname then
    return0 C_Val
  else if beq_nat tag dt_rpath then
    return0 C_Val
  else if beq_nat tag dt_symbolic then
    return0 C_Ignored
  else if beq_nat tag dt_rel then
    return0 C_Ptr
  else if beq_nat tag dt_relsz then
    return0 C_Val
  else if beq_nat tag dt_relent then
    return0 C_Val
  else if beq_nat tag dt_pltrel then
    return0 C_Val
  else if beq_nat tag dt_debug then
    return0 C_Ptr
  else if beq_nat tag dt_textrel then
    return0 C_Ignored
  else if beq_nat tag dt_jmprel then
    return0 C_Ptr
  else if beq_nat tag dt_bindnow then
    return0 C_Ignored
  else if beq_nat tag dt_init_array then
    return0 C_Ptr
  else if beq_nat tag dt_fini_array then
    return0 C_Ptr
  else if beq_nat tag dt_init_arraysz then
    return0 C_Val
  else if beq_nat tag dt_fini_arraysz then
    return0 C_Val
  else if beq_nat tag dt_runpath then
    return0 C_Val
  else if beq_nat tag dt_flags then
    return0 C_Val
  else if beq_nat tag dt_encoding then
    if negb shared_object then
      return0 C_Ignored
    else
      return0 C_Ptr
  else if beq_nat tag dt_preinit_arraysz then
    return0 C_Val
  else if nat_gteb tag dt_loproc && nat_lteb tag dt_hiproc then
    proc tag
  else if nat_gteb tag dt_loos && nat_lteb tag dt_hios then
    os tag
  else if os_additional_ranges tag then
    os tag
  else
    fail0 ("tag_correspondence_of_tag: invalid dynamic section tag").
(* [?]: removed value specification. *)

Definition read_elf32_dyn  (endian : endianness ) (bs0 : byte_sequence ) (shared_object : bool ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence ))  : error ((elf32_dyn *byte_sequence ) % type):= 
  read_elf32_sword endian bs0 >>= 
  (fun (p : (elf32_sword *byte_sequence ) % type) =>
     match ( (p) ) with ( (tag0,  bs1)) =>
       let tag := Zabs_nat (int_of_elf32_sword tag0) in
     tag_correspondence_of_tag shared_object tag os_additional_ranges os proc
     >>=
     (fun (corr : tag_correspondence ) =>
        match ( corr) with | C_Ptr =>
          read_elf32_addr endian bs1 >>=
          (fun (p : (elf32_addr *byte_sequence ) % type) =>
             match ( (p) ) with ( (ptr,  bs2)) =>
               return0
                 ({|elf32_dyn_tag := tag0 ;elf32_dyn_d_un := (D_Ptr ptr) |}, bs2)
             end) | C_Val =>
          read_elf32_word endian bs1 >>=
          (fun (p : (elf32_word *byte_sequence ) % type) =>
             match ( (p) ) with ( (vl,  bs2)) =>
               return0
                 ({|elf32_dyn_tag := tag0 ;elf32_dyn_d_un := (D_Val vl) |}, bs2)
             end) | C_Ignored =>
          match ( endian) with | Big =>
            read_4_bytes_be bs1 >>=
            (fun (p : (((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type) =>
               match ( (p) ) with ( ((b1,  b2,  b3,  b4),  bs2)) =>
                 let cut := byte_sequence.from_byte_lists [[b1; b2; b3; b4]] in
               return0
                 ({|elf32_dyn_tag := tag0 ;elf32_dyn_d_un := (D_Ignored cut) |}, bs2)
               end) | Little =>
            read_4_bytes_le bs1 >>=
            (fun (p : (((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type) =>
               match ( (p) ) with ( ((b1,  b2,  b3,  b4),  bs2)) =>
                 let cut := byte_sequence.from_byte_lists [[b1; b2; b3; b4]] in
               return0
                 ({|elf32_dyn_tag := tag0 ;elf32_dyn_d_un := (D_Ignored cut) |}, bs2)
               end) end end) end).
(* [?]: removed value specification. *)

Definition read_elf64_dyn  (endian : endianness ) (bs0 : byte_sequence ) (shared_object : bool ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence ))  : error ((elf64_dyn *byte_sequence ) % type):= 
  read_elf64_sxword endian bs0 >>= 
  (fun (p : (elf64_sxword *byte_sequence ) % type) =>
     match ( (p) ) with ( (tag0,  bs1)) =>
       let tag := Zabs_nat (int_of_elf64_sxword tag0) in
     tag_correspondence_of_tag shared_object tag os_additional_ranges os proc
     >>=
     (fun (corr : tag_correspondence ) =>
        match ( corr) with | C_Ptr =>
          read_elf64_addr endian bs1 >>=
          (fun (p : (elf64_addr *byte_sequence ) % type) =>
             match ( (p) ) with ( (ptr,  bs2)) =>
               return0
                 ({|elf64_dyn_tag := tag0 ;elf64_dyn_d_un := (D_Ptr ptr) |}, bs2)
             end) | C_Val =>
          read_elf64_xword endian bs1 >>=
          (fun (p : (elf64_xword *byte_sequence ) % type) =>
             match ( (p) ) with ( (vl,  bs2)) =>
               return0
                 ({|elf64_dyn_tag := tag0 ;elf64_dyn_d_un := (D_Val vl) |}, bs2)
             end) | C_Ignored =>
          match ( endian) with | Big =>
            read_8_bytes_be bs1 >>=
            (fun (p : (((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type) =>
               match ( (p) ) with
                   ( ((b1,  b2,  b3,  b4,  b5,  b6,  b7,  b8),  bs2)) =>
                 let cut := byte_sequence.from_byte_lists
                              [[b1; b2; b3; b4; b5; b6; b7; b8]] in
               return0
                 ({|elf64_dyn_tag := tag0 ;elf64_dyn_d_un := (D_Ignored cut) |}, bs2)
               end) | Little =>
            read_8_bytes_le bs1 >>=
            (fun (p : (((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type) =>
               match ( (p) ) with
                   ( ((b1,  b2,  b3,  b4,  b5,  b6,  b7,  b8),  bs2)) =>
                 let cut := byte_sequence.from_byte_lists
                              [[b1; b2; b3; b4; b5; b6; b7; b8]] in
               return0
                 ({|elf64_dyn_tag := tag0 ;elf64_dyn_d_un := (D_Ignored cut) |}, bs2)
               end) end end) end).
(* [?]: removed value specification. *)

Program Fixpoint obtain_elf32_dynamic_section_contents'  (endian : endianness ) (bs0 : byte_sequence ) (shared_object : bool ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence ))  : error (list (elf32_dyn )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf32_dyn endian bs0 shared_object os_additional_ranges os proc >>= 
  (fun (p : (elf32_dyn *byte_sequence ) % type) =>
     match ( (p) ) with ( (head1,  bs0)) =>
       if Z.eqb (int_of_elf32_sword (elf32_dyn_tag head1))
            ((Zpred (Zpos (P_of_succ_nat dt_null)))) then
         (* DT_NULL marks end of array *) return0 [head1] else
         obtain_elf32_dynamic_section_contents' endian bs0 shared_object
           os_additional_ranges os proc >>=
         (fun (tail1 : list (elf32_dyn )) => return0 (head1 :: tail1)) end).
(* [?]: removed value specification. *)

Program Fixpoint obtain_elf64_dynamic_section_contents'  (endian : endianness ) (bs0 : byte_sequence ) (shared_object : bool ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence ))  : error (list (elf64_dyn )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf64_dyn endian bs0 shared_object os_additional_ranges os proc >>= 
  (fun (p : (elf64_dyn *byte_sequence ) % type) =>
     match ( (p) ) with ( (head1,  bs0)) =>
       if Z.eqb (int_of_elf64_sxword (elf64_dyn_tag head1))
            ((Zpred (Zpos (P_of_succ_nat dt_null)))) then
         (* DT_NULL marks end of array *) return0 [head1] else
         obtain_elf64_dynamic_section_contents' endian bs0 shared_object
           os_additional_ranges os proc >>=
         (fun (tail1 : list (elf64_dyn )) => return0 (head1 :: tail1)) end).
(* [?]: removed value specification. *)

Definition obtain_elf32_dynamic_section_contents  (f1 : elf32_file ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence )) (bs0 : byte_sequence )  : error (list (elf32_dyn )):= 
  let endian := get_elf32_header_endianness(elf32_file_header f1) in
  let sht :=(elf32_file_section_header_table f1) in
  let shared_object := is_elf32_shared_object_file(elf32_file_header f1) in
    match ( List.filter (fun (ent : elf32_section_header_table_entry ) => beq_nat (nat_of_elf32_word(elf32_sh_type ent)) sht_dynamic) sht) with 
      | [] => fail0 "obtain_elf32_dynamic_section_contents: no SHT_DYNAMIC section header entries"
      | [dyn] =>
        let off := nat_of_elf32_off(elf32_sh_offset dyn) in
        let siz := nat_of_elf32_word(elf32_sh_size dyn) in
        byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
        obtain_elf32_dynamic_section_contents' endian rel shared_object os_additional_ranges os proc)
      | _ => fail0 "obtain_elf32_dynamic_section_contents: multiple SHT_DYNAMIC section header entries"
    end.
(* [?]: removed value specification. *)

Definition obtain_elf64_dynamic_section_contents  (f1 : elf64_file ) (os_additional_ranges : nat  -> bool ) (os : nat  -> error (tag_correspondence )) (proc : nat  -> error (tag_correspondence )) (bs0 : byte_sequence )  : error (list (elf64_dyn )):= 
  let endian := get_elf64_header_endianness(elf64_file_header f1) in
  let sht :=(elf64_file_section_header_table f1) in
  let shared_object := is_elf64_shared_object_file(elf64_file_header f1) in
    match ( List.filter (fun (ent : elf64_section_header_table_entry ) => beq_nat (nat_of_elf64_word(elf64_sh_type ent)) sht_dynamic) sht) with 
      | [] => fail0 "obtain_elf64_dynamic_section_contents: no SHT_DYNAMIC section header entries"
      | [dyn] =>
        let off := nat_of_elf64_off(elf64_sh_offset dyn) in
        let siz := nat_of_elf64_xword(elf64_sh_size dyn) in
        byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
        obtain_elf64_dynamic_section_contents' endian rel shared_object os_additional_ranges os proc)
      | _ => fail0 "obtain_elf64_dynamic_section_contents: multiple SHT_DYNAMIC section header entries"
    end.

(** DT Flags values *)

(** [df_origin] specific that the object being loaded may make reference to the
  * $(ORIGIN) substitution string.
  *)
Definition df_origin    :  nat :=  1. (* 0x1 *)
(** [df_symbolic] changes the linker's symbol resolution algorithm, resolving
  * symbols first from the shared object file rather than the executable file.
  *)
Definition df_symbolic    :  nat :=  2. (* 0x2 *)
(** [df_textrel] if this flag is not set then no relocation entry should cause
  * modification to a non-writable segment.
  *)
Definition df_textrel    :  nat :=  4. (* 0x4 *)
(** [df_bindnow] if set this instructs the linker to process all relocation entries
  * of the containing object before transferring control to the program.
  *)
Definition df_bindnow    :  nat :=  8. (* 0x8 *)
(** [df_static_tls] if set instructs the linker to reject all attempts to load
  * the containing file dynamically.
  *)
Definition df_static_tls    :  nat :=  16.
(* [?]: removed value specification. *)

Definition check_flag  (m : nat ) (pos : nat )  : bool :=  ( beq_nat m pos).
(* [?]: removed value specification. *)

Definition string_of_dt_flag  (flag : nat )  : string := 
  if check_flag flag( 0) then
    "None"
  else if check_flag flag df_origin then
    "ORIGIN"
  else if check_flag flag df_bindnow then
    "BIND_NOW"
  else if check_flag flag df_symbolic then
    "SYMBOLIC"
  else if check_flag flag df_textrel then
    "TEXTREL"
  else if check_flag flag df_static_tls then
    "STATIC_TLS"
  else if check_flag flag ( Coq.Init.Peano.plus df_bindnow df_static_tls) then
    "BIND_NOW STATIC_TLS"
  else if check_flag flag ( Coq.Init.Peano.plus df_static_tls df_symbolic) then
    "SYMBOLIC STATIC_TLS"
  else (* XXX: add more as needed *)
    "Invalid dynamic section flag".
    
(** [rel_type] represents the two types of relocation records potentially present
  * in an ELF file: relocation, and relocation with addends.
  *)
Inductive rel_type : Type :=
   Rel: rel_type   (** Plain relocation type. *)
  | RelA: rel_type .
Definition rel_type_default: rel_type  := Rel.
(* [?]: removed value specification. *)

Definition string_of_rel_type  (r : rel_type )  : string := 
  match ( r) with 
    | Rel  => "REL"
    | RelA => "RELA"
  end.
    
(** Type [dyn_value] represents the value of an ELF dynamic section entry.  Values
  * can represent various different types of objects (e.g. paths to libraries, or
  * flags, or sizes of other entries in a file), and this type collates them all.
  * Parameterised over two type variables so the type can be shared between ELF32
  * and ELF64.
  *)
Inductive dyn_value (addr : Type) (size : Type) : Type :=
   Address:    addr -> dyn_value addr size    (** An address. *)
  | Size:       size -> dyn_value addr size    (** A size (in bytes). *)
  | FName:      string  -> dyn_value addr size   (** A filename. *)
  | SOName:     string  -> dyn_value addr size   (** A shared object name. *)
  | Path:       string  -> dyn_value addr size   (** A path to some directory. *)
  | RPath:      string  -> dyn_value addr size   (** A "run path". *)
  | RunPath:    string  -> dyn_value addr size   (** A "run path". *)
  | Library:    string  -> dyn_value addr size   (** A library path. *)
  | Flags1:     nat  -> dyn_value addr size  (** Flags. *)
  | Flags:      nat  -> dyn_value addr size  (** Flags. *)
  | Numeric:    nat  -> dyn_value addr size  (** An uninterpreted numeric value. *)
  | Checksum:   nat  -> dyn_value addr size  (** A checksum value *)
  | RelType:    rel_type  -> dyn_value addr size (** A relocation entry type. *)
  | Timestamp:  nat  -> dyn_value addr size  (** A timestamp value. *)
  | Null: dyn_value addr size                  (** A null (0) value. *)
  | Ignored: dyn_value addr size.
Definition dyn_value_default {addr: Type} {size: Type} : dyn_value addr size := Address DAEMON.               (** An ignored value. *)
  
(** [elf32_dyn_value] and [elf64_dyn_value] are specialisations of [dyn_value]
  * fixing the correct types for the ['addr] and ['size] type variables.
  *)
Definition elf32_dyn_value : Type :=  dyn_value  elf32_addr   elf32_word .
Definition elf32_dyn_value_default: elf32_dyn_value  := DAEMON.
Definition elf64_dyn_value : Type :=  dyn_value  elf64_addr   elf64_xword .
Definition elf64_dyn_value_default: elf64_dyn_value  := DAEMON.
(* [?]: removed value specification. *)

Definition get_string_table_of_elf32_dyn_section  (endian : endianness ) (dyns : list (elf32_dyn )) (sht : list (elf32_section_header_table_entry )) (bs0 : byte_sequence )  : error (string_table ):= 
  let strtabs :=
    List.filter (fun (x : elf32_dyn ) => Z.eqb      
(int_of_elf32_sword(elf32_dyn_tag x)) ((Zpred (Zpos (P_of_succ_nat dt_strtab))))
    ) dyns
  in
    match ( strtabs) with 
      | [strtab] =>
        match ((elf32_dyn_d_un strtab)) with 
          | D_Val     v => fail0 "get_string_table_of_elf32_dyn_section: STRTAB must be a PTR"
          | D_Ptr     p =>
            let sect :=
              List.filter (fun (s : elf32_section_header_table_entry ) => unsigned_elf32_addr(elf32_sh_addr
                s) p && elf32_word_equal(elf32_sh_type
                  s) (elf32_word_of_nat sht_strtab)
              ) sht
            in
              match ( sect) with 
                | []  => fail0 "get_string_table_of_elf32_dyn_section: no section entry with same address as STRTAB"
                | [s] =>
                  let off := nat_of_elf32_off(elf32_sh_offset  s) in
                  let siz := nat_of_elf32_word(elf32_sh_size s) in
                  byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
                  let strings  := byte_sequence.string_of_byte_sequence rel in
                  return0 (string_table.mk_string_table strings (null_char)))
                | _   => fail0 "get_string_table_of_elf32_dyn_section: multiple section entries with same address as STRTAB"
              end
          | D_Ignored i => fail0 "get_string_table_of_elf32_dyn_section: STRTAB must be a PTR"
        end
      | []       => fail0 "get_string_table_of_elf32_dyn_section: no string table entry"
      | _        => fail0 "get_string_table_of_elf32_dyn_section: multiple string table entries"
    end.
(* [?]: removed value specification. *)

Definition get_string_table_of_elf64_dyn_section  (endian : endianness ) (dyns : list (elf64_dyn )) (sht : list (elf64_section_header_table_entry )) (bs0 : byte_sequence )  : error (string_table ):= 
  let strtabs :=
    List.filter (fun (x : elf64_dyn ) => Z.eqb      
(int_of_elf64_sxword(elf64_dyn_tag x)) ((Zpred (Zpos (P_of_succ_nat dt_strtab))))
    ) dyns
  in
    match ( strtabs) with 
      | [strtab] =>
        match ((elf64_dyn_d_un strtab)) with 
          | D_Val     v => fail0 "get_string_table_of_elf64_dyn_section: STRTAB must be a PTR"
          | D_Ptr     p =>
            let sect :=
              List.filter (fun (s : elf64_section_header_table_entry ) => elf64_addr_equal(elf64_sh_addr
                s) p && elf64_word_equal(elf64_sh_type
                  s) (elf64_word_of_nat sht_strtab)
              ) sht
            in
              match ( sect) with 
                | []  => fail0 "get_string_table_of_elf64_dyn_section: no section entry with same address as STRTAB"
                | [s] =>
                  let off := nat_of_elf64_off(elf64_sh_offset  s) in
                  let siz := nat_of_elf64_xword(elf64_sh_size s) in
                  byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
                  let strings  := byte_sequence.string_of_byte_sequence rel in
                  return0 (string_table.mk_string_table strings null_char))
                | _   => fail0 "get_string_table_of_elf64_dyn_section: multiple section entries with same address as STRTAB"
              end
          | D_Ignored i => fail0 "get_string_table_of_elf64_dyn_section: STRTAB must be a PTR"
        end
      | []       => fail0 "get_string_table_of_elf64_dyn_section: no string table entry"
      | _        => fail0 "get_string_table_of_elf64_dyn_section: multiple string table entries"
    end.
(* [?]: removed value specification. *)

Definition get_value_of_elf32_dyn  (shared_object : bool ) (dyn : elf32_dyn ) (os_additional_ranges : nat  -> bool ) (os : elf32_dyn  -> string_table  -> error (dyn_value (elf32_addr ) (elf32_word ))) (proc : elf32_dyn  -> string_table  -> error (dyn_value (elf32_addr ) (elf32_word ))) (stab : string_table )  : error (dyn_value (elf32_addr ) (elf32_word )):= 
  let tag := Zabs_nat (int_of_elf32_sword(elf32_dyn_tag dyn)) in
    if beq_nat tag dt_null then
      return0 Null
    else if beq_nat tag dt_needed then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf32_dyn_entry: NEEDED must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: NEEDED must be a Val"
      end >>= (fun (off : elf32_word ) =>
        let off := nat_of_elf32_word off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (Library str)))
    else if beq_nat tag dt_pltrelsz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_pltgot then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: PLTGOT must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: PLTGOT must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_hash then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: HASH must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: HASH must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_strtab then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: STRTAB must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: STRTAB must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_symtab then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: SYMTAB must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: SYMTAB must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_rela then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: RELA must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RELA must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_relasz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: RELASZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RELASZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_relaent then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: RELAENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RELAENT must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_strsz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: STRSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: STRSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_syment then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: SYMENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: SYMENT must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_init then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: INIT must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: INIT must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_fini then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: FINI must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: FINI must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_soname then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf32_dyn_entry: SONAME must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: SONAME must be a Val"
      end >>= (fun (off : elf32_word ) =>
        let off := nat_of_elf32_word off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (SOName str)))
    else if beq_nat tag dt_rpath then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf32_dyn_entry: RPATH must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RPATH must be a Val"
      end >>= (fun (off : elf32_word ) =>
        let off := nat_of_elf32_word off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (RPath str)))
    else if beq_nat tag dt_symbolic then
      return0 Null
    else if beq_nat tag dt_rel then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: REL must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: REL must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_relsz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: RELSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RELSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_relent then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: RELENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RELENT must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_pltrel then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: PLTREL must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: PLTREL must be a VAL"
      end >>= (fun (r : elf32_word ) =>
        if beq_nat (nat_of_elf32_word r) dt_rel then
          return0 (RelType Rel)
        else if beq_nat (nat_of_elf32_word r) dt_rela then
          return0 (RelType RelA)
        else
          fail0 "get_value_of_elf32_dyn_entry: PLTREL neither REL nor RELA")
    else if beq_nat tag dt_debug then
      return0 Null
    else if beq_nat tag dt_textrel then
      return0 Null
    else if beq_nat tag dt_jmprel then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: JMPREL must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: JMPREL must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_bindnow then
      return0 Ignored
    else if beq_nat tag dt_init_array then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_fini_array then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR"
      end >>= (fun (ptr : elf32_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_init_arraysz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_fini_arraysz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag dt_runpath then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf32_dyn_entry: RUNPATH must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: RUNPATH must be a Val"
      end >>= (fun (off : elf32_word ) =>
        let off := nat_of_elf32_word off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (RunPath str)))
    else if beq_nat tag dt_flags then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf32_dyn_entry: FLAGS must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: FLAGS must be a Val"
      end >>= (fun (flags : elf32_word ) =>
        return0 (Flags (nat_of_elf32_word flags)))
    else if beq_nat tag dt_encoding then
      if negb shared_object then
        return0 Ignored
      else
        match ((elf32_dyn_d_un dyn)) with 
          | D_Val     v => fail0 "get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR"
          | D_Ptr     p => return0 p
          | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR"
        end >>= (fun (ptr : elf32_addr ) =>
        return0 (Address ptr))
    else if beq_nat tag dt_preinit_arraysz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Checksum (nat_of_elf32_word sz))) (** XXX: bug in readelf does not print this as a size! *)
    else if nat_gteb tag dt_loproc && nat_lteb tag dt_hiproc then
      proc dyn stab
    else if nat_gteb tag dt_loos && nat_lteb tag dt_hios then
      os dyn stab
    else if os_additional_ranges tag then
      os dyn stab
    else
      fail0 "get_value_of_elf32_dyn: unrecognised tag type".
(* [?]: removed value specification. *)

Definition get_value_of_elf64_dyn  (shared_object : bool ) (dyn : elf64_dyn ) (os_additional_ranges : nat  -> bool ) (os_dyn : elf64_dyn  -> string_table  -> error (dyn_value (elf64_addr ) (elf64_xword ))) (proc_dyn : elf64_dyn  -> string_table  -> error (dyn_value (elf64_addr ) (elf64_xword ))) (stab : string_table )  : error (dyn_value (elf64_addr ) (elf64_xword )):= 
  let tag := Zabs_nat (int_of_elf64_sxword(elf64_dyn_tag dyn)) in
    if beq_nat tag dt_null then
      return0 Null
    else if beq_nat tag dt_needed then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf64_dyn_entry: NEEDED must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: NEEDED must be a Val"
      end >>= (fun (off : elf64_xword ) =>
        let off := nat_of_elf64_xword off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (Library str)))
    else if beq_nat tag dt_pltrelsz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_pltgot then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: PLTGOT must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: PLTGOT must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_hash then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: HASH must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: HASH must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_strtab then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: STRTAB must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: STRTAB must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_symtab then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: SYMTAB must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: SYMTAB must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_rela then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: RELA must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RELA must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_relasz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: RELASZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RELASZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_relaent then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: RELAENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RELAENT must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_strsz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: STRSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: STRSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_syment then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: SYMENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: SYMENT must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_init then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: INIT must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: INIT must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_fini then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: FINI must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: FINI must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_soname then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf64_dyn_entry: SONAME must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: SONAME must be a Val"
      end >>= (fun (off : elf64_xword ) =>
        let off := nat_of_elf64_xword off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (SOName str)))
    else if beq_nat tag dt_rpath then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf64_dyn_entry: RPATH must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RPATH must be a Val"
      end >>= (fun (off : elf64_xword ) =>
        let off := nat_of_elf64_xword off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (RPath str)))
    else if beq_nat tag dt_symbolic then
      return0 Null
    else if beq_nat tag dt_rel then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: REL must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: REL must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_relsz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: RELSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RELSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_relent then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: RELENT must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RELENT must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_pltrel then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: PLTREL must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: PLTREL must be a VAL"
      end >>= (fun (r : elf64_xword ) =>
        if beq_nat (nat_of_elf64_xword r) dt_rel then
          return0 (RelType Rel)
        else if beq_nat (nat_of_elf64_xword r) dt_rela then
          return0 (RelType RelA)
        else
          fail0 "get_value_of_elf64_dyn_entry: PLTREL neither REL nor RELA")
    else if beq_nat tag dt_debug then
      return0 Null
    else if beq_nat tag dt_textrel then
      return0 Null
    else if beq_nat tag dt_jmprel then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: JMPREL must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: JMPREL must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_bindnow then
      return0 Ignored
    else if beq_nat tag dt_init_array then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_fini_array then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR"
      end >>= (fun (ptr : elf64_addr ) =>
      return0 (Address ptr))
    else if beq_nat tag dt_init_arraysz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_fini_arraysz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag dt_runpath then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf64_dyn_entry: RUNPATH must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: RUNPATH must be a Val"
      end >>= (fun (off : elf64_xword ) =>
        let off := nat_of_elf64_xword off in
        string_table.get_string_at off stab >>= (fun (str : string ) =>
        return0 (RunPath str)))
    else if beq_nat tag dt_flags then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val v     => return0 v
        | D_Ptr p     => fail0 "get_value_of_elf64_dyn_entry: FLAGS must be a Val"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: FLAGS must be a Val"
      end >>= (fun (flags : elf64_xword ) =>
        return0 (Flags (nat_of_elf64_xword flags)))
    else if beq_nat tag dt_encoding then
      if negb shared_object then
        return0 Ignored
      else
        match ((elf64_dyn_d_un dyn)) with 
          | D_Val     v => fail0 "get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR"
          | D_Ptr     p => return0 p
          | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR"
        end >>= (fun (ptr : elf64_addr ) =>
        return0 (Address ptr))
    else if beq_nat tag dt_preinit_arraysz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
        | D_Ignored i => fail0 "get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Checksum (nat_of_elf64_xword sz))) (** XXX: bug in readelf does not print this as a size! *)
    else if nat_gteb tag dt_loproc && nat_lteb tag dt_hiproc then
      proc_dyn dyn stab
    else if nat_gteb tag dt_loos && nat_lteb tag dt_hios then
      os_dyn dyn stab
    else if os_additional_ranges tag then
      os_dyn dyn stab
    else
      fail0 "get_value_of_elf64_dyn: unrecognised tag type".
