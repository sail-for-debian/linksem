(* Generated by Lem from memory_image_orderings.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_map.
Require Export lem_map.

Require Import lem_set.
Require Export lem_set.

Require Import multimap.
Require Export multimap.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import show.
Require Export show.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import elf_file.
Require Export elf_file.

Require Import elf_header.
Require Export elf_header.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import memory_image.
Require Export memory_image.

Require Import abi_classes.
Require Export abi_classes.

(* open import Abis *)

Require Import missing_pervasives.
Require Export missing_pervasives.

(* [?]: removed value specification. *)

Definition elfFileFeatureCompare  (f1 : elf_file_feature ) (f2 : elf_file_feature )  : ordering :=  
  (* order is: *) match ( (f1, f2)) with (ElfHeader(x1),  ElfHeader(x2)) =>
    (* equal tags, so ... *) elf64_header_compare x1 x2
    | (ElfHeader(x1),  _) => LT
    | (ElfSectionHeaderTable(x1),  ElfHeader(x2)) => GT
    | (ElfSectionHeaderTable(x1),  ElfSectionHeaderTable(x2)) =>
    ( (* equal tags, so ... *) lexicographicCompareBy
        compare_elf64_section_header_table_entry x1 x2)
    | (ElfSectionHeaderTable(x1),  _) => LT
    | (ElfProgramHeaderTable(x1),  ElfHeader(x2)) => GT
    | (ElfProgramHeaderTable(x1),  ElfSectionHeaderTable(x2)) => GT
    | (ElfProgramHeaderTable(x1),  ElfProgramHeaderTable(x2)) =>
    (lexicographicCompareBy compare_elf64_program_header_table_entry x1 x2)
    | (ElfProgramHeaderTable(x1),  _) => LT
    | (ElfSection(x1),  ElfHeader(x2)) => GT
    | (ElfSection(x1),  ElfSectionHeaderTable(x2)) => GT
    | (ElfSection(x1),  ElfProgramHeaderTable(x2)) => GT
    | (ElfSection(x1),  ElfSection(x2)) =>
    (pairCompare (genericCompare nat_ltb beq_nat)
       compare_elf64_interpreted_section x1 x2) | (ElfSection(x1),  _) => LT
    | (ElfSegment(x1),  ElfHeader(x2)) => GT
    | (ElfSegment(x1),  ElfSectionHeaderTable(x2)) => GT
    | (ElfSegment(x1),  ElfProgramHeaderTable(x2)) => GT
    | (ElfSegment(x1),  ElfSection(x2)) => GT
    | (ElfSegment(x1),  ElfSegment(x2)) =>
    (pairCompare (genericCompare nat_ltb beq_nat)
       compare_elf64_interpreted_segment x1 x2) end.
(* [?]: removed value specification. *)

Definition elfFileFeatureTagEquiv  (f1 : elf_file_feature ) (f2 : elf_file_feature )  : bool :=  
    (* order is: *)
    match ( (f1, f2)) with 
        (ElfHeader(x1),  ElfHeader(x2)) => (* equal tags, so ... *) true
      | (ElfSectionHeaderTable(x1),  ElfSectionHeaderTable(x2)) => true
      | (ElfProgramHeaderTable(x1),  ElfProgramHeaderTable(x2)) => true
      | (ElfSection(x1),  ElfSection(x2)) => true
      | (ElfSegment(x1),  ElfSegment(x2)) => true
      | (_,  _) => false
    end.

Instance x110_Ord : Ord elf_file_feature := {
     compare  :=  elfFileFeatureCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elfFileFeatureCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elfFileFeatureCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elfFileFeatureCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elfFileFeatureCompare f1 f2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

Definition tagCompare {abifeature : Type} `{Ord abifeature}  (k1 : range_tag abifeature) (k2 : range_tag abifeature)  : ordering :=  
  match ( (k1, k2)) with (ImageBase,  ImageBase) => EQ | (ImageBase,  _) =>
    LT | (EntryPoint,  ImageBase) => GT | (EntryPoint,  EntryPoint) => EQ
    | (EntryPoint,  _) => LT | (SymbolDef(_),  ImageBase) => GT
    | (SymbolDef(_),  EntryPoint) => GT | (SymbolDef(x1),  SymbolDef(x2)) =>
    symDefCompare x1 x2 | (SymbolDef(_),  _) => LT
    | (SymbolRef(_),  ImageBase) => GT | (SymbolRef(_),  EntryPoint) => GT
    | (SymbolRef(_),  SymbolDef(_)) => GT
    | (SymbolRef(x1),  SymbolRef(x2)) => symRefAndRelocSiteCompare x1 x2
    | (SymbolRef(_),  _) => LT | (FileFeature(_),  ImageBase) => GT
    | (FileFeature(_),  EntryPoint) => GT
    | (FileFeature(_),  SymbolDef(_)) => GT
    | (FileFeature(_),  SymbolRef(_)) => GT
    | (FileFeature(x1),  FileFeature(x2)) => elfFileFeatureCompare x1 x2
    | (FileFeature(_),  _) => LT | (AbiFeature(_),  ImageBase) => GT
    | (AbiFeature(_),  EntryPoint) => GT | (AbiFeature(_),  SymbolDef(_)) =>
    GT | (AbiFeature(_),  SymbolRef(_)) => GT
    | (AbiFeature(_),  FileFeature(_)) => GT
    | (AbiFeature(x1),  AbiFeature(x2)) => compare x1 x2 end.

Instance x109_Ord{abifeature: Type} `{Ord abifeature}: Ord range_tag  abifeature:= {
     compare  :=  tagCompare;
     isLess  :=  fun  tag1 => (fun  tag2 => ( (ordering_equal (tagCompare tag1 tag2) LT)));
     isLessEqual  :=  fun  tag1 => (fun  tag2 => (set_member_by (fun  x  y=>EQ) (tagCompare tag1 tag2) [LT;  EQ]));
     isGreater  :=  fun  tag1 => (fun  tag2 => ( (ordering_equal (tagCompare tag1 tag2) GT)));
     isGreaterEqual  :=  fun  tag1 => (fun  tag2 => (set_member_by (fun  x  y=>EQ) (tagCompare tag1 tag2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

Definition tagEquiv {abifeature : Type} `{AbiFeatureTagEquiv abifeature}  (k1 : range_tag abifeature) (k2 : range_tag abifeature)  : bool :=  
    match ( (k1, k2)) with 
        (ImageBase,  ImageBase) => true
        | (EntryPoint,  EntryPoint) => true
        | (SymbolDef(x1),  SymbolDef(x2)) => true
        | (SymbolRef(_),  SymbolRef(_)) => true
        | (FileFeature(x1),  FileFeature(x2)) => elfFileFeatureTagEquiv x1 x2
        | (AbiFeature(x1),  AbiFeature(x2)) => abiFeatureTagEquiv x1 x2
        | (_,  _) => false
    end.
(* [?]: removed value specification. *)

Definition unique_tag_matching {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (tag : range_tag abifeature) (img3 : annotated_memory_image abifeature)  : range_tag abifeature:=  
    match ( multimap.lookupBy0 tagEquiv tag(by_tag img3)) with 
        [] => DAEMON
        | [(t,  r)] => t
        | x => DAEMON (* (ranges: " ^ 
            (show (List.map (fun (t, r) -> r) x))
            ^  ") when asserted unique")" *)
    end.
(* [?]: removed value specification. *)

Definition tagged_ranges_matching_tag {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (tag : range_tag abifeature) (img3 : annotated_memory_image abifeature)  : list ((range_tag abifeature*option (element_range ) ) % type):=  
    multimap.lookupBy0 tagEquiv tag(by_tag img3).
(* [?]: removed value specification. *)

Definition element_range_compare   : (string *((nat *nat ) % type)) % type -> (string *((nat *nat ) % type)) % type -> ordering :=  pairCompare (fun (x : string ) (y : string )=>EQ) (pairCompare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat)).
(* [?]: removed value specification. *)

Definition unique_tag_matching_at_range_exact {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (r : option (element_range ) ) (tag : range_tag abifeature) (img3 : annotated_memory_image abifeature)  : range_tag abifeature:=  
  (* 1. find tags a unique range labelled as ELF section header table. *)
  match ( unzip
            (multimap.lookupBy0
               (maybeEqualBy
                  ((fun (left : (string *range ) % type) (right : (string *range ) % type)=>
                      (tuple_equal_by
                         (fun (left : string ) (right : string )=>
                            (string_equal left right))
                         ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>
                             (tuple_equal_by beq_nat beq_nat left right)))
                         left right)))) r (by_range img3))) with
      (_,  allRangeMatches) =>
    let tagAlsoMatches  := List.filter
                             (fun (x : range_tag abifeature) =>
                                tagEquiv x tag) allRangeMatches in
  match ( tagAlsoMatches) with [] => DAEMON | [x] => x | _ => DAEMON end end.
(* [?]: removed value specification. *)

Definition symbol_def_ranges {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (img3 : annotated_memory_image abifeature)  : (list (range_tag abifeature)*list (option (element_range ) )) % type:=  
  (* find all element ranges labelled as ELF symbols *)
  match ( unzip
            (
            tagged_ranges_matching_tag (SymbolDef (null_symbol_definition))
              img3 )) with (tags,  maybe_ranges) =>
    (* some symbols, specifically ABS symbols, needn't label a range. *)
  (tags, maybe_ranges) end.
(* [?]: removed value specification. *)

Definition name_of_symbol_def  (sym : symbol_definition )  : string := (def_symname sym).
(* [?]: removed value specification. *)

Definition defined_symbols_and_ranges {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (img3 : annotated_memory_image abifeature)  : list ((option (element_range ) *symbol_definition ) % type):=  
    lem_list.mapMaybe (
  fun (p : (range_tag abifeature*option (element_range ) ) % type) =>
    match ( (p) ) with ( (tag,  maybeRange)) =>
      match ( tag) with SymbolDef(ent) => Some (maybeRange, ent) | _ =>
        DAEMON end end) (tagged_ranges_matching_tag (SymbolDef(null_symbol_definition)) img3).
(* [?]: removed value specification. *)

Definition make_ranges_definite  (rs : list (option (element_range ) ))  : list ((string *range ) % type):=  
    List.map (fun  (maybeR : option  element_range  ) => match ( maybeR) with 
            Some r => r
            | None => DAEMON
        end) rs.
(* [?]: removed value specification. *)

Definition find_defs_matching {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (bound_def : symbol_definition ) (img3 : annotated_memory_image abifeature)  : list ((((string *range ) % type)*symbol_definition ) % type):=  
    let ranges_and_defs := defined_symbols_and_ranges img3
    in 
    (*let _ = errln ("Searching for the bound-to symbol, which came from linkable idx " ^ 
        (show bound_def.def_linkable_idx) ^ ", section " ^ 
        (show bound_def.def_syment.elf64_st_shndx) ^ 
        ", symtab shndx " ^ (show bound_def.def_sym_scn) ^ 
        ", symind " ^ (show bound_def.def_sym_idx))
    in*)
    lem_list.mapMaybe (
  fun (p : (option ((string *range ) % type) *symbol_definition ) % type) =>
    match ( (p) ) with ( (maybe_some_range,  some_def)) =>
      match ( maybe_some_range) with None => DAEMON | Some some_range =>
        if (string_equal (def_symname some_def) (def_symname bound_def)) &&
           beq_nat (def_linkable_idx some_def) (def_linkable_idx bound_def) then
          (*let _ = errln ("Found one in the same linkable: syment is " ^
                        (show some_def.def_syment))
                    in*)
          if classical_boolean_equivalence some_def bound_def then
            Some (some_range, some_def) else None else
          if classical_boolean_equivalence some_def bound_def then
            Some (some_range, some_def) else None end end
    ) ranges_and_defs.
(* [?]: removed value specification. *)

Definition defined_symbols {abifeature : Type} `{Ord abifeature} `{AbiFeatureTagEquiv abifeature}  (img3 : annotated_memory_image abifeature)  : list (symbol_definition ):=  
  match ( symbol_def_ranges img3) with
      (all_symbol_tags,  all_symbol_ranges) =>
    lem_list.mapMaybe
      (fun (tag : range_tag abifeature) =>
         match ( tag) with SymbolDef(ent) => Some ent | _ => DAEMON end)
      all_symbol_tags end.
