(* Generated by Lem from abis/aarch64/abi_aarch64_le.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [abi_aarch64_le] contains top-level definition for the AArch64 ABI (little-endian case).
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.


Require Import elf_header.
Require Export elf_header.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_file.
Require Export elf_file.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.


Require Import endianness.
Require Export endianness.

(* open import Elf_memory_image *)
Require Import abi_classes.
Require Export abi_classes.

Require Import memory_image.
Require Export memory_image.

Require Import abi_aarch64_relocation.
Require Export abi_aarch64_relocation.

Require Import abi_aarch64_le_elf_header.
Require Export abi_aarch64_le_elf_header.

(* [?]: removed value specification. *)

Definition abi_aarch64_le_compute_program_entry_point  (segs : list (elf64_interpreted_segments )) (entry : elf64_addr )  : error (elf64_addr ):= 
	return0 entry.
(* [?]: removed value specification. *)

Definition header_is_aarch64_le  (h : elf64_header )  : bool :=  
    is_valid_elf64_header h
    && ((maybeEqualBy unsigned_char_eq (lem_list.index(elf64_ident h) (id elf_ii_data)) (Some (unsigned_char_of_nat elf_data_2lsb)))
    && (is_valid_abi_aarch64_le_machine_architecture (nat_of_elf64_half(elf64_machine h))
    && is_valid_abi_aarch64_le_magic_number(elf64_ident h))).
    
Inductive aarch64_le_abi_feature : Type :=  GOT: aarch64_le_abi_feature  | PLT: aarch64_le_abi_feature .
Definition aarch64_le_abi_feature_default: aarch64_le_abi_feature  := GOT.
(* [?]: removed value specification. *)

Definition abiFeatureCompare  (f1 : aarch64_le_abi_feature ) (f2 : aarch64_le_abi_feature )  : ordering :=  
    match ( (f1, f2)) with 
        (GOT,  GOT) => EQ
        | (GOT,  PLT) => LT
        | (PLT,  PLT) => EQ
        | (PLT,  GOT) => GT
    end.
(* [?]: removed value specification. *)

Definition abiFeatureTagEq  (f1 : aarch64_le_abi_feature ) (f2 : aarch64_le_abi_feature )  : bool :=  
    match ( (f1, f2)) with 
        (GOT,  GOT) => true
        | (PLT,  PLT) => true
        | (_,  _) => false
    end.

Instance x112_Ord : Ord aarch64_le_abi_feature := {
     compare  :=  abiFeatureCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (abiFeatureCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (abiFeatureCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (abiFeatureCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (abiFeatureCompare f1 f2) [GT;  EQ]))
}.


Instance x111_AbiFeatureTagEquiv : AbiFeatureTagEquiv aarch64_le_abi_feature := {
     abiFeatureTagEquiv  :=  abiFeatureTagEq
}.

(* [?]: removed value specification. *)

Definition section_is_special0 {abifeature : Type}  (s : elf64_interpreted_section ) (f : annotated_memory_image abifeature)  : bool :=  
    elf_section_is_special s f || (* FIXME *) false.
