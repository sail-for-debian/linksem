(* Generated by Lem from gnu_extensions/gnu_ext_abi.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import show.
Require Export show.

Require Import missing_pervasives.
Require Export missing_pervasives.


Require Import byte_sequence.
Require Export byte_sequence.


Require Import abis.
Require Export abis.


Require Import elf_file.
Require Export elf_file.

Require Import elf_header.
Require Export elf_header.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import memory_image.
Require Export memory_image.

(* [?]: removed value specification. *)

Definition gnu_extend {abifeature : Type}  (a : abi abifeature)  : abi abifeature:=  
   {|is_valid_elf_header :=(is_valid_elf_header a)
    ;make_elf_header     :=            
( (*  t -> entry -> shoff -> phoff -> phnum -> shnum -> shstrndx -> hdr *)fun (t : nat ) => fun (entry : nat ) => fun (shoff : nat ) => fun (phoff : nat ) => fun (phnum : nat ) => fun (shnum : nat ) => fun (shstrndx : nat ) =>
            let unmod :=(make_elf_header a) t entry shoff phoff phnum shnum shstrndx
            in
              {|elf64_ident    := 
  match ((elf64_ident unmod)) with i0 :: i1 :: i2 :: i3 :: i4 :: i5 :: i6 ::
  _ :: _ :: i9 :: i10 :: i11 :: i12 :: i13 :: i14 :: i15 :: [] =>
    [i0; i1; i2; i3; i4; i5; i6; unsigned_char_of_nat elf_osabi_gnu;
  unsigned_char_of_nat ( 1); i9; i10; i11; i12; i13; i14; i15] | [] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _::[] =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
    | _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _:: _ =>
    DAEMON (* Incomplete Pattern at File \"gnu_extensions/gnu_ext_abi.lem\", line 37, character 35 to line 44, character 19 *)
  end
               ;elf64_type     := (elf64_half_of_nat t)
               ;elf64_machine  :=(elf64_machine unmod)
               ;elf64_version  :=(elf64_version unmod)
               ;elf64_entry    :=(elf64_entry unmod)
               ;elf64_phoff    := (elf64_off_of_nat phoff)
               ;elf64_shoff    := (elf64_off_of_nat shoff)
               ;elf64_flags    :=(elf64_flags unmod)
               ;elf64_ehsize   :=(elf64_ehsize unmod)
               ;elf64_phentsize:=(elf64_phentsize unmod)
               ;elf64_phnum    := (elf64_half_of_nat phnum)
               ;elf64_shentsize:=(elf64_shentsize unmod)
               ;elf64_shnum    := (elf64_half_of_nat shnum)
               ;elf64_shstrndx := (elf64_half_of_nat shstrndx)
               |})
    ;reloc               :=(reloc a)
    ;section_is_special  := (fun (isec1 : elf64_interpreted_section ) => (fun (img3 : annotated_memory_image abifeature) => ((section_is_special
                                a) isec1 img3
                                || (                                 
(maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right))(missing_pervasives.string_prefix ( (String.length ".gnu.warning"))(elf64_section_name_as_string isec1)) (Some(".gnu.warning"))))
        (* FIXME: This is a slight abuse. The GNU linker's treatment of 
         * ".gnu.warning.*" section is not really a function of the output
         * ABI -- it's a function of the input ABI, or arguably perhaps just
         * of the linker itself. We have to do something to make sure these
         * sections get silently processed separately from the usual linker
         * control script, because otherwise our link map output doesn't match
         * the GNU linker's. By declaring these sections "special" we achieve
         * this by saying they don't participate in linking proper, just like 
         * ".symtab" and similar sections don't. HMM. I suppose this is 
         * okay, in that although a non-GNU linker might happily link these
         * sections, arguably that is a failure to understand the input files. 
         * But the issue about it being a per-input-file property remains.
         * Q. What does the GNU linker do if a reloc input file whose OSABI
         * is *not* GNU contains a .gnu.warning.* section? That would be a fair
         * test about whether looking at the input ABI is worth doing. *)
                            )))
    ;section_is_large    :=(section_is_large a)
    ;maxpagesize         :=(maxpagesize a)
    ;minpagesize         :=(minpagesize a)
    ;commonpagesize      :=(commonpagesize a)
    ;symbol_is_generated_by_linker :=(symbol_is_generated_by_linker a)
    ;make_phdrs          :=(make_phdrs a) (* FIXME: also make the GNU phdrs! *)
    ;max_phnum           := (Coq.Init.Peano.plus( 2)(max_phnum a)) (* FIXME: GNU_RELRO, GNU_STACK; what else? *)
    ;guess_entry_point   :=(guess_entry_point a)
    ;pad_data            :=(pad_data a)
    ;pad_code            :=(pad_code a)
    ;generate_support    :=(generate_support a)
    ;concretise_support  :=(concretise_support a)
    |}.
