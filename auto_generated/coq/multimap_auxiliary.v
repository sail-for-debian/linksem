(* Generated by Lem from multimap.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Open Scope nat_scope.
Open Scope string_scope.



Lemma lowest_simple:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findLowestKVWithKEquivTo( 4) testEquiv 
([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 4, 0);  ( 5, 0);  ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) (Some ( 3, 0))): Prop) .
Lemma lowest_kv:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findLowestKVWithKEquivTo( 4) testEquiv 
([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 3, 1);  ( 4, 0);  ( 5, 0);  ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) (Some ( 3, 0))): Prop) .
Lemma lowest_empty:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findLowestKVWithKEquivTo( 4) testEquiv
([] :  set  ((nat  * nat ) % type)) None) None): Prop) .
Lemma lowest_onepast:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findLowestKVWithKEquivTo( 4) testEquiv
([ ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) None): Prop) .
Lemma lowest_oneprev:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findLowestKVWithKEquivTo( 4) testEquiv 
([ ( 2, 0) ] :  set  ((nat  * nat ) % type)) None) None): Prop) .

(*
let _ = Missing_pervasives.errln ("choose_and_split {3, 4, 5} is " ^ 
    (match Set_extra.chooseAndSplit ({3;4;5} : set natural)
     with Just (l, m, r) -> (show (toList l, m, toList r))
     | Nothing -> "Nothing" end))
*)

Lemma highest_simple:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findHighestKVWithKEquivTo( 4) testEquiv
([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 4, 0);  ( 5, 0);  ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) (Some ( 5, 0))): Prop) .
Lemma highest_kv:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findHighestKVWithKEquivTo( 4) testEquiv
([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 4, 0);  ( 5, 0);  ( 5, 1);  ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) (Some ( 5, 1))): Prop) .
Lemma highest_empty:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findHighestKVWithKEquivTo( 4) testEquiv
([] :  set  ((nat  * nat ) % type)) None) None): Prop) .
Lemma highest_onepast:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findHighestKVWithKEquivTo( 4) testEquiv 
([ ( 6, 0) ] :  set  ((nat  * nat ) % type)) None) None): Prop) .
Lemma highest_oneprev:( (maybeEqualBy ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (findHighestKVWithKEquivTo( 4) testEquiv
([ ( 2, 0) ] :  set  ((nat  * nat ) % type)) None) None): Prop) .

(*
let _ = Missing_pervasives.errln
("lookupBy testEquiv 4 { (1, 0); (2, 0); (3, 0); (4, 0); (5, 0); (6, 0) } is : "
^ (show (lookupBy testEquiv 
4 ({ (1, 0); (2, 0); (3, 0); (4, 0); (5, 0); (6, 0) } : set (natural * natural)))))
*)

Lemma lookup_simple :(
(list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 4, 0);  ( 5, 0);  ( 6, 0) ] :  set  ((nat  * nat ) % type))) ([( 3, 0); ( 4, 0); ( 5, 0)] :  list  ((nat  * nat ) % type))): Prop) .
Lemma lookup_kv :(
(list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([ ( 1, 0);  ( 2, 0);  ( 3, 0);  ( 4, 0);  ( 4, 1);  ( 5, 0);  ( 6, 0) ] :  set  ((nat  * nat ) % type))) ([( 3, 0); ( 4, 0); ( 4, 1); ( 5, 0)] :  list  ((nat  * nat ) % type))): Prop) .
Lemma lookup_empty:( (list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([] :  set  ((nat  * nat ) % type))) ([] : list  ((nat  * nat ) % type))): Prop) .
Lemma lookup_singleton:( (list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([( 5, 0)] :  set  ((nat  * nat ) % type))) ([( 5, 0)] : list  ((nat  * nat ) % type))): Prop) .
Lemma lookup_onepast:( (list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([ ( 6, 0) ] :  set  ((nat  * nat ) % type))) ([] :  list  ((nat  * nat ) % type))): Prop) .
Lemma lookup_oneprev:( (list_equal_by ((fun (left : (nat *nat ) % type) (right : (nat *nat ) % type)=>(tuple_equal_by beq_nat beq_nat left right))) (lookupBy0 testEquiv( 4) ([ ( 2, 0) ] :  set  ((nat  * nat ) % type))) ([] :  list  ((nat  * nat ) % type))): Prop) .


(* To delete all pairs with key equiv to k, can use deleteBy *)

