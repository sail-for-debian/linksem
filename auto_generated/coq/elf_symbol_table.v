(* Generated by Lem from elf_symbol_table.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [elf_symbol_table] provides types, functions and other definitions for
  * working with ELF symbol tables.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_set.
Require Export lem_set.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


Require Import elf_header.
Require Export elf_header.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import endianness.
Require Export endianness.

Require Import string_table.
Require Export string_table.


(** Undefined symbol index *)

Definition stn_undef    :  nat :=  0.

(** Symbol binding *)

(** Local symbols are not visible outside of the object file containing their
  * definition.
  *)
Definition stb_local    :  nat :=  0.

(** Global symbols are visible to all object files being combined.
  *)
Definition stb_global    :  nat :=  1.

(** Weak symbols resemble global symbols but their definitions have lower
  * precedence.
  *)
Definition stb_weak    :  nat :=  2.

(** Values in the following range have reserved OS specific semantics.
  *)
Definition stb_loos    :  nat :=  10.
Definition stb_hios    :  nat :=  12.

(** Values in the following range have reserved processor specific semantics.
  *)
Definition stb_loproc    :  nat :=  13.
Definition stb_hiproc    :  nat :=  15.
(* [?]: removed value specification. *)


(** Symbol types *)

(** The symbol's type is not specified.
  *)
Definition stt_notype    :  nat :=  0.

(** The symbol is associated with a data object such as a variable.
  *)
Definition stt_object    :  nat :=  1.

(** The symbol is associated with a function or other executable code.
  *)
Definition stt_func    :  nat :=  2.

(** The symbol is associated with a section.
  *)
Definition stt_section    :  nat :=  3.

(** Conventionally the symbol's value gives the name of the source file associated
  * with the object file.
  *)
Definition stt_file    :  nat :=  4.

(** The symbol is an uninitialised common block.
  *)
Definition stt_common    :  nat :=  5.

(** The symbol specified a Thread Local Storage (TLS) entity.
  *)
Definition stt_tls    :  nat :=  6.

(** Values in the following range are reserved solely for OS-specific semantics.
  *)
Definition stt_loos    :  nat :=  10.
Definition stt_hios    :  nat :=  12.

(** Values in the following range are reserved solely for processor-specific
  * semantics.
  *)
Definition stt_loproc    :  nat :=  13.
Definition stt_hiproc    :  nat :=  15.
(* [?]: removed value specification. *)

Definition string_of_symbol_type  (m : nat ) (os : nat  -> string ) (proc : nat  -> string )  : string := 
  if beq_nat m stt_notype then
    "NOTYPE"
  else if beq_nat m stt_object then
    "OBJECT"
  else if beq_nat m stt_func then
    "FUNC"
  else if beq_nat m stt_section then
    "SECTION"
  else if beq_nat m stt_file then
    "FILE"
  else if beq_nat m stt_common then
    "COMMON"
  else if beq_nat m stt_tls then
    "TLS"
  else if nat_gteb m stt_loos && nat_lteb m stt_hios then
    os m
  else if nat_gteb m stt_loproc && nat_lteb m stt_hiproc then
    proc m
  else
    "Invalid symbol type".

(** Symbol visibility *)

(** The visibility of the symbol is as specified by the symbol's binding type.
  *)
Definition stv_default    :  nat :=  0.

(** The meaning of this visibility may be defined by processor supplements to
  * further constrain hidden symbols.
  *)
Definition stv_internal    :  nat :=  1.

(** The symbol's name is not visible in other components.
  *)
Definition stv_hidden    :  nat :=  2.

(** The symbol is visible in other components but not pre-emptable.  That is,
  * references to the symbol in the same component resolve to this symbol even
  * if other symbols of the same name in other components would normally be
  * resolved to instead if we followed the normal rules of symbol resolution.
  *)
Definition stv_protected    :  nat :=  3.
(* [?]: removed value specification. *)

Definition string_of_symbol_visibility  (m : nat )  : string := 
  if beq_nat m stv_default then
    "DEFAULT"
  else if beq_nat m stv_internal then
    "INTERNAL"
  else if beq_nat m stv_hidden then
    "HIDDEN"
  else if beq_nat m stv_protected then
    "PROTECTED"
  else
    "Invalid symbol visibility".

(** Symbol table entry type *)

(** [elf32_symbol_table_entry] is an entry in a symbol table.
  *)
Record elf32_symbol_table_entry : Type :=
  { elf32_st_name  : elf32_word      (** Index into the object file's string table *)
   ; elf32_st_value : elf32_addr      (** Gives the value of the associated symbol *)
   ; elf32_st_size  : elf32_word      (** Size of the associated symbol *)
   ; elf32_st_info  : unsigned_char   (** Specifies the symbol's type and binding attributes *)
   ; elf32_st_other : unsigned_char   (** Currently specifies the symbol's visibility *)
   ; elf32_st_shndx : elf32_half      (** Section header index symbol is defined with respect to *)
   }.
Notation "{[ r 'with' 'elf32_st_name' := e ]}" := ({| elf32_st_name := e; elf32_st_value := elf32_st_value r; elf32_st_size := elf32_st_size r; elf32_st_info := elf32_st_info r; elf32_st_other := elf32_st_other r; elf32_st_shndx := elf32_st_shndx r |}).
Notation "{[ r 'with' 'elf32_st_value' := e ]}" := ({| elf32_st_value := e; elf32_st_name := elf32_st_name r; elf32_st_size := elf32_st_size r; elf32_st_info := elf32_st_info r; elf32_st_other := elf32_st_other r; elf32_st_shndx := elf32_st_shndx r |}).
Notation "{[ r 'with' 'elf32_st_size' := e ]}" := ({| elf32_st_size := e; elf32_st_name := elf32_st_name r; elf32_st_value := elf32_st_value r; elf32_st_info := elf32_st_info r; elf32_st_other := elf32_st_other r; elf32_st_shndx := elf32_st_shndx r |}).
Notation "{[ r 'with' 'elf32_st_info' := e ]}" := ({| elf32_st_info := e; elf32_st_name := elf32_st_name r; elf32_st_value := elf32_st_value r; elf32_st_size := elf32_st_size r; elf32_st_other := elf32_st_other r; elf32_st_shndx := elf32_st_shndx r |}).
Notation "{[ r 'with' 'elf32_st_other' := e ]}" := ({| elf32_st_other := e; elf32_st_name := elf32_st_name r; elf32_st_value := elf32_st_value r; elf32_st_size := elf32_st_size r; elf32_st_info := elf32_st_info r; elf32_st_shndx := elf32_st_shndx r |}).
Notation "{[ r 'with' 'elf32_st_shndx' := e ]}" := ({| elf32_st_shndx := e; elf32_st_name := elf32_st_name r; elf32_st_value := elf32_st_value r; elf32_st_size := elf32_st_size r; elf32_st_info := elf32_st_info r; elf32_st_other := elf32_st_other r |}).
Definition elf32_symbol_table_entry_default: elf32_symbol_table_entry  := {| elf32_st_name := elf32_word_default; elf32_st_value := elf32_addr_default; elf32_st_size := elf32_word_default; elf32_st_info := unsigned_char_default; elf32_st_other := unsigned_char_default; elf32_st_shndx := elf32_half_default |}.
(* [?]: removed value specification. *)

Definition elf32_symbol_table_entry_compare  (ent1 : elf32_symbol_table_entry ) (ent2 : elf32_symbol_table_entry )  : ordering :=     
 (sextupleCompare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (nat_of_elf32_word(elf32_st_name ent1), nat_of_elf32_addr(elf32_st_value ent1), 
        nat_of_elf32_word(elf32_st_size ent1), nat_of_unsigned_char(elf32_st_info ent1), 
        nat_of_unsigned_char(elf32_st_other ent1), nat_of_elf32_half(elf32_st_shndx ent1))
       (nat_of_elf32_word(elf32_st_name ent2), nat_of_elf32_addr(elf32_st_value ent2), 
        nat_of_elf32_word(elf32_st_size ent2), nat_of_unsigned_char(elf32_st_info ent2), 
        nat_of_unsigned_char(elf32_st_other ent2), nat_of_elf32_half(elf32_st_shndx ent2))).

Instance x55_Ord : Ord elf32_symbol_table_entry := {
     compare  :=  elf32_symbol_table_entry_compare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf32_symbol_table_entry_compare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf32_symbol_table_entry_compare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf32_symbol_table_entry_compare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf32_symbol_table_entry_compare f1 f2) [GT;  EQ]))
}.

   
(** [elf64_symbol_table_entry] is an entry in a symbol table.
  *)
Record elf64_symbol_table_entry : Type :=
  { elf64_st_name  : elf64_word      (** Index into the object file's string table *)
   ; elf64_st_info  : unsigned_char   (** Specifies the symbol's type and binding attributes *)
   ; elf64_st_other : unsigned_char   (** Currently specifies the symbol's visibility *)
   ; elf64_st_shndx : elf64_half      (** Section header index symbol is defined with respect to *)
   ; elf64_st_value : elf64_addr      (** Gives the value of the associated symbol *)
   ; elf64_st_size  : elf64_xword     (** Size of the associated symbol *)
   }.
Notation "{[ r 'with' 'elf64_st_name' := e ]}" := ({| elf64_st_name := e; elf64_st_info := elf64_st_info r; elf64_st_other := elf64_st_other r; elf64_st_shndx := elf64_st_shndx r; elf64_st_value := elf64_st_value r; elf64_st_size := elf64_st_size r |}).
Notation "{[ r 'with' 'elf64_st_info' := e ]}" := ({| elf64_st_info := e; elf64_st_name := elf64_st_name r; elf64_st_other := elf64_st_other r; elf64_st_shndx := elf64_st_shndx r; elf64_st_value := elf64_st_value r; elf64_st_size := elf64_st_size r |}).
Notation "{[ r 'with' 'elf64_st_other' := e ]}" := ({| elf64_st_other := e; elf64_st_name := elf64_st_name r; elf64_st_info := elf64_st_info r; elf64_st_shndx := elf64_st_shndx r; elf64_st_value := elf64_st_value r; elf64_st_size := elf64_st_size r |}).
Notation "{[ r 'with' 'elf64_st_shndx' := e ]}" := ({| elf64_st_shndx := e; elf64_st_name := elf64_st_name r; elf64_st_info := elf64_st_info r; elf64_st_other := elf64_st_other r; elf64_st_value := elf64_st_value r; elf64_st_size := elf64_st_size r |}).
Notation "{[ r 'with' 'elf64_st_value' := e ]}" := ({| elf64_st_value := e; elf64_st_name := elf64_st_name r; elf64_st_info := elf64_st_info r; elf64_st_other := elf64_st_other r; elf64_st_shndx := elf64_st_shndx r; elf64_st_size := elf64_st_size r |}).
Notation "{[ r 'with' 'elf64_st_size' := e ]}" := ({| elf64_st_size := e; elf64_st_name := elf64_st_name r; elf64_st_info := elf64_st_info r; elf64_st_other := elf64_st_other r; elf64_st_shndx := elf64_st_shndx r; elf64_st_value := elf64_st_value r |}).
Definition elf64_symbol_table_entry_default: elf64_symbol_table_entry  := {| elf64_st_name := elf64_word_default; elf64_st_info := unsigned_char_default; elf64_st_other := unsigned_char_default; elf64_st_shndx := elf64_half_default; elf64_st_value := elf64_addr_default; elf64_st_size := elf64_xword_default |}.
(* [?]: removed value specification. *)

Definition elf64_symbol_table_entry_compare  (ent1 : elf64_symbol_table_entry ) (ent2 : elf64_symbol_table_entry )  : ordering :=     
 (sextupleCompare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) (nat_of_elf64_word(elf64_st_name ent1), nat_of_elf64_addr(elf64_st_value ent1), 
        nat_of_elf64_xword(elf64_st_size ent1), nat_of_unsigned_char(elf64_st_info ent1), 
        nat_of_unsigned_char(elf64_st_other ent1), nat_of_elf64_half(elf64_st_shndx ent1))
       (nat_of_elf64_word(elf64_st_name ent2), nat_of_elf64_addr(elf64_st_value ent2), 
        nat_of_elf64_xword(elf64_st_size ent2), nat_of_unsigned_char(elf64_st_info ent2), 
        nat_of_unsigned_char(elf64_st_other ent2), nat_of_elf64_half(elf64_st_shndx ent2))).

Instance x54_Ord : Ord elf64_symbol_table_entry := {
     compare  :=  elf64_symbol_table_entry_compare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf64_symbol_table_entry_compare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf64_symbol_table_entry_compare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (elf64_symbol_table_entry_compare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (elf64_symbol_table_entry_compare f1 f2) [GT;  EQ]))
}.

  
Definition elf32_symbol_table : Type := 
  list  elf32_symbol_table_entry .
Definition elf32_symbol_table_default: elf32_symbol_table  := DAEMON.
  
Definition elf64_symbol_table : Type := 
  list  elf64_symbol_table_entry .
Definition elf64_symbol_table_default: elf64_symbol_table  := DAEMON.
(* [?]: removed value specification. *)

Definition extract_symbol_binding  (entry : unsigned_char )  : nat := 
  nat_of_unsigned_char (unsigned_char_rshift entry( 4)).
(* [?]: removed value specification. *)

Definition extract_symbol_type  (entry : unsigned_char )  : nat := 
  nat_of_unsigned_char (unsigned_char_land entry (unsigned_char_of_nat( 15))).
(* [?]: removed value specification. *)

Definition make_symbol_info  (binding1 : nat ) (symtype : nat )  : unsigned_char := 
  unsigned_char_plus
    (unsigned_char_lshift (unsigned_char_of_nat binding1)( 4))
    (unsigned_char_land (unsigned_char_of_nat symtype)
      (unsigned_char_of_nat( 15))).
(* [?]: removed value specification. *)

Definition get_symbol_visibility  (info : unsigned_char )  : nat := 
  nat_of_unsigned_char (unsigned_char_land info (unsigned_char_of_nat( 3))).
(* [?]: removed value specification. *)

Definition make_symbol_other  (visibility : nat )  : unsigned_char := 
  unsigned_char_of_nat visibility.
(* [?]: removed value specification. *)

Definition is_elf32_shndx_too_large  (syment : elf32_symbol_table_entry )  : bool :=  beq_nat  
(nat_of_elf32_half(elf32_st_shndx syment)) shn_xindex.
(* [?]: removed value specification. *)

Definition is_elf64_shndx_too_large  (syment : elf64_symbol_table_entry )  : bool :=  beq_nat  
(nat_of_elf64_half(elf64_st_shndx syment)) shn_xindex.
(* [?]: removed value specification. *)

Definition is_elf32_null_entry  (ent : elf32_symbol_table_entry )  : bool :=  beq_nat 
    (nat_of_elf32_word(elf32_st_name ent))( 0)
    && (( beq_nat(nat_of_elf32_addr(elf32_st_value ent))( 0))
    && (( beq_nat(nat_of_elf32_word(elf32_st_size ent))( 0))
    && (( beq_nat(nat_of_unsigned_char(elf32_st_info ent))( 0))
    && (( beq_nat(nat_of_unsigned_char(elf32_st_other ent))( 0))
    && ( beq_nat(nat_of_elf32_half(elf32_st_shndx ent))( 0)))))).
(* [?]: removed value specification. *)

Definition is_elf64_null_entry  (ent : elf64_symbol_table_entry )  : bool :=  beq_nat 
    (nat_of_elf64_word(elf64_st_name ent))( 0)
    && (( beq_nat(nat_of_elf64_addr(elf64_st_value ent))( 0))
    && (( beq_nat(nat_of_elf64_xword(elf64_st_size ent))( 0))
    && (( beq_nat(nat_of_unsigned_char(elf64_st_info ent))( 0))
    && (( beq_nat(nat_of_unsigned_char(elf64_st_other ent))( 0))
    && ( beq_nat(nat_of_elf64_half(elf64_st_shndx ent))( 0)))))).

(** Printing symbol table entries *)

Definition symtab_print_bundle : Type := (
  (nat  ->  string ) * (nat  ->  string )) % type.
Definition symtab_print_bundle_default: symtab_print_bundle  := ((fun (x52 : nat ) => string_default), (fun (x53 : nat ) => string_default)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition elf64_null_symbol_table_entry   : elf64_symbol_table_entry := 
  {|elf64_st_name  := (elf64_word_of_nat( 0))
   ;elf64_st_info  := (unsigned_char_of_nat( 0))
   ;elf64_st_other := (unsigned_char_of_nat( 0))
   ;elf64_st_shndx := (elf64_half_of_nat( 0))
   ;elf64_st_value := (elf64_addr_of_nat( 0))
   ;elf64_st_size  := (elf64_xword_of_nat( 0))
   |}.
(* [?]: removed value specification. *)

(* 
  
Instance x51_Show : Show elf32_symbol_table_entry := {
     show  :=  string_of_elf32_symbol_table_entry
}.
 *)
(* 

Instance x50_Show : Show elf64_symbol_table_entry := {
     show  :=  string_of_elf64_symbol_table_entry
}.
 *)
(* [?]: removed value specification. *)

Definition read_elf32_symbol_table_entry  (endian : endianness ) (bs0 : byte_sequence )  : error ((elf32_symbol_table_entry *byte_sequence ) % type):= 
  read_elf32_word endian bs0 >>= 
  (fun (p : (elf32_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (st_name,  bs0)) =>
       read_elf32_addr endian bs0 >>=
       (fun (p : (elf32_addr *byte_sequence ) % type) =>
          match ( (p) ) with ( (st_value,  bs0)) =>
            read_elf32_word endian bs0 >>=
            (fun (p : (elf32_word *byte_sequence ) % type) =>
               match ( (p) ) with ( (st_size,  bs0)) =>
                 read_unsigned_char endian bs0 >>=
                 (fun (p : (unsigned_char *byte_sequence ) % type) =>
                    match ( (p) ) with ( (st_info,  bs0)) =>
                      read_unsigned_char endian bs0 >>=
                      (fun (p : (unsigned_char *byte_sequence ) % type) =>
                         match ( (p) ) with ( (st_other,  bs0)) =>
                           read_elf32_half endian bs0 >>=
                           (fun (p : (elf32_half *byte_sequence ) % type) =>
                              match ( (p) ) with ( (st_shndx,  bs0)) =>
                                return0
                                  ({|elf32_st_name := st_name;elf32_st_value := st_value;elf32_st_size := st_size;elf32_st_info := st_info;elf32_st_other := st_other;elf32_st_shndx := st_shndx |}, bs0)
                              end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition bytes_of_elf32_symbol_table_entry  (endian : endianness ) (entry : elf32_symbol_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf32_word endian(elf32_st_name entry)
  ; bytes_of_elf32_addr endian(elf32_st_value entry)
  ; bytes_of_elf32_word endian(elf32_st_size entry)
  ; bytes_of_unsigned_char(elf32_st_info entry)
  ; bytes_of_unsigned_char(elf32_st_other entry)
  ; bytes_of_elf32_half endian(elf32_st_shndx entry)]
  .
(* [?]: removed value specification. *)

Definition read_elf64_symbol_table_entry  (endian : endianness ) (bs0 : byte_sequence )  : error ((elf64_symbol_table_entry *byte_sequence ) % type):= 
  read_elf64_word endian bs0 >>= 
  (fun (p : (elf64_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (st_name,  bs0)) =>
       read_unsigned_char endian bs0 >>=
       (fun (p : (unsigned_char *byte_sequence ) % type) =>
          match ( (p) ) with ( (st_info,  bs0)) =>
            read_unsigned_char endian bs0 >>=
            (fun (p : (unsigned_char *byte_sequence ) % type) =>
               match ( (p) ) with ( (st_other,  bs0)) =>
                 read_elf64_half endian bs0 >>=
                 (fun (p : (elf64_half *byte_sequence ) % type) =>
                    match ( (p) ) with ( (st_shndx,  bs0)) =>
                      read_elf64_addr endian bs0 >>=
                      (fun (p : (elf64_addr *byte_sequence ) % type) =>
                         match ( (p) ) with ( (st_value,  bs0)) =>
                           read_elf64_xword endian bs0 >>=
                           (fun (p : (elf64_xword *byte_sequence ) % type) =>
                              match ( (p) ) with ( (st_size,  bs0)) =>
                                return0
                                  ({|elf64_st_name := st_name;elf64_st_info := st_info;elf64_st_other := st_other;elf64_st_shndx := st_shndx;elf64_st_value := st_value;elf64_st_size := st_size |}, bs0)
                              end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition bytes_of_elf64_symbol_table_entry  (endian : endianness ) (entry : elf64_symbol_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf64_word endian(elf64_st_name entry)
  ; bytes_of_unsigned_char(elf64_st_info entry)
  ; bytes_of_unsigned_char(elf64_st_other entry)
  ; bytes_of_elf64_half endian(elf64_st_shndx entry)
  ; bytes_of_elf64_addr  endian(elf64_st_value entry)
  ; bytes_of_elf64_xword endian(elf64_st_size entry)]
  .
(* [?]: removed value specification. *)

Program Fixpoint read_elf32_symbol_table  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf32_symbol_table_entry )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf32_symbol_table_entry endian bs0 >>= 
  (fun (p : (elf32_symbol_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (head1,  bs0)) =>
       read_elf32_symbol_table endian bs0 >>=
       (fun (tail1 : list (elf32_symbol_table_entry )) =>
          return0 (head1 :: tail1)) end).
(* [?]: removed value specification. *)

Program Fixpoint read_elf64_symbol_table  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf64_symbol_table_entry )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf64_symbol_table_entry endian bs0 >>= 
  (fun (p : (elf64_symbol_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (head1,  bs0)) =>
       read_elf64_symbol_table endian bs0 >>=
       (fun (tail1 : list (elf64_symbol_table_entry )) =>
          return0 (head1 :: tail1)) end).

(** Association map of symbol name, symbol type, symbol size, symbol address
  * and symbol binding.
  * A PPCMemism.
  *)
Definition symbol_address_map : Type :=
   list  ((string  * ((nat  * nat  * nat  * nat ) % type)) % type).
Definition symbol_address_map_default: symbol_address_map  := DAEMON.
(* [?]: removed value specification. *)

Definition get_elf32_symbol_image_address  (symtab : list (elf32_symbol_table_entry )) (strtab : string_table )  : error (list ((string *((nat *nat *nat *nat ) % type)) % type)):= 
  mapM (fun (entry : elf32_symbol_table_entry ) =>
    let name1 := nat_of_elf32_word(elf32_st_name entry) in
    let addr := nat_of_elf32_addr(elf32_st_value entry) in
    let size2 := Coq.Init.Peano.mult (nat_of_elf32_word(elf32_st_size entry))( 8) in
    let typ  := extract_symbol_type(elf32_st_info entry) in
    let bnd  := extract_symbol_binding(elf32_st_info entry) in
      string_table.get_string_at name1 strtab >>= (fun (str : string ) =>
      return0 (str, (typ, size2, addr, bnd)))
  ) symtab.
(* [?]: removed value specification. *)

Definition get_elf64_symbol_image_address  (symtab : list (elf64_symbol_table_entry )) (strtab : string_table )  : error (list ((string *((nat *nat *nat *nat ) % type)) % type)):= 
  mapM (fun (entry : elf64_symbol_table_entry ) =>
    let name1 := nat_of_elf64_word(elf64_st_name entry) in
    let addr := nat_of_elf64_addr(elf64_st_value entry) in
    let size2 := nat_of_elf64_xword(elf64_st_size entry) in
    let typ  := extract_symbol_type(elf64_st_info entry) in
    let bnd  := extract_symbol_binding(elf64_st_info entry) in 
      string_table.get_string_at name1 strtab >>= (fun (str : string ) =>
      return0 (str, (typ, size2, addr, bnd)))
  ) symtab.
(* [?]: removed value specification. *)

Definition get_elf32_symbol_type  (syment : elf32_symbol_table_entry )  : nat :=  extract_symbol_type(elf32_st_info syment).
(* [?]: removed value specification. *)

Definition get_elf64_symbol_type  (syment : elf64_symbol_table_entry )  : nat :=  extract_symbol_type(elf64_st_info syment).
(* [?]: removed value specification. *)

Definition get_elf32_symbol_binding  (syment : elf32_symbol_table_entry )  : nat :=  extract_symbol_binding(elf32_st_info syment).
(* [?]: removed value specification. *)

Definition get_elf64_symbol_binding  (syment : elf64_symbol_table_entry )  : nat :=  extract_symbol_binding(elf64_st_info syment).
