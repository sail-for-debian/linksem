(* Generated by Lem from multimap.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_bool.
Require Export lem_bool.
 
Require Import lem_basic_classes.
Require Export lem_basic_classes.
 
Require Import lem_maybe.
Require Export lem_maybe.
 
Require Import lem_function.
Require Export lem_function.
 
Require Import lem_num.
Require Export lem_num.
 
Require Import lem_list.
Require Export lem_list.

Require Import lem_set.
Require Export lem_set.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import lem_string.
Require Export lem_string.

Require Import show.
Require Export show.


(* HMM. Is the right thing instead to implement multiset first? Probably. *)

(* This is a set of pairs
 * augmented with operations implementing a particular kind of 
 * map.
 * 
 * This map differs from the Lem map in the following ways.
 * 
 * 0. The basic idea: it's a multimap, so a single key, supplied as a "query",
 *    can map to many (key, value) results.
 *    But PROBLEM: how do we store them in a tree? We're using OCaml's
 *    Set implementation underneath, and that doesn't allow duplicates.
 * 
 * 1. ANSWER: require keys still be unique, but that the user supplies an 
 *    equivalence relation on them, which
 *    is coarser-grained than the ordering relation
 *    used to order the set. It must be consistent with it, though: 
 *    equivalent keys should appear as a contiguous range in the 
 *    ordering.
 * 
 * 2. This allows many "non-equal" keys, hence present independently
 *    in the set of pairs, to be "equivalent" for the purposes of a 
 *    query.
 * 
 * 3. The coarse-grained equivalence relation can be supplied on a 
 *    per-query basis, meaning that different queries on the same
 *    set can query by finer or coarser criteria (while respecting 
 *    the requirement to be consistent with the ordering).
 * 
 * Although this seems more complicated than writing a map from 
 * k to list (k, v), which would allow us to ditch the finer ordering, 
 * it scales better (no lists) and allows certain range queries which 
 * would be harder to implement under that approach. It also has the 
 * nice property that the inverse multimap is represented as the same
 * set but with the pairs reversed.
 *)

Definition multimap  (k: Type) (v: Type) : Type :=  set  ((k * v) % type).
Definition multimap_default {k: Type} {v: Type} : multimap k v := DAEMON.

(* In order for bisection search within a set to work, 
 * we need the equivalence class to tell us whether we're less than or
 * greater than the members of the key's class. 
 * It effectively identifies a set of ranges. *)
Definition key_equiv (k: Type) : Type :=  k ->  k ->  bool .
Definition key_equiv_default{k: Type} : key_equiv k := (fun (x14 :  k) => (fun (x15 :  k) => bool_default)).
(* [?]: removed value specification. *)

Program Fixpoint findLowestKVWithKEquivTo {k v : Type} `{Ord k} `{Ord v} `{SetType k} `{SetType v}  (k1 : k) (equiv : k -> k -> bool ) (subSet : set ((k*v) % type)) (maybeBest : option ((k*v) % type) )  : option ((k*v) % type) :=  
    match ( choose_and_split subSet) with 
        None => (* empty subset *) maybeBest
      | Some(lower,  (chosenK,  chosenV),  higher) =>
            (* is k equiv to chosen? *)
            if equiv k1 chosenK
            then (* is chosen less than our current best? *)
 match ( match ( maybeBest) with None => (chosenK, chosenV)
           | Some(currentBestK,  currentBestV) =>
           if pairLess (chosenK, chosenV) (currentBestK, currentBestV) then
             (chosenK, chosenV) else (currentBestK, currentBestV) end) with
     (bestK,  bestV) =>
   (* recurse down lower subSet; best is whichever is lower *)
   findLowestKVWithKEquivTo k1 equiv lower (Some (bestK, bestV)) end
            else
                (* k is not equiv to chosen; do we need to look lower or higher? *)
                if  isLess k1 chosenK
                then
                    (* k is lower, so look lower for equivs-to-k *)
                    findLowestKVWithKEquivTo k1 equiv lower maybeBest
                else
                    (* k is higher *)
                    findLowestKVWithKEquivTo k1 equiv higher maybeBest
    end.
(* [?]: removed value specification. *)

Definition testEquiv  (x : nat ) (y : nat )  : bool :=  if ( nat_gteb x( 3) && (nat_ltb x( 5) && (nat_gteb y( 3) && nat_lteb y( 5)))) then true
     else if ( nat_ltb x( 3) && nat_ltb y( 3)) then true
     else if ( nat_gtb x( 5) && nat_gtb y( 5)) then true
     else false.
(* [?]: removed value specification. *)

Program Fixpoint findHighestKVWithKEquivTo {k v : Type} `{Ord k} `{Ord v} `{SetType k} `{SetType v}  (k1 : k) (equiv : k -> k -> bool ) (subSet : set ((k*v) % type)) (maybeBest : option ((k*v) % type) )  : option ((k*v) % type) :=  
    match ( choose_and_split subSet) with 
        None => (* empty subset *) maybeBest
      | Some(lower,  (chosenK,  chosenV),  higher) =>
            (* is k equiv to chosen? *)
            if equiv k1 chosenK
            then (* is chosen greater than our current best? *)
 match ( match ( maybeBest) with None => (chosenK, chosenV)
           | Some(currentBestK,  currentBestV) =>
           if pairGreater (chosenK, chosenV) (currentBestK, currentBestV)
           then (chosenK, chosenV) else (currentBestK, currentBestV) end) with
     (bestK,  bestV) =>
   (* recurse down higher-than-chosen subSet; best is whichever is higher *)
   findHighestKVWithKEquivTo k1 equiv higher (Some (bestK, bestV)) end
            else
                (* k is not equiv to chosen; do we need to look lower or higher? 
                 * NOTE: the pairs in the set must be lexicographically ordered! *)
                if  isGreater k1 chosenK
                then
                    (* k is higher than chosen, so look higher for equivs-to-k *)
                    findHighestKVWithKEquivTo k1 equiv higher maybeBest
                else
                    (* k is lower than chosen, so look lower *)
                    findHighestKVWithKEquivTo k1 equiv lower maybeBest
    end.
(* [?]: removed value specification. *)

Definition lookupBy0 {k v : Type} `{Ord k} `{Ord v} `{SetType k} `{SetType v}  (equiv : k -> k -> bool ) (k1 : k) (m : set ((k*v) % type))  : list ((k*v) % type):=  
    (* Find the lowest and highest elements equiv to k. 
     * We do this using chooseAndSplit recursively. *)
    match ( findLowestKVWithKEquivTo k1 equiv m None) with 
        None => []
        | Some lowestEquiv => 
            let highestEquiv  := 
                (* We can't just invert the relation on the set, because
                 * the whole set is ordered *)
                match ( findHighestKVWithKEquivTo k1 equiv m None) with 
                    None => DAEMON
                    | Some highestEquiv => highestEquiv
                end
        in (* FIXME: split is currently needlessly inefficient on OCaml! *)
 match ( lem_set.split lowestEquiv m) with (lowerThanLow,  highEnough) =>
   match ( lem_set.split highestEquiv highEnough) with (wanted,  tooHigh) =>
     (* NOTE that lowestEquiv is a single element; we want to include 
         * *all those equiv to it*, which may be non-equal. FIXME: use splitMember,
         * although that needs fixing in Lem (plus an optimised OCaml version). *)
     (@ List.app _)
       ((@ List.app _)
          (set_to_list
             (let x2  := [] in set_fold
                                 (fun (s : (k*v) % type) (x2 : set ((k*v) % type)) =>
                                    if (ordering_equal EQ
                                          (pairCompare compare compare 
                                           s lowestEquiv)) then set_add s x2
                                    else x2) m x2)) (set_to_list wanted))
       (
       (* don't include the lowest and highest twice, if they're the same *)
       if pairLess lowestEquiv highestEquiv then
         (set_to_list
            (let x2  := [] in set_fold
                                (fun (s : (k*v) % type) (x2 : set ((k*v) % type)) =>
                                   if (ordering_equal EQ
                                         (pairCompare compare compare 
                                          s highestEquiv)) then set_add s x2
                                   else x2) m x2)) else [] ) end end
    end.


(* To delete all pairs with key equiv to k, can use deleteBy *)

