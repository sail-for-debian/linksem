(* Generated by Lem from link.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_map.
Require Export lem_map.

Require Import lem_set.
Require Export lem_set.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import command_line.
Require Export command_line.

Require Import input_list.
Require Export input_list.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import default_printing.
Require Export default_printing.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.

Require Import endianness.
Require Export endianness.


Require Import elf_header.
Require Export elf_header.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_relocation.
Require Export elf_relocation.


Require Import abis.
Require Export abis.

Require Import abi_amd64_relocation.
Require Export abi_amd64_relocation.
 (* HACK -- remove me *)

Require Import input_list.
Require Export input_list.

Require Import linkable_list.
Require Export linkable_list.

Require Import command_line.
Require Export command_line.


Require Import memory_image.
Require Export memory_image.

Require Import memory_image_orderings.
Require Export memory_image_orderings.

Require Import elf_memory_image.
Require Export elf_memory_image.

Require Import elf_memory_image_of_elf64_file.
Require Export elf_memory_image_of_elf64_file.

Require Import linker_script.
Require Export linker_script.


Definition all_common_symbols  (img3 : annotated_memory_image (any_abi_feature ))  : list (symbol_definition ):=  List.filter (fun (def : symbol_definition ) => beq_nat    
 (nat_of_elf64_half(elf64_st_shndx(def_syment def))) shn_common
) (elf_memory_image_defined_symbols img3).
(* [?]: removed value specification. *)

Definition def_is_in_reloc  (def_item : (linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)  : bool :=  match ( def_item) with 
    (RelocELF(_),  _,  _) => true
    | (ScriptAST(_),  _,  _) => true
    | _ => false
end.

Definition retrieve_binding_for_ref {a b c d e : Type} `{Eq b}  (r : symbol_reference_and_reloc_site ) (r_linkable_idx : b) (item : e) (bindings_by_name : fmap (string ) (list ((a*((((b*symbol_reference *d) % type)*c) % type)) % type)))  : (((b*symbol_reference *d) % type)*c) % type:=  
    let maybe_found_bs  := (fmap_lookup_by (fun (x : string ) (y : string )=>EQ)(ref_symname(ref r)) bindings_by_name)
    in 
    match ( maybe_found_bs) with 
        None => DAEMON
            (* FIXME: could this actually be an "undefined symbol" link error perhaps? *)
        | Some bis_and_bs => match ( List.filter (
  fun (p : (a*((((b*symbol_reference *d) % type)*c) % type)) % type) =>
    match ( (p) ) with
        ( (b_idx,  ((b_ref_idx,  b_ref,  b_ref_item),  b_maybe_def))) =>
      if (b_ref_idx = r_linkable_idx) &&
         classical_boolean_equivalence b_ref (ref r) then
        (*let _ = Missing_pervasives.outln ("saw ref from linkable idx " ^ (show r_linkable_idx) 
                ^ ", ref sym scn " ^ (show r.ref.ref_sym_scn) ^ ", ref sym idx "^ (show r.ref.ref_sym_idx) 
                ^ ", item " ^ (show item) ^ "; binding to " ^ (
                    match b_maybe_def with
                        Just (def_idx, def, def_item) -> "linkable idx " ^ (show def_idx) ^ 
                            ", def sym scn " ^ (show def.def_sym_scn) ^ ", def sym idx " ^ 
                            (show def.def_sym_idx)
                      | Nothing -> "no definition"
                    end
                )
            )
            in*) true
      else false end) bis_and_bs) with 
                  [] => DAEMON
                | [(bi,  b1)] => b1
                | _ =>  DAEMON
            end
    end.

Definition reloc_site_resolution : Type := ( reloc_site  * binding  * reloc_decision ) % type.
Definition reloc_site_resolution_default: reloc_site_resolution  := (reloc_site_default, binding_default, reloc_decision_default).

Definition reloc_simplify_fn : Type :=  reloc_site  ->  binding  ->  reloc_decision  ->  set  command_line.link_option  ->  reloc_decision .
Definition reloc_simplify_fn_default: reloc_simplify_fn  := (fun (x138 :  reloc_site ) => (fun (x139 :  binding ) => (fun (x140 :  reloc_decision ) => (fun (x141 :  set  command_line.link_option ) => reloc_decision_default)))).
(* [?]: removed value specification. *)

Definition default_simplify_reloc  (rs : reloc_site ) (b : (((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type) (rd : reloc_decision ) (options : set (command_line.link_option ))  : reloc_decision :=  
    (* If we're building a static executable, simplify PIC-style relocs 
     * so that they bind directly. *)
    let building_executable := (set_member_by (fun (x : command_line.link_option ) (y : command_line.link_option )=>EQ) (command_line.OutputKind(command_line.Executable)) options) in
    let linking_statically := (* for the moment *) true in 
  match ( b) with ((ref_idx,  ref1,  ref_item),  maybe_def) =>
    if building_executable && linking_statically then
      match ( rd) with ApplyReloc(None) =>
        (* Okay -- simplify non-TLS via-GOT ones.
             * ARGH. We can't just turn a via-GOT access into a not-via-GOT access.
             * We need to change the addressing mode to be less indirect by one level.
             * This means rewriting the instruction (from mov to lea, say).
             * GNU ld does this even with --no-relax. *)
      let replacement := (*  match Abi_amd64_relocation.string_of_amd64_relocation_type (get_elf64_relocation_a_type rs.ref_relent) with
                "r_x86_64_got32"        -> 
                | "r_x86_64_gotpcrel"   -> 
                | "r_x86_64_gotoff64"   -> 
                | "r_x86_64_gotpc32"    -> 
                | _ -> Nothing
            end *) None
      in
      if negb ((maybeEqualBy tripleEqual replacement None)) then
        (*let _ = errln ("Simplifying a via-GOT symbol reference: " ^ ref.ref_symname ^ " coming from linkable " ^ (show ref_idx) ^ 
                    ", logically from section " ^ (show rs.ref_src_scn)) 
                in*)
        ApplyReloc (replacement) else (* FIXME: also simplify PLT ones. *) rd
        | _ => rd end else rd end.
(* [?]: removed value specification. *)

Definition mark_fate_of_relocs  (linkable_idx : nat ) (a : abi (any_abi_feature )) (simplify_reloc : reloc_site  -> binding  -> reloc_decision  -> set (command_line.link_option ) -> reloc_decision ) (options : set (command_line.link_option )) (bindings_by_name : fmap (string ) (list ((nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)) % type))) (item : (linkable_object *input_item *input_options ) % type) (img3 : annotated_memory_image (any_abi_feature ))  : (list ((reloc_site *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)*reloc_decision ) % type)*annotated_memory_image (any_abi_feature )) % type:=  
    (* Our image already models relocation sites. For each relocation *record*,
     * we use our bindings to make a decision about whether to apply it or not.
     * 
     * Q1. How do we get the .rela.dyn made? Synthesise a fake reloc section?
     * Or pass them through to the linker script separately?
     * AHA. Note that the script already has an entry for .rela.dyn.
     * And it matches the ordinary rel sections, e.g. .rela.text and so on.
     * So if "-q" is active, the applied relocs need to be injected back in *after* the script
     * has run.
     * So we need both to materialize some relocs into the script inputs, *and* save some for later. 
     * 
     * Can we just use memory image metadata as the "saved for later" case? YES, I think so.
     * What do we do with metadata that is now being materialized?
     * I think we should only remove the metadata when we apply the relocation.
     * Q. When do we do that?
     * A. *After* address assignment has happened, i.e. all sections are allocated.
     *)
    let building_executable := (set_member_by (fun (x : command_line.link_option ) (y : command_line.link_option )=>EQ) (command_line.OutputKind(command_line.Executable)) options) in
    let building_shared_library := (set_member_by (fun (x : command_line.link_option ) (y : command_line.link_option )=>EQ) (command_line.OutputKind(command_line.SharedLibrary)) options) in
    let bind_functions_early := (set_member_by (fun (x : command_line.link_option ) (y : command_line.link_option )=>EQ) command_line.BindFunctionsEarly options) in
    let bind_non_functions_early := (set_member_by (fun (x : command_line.link_option ) (y : command_line.link_option )=>EQ) command_line.BindNonFunctionsEarly options) in 
  match ( List.fold_left
            (fun (p : (set ((range_tag (any_abi_feature )*option (element_range ) ) % type)*list ((reloc_site *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)*reloc_decision ) % type)) % type) =>
               match ( (p) ) with ( (acc_by_tag,  rev_acc_decisions)) =>
                 (fun (p : (range_tag (any_abi_feature )*option (element_range ) ) % type) =>
                    match ( (p) ) with ( (tag,  maybe_range)) =>
                      let pass_through := (set_add (tag, maybe_range)
                                             acc_by_tag, rev_acc_decisions)
                    in
                    match ( tag) with SymbolRef(r) =>
                      match ((maybe_reloc r)) with Some reloc1 =>
                        (* decision: do we want to
                         *  - apply it?   if so, do we need a consequent relocation (e.g. R_*_RELATIVE) in the output?
                         *  - PICify it, but leave it interposable?    
                         *  - is "PICified, non-interposable" a thing? I don't think so, because non-interposable bindings are 
                                     either intra-object *or* necessarily need load-time relocation to account for load addresses.
                                     In fact ELF can't express "non-interposable inter-object bindings" because we can't name
                                     specific objects when binding symbols.
                         *  - leave it alone, i.e. "relocate at load time"?
                         * 
                         * Some useful questions: is the binding final? 
                         * The GNU linker *never* leaves text relocs alone when generating shared libs; 
                         * it always PICifies them.
                         * It can leave them alone when generating executables, though.
                         * This is an approximation; load-time text relocation can make sense for shared libs.
                         *     (but it's dangerous because PC32 relocs might overflow)
                         *)
                      let binding_is_final
                      := fun (options : set (command_line.link_option )) =>
                           (fun (p : (((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type) =>
                              match ( (p) ) with
                                  ( ((ref_idx,  ref1,  ref_item),  maybe_def)) =>
                                match ( maybe_def) with
                                    (* Weak bindings to 0 are final (though libcrunch wishes they weren't!). *)
                                None => true
                                  | Some (def_idx,  def,  def_item) =>
                                  beq_nat
                                    (
                                    (* Bindings to non-global symbols are final. *) get_elf64_symbol_binding
                                      (def_syment def)) stb_local ||
                                  ((
                                   (* Bindings to hidden- or protected- or internal-visibility globals 
                                     *    are final. *) set_member_by
                                     (genericCompare nat_ltb beq_nat)
                                     (get_symbol_visibility
                                        (elf64_st_info(def_syment def)))
                                     [ stv_hidden;  stv_protected;  stv_internal ])
                                   ||
                                   (
                                   (* Bindings to global symbols are non-final
                                     *    *unless* 
                                     *      1. the symbol definition is [going to end up] in the executable
                                     *      2. we're -Bsymbolic, outputting a shared object,
                                     *           and the symbol definition is [going to end up] within the same shared object
                                     *      3. we're -Bsymbolic-functions, outputting a shared object,
                                     *           and the symbol definition has STT_FUNC and is [going to end up] within the same shared object
                                     *
                                     * ... where "going to end up in an X" means "we're building an X and def is in a RelocELF rather than a SharedELF".
                                     *)
                                   (* 1. *) (building_executable &&
                                             def_is_in_reloc def_item) ||
                                   (* 2 and 3. *)
                                   (building_shared_library &&
                                    (def_is_in_reloc def_item &&
                                     ( ( beq_nat
                                           (get_elf64_symbol_type
                                              (def_syment def)) stt_func &&
                                         bind_functions_early) ||
                                       ( negb
                                           (beq_nat
                                              (get_elf64_symbol_type
                                                 (def_syment def)) stt_func)
                                         && bind_non_functions_early) )) )))
                                (* FIXME: does it matter if the binding is intra-object or inter-object?
                                     * We don't get inter-object bindings much to non-{default global}s. How much? *)
                                end end) in
                      let reloc_is_absolute := fun (rs : reloc_site ) =>
                                                 let kind := get_elf64_relocation_a_type
                                                               (ref_relent rs) in
                                                 match ((reloc a) kind) with
                                                     (is_abs,  _) => is_abs
                                                 end in
                      (* What's our decision for this reloc? leave, apply, MakePIC? 
                         * In fact we return both a decision and a maybe-function to create
                         * the consequent reloc. 
                         * In what circumstances do we leave the reloc? If we're making an executable
                               and the definition is not in a relocatable input file or archive or script.
                               Or if we're making a shared library and the reference is "from data".
                               What does "from data" mean? I think it means it's a PC-relative reloc. 
                               If we compile our code to do movabs $addr, even from a *local* address,
                               it's not PIC because that address needs load-time fixup.
                               So actually it's "is absolute address" again.
                         *)
                      let b := retrieve_binding_for_ref r linkable_idx 
                               item bindings_by_name in
                      match ( b) with
                          ((ref_idx,  _,  ref_item),  maybe_def) =>
                        let defined_in_shared_lib := match ( maybe_def) with
                                                         Some (def_idx,  def,  def_item) =>
                                                       negb
                                                         (def_is_in_reloc
                                                            def_item)
                                                       | None =>
                                                       false (* i.e. the "definition", 0, can be "linked in" *)
                                                     end in
                      let decide := fun (decision : reloc_decision ) => (
                                      (*let _ = errln ("Decided to " ^ match decision with
                                LeaveReloc -> "leave"
                                | ApplyReloc(_) -> "apply"
                                | ChangeTo(_) -> "change somehow (maybe PICify?)"
                            end ^ " relocation in linkable " ^ (show ref_item) ^ "'s image, bound to " ^ 
                            match maybe_def with
                                Just(def_idx, def, def_item) -> "a definition called `" ^ def.def_symname ^ "' in linkable " ^
                                    (show def_item)
                                | Nothing -> "no definition"
                            end
                            )
                            in*)
                                      set_add
                                        (SymbolRef
                                           ({|ref :=(ref r)
                                           ;maybe_reloc :=(maybe_reloc r)
                                           ;maybe_def_bound_to := (Some
                                                                    (decision,
                                                                    match ( maybe_def) with
                                                                    Some(def_idx,  def,  def_item) =>
                                                                    Some
                                                                    {|def_symname :=(def_symname def)
                                                                    ;def_syment :=(def_syment def)
                                                                    ;def_sym_scn :=(def_sym_scn def)
                                                                    ;def_sym_idx :=(def_sym_idx def)
                                                                    ;def_linkable_idx := def_idx
                                                                    |}
                                                                    | None =>
                                                                    None end) )
                                           |} ), maybe_range) acc_by_tag,
                                      ((reloc1, b, decision) ::
                                       rev_acc_decisions)) in
                      if (building_executable && defined_in_shared_lib) ||
                         (building_shared_library &&
                          (reloc_is_absolute reloc1)) then decide LeaveReloc
                      else
                        (* In what circumstances do we apply the reloc? If it's a final binding. *)
                        if binding_is_final options b then
                          decide (ApplyReloc (None))
                        (* In what circumstances do we MakePIC? If it's a non-absolute relocatable field
                         *     and we're building a shared library. 
                         * 
                         * PIC is a kind of "consequent relocation", so let's think through it. 
                         * A call site that calls <printf>      will usually be non-final (overridable).
                         * Output needs to call   <printf@plt>. BUT the trick is as follows:
                         *        the reloc is swizzled so that it binds to the PLT slot <printf@plt>;
                         *        the PLT slot is locally generated, so no reloc is needed.
                         * So the point is that
                         *        a *non*-applied reloc
                         *        might still need "applying" after a fashion (swizzling).
                         * The initial reloc is removed! Since PLT means removing relocs from code
                         * and reproducing their effect using a PLT.
                         * That's why we need this special MakePIC behaviour.
                         * Actually, generalise to a ChangeRelocTo.
                         * 
                         * What about data?
                         * Suppose I have a shared library containing a read-only pointer to <environ>.
                         * The binding is final because <environ> is defined in the executable, say.
                         * PIC doesn't handle this case -- we still need load-time relocation.
                         * It's PIC, not PID: data can't be made position-independent.
                         *
                         * So, at least for simple cases of PIC, we don't need consequent relocation if
                         * we don't apply the reloc. We'll be removing the reloc. But we *do* need to create 
                         * extra stuff later (PLT, GOT).
                         *)
                        else
                          if building_shared_library then
                            decide
                              (* MakePIC *) (ChangeRelocTo
                                               ( 0,(ref r), reloc1)) (* FIXME *)
                          (* The above are non-exclusive and non-exhaustive. Often, more than one option is available,
                         * ABIs / practice makes an arbitrary choice. For example, final bindings
                         * within a library could be realised the PIC way, but aren't (it'd create a 
                         * pointless indirection). *)
                          else DAEMON end | None =>
                        (* symbol ref with no reloc *) pass_through end
                      | _ => pass_through end end ) end)
            (set_to_list (by_tag img3)) ([], [])) with
      (new_by_tag,  rev_decisions) =>
    (List.rev rev_decisions, {|elements :=(elements img3)
  ;by_tag := new_by_tag ;by_range := (by_range_from_by_tag new_by_tag) |})
  end.
(* [?]: removed value specification. *)

Definition strip_metadata_sections  (reloc_decisions : list ((reloc_site *((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)*reloc_decision ) % type)) (a : abi (any_abi_feature )) (img3 : annotated_memory_image (any_abi_feature ))  : annotated_memory_image (any_abi_feature ):=  
  match ( elf_memory_image_section_ranges img3) with
      (section_tags,  section_ranges) =>
    let rel_sections := lem_list.mapMaybe
                          (fun (p : (range_tag (any_abi_feature )*((string *((nat *nat ) % type)) % type)) % type) =>
                             match ( (p) ) with
                                 ( (range_tag1,  (el_name,  el_range))) =>
                               match ( range_tag1) with
                                   FileFeature(ElfSection(idx1,  isec1)) =>
                                 if (set_member_by
                                       (genericCompare nat_ltb beq_nat)
                                       (elf64_section_type isec1)
                                       [ sht_rel;  sht_rela ]) then
                                   Some (idx1, isec1, el_name) else None
                                 | _ => None end end )
                          (zip section_tags section_ranges) in
  let discarded_sections_with_element_name := lem_list.mapMaybe
                                                (fun (p : (range_tag (any_abi_feature )*((string *((nat *nat ) % type)) % type)) % type) =>
                                                   match ( (p) ) with
                                                       ( (range_tag1,  (el_name,  el_range))) =>
                                                     match ( range_tag1) with
                                                         FileFeature(ElfSection(idx1,  isec1)) =>
                                                       if(section_is_special a)
                                                           isec1 img3 (* discard reloc sections, and we'll re-add them *)
                                                       then
                                                         Some
                                                           (el_name, range_tag1)
                                                       else None
                                                       | ImageBase =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | EntryPoint =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | SymbolDef _ =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | SymbolRef _ =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | FileFeature(ElfHeader _) =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | FileFeature(ElfSectionHeaderTable _) =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | FileFeature(ElfProgramHeaderTable _) =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | FileFeature(ElfSegment _) =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                       | AbiFeature _ =>
                                                       DAEMON (* Incomplete Pattern at File \"link.lem\", line 355, character 9 to line 359, character 11 *)
                                                     end end )
                                                (zip section_tags
                                                   section_ranges) in
  let discarded_elements_map := List.fold_left
                                  (fun (m : fmap (string ) (range_tag (any_abi_feature ))) =>
                                     (fun (p : (string *range_tag (any_abi_feature )) % type) =>
                                        match ( (p) ) with
                                            ( (el_name,  range_tag1)) =>
                                          fmap_add el_name range_tag1 m end))
                                  discarded_sections_with_element_name
                                  fmap_empty in
  let filtered_image := memory_image.filter_elements
                          (fun (p : (string *element ) % type) =>
                             match ( (p) ) with ( (el_name,  el)) =>
                               negb
                                 ( (set_member_by
                                      (fun (x : string ) (y : string )=> EQ)
                                      el_name
                                      (fmap_domain_by
                                         (fun (x : string ) (y : string )=>
                                            EQ) discarded_elements_map))) end)
                          img3 in
  let new_reloc_section_length := fun (idx1 : nat ) =>
                                    (fun (isec1 : elf64_interpreted_section ) =>
                                       let retained_relocs_from_this_section := let x2 := [] in 
                                       List.fold_right
                                         (fun (p : (reloc_site *((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)*reloc_decision ) % type) (x2 : list ((reloc_site *((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)*reloc_decision ) % type)) =>
                                            match ( (p ,x2) ) with
                                                ((reloc1,  b,  decision) ,  x2) =>
                                              if beq_nat
                                                   (ref_rel_scn (* is it from this section? *)
                                                   reloc1) idx1
                                                 (* are we retaining it? *)
                                                 &&
                                                 classical_boolean_equivalence
                                                   decision LeaveReloc then
                                                (reloc1, b, decision) :: x2
                                              else x2 end) x2 reloc_decisions
                                       in Coq.Init.Peano.mult
                                            (length
                                               retained_relocs_from_this_section)
                                            (elf64_section_entsize isec1) )
  in
  match ( unzip
            (let x2 := [] in List.fold_right
                               (fun (p : (nat *elf64_interpreted_section *string ) % type) (x2 : list ((((string *element ) % type)*((range_tag (any_abi_feature )*option ((string *((nat *nat ) % type)) % type) ) % type)) % type)) =>
                                  match ( (p ,x2) ) with
                                      ((idx1,  isec1,  el_name) ,  x2) =>
                                    if nat_gtb
                                         (new_reloc_section_length idx1 isec1)
                                         ( 0) then
                                      (let new_len := new_reloc_section_length
                                                        idx1 isec1 in
                                      let new_el := {|startpos := None ;length1 := (
                                      Some new_len);contents := [] |} in
                                      let new_isec := {|elf64_section_name :=(elf64_section_name isec1)
                                      ;elf64_section_type :=(elf64_section_type isec1)
                                      ;elf64_section_flags :=(elf64_section_flags isec1)
                                      ;elf64_section_addr :=( 0) (* should be 0 anyway *)
                                      ;elf64_section_offset :=( 0) (* ignored *)
                                      ;elf64_section_size := new_len
                                      ;elf64_section_link :=(elf64_section_link isec1)
                                      ;elf64_section_info :=(elf64_section_info isec1)
                                      ;elf64_section_align :=(elf64_section_align isec1)
                                      ;elf64_section_entsize :=(elf64_section_entsize isec1)
                                      ;elf64_section_body := byte_sequence.empty (* ignored *)
                                      ;elf64_section_name_as_string :=(elf64_section_name_as_string isec1)
                                      |} in
                                      let new_meta := FileFeature
                                                        (ElfSection
                                                           (idx1, new_isec))
                                      in
                                      ((el_name, new_el), (new_meta, 
                                      Some (el_name, ( 0, new_len))))) :: 
                                      x2 else x2 end) x2 rel_sections)) with
      (new_reloc_elements,  new_reloc_tags_and_ranges) =>
    let new_by_tag := lem_set.bigunion
                        [(by_tag filtered_image);  (set_from_list_by
                                                      (pairCompare
                                                         (fun (x : range_tag (any_abi_feature )) (y : range_tag (any_abi_feature ))=>
                                                            EQ)
                                                         (maybeCompare
                                                            (pairCompare
                                                               (fun (x : string ) (y : string )=>
                                                                  EQ)
                                                               (pairCompare
                                                                  (genericCompare
                                                                    nat_ltb
                                                                    beq_nat)
                                                                  (genericCompare
                                                                    nat_ltb
                                                                    beq_nat)))))
                                                      new_reloc_tags_and_ranges) ]
  in
  {|elements := (List.fold_right (@ List.app _) fmap_empty
                   [(elementsfiltered_image); lem_map.fromList
                                                new_reloc_elements])
  ;by_tag := new_by_tag ;by_range := (by_range_from_by_tag new_by_tag) |} end
  end.
     

Definition expand_sections_for_one_image  (a : abi (any_abi_feature )) (options : set (command_line.link_option )) (bindings_by_name : fmap (string ) (list ((nat *binding ) % type))) (linkable_idx : nat ) (item : (linkable_object *input_item *input_options ) % type)  : (list ((reloc_site *binding *reloc_decision ) % type)*annotated_memory_image (any_abi_feature )*list (input_spec )) % type:=  
    match ( item) with 
    (RelocELF(img3),  (fname1,  blob,  origin),  input_opts) => 
  (*let _ = List.foldl (fun _ -> fun (isec, shndx) ->  
            let _ = errln ("For file " ^ fname ^ " before stripping, saw section idx " ^ (show shndx) ^ 
                " with name " ^ isec.elf64_section_name_as_string ^ ", first 20 bytes: " ^ (show (take 20 (
                    (let maybe_elname = elf_memory_image_element_coextensive_with_section shndx img
                     in
                     match maybe_elname with
                        Nothing -> failwith ("impossible: no such section (" ^ (show shndx) ^ ") in image of " ^ fname)
                        | Just idstr -> 
                            match Map.lookup idstr img.elements with
                                Just el -> el.contents
                                | Nothing -> failwith "no such element"
                            end
                    end
                    )))))
                in
                ()
            ) () (elf_memory_image_sections_with_indices img)
        in*)
  match ( mark_fate_of_relocs linkable_idx a default_simplify_reloc options
            bindings_by_name item img3) with
      (reloc_decisions,  marked_img) =>
    (* Now we have a decision for each reloc: Leave, Apply, MakePIC. Which ones
         * do we materialize? Only the Leave ones, for now. For each relocation that
         * we Leave, we figure out its originating section and create a lookalike
         * in the memory image. We'll need to create .plt and .rela.plt later (FIXME).
         *)
  let stripped_img_with_reloc_sections := strip_metadata_sections
                                            reloc_decisions a marked_img in
  (* Now we have a whole new image! It differs from the old one in that 
         * - non-special sections have been stripped
         * - the relocs we want to participate in linking have been materialized.
         *)
  (* The "-q" option is tricky. It causes all incoming relocs to be retained, but 
         * they *don't* participate in linking -- notice that the default linker script
         * pulls all .rela.* sections into .rela.dyn, whereas these ones *don't* go in there.
         * So FIXME: to support this, we need a way to re-add them, probably when we 
         * generate meta-output like .symtab etc.. *)
  let inputs :=
  (@ List.app _)
    (let x2 := [] (* not (a.section_is_special isec img *) in List.fold_right
                                                                (fun (p : (elf64_interpreted_section *nat ) % type) (x2 : list (input_spec )) =>
                                                                   match ( (p ,x2) ) with
                                                                    ((isec1,  shndx1) ,  x2) =>
                                                                    if 
                                                                    true then
                                                                    (let short_name := 
                                                                    short_string_of_linkable_item
                                                                    item in
                                                                    (*let _ = errln ("For file " ^ short_name ^ " after stripping, saw section idx " ^ (show shndx) ^ 
                " with name " ^ isec.elf64_section_name_as_string ^ ", first 20 bytes: " ^ (show (take 20 (
                    (let maybe_elname = elf_memory_image_element_coextensive_with_section shndx stripped_img_with_reloc_sections
                     in
                     match maybe_elname with
                        Nothing -> failwith ("impossible: no such section (matching " ^ (show shndx) ^ ")")
                        | Just idstr -> 
                            match Map.lookup idstr stripped_img_with_reloc_sections.elements with
                                Just el -> el.contents
                                | Nothing -> failwith "no such element"
                            end
                    end
                    )))))
            in*)
                                                                    InputSection
                                                                    ({|idx := linkable_idx
                                                                    ;fname := short_name
                                                                    ;img := stripped_img_with_reloc_sections
                                                                    ;shndx := shndx1
                                                                    ;secname :=(elf64_section_name_as_string isec1)
                                                                    ;isec := isec1
                                                                    |})) ::
                                                                    x2 else
                                                                    x2 end)
                                                                x2
                                                                (elf_memory_image_sections_with_indices
                                                                   stripped_img_with_reloc_sections))
    (
    (* One item per common symbol. FIXME: what about common symbols that have the same name? 
         * We need to explicitly instantiate common symbols somewhere, probably here. 
         * This means dropping any that are unreferenced (does it?) and merging any multiply-defined.
         * Actually, we deal with section merging at the same time as section concatenation, so during
         * linker script processing. For discarding unused common symbols, I *think* that this has already
         * been done by discarding unreferenced inputs.  *)
    let common_symbols := all_common_symbols stripped_img_with_reloc_sections
    in
    (*let _ = errln ("Expanding " ^ (show (length common_symbols)) ^ " common symbols")
        in*)
    let x2 := [] in List.fold_right
                      (fun (def : symbol_definition ) (x2 : list (input_spec )) =>
                         if
                         (*let _ = Missing_pervasives.outln ((space_padded_and_maybe_newline 20 def.def_symname)
                ^ (let hexstr = "0x" ^ (hex_string_of_natural (natural_of_elf64_xword def.def_syment.elf64_st_size))
                  in
                  space_padded_and_maybe_newline 20 hexstr
                  )
                ^ 
                fname)
            in*)
                         true then
                           Common
                             (linkable_idx, fname1, stripped_img_with_reloc_sections, def)
                           :: x2 else x2) x2 common_symbols )
  in (reloc_decisions, stripped_img_with_reloc_sections, inputs) end
    | _ => DAEMON
end.

Definition reloc_resolution : Type := ( reloc_site  * binding  * reloc_decision ) % type.
Definition reloc_resolution_default: reloc_resolution  := (reloc_site_default, binding_default, reloc_decision_default).
(* [?]: removed value specification. *)

Definition default_merge_generated  (a : abi (any_abi_feature )) (generated_img : annotated_memory_image (any_abi_feature )) (input_spec_lists : list (list (input_spec )))  : list (list (input_spec )):=  
    (* We expand the sections in the generated image and hang them off
     * the first linkable item. *) 
    (*let _ = errln ("Generated image has " ^ (show (Map.size generated_img.elements)) ^ " elements and " ^ (show (Set.size (generated_img.by_tag))) ^ 
        " metadata elements (sanity: " ^ (show (Set.size (generated_img.by_range))) ^ ")")
    in*)
    let dummy_input_item := ("(no file)", input_list.Reloc(Sequence([])), ((command_line.File(command_line.Filename("(no file)"), command_line.null_input_file_options)), [InCommandLine( 0)]))
    in 
    let dummy_linkable_item := (RelocELF(generated_img), dummy_input_item, input_list.null_input_options)
    in match ( expand_sections_for_one_image a [] fmap_empty ( 0)
           dummy_linkable_item) with (_,  _,  generated_inputs) =>
   (* okay, hang them off the first one *) match ( input_spec_lists) with
       [] => DAEMON | first_input_list :: more_input_lists =>
     ( (@ List.app _) first_input_list generated_inputs) :: more_input_lists
   end end.
(* [?]: removed value specification. *)

Definition expand_sections_for_all_inputs  (a : abi (any_abi_feature )) (options : set (command_line.link_option )) (bindings_by_name : fmap (string ) (list ((nat *binding ) % type))) (merge_generated : abi (any_abi_feature ) -> annotated_memory_image (any_abi_feature ) -> list (list (input_spec )) -> list (list (input_spec ))) (idx_and_linkables : list ((nat *((linkable_object *input_item *input_options ) % type)) % type))  : list ((list ((reloc_site *binding *reloc_decision ) % type)*annotated_memory_image (any_abi_feature )*list (input_spec )) % type):=  
  match ( unzip3
            (List.map
               (fun (p : (nat *((linkable_object *input_item *input_options ) % type)) % type) =>
                  match ( (p) ) with ( (idx1,  linkable)) =>
                    expand_sections_for_one_image a options bindings_by_name
                      idx1 linkable end) idx_and_linkables)) with
      (expanded_reloc_lists,  expanded_imgs,  linker_script_input_lists) =>
    let fnames := List.map
                    (fun (p : (nat *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type) =>
                       match ( (p) ) with
                           ( (idx1,  (_,  (fname1,  _,  _),  _))) => fname1
                       end) idx_and_linkables in
  (* We pass the collection of linkable images and reloc decision lists 
     * to an ABI tap function. 
     * 
     * This returns us a new *image* containing all the elements. Logically
     * this is another participant in the link, which we could expand separately.
     * A personality function takes care of actually merging it back into the 
     * linker script inputs... in the case of the GNU linker, this means pretending
     * the generated stuff came from the first input object.
     *)
  let generated_img :=(generate_support a)
                        (* expanded_relocs *) (zip fnames expanded_imgs) in
  (* We need to return a 
     * 
     *    list (list reloc_decision * elf_memory_image * list Linker_script.input_spec)
     *
     * i.e. one item for every input image. *)
  let final_input_spec_lists := merge_generated a generated_img
                                  linker_script_input_lists in
  zip3 expanded_reloc_lists expanded_imgs final_input_spec_lists end.
(* [?]: removed value specification. *)

Definition relocate_output_image  (a : abi (any_abi_feature )) (bindings_by_name : fmap (string ) (list ((nat *binding ) % type))) (img3 : annotated_memory_image (any_abi_feature ))  : annotated_memory_image (any_abi_feature ):=  
    let relocs := multimap.lookupBy0 memory_image_orderings.tagEquiv (SymbolRef(null_symbol_reference_and_reloc_site))(by_tag
        img3)
    in
    
    (*let _ = errln ("For __libc_multiple_threads (in relocate_output_image), we have " ^ 
        (let all_bs = match Map.lookup "__libc_multiple_threads" bindings_by_name with
            Just l -> l
            | Nothing -> []
        end
        in
        ((show (length all_bs)) ^ 
        " bindings, of which " ^ 
        (show (length (List.filter (fun (bi, ((ref_idx, ref, ref_item), maybe_def)) -> 
            match maybe_def with
                Just _ -> true
                | _ -> false
            end
        ) all_bs))) ^ " have defs")))
    in*)
    let apply_reloc := 
  fun (img3 : annotated_memory_image (any_abi_feature )) =>
    fun (p : (string *nat *nat ) % type) =>
      match ( (p) ) with ( (el_name,  start,  len)) =>
        fun (symref_and_reloc_site : symbol_reference_and_reloc_site ) =>
          fun (symaddr : nat ) => (
            let reloc_site1 := match ((maybe_reloc symref_and_reloc_site)) with
                                   None => DAEMON | Some r => r end in
            match ((reloc a)
                     (get_elf64_relocation_a_type (ref_relent reloc_site1))) with
                (field_is_absolute_addr,  applyfn) =>
              let element1 := match ( (fmap_lookup_by
                                         (fun (x : string ) (y : string )=>
                                            EQ) el_name (elements img3))) with
                                  None => DAEMON | Some e => e end in
            let site_address := match ((startpos element1)) with Some addr =>
                                  Coq.Init.Peano.plus addr start | None =>
                                  DAEMON end in
            match ( applyfn img3 site_address symref_and_reloc_site) with
                (width,  calculate) =>
              let existing_field := extract_natural_field width element1
                                      start in
            (*let _ = errln ("Existing field has value 0x" ^ (hex_string_of_natural existing_field))
        in*)
            (*let _ = errln ("Symaddr has value 0x" ^ (hex_string_of_natural symaddr))
        in*)
            let addend := int_of_elf64_sxword
                            (elf64_ra_addend(ref_relent reloc_site1)) in
            let new_field_value := calculate symaddr addend existing_field in
            (*let _ = errln ("Calculated new field value 0x" ^ (hex_string_of_natural new_field_value))
        in*)
            let new_element := write_natural_field new_field_value width
                                 element1 start in
            {|elements := (fmap_add el_name new_element
                             ((fmap_delete_by
                                 (fun (x : string ) (y : string )=> EQ)
                                 el_name (elements img3))))
            ;by_tag := (set_diff_by
                          (pairCompare
                             (fun (x : range_tag (any_abi_feature )) (y : range_tag (any_abi_feature ))=>
                                EQ)
                             (maybeCompare
                                (pairCompare
                                   (fun (x : string ) (y : string )=> EQ)
                                   (pairCompare
                                      (genericCompare nat_ltb beq_nat)
                                      (genericCompare nat_ltb beq_nat)))))
                          (by_tag img3)
                          [(SymbolRef (symref_and_reloc_site), Some
                                                                 (el_name, (start, len)))])
            ;by_range := (set_diff_by
                            (pairCompare
                               (maybeCompare
                                  (pairCompare
                                     (fun (x : string ) (y : string )=> EQ)
                                     (pairCompare
                                        (genericCompare nat_ltb beq_nat)
                                        (genericCompare nat_ltb beq_nat))))
                               (fun (x : range_tag (any_abi_feature )) (y : range_tag (any_abi_feature ))=>
                                  EQ)) (by_range img3)
                            [(Some (el_name, (start, len)), SymbolRef
                                                              (symref_and_reloc_site))])
            |} end end ) end
    in
    let relocated_img := List.fold_left (fun (acc_img : annotated_memory_image (any_abi_feature )) => (
  fun (p : (range_tag (any_abi_feature )*option ((string *((nat *nat ) % type)) % type) ) % type) =>
    match ( (p) ) with ( (tag,  maybe_range)) =>
      match ( tag) with SymbolRef(x) =>
        match ((maybe_reloc x)) with Some rs =>
          match ( maybe_range) with None => DAEMON
            | Some (el_name,  (start,  len)) =>
            (*let _ = errln ("During relocation, saw a reloc site in element " ^ el_name ^ ", offset 0x" ^
                                (hex_string_of_natural start) ^ ", length 0x" ^ (hex_string_of_natural len) ^ 
                                ", reloc type " ^ (* a. *) Abi_amd64_relocation.string_of_amd64_relocation_type (get_elf64_relocation_a_type rs.ref_relent) ^ 
                                ", symbol name `" ^ x.ref.ref_symname ^ "'")
                            in*)
          let symaddr := match ((maybe_def_bound_to x)) with
                             Some(ApplyReloc(_),  Some(bound_def)) =>
                           match ( find_defs_matching bound_def img3) with
                               [] => DAEMON
                             | ((el_name,  (start,  len)),  d) :: more =>
                             let v := match ( element_and_offset_to_address
                                                (el_name, start) img3) with
                                          Some a => a | None => DAEMON end in
                           match ( more) with [] => v | _ =>
                             (*let _ = errln ("FIXME: internal error: more than one def range equalling bound def " ^
                                                    "in section " ^ el_name)
                                                    in*) v
                           end end | None => DAEMON
                           | Some(ApplyReloc(_),  None) =>
                           (*let _ = errln "No definition, so we think this is a weak reference; giving it value 0."
                                    in*)
                           (* CHECK: does the syment say it's weak? *)
                           if negb
                                (beq_nat
                                   (get_elf64_symbol_binding
                                      (ref_syment(ref x))) stb_weak) then
                             (*let _ = errln "Actually not weak! bailing"
                                        in*)
                             DAEMON else  (* Weak symbol. *) 0
                           | Some(LeaveReloc,  _) =>
                           (* We shouldn't be seeing this, given that we're applying the reloc Right Now. *)
                           DAEMON | Some(ChangeRelocTo _,  _) =>
                           nat_default (* Incomplete Pattern at File \"link.lem\", line 628, character 43 to line 659, character 31 *)
                         end in
          (*let _ = errln ("Got symaddr: 0x" ^ (hex_string_of_natural symaddr))
                            in*)
          apply_reloc acc_img (el_name, start, len) x symaddr end | None =>
          (* okay, do nothing *) acc_img end | _ => DAEMON end end
    )) relocs img3
    in
    relocated_img.
(* [?]: removed value specification. *)

Definition link  (script1 : list (script_element )) (a : abi (any_abi_feature )) (options : set (command_line.link_option )) (linkables : list ((linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type))  : annotated_memory_image (any_abi_feature ):=  
    let initial_included_indices := mapMaybei (fun (i : nat ) => (
  fun (p : (linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type) =>
    match ( (p) ) with ( (obj,  inp,  opts)) =>
      if(item_force_output opts) then Some i else None end
    )) linkables
    in
    let linker_script_linkable_idx := length linkables
    in
    let defmap :=  all_definitions_by_name linkables
    in
    let accumulated_bindings
     := (* accumulate_bindings_bf a linkables defmap {} initial_included_indices []  *)
          accumulate_bindings_objectwise_df a linkables defmap [] [] initial_included_indices
    in
    (* Keep a map whose keys are referenced objects, and whose values are 
     * *some* (diagnostic purposes only) reference to that linkable. *)
    let referenced_object_indices_and_reasons := List.fold_left (fun (acc_m : fmap (nat ) ((symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)) => (
  fun (p : (((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type) =>
    match ( (p) ) with
        ( ((ref_idx,  ref_sym,  ref_linkable),  maybe_def_idx_and_sym_and_linkable)) =>
      match ( maybe_def_idx_and_sym_and_linkable) with None => acc_m
        | Some (def_idx,  def_sym,  def_linkable) =>
        (* Make sure the map contains this key. *)
        if (maybeEqualBy
              ((fun (left : (symbol_reference *((linkable_object *input_item *input_options ) % type)) % type) (right : (symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)=>
                  (tuple_equal_by classical_boolean_equivalence tripleEqual
                     left right)))
              (fmap_lookup_by (genericCompare nat_ltb beq_nat) def_idx acc_m)
              None) then fmap_add def_idx (ref_sym, ref_linkable) acc_m else
          acc_m end end
    )) accumulated_bindings (fmap_empty :  fmap  nat   ((symbol_reference  * linkable_item ) % type))
    in
    (* Print something similar to GNU ld's linker map output, about included archive members. *)
    (*let _ = Missing_pervasives.outln "Archive member included to satisfy reference by file (symbol)\n" in*)
    let linkables_not_discarded := mapMaybei (fun (i : nat ) => (
  fun (p : (linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type) =>
    match ( (p) ) with ( (obj,  inp,  opts)) =>
      let referenced_object_map_entry := (fmap_lookup_by
                                            (genericCompare nat_ltb beq_nat)
                                            i
                                            referenced_object_indices_and_reasons)
    in
    let referenced := ( negb
                          ((maybeEqualBy
                              ((fun (left : (symbol_reference *((linkable_object *input_item *input_options ) % type)) % type) (right : (symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)=>
                                  (tuple_equal_by
                                     classical_boolean_equivalence
                                     tripleEqual left right)))
                              referenced_object_map_entry None))) in
    (* Print our link map thing *)
    (*let _ = (
            if (not referenced) then () else
                (* Did it come from an archive? *)
                let (name, _, (inp_unit, coordlist)) = inp in
                match coordlist with
                    InArchive(aid, aidx, aname, _) :: _ ->
                        (* yes, from an archive, so print a line *)
                        let (ref_sym, (ref_obj, (ref_name, ref_blob, ref_origin), ref_opts)) = match referenced_object_map_entry with
                            Just(x, y) -> (x, y)
                            | Nothing -> failwith "impossible: referenced item has no definition"
                        end
                        in
                        let lhs_name = aname ^ "(" ^ name ^ ")"
                        in
                        let lhs_name_len = stringLength lhs_name
                        in
                        let spacing = if lhs_name_len >= 29
                            then ("\n" ^ (makeString 30 #' '))
                            else makeString (30 - lhs_name_len) #' '
                        in
                        Missing_pervasives.outln (
                            lhs_name ^ spacing ^ 
                            (match ref_origin with
                                (_, InArchive(bid, bidx, bname, _) :: _) -> bname ^ "(" ^ ref_name ^ ")"
                                | _ -> ref_name
                            end)
                            ^ " (" ^ ref_sym.ref_symname ^ ")"
                        )
                    | _ (* not from an archive *) -> ()
                end
        )
        in*)
    if referenced || (item_force_output opts) then Some (i, (obj, inp, opts))
    else None end
    )) linkables
    in
    (*let _ = Missing_pervasives.outln "\nAllocating common symbols\nCommon symbol       size              file\n"
    in*)
    (* We have to do a pass over relocations quite early. This is because relocs *do* participate 
     * in linking. For each reloc, we need to decide whether to apply it or not. For those not applied,
     * we include it in a synthesised section that participates in linking. 
     * 
     * Similarly, the GOT needs to participate in linking, so that it gets assigned an address 
     * at the appropriate place (as determined by the script). So we have to generate the GOT 
     * *before* running the linker script. The GNU linker hangs the whole GOT and PLT content 
     * off the first input object (usually crt1.o). In general, expand_sections calls an ABI tap 
     * which synthesises all the necessary things, like (in the GNU case) the .got and .plt sections 
     * hanging off the first input object. *)
    let initial_bindings_by_name := 
        List.fold_left (
  fun (m : fmap (string ) (list ((nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)) % type))) =>
    fun (p : (nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)) % type) =>
      match ( (p) ) with
          ( (b_idx,  ((ref_idx,  ref1,  ref_item),  maybe_def))) =>
        match ( (fmap_lookup_by (fun (x : string ) (y : string )=> EQ)
                   (ref_symname ref1) m)) with None =>
          fmap_add (ref_symname ref1)
            [ (b_idx, ((ref_idx, ref1, ref_item), maybe_def))]  m
          | Some( (bi,  b) :: more) =>
          fmap_add (ref_symname ref1)
            ((b_idx, ((ref_idx, ref1, ref_item), maybe_def)) ::
             ((bi, b) :: more)) m | _ => DAEMON end end) (lem_list.mapi (fun (i : nat ) => fun (b : (((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type) => ( i, b)) accumulated_bindings) fmap_empty
    in
    let expanded_triples
     := expand_sections_for_all_inputs a options initial_bindings_by_name default_merge_generated linkables_not_discarded
    in match ( unzip3 expanded_triples) with
     (reloc_resolutions,  imgs,  input_lists) =>
   let input_sections := list_concat input_lists in
 let seen_ordering := fun (is1 : input_spec ) =>
                        (fun (is2 : input_spec ) => (
                           let toNaturalList := fun (is : input_spec ) => (
                                                  (* We're mapping the item to a list of naturals that determine a 
             * lexicographic order. The list has a fixed depth:
             * 
             * [within-commandline, within-group, within-archive, section-or-symbol]
             * 
             * For .o files on the command line, we use the command line order. This
             * is the first level in the hierarchy.
             *  
             * For .a files with --whole-archive, we want to do the same. Do this
             * by using archive position as the second level of the hierarchy, *if*
             * the item is marked as force_output.
             *
             * For other archives, "order seen" means something different: it's
             * the order in which they were "pulled in" during input enumeration. Another
             * way to say this is that they're ordered by the first binding that was
             * made to them. We map these to numbers starting from the size of the archive,
             * i.e. so that "force_output" makes an element appear sooner. In practice
             * we won't get a mixture of force_output and non- in the same archive,
             * so each archive will use only one of the two orderings.
             * 
             * How do sections order relative to common symbols? Again, in practice it
             * doesn't matter because no input query will get a mixture of the two.
             * For symbols, we start the numbering from the number of sections in the file,
             * so symbols always appear later in the sortd order.
             *)
                                                  match ( match ( is) with
                                                              Common(idx1,  fname1,  img3,  def) =>
                                                            (idx1, Coq.Init.Peano.plus
                                                                    (
                                                                    match ( (
                                                                    elf_memory_image_section_ranges
                                                                    img3)) with
                                                                    (_,  l) =>
                                                                    length l
                                                                    end)
                                                                    (def_sym_idx def))
                                                            | InputSection(isrec) =>
                                                            ((idxisrec),(shndx isrec))
                                                          end) with
                                                      (linkable_idx,  section_or_symbol_idx) =>
                                                    match ( lem_list.index
                                                              linkables
                                                              (id
                                                                 linkable_idx)) with
                                                        None => DAEMON
                                                      | Some (obj,  (fname1,  blob,  (inp_unit,  coords)),  options) =>
                                                      match ( match ( coords) with
                                                                  InArchive(aid,  aidx,  _,  asize) :: InGroup(gid1,  gidx) :: [InCommandLine(cid)] =>
                                                                (cid, gid1, aid, 
                                                              Some asize)
                                                                | InArchive(aid,  aidx,  _,  asize) :: [InCommandLine(cid)] =>
                                                                (cid,
                                                               0, aid, 
                                                              Some asize)
                                                                | InGroup(gid1,  gidx) :: [InCommandLine(cid)] =>
                                                                (cid, gid1,
                                                               0, None)
                                                                | [InCommandLine(cid)] =>
                                                                (cid,
                                                               0, 0, None)
                                                                | _ => 
                                                              DAEMON end) with
                                                          (our_cid,  our_gid,  our_aid,  maybe_archive_size) =>
                                                        let aid_to_use :=
                                                      if(item_force_output options) then
                                                        our_aid else
                                                        (* how many elements does the archive have? *)
                                                        let archive_size := 
                                                        match ( maybe_archive_size) with
                                                            None => DAEMON
                                                          | Some a => a end
                                                        in Coq.Init.Peano.plus
                                                             archive_size
                                                             (* search the bindings: we want the index of the first binding
                           that refers to this object.
                         *)
                                                             match ( 
                                                             lem_list.findIndex
                                                               (fun (p : (((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type) =>
                                                                  match ( (p) ) with
                                                                    ( ((b_ref_idx,  b_ref,  b_ref_item),  b_maybe_def)) =>
                                                                    match ( b_maybe_def) with
                                                                    Some (b_def_idx,  b_def,  b_def_item) =>
                                                                    beq_nat
                                                                    b_def_idx
                                                                    linkable_idx
                                                                    | _ =>
                                                                    false end
                                                                  end)
                                                               accumulated_bindings) with
                                                                 Some n => 
                                                              n | None =>
                                                               DAEMON end in
                                                      (* do we care about group idx? probably not. *)
                                                      [our_cid; aid_to_use; section_or_symbol_idx]
                                                      end end end ) in
                           (lexicographicCompareBy
                              (genericCompare nat_ltb beq_nat)
                              (toNaturalList is1) (toNaturalList is2)) )) in
 (*
    let get_binding_for_ref = (fun symref -> (fun linkable_idx -> (fun fname -> 
        let name_matches = match Map.lookup symref.ref_symname bindings_by_name with Just x -> x | Nothing -> [] end
        in
        match List.filter (fun (bi, ((r_idx, r, r_item), m_d)) -> r_idx = linkable_idx && r = symref) name_matches with
            [(b_idx, b)] -> (b_idx, b)
            | [] -> failwith "no binding found"
            | _  -> failwith ("ambiguous binding found for symbol `" ^ symref.ref_symname ^ "' in file " ^ fname)
        end
    )))
    in
    *)
 match ( interpret_linker_control_script script1 linker_script_linkable_idx 
         a input_sections seen_ordering default_place_orphans
           initial_bindings_by_name) with
     (unrelocated_output_image,  bindings_by_name) =>
   (* This image has 
     * - addresses assigned 
     * - relocations *not* applied
     * - no entry point
     * - some ABI features not generated? GOT, certainly. HMM.
           -- don't consider output features, like symtabs, yet;
           -- other ABI features have to be generated before the linker script runs (dyn relocs, GOT, PLT?)
           -- ... so we might be okay for now.
     *)
 let remaining_relocs := multimap.lookupBy0 memory_image_orderings.tagEquiv
                           (SymbolRef (null_symbol_reference_and_reloc_site))
                           (by_tag unrelocated_output_image) in
 let _ := List.fold_left
            (fun  _ : unit  =>
               (fun (p : (range_tag (any_abi_feature )*option ((string *((nat *nat ) % type)) % type) ) % type) =>
                  match ( (p) ) with ( (tag,  maybe_range)) =>
                    let _ := match ( tag) with SymbolRef(x) =>
                               match ((maybe_reloc x)) with Some rs =>
                                 match ( maybe_range) with None => DAEMON
                                   | Some (el_name,  (start,  len)) =>
                                   tt (* errln ("After linking, saw a reloc site in element " ^ el_name ^ ", offset 0x" ^
                                (hex_string_of_natural start) ^ ", length 0x" ^ (hex_string_of_natural len) ^ 
                                ", reloc type " ^ Abi_amd64_relocation.string_of_amd64_relocation_type (get_elf64_relocation_a_type rs.ref_relent)) *)
                                 end | None => (* okay, do nothing *) tt end
                               | _ => DAEMON end in tt end ))
            remaining_relocs tt in
 (* Before we relocate, we concretise any ABI features that we've linked in. *)
 let unrelocated_concrete_output_image :=(concretise_support a)
                                           unrelocated_output_image in
 let output_image := relocate_output_image a bindings_by_name
                       unrelocated_concrete_output_image in
 let maybe_entry_point_address :=
 match ( command_line.find_option_matching_tag
           (command_line.EntryAddress ( 0)) options) with None =>
   (guess_entry_point a) output_image | Some(command_line.EntryAddress(x)) =>
   Some x | Some(command_line.OutputFilename _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.OutputKind _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.ForceCommonDefined _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.Soname _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.TextSegmentStart _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.RodataSegmentStart _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some(command_line.LdataSegmentStart _) =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some command_line.BindFunctionsEarly =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
   | Some command_line.BindNonFunctionsEarly =>
   DAEMON (* Incomplete Pattern at File \"link.lem\", line 895, character 9 to line 898, character 11 *)
 end in
 match ( maybe_entry_point_address) with Some addr =>
   match ( address_to_element_and_offset addr output_image) with
       Some (el_name,  el_offset) =>
     (*let _ = errln ("Tagging element " ^ el_name ^ " as containing entry point at offset 0x" ^ (hex_string_of_natural el_offset))
                    in*)
     tag_image (EntryPoint) el_name el_offset ( 0) output_image | None =>
     (* HMM. entry point symbol has no address at present. *) DAEMON end
   | None =>
   (*let _ = errln "Warning: not tagging entry point in output image"
            in*)
 output_image end end end.
