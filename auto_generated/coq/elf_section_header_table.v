(* Generated by Lem from elf_section_header_table.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [elf_section_header_table] provides types, functions and other definitions
  * for working with section header tables and their entries.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_function.
Require Export lem_function.

Require Import lem_list.
Require Export lem_list.

Require Import lem_map.
Require Export lem_map.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


Require Import endianness.
Require Export endianness.

Require Import string_table.
Require Export string_table.


Require Import elf_header.
Require Export elf_header.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_program_header_table.
Require Export elf_program_header_table.


(** Special section indices. *)

(** See elf_header.lem for shn_undef *)

(** [shn_loreserve]: this specifies the lower bound of the range of reserved
  * indices.
  *)
Definition shn_loreserve    :  nat :=  65280. (* 0xff00 *)
(** [shn_loproc]: start of the range reserved for processor-specific semantics.
  *)
Definition shn_loproc    :  nat :=  65280. (* 0xff00 *)
(** [shn_hiproc]: end of the range reserved for processor-specific semantics.
  *)
Definition shn_hiproc    :  nat :=  65311. (* 0xff1f *)
(** [shn_loos]: start of the range reserved for operating system-specific
  * semantics.
  *)
Definition shn_loos    :  nat :=  65312. (* 0xff20 *)
(** [shn_hios]: end of the range reserved for operating system-specific
  * semantics.
  *)
Definition shn_hios    :  nat :=  65343. (* 0xff3f *)
(** [shn_abs]: specifies the absolute values for the corresponding reference.
  * Symbols defined relative to section number [shn_abs] have absolute values
  * and are not affected by relocation.
  *)
Definition shn_abs    :  nat :=  65521. (* 0xfff1 *)
(** [shn_common]: symbols defined relative to this index are common symbols,
  * such as unallocated C external variables.
  *)
Definition shn_common    :  nat :=  65522. (* 0xfff2 *)

(** See elf_header.lem for shn_xindex. *)

(** [shn_hireserve]: specifies the upper-bound of reserved values.
  *)
Definition shn_hireserve    :  nat :=  65535.
(* [?]: removed value specification. *)


(** Section types. *)

(** Marks the section header as being inactive. *)
Definition sht_null    :  nat :=  0.
(** Section holds information defined by the program. *)
Definition sht_progbits    :  nat :=  1.
(** The following two section types hold a symbol table.  An object file may only
  * have one symbol table of each of the respective types.  The symtab provides
  * a place for link editing, whereas the dynsym section holds a minimal set of
  * dynamic linking symbols
  *)
Definition sht_symtab    :  nat :=  2.
Definition sht_dynsym    :  nat :=  11.
(** Section holds a string table *)
Definition sht_strtab    :  nat :=  3.
(** Section holds relocation entries with explicit addends.  An object file may
  * have multiple section of this type.
  *)
Definition sht_rela    :  nat :=  4.
(** Section holds a symbol hash table.  An object file may only have a single
  * hash table.
  *)
Definition sht_hash    :  nat :=  5.
(** Section holds information for dynamic linking.  An object file may only have
  * a single dynamic section.
  *)
Definition sht_dynamic    :  nat :=  6.
(** Section holds information that marks the file in some way. *)
Definition sht_note    :  nat :=  7.
(** Section occupies no space in the file but otherwise resembles a progbits
  * section.
  *)
Definition sht_nobits    :  nat :=  8.
(** Section holds relocation entries without explicit addends.  An object file
  * may have multiple section of this type.
  *)
Definition sht_rel    :  nat :=  9.
(** Section type is reserved but has an unspecified meaning. *)
Definition sht_shlib    :  nat :=  10.
(** Section contains an array of pointers to initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
Definition sht_init_array    :  nat :=  14.
(** Section contains an array of pointers to termination functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
Definition sht_fini_array    :  nat :=  15.
(** Section contains an array of pointers to initialisation functions that are
  * invoked before all other initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
Definition sht_preinit_array    :  nat :=  16.
(** Section defines a section group, i.e. a set of sections that are related and
  * must be treated especially by the linker.  May only appear in relocatable
  * objects.
  *)
Definition sht_group    :  nat :=  17.
(** Section is associated with sections of type SHT_SYMTAB and is required if
  * any of the section header indices referenced by that symbol table contains
  * the escape value SHN_XINDEX.
  *
  * FIXME: Lem bug as [int] type used throughout Lem codebase, rather than
  * [BigInt.t], so Lem chokes on these large constants below, hence the weird
  * way in which they are written.
  *)
Definition sht_symtab_shndx    :  nat :=  18.

(** The following ranges are reserved solely for OS-, processor- and user-
  * specific semantics, respectively.
  *)
Definition sht_loos      :  nat :=  Coq.Init.Peano.mult (Coq.Init.Peano.mult (Coq.Init.Peano.mult( 3)( 1024))( 1024))( 512). (* 1610612736 (* 0x60000000 *) *)
Definition sht_hios      :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 469762047)( 4))( 3). (* 1879048191 (* 0x6fffffff *) *)
Definition sht_loproc    :  nat :=  ( Coq.Init.Peano.mult( 469762048)( 4)). (* 1879048192 (* 0x70000000 *) *)
Definition sht_hiproc    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 536870911)( 4))( 3). (* 2147483647 (* 0x7fffffff *) *)
Definition sht_louser    :  nat :=  ( Coq.Init.Peano.mult( 536870912)( 4)). (* 2147483648 (* 0x80000000 *) *)
Definition sht_hiuser    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 603979775)( 4))( 3).
(* [?]: removed value specification. *)


(** Section flag numeric values. *)

(** The section contains data that should be writable during program execution.
  *)
Definition shf_write               :  nat :=  1.
(** The section occupies memory during program execution.
  *)
Definition shf_alloc               :  nat :=  2.
(** The section contains executable instructions.
  *)
Definition shf_execinstr           :  nat :=  4.
(** The data in the section may be merged to reduce duplication.  Each section
  * is compared based on name, type and flags set with sections with identical
  * values at run time being mergeable.
  *)
Definition shf_merge               :  nat :=  16.
(** The section contains null-terminated character strings.
  *)
Definition shf_strings             :  nat :=  32.
(** The [info] field of this section header contains a section header table
  * index.
  *)
Definition shf_info_link           :  nat :=  64.
(** Adds special link ordering for link editors.
  *)
Definition shf_link_order          :  nat :=  128.
(** This section requires special OS-specific processing beyond the standard
  * link rules.
  *)
Definition shf_os_nonconforming    :  nat :=  256.
(** This section is a member (potentially the only member) of a link group.
  *)
Definition shf_group               :  nat :=  512.
(** This section contains Thread Local Storage (TLS) meaning that each thread of
  * execution has its own instance of this data.
  *)
Definition shf_tls                 :  nat :=  1024.
(** This section contains compressed data.  Compressed data may not be marked as
  * allocatable.
  *)
Definition shf_compressed          :  nat :=  2048.
(** All bits included in these masks are reserved for OS and processor specific
  * semantics respectively.
  *)
Definition shf_mask_os             :  nat :=  267386880.      (* 0x0ff00000 *)
Definition shf_mask_proc           :  nat :=  Coq.Init.Peano.mult( 4)( 1006632960).
(* [?]: removed value specification. *)


(** Section compression. *)

(** Type [elf32_compression_header] provides information about the compression and
  * decompression of compressed sections.  All compressed sections on ELF32 begin
  * with an [elf32_compression_header] entry.
  *)
Record elf32_compression_header : Type :=
  { elf32_chdr_type      : elf32_word   (** Specifies the compression algorithm *)
   ; elf32_chdr_size      : elf32_word   (** Size in bytes of the uncompressed data *)
   ; elf32_chdr_addralign : elf32_word   (** Specifies the required alignment of the uncompressed data *)
   }.
Notation "{[ r 'with' 'elf32_chdr_type' := e ]}" := ({| elf32_chdr_type := e; elf32_chdr_size := elf32_chdr_size r; elf32_chdr_addralign := elf32_chdr_addralign r |}).
Notation "{[ r 'with' 'elf32_chdr_size' := e ]}" := ({| elf32_chdr_size := e; elf32_chdr_type := elf32_chdr_type r; elf32_chdr_addralign := elf32_chdr_addralign r |}).
Notation "{[ r 'with' 'elf32_chdr_addralign' := e ]}" := ({| elf32_chdr_addralign := e; elf32_chdr_type := elf32_chdr_type r; elf32_chdr_size := elf32_chdr_size r |}).
Definition elf32_compression_header_default: elf32_compression_header  := {| elf32_chdr_type := elf32_word_default; elf32_chdr_size := elf32_word_default; elf32_chdr_addralign := elf32_word_default |}.

(** Type [elf64_compression_header] provides information about the compression and
  * decompression of compressed sections.  All compressed sections on ELF64 begin
  * with an [elf64_compression_header] entry.
  *)   
Record elf64_compression_header : Type :=
  { elf64_chdr_type      : elf64_word   (** Specified the compression algorithm *)
   ; elf64_chdr_reserved  : elf64_word   (** Reserved. *)
   ; elf64_chdr_size      : elf64_xword  (** Size in bytes of the uncompressed data *)
   ; elf64_chdr_addralign : elf64_xword  (** Specifies the required alignment of the uncompressed data *)
   }.
Notation "{[ r 'with' 'elf64_chdr_type' := e ]}" := ({| elf64_chdr_type := e; elf64_chdr_reserved := elf64_chdr_reserved r; elf64_chdr_size := elf64_chdr_size r; elf64_chdr_addralign := elf64_chdr_addralign r |}).
Notation "{[ r 'with' 'elf64_chdr_reserved' := e ]}" := ({| elf64_chdr_reserved := e; elf64_chdr_type := elf64_chdr_type r; elf64_chdr_size := elf64_chdr_size r; elf64_chdr_addralign := elf64_chdr_addralign r |}).
Notation "{[ r 'with' 'elf64_chdr_size' := e ]}" := ({| elf64_chdr_size := e; elf64_chdr_type := elf64_chdr_type r; elf64_chdr_reserved := elf64_chdr_reserved r; elf64_chdr_addralign := elf64_chdr_addralign r |}).
Notation "{[ r 'with' 'elf64_chdr_addralign' := e ]}" := ({| elf64_chdr_addralign := e; elf64_chdr_type := elf64_chdr_type r; elf64_chdr_reserved := elf64_chdr_reserved r; elf64_chdr_size := elf64_chdr_size r |}).
Definition elf64_compression_header_default: elf64_compression_header  := {| elf64_chdr_type := elf64_word_default; elf64_chdr_reserved := elf64_word_default; elf64_chdr_size := elf64_xword_default; elf64_chdr_addralign := elf64_xword_default |}.

(** This section is compressed with the ZLIB algorithm.  The compressed data begins
  * at the first byte immediately following the end of the compression header.
  *)   
Definition elfcompress_zlib      :  nat :=  1.

(** Values in these ranges are reserved for OS-specific semantics.
  *)
Definition elfcompress_loos      :  nat :=  Coq.Init.Peano.mult( 4)( 402653184).       (* 0x60000000 *)
Definition elfcompress_hios      :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 2)( 939524095))( 1). (* 0x6fffffff *)

(** Values in these ranges are reserved for processor-specific semantics.
  *)
Definition elfcompress_loproc    :  nat :=  Coq.Init.Peano.mult( 4)( 469762048).        (* 0x70000000 *)
Definition elfcompress_hiproc    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 2)( 1073741823))( 1).
(* [?]: removed value specification. *)

Definition read_elf32_compression_header  (ed : endianness ) (bs0 : byte_sequence )  : error ((elf32_compression_header *byte_sequence ) % type):= 
  read_elf32_word ed bs0 >>= 
  (fun (p : (elf32_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (typ,  bs1)) =>
       read_elf32_word ed bs1 >>=
       (fun (p : (elf32_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (siz,  bs2)) =>
            read_elf32_word ed bs2 >>=
            (fun (p : (elf32_word *byte_sequence ) % type) =>
               match ( (p) ) with ( (ali,  bs3)) =>
                 return0
                   ({|elf32_chdr_type := typ;elf32_chdr_size := siz;elf32_chdr_addralign := ali |}, bs3)
               end) end) end).
(* [?]: removed value specification. *)

Definition read_elf64_compression_header  (ed : endianness ) (bs0 : byte_sequence )  : error ((elf64_compression_header *byte_sequence ) % type):= 
  read_elf64_word ed bs0  >>= 
  (fun (p : (elf64_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (typ,  bs1)) =>
       read_elf64_word ed bs1 >>=
       (fun (p : (elf64_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (res,  bs2)) =>
            read_elf64_xword ed bs2 >>=
            (fun (p : (elf64_xword *byte_sequence ) % type) =>
               match ( (p) ) with ( (siz,  bs3)) =>
                 read_elf64_xword ed bs3 >>=
                 (fun (p : (elf64_xword *byte_sequence ) % type) =>
                    match ( (p) ) with ( (ali,  bs4)) =>
                      return0
                        ({|elf64_chdr_type := typ;elf64_chdr_reserved := res;elf64_chdr_size := siz;elf64_chdr_addralign := ali |}, bs4)
                    end) end) end) end).

(** Section header table entry type. *)

(** [elf32_section_header_table_entry] is the type of entries in the section
  * header table in 32-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
Record elf32_section_header_table_entry : Type :=
  { elf32_sh_name      : elf32_word  (** Name of the section *)
   ; elf32_sh_type      : elf32_word  (** Type of the section and its semantics *)
   ; elf32_sh_flags     : elf32_word  (** Flags associated with the section *)
   ; elf32_sh_addr      : elf32_addr  (** Address of first byte of section in memory image *)
   ; elf32_sh_offset    : elf32_off   (** Offset from beginning of file of first byte of section *)
   ; elf32_sh_size      : elf32_word  (** Section size in bytes *)
   ; elf32_sh_link      : elf32_word  (** Section header table index link *)
   ; elf32_sh_info      : elf32_word  (** Extra information, contents depends on type of section *)
   ; elf32_sh_addralign : elf32_word  (** Alignment constraints for section *)
   ; elf32_sh_entsize   : elf32_word  (** Size of each entry in table, if section is one *)
   }.
Notation "{[ r 'with' 'elf32_sh_name' := e ]}" := ({| elf32_sh_name := e; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_type' := e ]}" := ({| elf32_sh_type := e; elf32_sh_name := elf32_sh_name r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_flags' := e ]}" := ({| elf32_sh_flags := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_addr' := e ]}" := ({| elf32_sh_addr := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_offset' := e ]}" := ({| elf32_sh_offset := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_size' := e ]}" := ({| elf32_sh_size := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_link' := e ]}" := ({| elf32_sh_link := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_info' := e ]}" := ({| elf32_sh_info := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_addralign := elf32_sh_addralign r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_addralign' := e ]}" := ({| elf32_sh_addralign := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_entsize := elf32_sh_entsize r |}).
Notation "{[ r 'with' 'elf32_sh_entsize' := e ]}" := ({| elf32_sh_entsize := e; elf32_sh_name := elf32_sh_name r; elf32_sh_type := elf32_sh_type r; elf32_sh_flags := elf32_sh_flags r; elf32_sh_addr := elf32_sh_addr r; elf32_sh_offset := elf32_sh_offset r; elf32_sh_size := elf32_sh_size r; elf32_sh_link := elf32_sh_link r; elf32_sh_info := elf32_sh_info r; elf32_sh_addralign := elf32_sh_addralign r |}).
Definition elf32_section_header_table_entry_default: elf32_section_header_table_entry  := {| elf32_sh_name := elf32_word_default; elf32_sh_type := elf32_word_default; elf32_sh_flags := elf32_word_default; elf32_sh_addr := elf32_addr_default; elf32_sh_offset := elf32_off_default; elf32_sh_size := elf32_word_default; elf32_sh_link := elf32_word_default; elf32_sh_info := elf32_word_default; elf32_sh_addralign := elf32_word_default; elf32_sh_entsize := elf32_word_default |}.
   
Definitionelf32_null_section_header   : elf32_section_header_table_entry := 
  {|elf32_sh_name      := (elf32_word_of_nat( 0))
   ;elf32_sh_type      := (elf32_word_of_nat( 0))
   ;elf32_sh_flags     := (elf32_word_of_nat( 0))
   ;elf32_sh_addr      := (elf32_addr_of_nat( 0))
   ;elf32_sh_offset    := (elf32_off_of_nat( 0)) 
   ;elf32_sh_size      := (elf32_word_of_nat( 0))
   ;elf32_sh_link      := (elf32_word_of_nat( 0))
   ;elf32_sh_info      := (elf32_word_of_nat( 0))
   ;elf32_sh_addralign := (elf32_word_of_nat( 0))
   ;elf32_sh_entsize   := (elf32_word_of_nat( 0))
   |}.
(* [?]: removed value specification. *)

Definition compare_elf32_section_header_table_entry  (h1 : elf32_section_header_table_entry ) (h2 : elf32_section_header_table_entry )  : ordering :=    
 (lexicographicCompareBy (genericCompare nat_ltb beq_nat) 
    [nat_of_elf32_word(elf32_sh_name h1);
    nat_of_elf32_word(elf32_sh_type h1); 
    nat_of_elf32_word(elf32_sh_flags h1);
    nat_of_elf32_addr(elf32_sh_addr h1); 
    nat_of_elf32_off(elf32_sh_offset h1);
    nat_of_elf32_word(elf32_sh_size h1); 
    nat_of_elf32_word(elf32_sh_link h1); 
    nat_of_elf32_word(elf32_sh_info h1); 
    nat_of_elf32_word(elf32_sh_addralign h1); 
    nat_of_elf32_word(elf32_sh_entsize h1)]
    [nat_of_elf32_word(elf32_sh_name h2);
    nat_of_elf32_word(elf32_sh_type h2); 
    nat_of_elf32_word(elf32_sh_flags h2);
    nat_of_elf32_addr(elf32_sh_addr h2); 
    nat_of_elf32_off(elf32_sh_offset h2);
    nat_of_elf32_word(elf32_sh_size h2); 
    nat_of_elf32_word(elf32_sh_link h2); 
    nat_of_elf32_word(elf32_sh_info h2); 
    nat_of_elf32_word(elf32_sh_addralign h2); 
    nat_of_elf32_word(elf32_sh_entsize h2)]).

Instance x68_Ord : Ord elf32_section_header_table_entry := {
     compare  :=  compare_elf32_section_header_table_entry;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf32_section_header_table_entry f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf32_section_header_table_entry f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf32_section_header_table_entry f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf32_section_header_table_entry f1 f2) [GT;  EQ]))
}.


(** [elf64_section_header_table_entry] is the type of entries in the section
  * header table in 64-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
Record elf64_section_header_table_entry : Type :=
  { elf64_sh_name      : elf64_word   (** Name of the section *)
   ; elf64_sh_type      : elf64_word   (** Type of the section and its semantics *)
   ; elf64_sh_flags     : elf64_xword  (** Flags associated with the section *)
   ; elf64_sh_addr      : elf64_addr   (** Address of first byte of section in memory image *)
   ; elf64_sh_offset    : elf64_off    (** Offset from beginning of file of first byte of section *)
   ; elf64_sh_size      : elf64_xword  (** Section size in bytes *)
   ; elf64_sh_link      : elf64_word   (** Section header table index link *)
   ; elf64_sh_info      : elf64_word   (** Extra information, contents depends on type of section *)
   ; elf64_sh_addralign : elf64_xword  (** Alignment constraints for section *)
   ; elf64_sh_entsize   : elf64_xword  (** Size of each entry in table, if section is one *)
   }.
Notation "{[ r 'with' 'elf64_sh_name' := e ]}" := ({| elf64_sh_name := e; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_type' := e ]}" := ({| elf64_sh_type := e; elf64_sh_name := elf64_sh_name r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_flags' := e ]}" := ({| elf64_sh_flags := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_addr' := e ]}" := ({| elf64_sh_addr := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_offset' := e ]}" := ({| elf64_sh_offset := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_size' := e ]}" := ({| elf64_sh_size := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_link' := e ]}" := ({| elf64_sh_link := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_info' := e ]}" := ({| elf64_sh_info := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_addralign := elf64_sh_addralign r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_addralign' := e ]}" := ({| elf64_sh_addralign := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_entsize := elf64_sh_entsize r |}).
Notation "{[ r 'with' 'elf64_sh_entsize' := e ]}" := ({| elf64_sh_entsize := e; elf64_sh_name := elf64_sh_name r; elf64_sh_type := elf64_sh_type r; elf64_sh_flags := elf64_sh_flags r; elf64_sh_addr := elf64_sh_addr r; elf64_sh_offset := elf64_sh_offset r; elf64_sh_size := elf64_sh_size r; elf64_sh_link := elf64_sh_link r; elf64_sh_info := elf64_sh_info r; elf64_sh_addralign := elf64_sh_addralign r |}).
Definition elf64_section_header_table_entry_default: elf64_section_header_table_entry  := {| elf64_sh_name := elf64_word_default; elf64_sh_type := elf64_word_default; elf64_sh_flags := elf64_xword_default; elf64_sh_addr := elf64_addr_default; elf64_sh_offset := elf64_off_default; elf64_sh_size := elf64_xword_default; elf64_sh_link := elf64_word_default; elf64_sh_info := elf64_word_default; elf64_sh_addralign := elf64_xword_default; elf64_sh_entsize := elf64_xword_default |}.
   
Definitionelf64_null_section_header   : elf64_section_header_table_entry := 
  {|elf64_sh_name      := (elf64_word_of_nat( 0)) 
   ;elf64_sh_type      := (elf64_word_of_nat( 0)) 
   ;elf64_sh_flags     := (elf64_xword_of_nat( 0))
   ;elf64_sh_addr      := (elf64_addr_of_nat( 0)) 
   ;elf64_sh_offset    := (elf64_off_of_nat( 0))  
   ;elf64_sh_size      := (elf64_xword_of_nat( 0))
   ;elf64_sh_link      := (elf64_word_of_nat( 0)) 
   ;elf64_sh_info      := (elf64_word_of_nat( 0)) 
   ;elf64_sh_addralign := (elf64_xword_of_nat( 0))
   ;elf64_sh_entsize   := (elf64_xword_of_nat( 0))
   |}.
(* [?]: removed value specification. *)

Definition compare_elf64_section_header_table_entry  (h1 : elf64_section_header_table_entry ) (h2 : elf64_section_header_table_entry )  : ordering :=    
 (lexicographicCompareBy (genericCompare nat_ltb beq_nat) 
    [nat_of_elf64_word(elf64_sh_name h1);
    nat_of_elf64_word(elf64_sh_type h1); 
    nat_of_elf64_xword(elf64_sh_flags h1);
    nat_of_elf64_addr(elf64_sh_addr h1); 
    nat_of_elf64_off(elf64_sh_offset h1);
    nat_of_elf64_xword(elf64_sh_size h1); 
    nat_of_elf64_word(elf64_sh_link h1); 
    nat_of_elf64_word(elf64_sh_info h1); 
    nat_of_elf64_xword(elf64_sh_addralign h1); 
    nat_of_elf64_xword(elf64_sh_entsize h1)]
    [nat_of_elf64_word(elf64_sh_name h2);
    nat_of_elf64_word(elf64_sh_type h2); 
    nat_of_elf64_xword(elf64_sh_flags h2);
    nat_of_elf64_addr(elf64_sh_addr h2); 
    nat_of_elf64_off(elf64_sh_offset h2);
    nat_of_elf64_xword(elf64_sh_size h2); 
    nat_of_elf64_word(elf64_sh_link h2); 
    nat_of_elf64_word(elf64_sh_info h2); 
    nat_of_elf64_xword(elf64_sh_addralign h2); 
    nat_of_elf64_xword(elf64_sh_entsize h2)]).

Instance x67_Ord : Ord elf64_section_header_table_entry := {
     compare  :=  compare_elf64_section_header_table_entry;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf64_section_header_table_entry f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf64_section_header_table_entry f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf64_section_header_table_entry f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf64_section_header_table_entry f1 f2) [GT;  EQ]))
}.


(** Section header table type *)

(** Type [elf32_section_header_table] represents a section header table for 32-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
Definition elf32_section_header_table : Type := 
  list  elf32_section_header_table_entry .
Definition elf32_section_header_table_default: elf32_section_header_table  := DAEMON.

(** Type [elf64_section_header_table] represents a section header table for 64-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
Definition elf64_section_header_table : Type := 
  list  elf64_section_header_table_entry .
Definition elf64_section_header_table_default: elf64_section_header_table  := DAEMON.
(* [?]: removed value specification. *)

Definition bytes_of_elf32_section_header_table_entry  (endian : endianness ) (entry : elf32_section_header_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf32_word endian(elf32_sh_name entry)
  ; bytes_of_elf32_word endian(elf32_sh_type entry)
  ; bytes_of_elf32_word endian(elf32_sh_flags entry)
  ; bytes_of_elf32_addr endian(elf32_sh_addr entry)
  ; bytes_of_elf32_off  endian(elf32_sh_offset entry)
  ; bytes_of_elf32_word endian(elf32_sh_size entry)
  ; bytes_of_elf32_word endian(elf32_sh_link entry)
  ; bytes_of_elf32_word endian(elf32_sh_info entry)
  ; bytes_of_elf32_word endian(elf32_sh_addralign entry)
  ; bytes_of_elf32_word endian(elf32_sh_entsize entry)]
  .
(* [?]: removed value specification. *)

Definition read_elf32_section_header_table_entry  (endian : endianness ) (bs : byte_sequence )  : error ((elf32_section_header_table_entry *byte_sequence ) % type):= 
	read_elf32_word endian bs >>= 
  (fun (p : (elf32_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (sh_name,  bs)) =>
       read_elf32_word endian bs >>=
       (fun (p : (elf32_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (sh_type,  bs)) =>
            read_elf32_word endian bs >>=
            (fun (p : (elf32_word *byte_sequence ) % type) =>
               match ( (p) ) with ( (sh_flags,  bs)) =>
                 read_elf32_addr endian bs >>=
                 (fun (p : (elf32_addr *byte_sequence ) % type) =>
                    match ( (p) ) with ( (sh_addr,  bs)) =>
                      read_elf32_off endian bs >>=
                      (fun (p : (elf32_off *byte_sequence ) % type) =>
                         match ( (p) ) with ( (sh_offset,  bs)) =>
                           read_elf32_word endian bs >>=
                           (fun (p : (elf32_word *byte_sequence ) % type) =>
                              match ( (p) ) with ( (sh_size,  bs)) =>
                                read_elf32_word endian bs >>=
                                (fun (p : (elf32_word *byte_sequence ) % type) =>
                                   match ( (p) ) with ( (sh_link,  bs)) =>
                                     read_elf32_word endian bs >>=
                                     (fun (p : (elf32_word *byte_sequence ) % type) =>
                                        match ( (p) ) with
                                            ( (sh_info,  bs)) =>
                                          read_elf32_word endian bs >>=
                                          (fun (p : (elf32_word *byte_sequence ) % type) =>
                                             match ( (p) ) with
                                                 ( (sh_addralign,  bs)) =>
                                               read_elf32_word endian bs >>=
                                               (fun (p : (elf32_word *byte_sequence ) % type) =>
                                                  match ( (p) ) with
                                                      ( (sh_entsize,  bs)) =>
                                                    return0
                                                      ({|elf32_sh_name := sh_name;elf32_sh_type := sh_type;elf32_sh_flags := sh_flags;elf32_sh_addr := sh_addr;elf32_sh_offset := sh_offset;elf32_sh_size := sh_size;elf32_sh_link := sh_link;elf32_sh_info := sh_info;elf32_sh_addralign := sh_addralign;elf32_sh_entsize := sh_entsize |}, bs)
                                                  end) end) end) end) end)
                         end) end) end) end) end).
(* [?]: removed value specification. *)

Definition bytes_of_elf64_section_header_table_entry  (endian : endianness ) (entry : elf64_section_header_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf64_word  endian(elf64_sh_name entry)
  ; bytes_of_elf64_word  endian(elf64_sh_type entry)
  ; bytes_of_elf64_xword endian(elf64_sh_flags entry)
  ; bytes_of_elf64_addr  endian(elf64_sh_addr entry)
  ; bytes_of_elf64_off   endian(elf64_sh_offset entry)
  ; bytes_of_elf64_xword endian(elf64_sh_size entry)
  ; bytes_of_elf64_word  endian(elf64_sh_link entry)
  ; bytes_of_elf64_word  endian(elf64_sh_info entry)
  ; bytes_of_elf64_xword endian(elf64_sh_addralign entry)
  ; bytes_of_elf64_xword endian(elf64_sh_entsize entry)]
  .
(* [?]: removed value specification. *)

Definition read_elf64_section_header_table_entry  (endian : endianness ) (bs : byte_sequence )  : error ((elf64_section_header_table_entry *byte_sequence ) % type):= 
  read_elf64_word endian bs  >>= 
  (fun (p : (elf64_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (sh_name,  bs)) =>
       read_elf64_word endian bs >>=
       (fun (p : (elf64_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (sh_type,  bs)) =>
            read_elf64_xword endian bs >>=
            (fun (p : (elf64_xword *byte_sequence ) % type) =>
               match ( (p) ) with ( (sh_flags,  bs)) =>
                 read_elf64_addr endian bs >>=
                 (fun (p : (elf64_addr *byte_sequence ) % type) =>
                    match ( (p) ) with ( (sh_addr,  bs)) =>
                      read_elf64_off endian bs >>=
                      (fun (p : (elf64_off *byte_sequence ) % type) =>
                         match ( (p) ) with ( (sh_offset,  bs)) =>
                           read_elf64_xword endian bs >>=
                           (fun (p : (elf64_xword *byte_sequence ) % type) =>
                              match ( (p) ) with ( (sh_size,  bs)) =>
                                read_elf64_word endian bs >>=
                                (fun (p : (elf64_word *byte_sequence ) % type) =>
                                   match ( (p) ) with ( (sh_link,  bs)) =>
                                     read_elf64_word endian bs >>=
                                     (fun (p : (elf64_word *byte_sequence ) % type) =>
                                        match ( (p) ) with
                                            ( (sh_info,  bs)) =>
                                          read_elf64_xword endian bs >>=
                                          (fun (p : (elf64_xword *byte_sequence ) % type) =>
                                             match ( (p) ) with
                                                 ( (sh_addralign,  bs)) =>
                                               read_elf64_xword endian bs >>=
                                               (fun (p : (elf64_xword *byte_sequence ) % type) =>
                                                  match ( (p) ) with
                                                      ( (sh_entsize,  bs)) =>
                                                    return0
                                                      ({|elf64_sh_name := sh_name;elf64_sh_type := sh_type;elf64_sh_flags := sh_flags;elf64_sh_addr := sh_addr;elf64_sh_offset := sh_offset;elf64_sh_size := sh_size;elf64_sh_link := sh_link;elf64_sh_info := sh_info;elf64_sh_addralign := sh_addralign;elf64_sh_entsize := sh_entsize |}, bs)
                                                  end) end) end) end) end)
                         end) end) end) end) end).
(* [?]: removed value specification. *)

Definition bytes_of_elf32_section_header_table  (endian : endianness ) (tbl : list (elf32_section_header_table_entry ))  : byte_sequence := 
  byte_sequence.concat1 (List.map (bytes_of_elf32_section_header_table_entry endian) tbl).
(* [?]: removed value specification. *)

Definition bytes_of_elf64_section_header_table  (endian : endianness ) (tbl : list (elf64_section_header_table_entry ))  : byte_sequence := 
  byte_sequence.concat1 (List.map (bytes_of_elf64_section_header_table_entry endian) tbl).
(* [?]: removed value specification. *)

Program Fixpoint read_elf32_section_header_table'  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf32_section_header_table_entry )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf32_section_header_table_entry endian bs0 >>= 
  (fun (p : (elf32_section_header_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (entry,  bs1)) =>
       read_elf32_section_header_table' endian bs1 >>=
       (fun (tail1 : list (elf32_section_header_table_entry )) =>
          return0 (entry :: tail1)) end).
(* [?]: removed value specification. *)

Program Fixpoint read_elf64_section_header_table'  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf64_section_header_table_entry )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf64_section_header_table_entry endian bs0 >>= 
  (fun (p : (elf64_section_header_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (entry,  bs1)) =>
       read_elf64_section_header_table' endian bs1 >>=
       (fun (tail1 : list (elf64_section_header_table_entry )) =>
          return0 (entry :: tail1)) end).
(* [?]: removed value specification. *)

Definition read_elf32_section_header_table  (table_size : nat ) (endian : endianness ) (bs0 : byte_sequence )  : error ((list (elf32_section_header_table_entry )*byte_sequence ) % type):= 
  partition1 table_size bs0 >>= 
  (fun (p : (byte_sequence *byte_sequence ) % type) =>
     match ( (p) ) with ( (eat,  rest)) =>
       read_elf32_section_header_table' endian eat >>=
       (fun (entries : list (elf32_section_header_table_entry )) =>
          return0 (entries, rest)) end).

(* [?]: removed value specification. *)

Definition read_elf64_section_header_table  (table_size : nat ) (endian : endianness ) (bs0 : byte_sequence )  : error ((list (elf64_section_header_table_entry )*byte_sequence ) % type):= 
  partition1 table_size bs0 >>= 
  (fun (p : (byte_sequence *byte_sequence ) % type) =>
     match ( (p) ) with ( (eat,  rest)) =>
       read_elf64_section_header_table' endian eat >>=
       (fun (entries : list (elf64_section_header_table_entry )) =>
          return0 (entries, rest)) end).

(* [?]: removed value specification. *)

Definition elf32_size_correct  (hdr : elf32_section_header_table_entry ) (tbl : list (elf32_section_header_table_entry ))  : bool := 
  let m := nat_of_elf32_word(elf32_sh_size hdr) in
    if beq_nat m( 0) then
      true
    else beq_nat
      m ( (List.length tbl)).

(* [?]: removed value specification. *)

Definition elf64_size_correct  (hdr : elf64_section_header_table_entry ) (tbl : list (elf64_section_header_table_entry ))  : bool := 
  let m := nat_of_elf64_xword(elf64_sh_size hdr) in
    if beq_nat m( 0) then
      true
    else beq_nat
      m ( (List.length tbl)).

(* [?]: removed value specification. *)

Definition is_elf32_addr_addralign_correct  (ent : elf32_section_header_table_entry )  : bool := 
  let align := nat_of_elf32_word(elf32_sh_addralign ent) in
  let addr  := nat_of_elf32_addr(elf32_sh_addr ent) in
    if beq_nat (Coq.Numbers.Natural.Peano.NPeano.modulo addr align)( 0) then beq_nat
      align( 0) || beq_nat align( 1) (* TODO: or a power of two *)
    else
      false.
(* [?]: removed value specification. *)

Definition is_elf64_addr_addralign_correct  (ent : elf64_section_header_table_entry )  : bool := 
  let align := nat_of_elf64_xword(elf64_sh_addralign ent) in
  let addr  := nat_of_elf64_addr(elf64_sh_addr ent) in
    if beq_nat (Coq.Numbers.Natural.Peano.NPeano.modulo addr align)( 0) then beq_nat
      align( 0) || beq_nat align( 1) (* TODO: or a power of two *)
    else
      false.
(* [?]: removed value specification. *)

Definition is_valid_elf32_section_header_table  (tbl : list (elf32_section_header_table_entry ))  : bool := 
  match ( tbl) with 
    | []    => true
    | x::xs => beq_nat        
(nat_of_elf32_word(elf32_sh_name x))( 0) && (beq_nat        
(nat_of_elf32_word(elf32_sh_type x)) sht_null && (beq_nat        
(nat_of_elf32_word(elf32_sh_flags x))( 0) && (beq_nat        
(nat_of_elf32_addr(elf32_sh_addr x))( 0) && (beq_nat        
(nat_of_elf32_off(elf32_sh_offset x))( 0) && (beq_nat        
(nat_of_elf32_word(elf32_sh_info x))( 0) && (beq_nat        
(nat_of_elf32_word(elf32_sh_addralign x))( 0) && (beq_nat        
(nat_of_elf32_word(elf32_sh_entsize x))( 0) &&
        elf32_size_correct x tbl)))))))
        (* XXX: more correctness criteria in time *)
  end.
(* [?]: removed value specification. *)

Definition is_valid_elf64_section_header_table  (tbl : list (elf64_section_header_table_entry ))  : bool := 
  match ( tbl) with 
    | []    => true
    | x::xs => beq_nat        
(nat_of_elf64_word(elf64_sh_name x))( 0) && (beq_nat        
(nat_of_elf64_word(elf64_sh_type x)) sht_null && (beq_nat        
(nat_of_elf64_xword(elf64_sh_flags x))( 0) && (beq_nat        
(nat_of_elf64_addr(elf64_sh_addr x))( 0) && (beq_nat        
(nat_of_elf64_off(elf64_sh_offset x))( 0) && (beq_nat        
(nat_of_elf64_word(elf64_sh_info x))( 0) && (beq_nat        
(nat_of_elf64_xword(elf64_sh_addralign x))( 0) && (beq_nat        
(nat_of_elf64_xword(elf64_sh_entsize x))( 0) &&
        elf64_size_correct x tbl)))))))
        (* XXX: more correctness criteria in time *)
  end.

(** Pretty printing *)

(** The [sht_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
Definition sht_print_bundle : Type := (
  (nat  ->  string ) * (nat  ->  string ) * (nat  ->  string )) % type.
Definition sht_print_bundle_default: sht_print_bundle  := ((fun (x64 : nat ) => string_default), (fun (x65 : nat ) => string_default), (fun (x66 : nat ) => string_default)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 

Instance x63_Show : Show elf32_section_header_table_entry := {
   show  :=  string_of_elf32_section_header_table_entry_default
}.
 *)
(* [?]: removed value specification. *)

(* 

Instance x62_Show : Show elf64_section_header_table_entry := {
   show  :=  string_of_elf64_section_header_table_entry_default
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition is_elf32_tbss_special  (sec_hdr : elf32_section_header_table_entry ) (segment : elf32_program_header_table_entry )  : bool :=  negb (elf32_word_equal (elf32_word_land(elf32_sh_flags sec_hdr) (elf32_word_of_nat shf_tls)) (elf32_word_of_nat( 0))) &&    
(( beq_nat(nat_of_elf32_word(elf32_sh_type sec_hdr)) sht_nobits) &&
    ( negb (beq_nat (nat_of_elf32_word(elf32_p_type segment)) elf_pt_tls))).
(* [?]: removed value specification. *)

Definition is_elf64_tbss_special  (sec_hdr : elf64_section_header_table_entry ) (segment : elf64_program_header_table_entry )  : bool :=  negb (elf64_xword_equal (elf64_xword_land(elf64_sh_flags sec_hdr) (elf64_xword_of_nat shf_tls)) (elf64_xword_of_nat( 0))) &&    
(( beq_nat(nat_of_elf64_word(elf64_sh_type sec_hdr)) sht_nobits) &&
    ( negb (beq_nat (nat_of_elf64_word(elf64_p_type segment)) elf_pt_tls))).
(* [?]: removed value specification. *)

Program Fixpoint get_elf32_section_to_segment_mapping  (hdr : elf32_header ) (sects : list (elf32_section_header_table_entry )) (pent : elf32_program_header_table_entry ) (isin : elf32_header  -> elf32_section_header_table_entry  -> elf32_program_header_table_entry  -> bool ) (stbl : string_table )  : error (list (string )):= 
  match ( sects) with 
    | []    => return0 []
    | x::xs =>
      if is_elf32_tbss_special x pent then
        get_elf32_section_to_segment_mapping hdr xs pent isin stbl
      else if negb (isin hdr x pent) then
        get_elf32_section_to_segment_mapping hdr xs pent isin stbl
      else
        let nm := nat_of_elf32_word(elf32_sh_name x) in
          get_string_at nm stbl >>= (fun (str : string ) =>
          get_elf32_section_to_segment_mapping hdr xs pent isin stbl >>= (fun (tl : list (string )) =>
          return0 (str :: tl)))
  end.
(* [?]: removed value specification. *)

Program Fixpoint get_elf64_section_to_segment_mapping  (hdr : elf64_header ) (sects : list (elf64_section_header_table_entry )) (pent : elf64_program_header_table_entry ) (isin : elf64_header  -> elf64_section_header_table_entry  -> elf64_program_header_table_entry  -> bool ) (stbl : string_table )  : error (list (string )):= 
  match ( sects) with 
    | []    => return0 []
    | x::xs =>
      if negb (isin hdr x pent) then
        get_elf64_section_to_segment_mapping hdr xs pent isin stbl
      else if is_elf64_tbss_special x pent then
        get_elf64_section_to_segment_mapping hdr xs pent isin stbl
      else
        let nm := nat_of_elf64_word(elf64_sh_name x) in
          get_string_at nm stbl >>= (fun (str : string ) =>
          get_elf64_section_to_segment_mapping hdr xs pent isin stbl >>= (fun (tl : list (string )) =>
          return0 (str :: tl)))
  end.
  
(** Section groups *)

(** This is a COMDAT group and may duplicate other COMDAT groups in other object
  * files.
  *)
Definition grp_comdat      :  nat :=  1.

(** Any bits in the following mask ranges are reserved exclusively for OS and
  * processor specific semantics, respectively.
  *)
Definition grp_maskos      :  nat :=  267386880.      (* 0x0ff00000 *)
Definition grp_maskproc    :  nat :=  Coq.Init.Peano.mult( 4)( 1006632960).
(* [?]: removed value specification. *)

Definition obtain_elf32_section_group_indices  (endian : endianness ) (sht : list (elf32_section_header_table_entry )) (bs0 : byte_sequence )  : error (list ((nat *list (elf32_word )) % type)):= 
  let filtered := List.filter (fun (ent : elf32_section_header_table_entry ) => beq_nat    
(nat_of_elf32_word(elf32_sh_type ent)) sht_group) sht
  in
    mapM (fun (grp : elf32_section_header_table_entry ) =>
      let off := nat_of_elf32_off(elf32_sh_offset grp) in
      let siz := nat_of_elf32_word(elf32_sh_size grp) in
      let cnt := Coq.Numbers.Natural.Peano.NPeano.div siz( 4) (* size of elf32_word in bytes *) in
      byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
      error.repeatM' cnt rel (read_elf32_word endian) >>= 
  (fun (p : (list (elf32_word )*byte_sequence ) % type) =>
     match ( (p) ) with ( (mems,  _)) =>
       match ( mems) with | [] =>
         fail0
           "obtain_elf32_section_group_indices: section group sections must consist of at least one elf32_word"
         | x::xs => let flag := nat_of_elf32_word x in return0 (flag, xs) end
     end))
    ) filtered.
(* [?]: removed value specification. *)

Definition obtain_elf64_section_group_indices  (endian : endianness ) (sht : list (elf64_section_header_table_entry )) (bs0 : byte_sequence )  : error (list ((nat *list (elf64_word )) % type)):= 
  let filtered := List.filter (fun (ent : elf64_section_header_table_entry ) => beq_nat    
(nat_of_elf64_word(elf64_sh_type ent)) sht_group) sht
  in
    mapM (fun (grp : elf64_section_header_table_entry ) =>
      let off := nat_of_elf64_off(elf64_sh_offset grp) in
      let siz := nat_of_elf64_xword(elf64_sh_size grp) in
      let cnt := Coq.Numbers.Natural.Peano.NPeano.div siz( 4) (* size of elf64_word in bytes *) in
      byte_sequence.offset_and_cut off siz bs0 >>= (fun (rel : byte_sequence ) =>
      error.repeatM' cnt rel (read_elf64_word endian) >>= 
  (fun (p : (list (elf64_word )*byte_sequence ) % type) =>
     match ( (p) ) with ( (mems,  _)) =>
       match ( mems) with | [] =>
         fail0
           "obtain_elf64_section_group_indices: section group sections must consist of at least one elf64_word"
         | x::xs => let flag := nat_of_elf64_word x in return0 (flag, xs) end
     end))
    ) filtered.
(* [?]: removed value specification. *)

Definition obtain_elf32_tls_template  (sht : list (elf32_section_header_table_entry ))  : list (elf32_section_header_table_entry ):= 
  List.filter (fun (ent : elf32_section_header_table_entry ) =>
    let flags := nat_of_elf32_word(elf32_sh_flags ent) in negb (beq_nat (nat_land flags shf_tls)( 0))) sht.
(* [?]: removed value specification. *)

Definition obtain_elf64_tls_template  (sht : list (elf64_section_header_table_entry ))  : list (elf64_section_header_table_entry ):= 
  List.filter (fun (ent : elf64_section_header_table_entry ) =>
    let flags := nat_of_elf64_xword(elf64_sh_flags ent) in negb (beq_nat (nat_land flags shf_tls)( 0))) sht.
(* [?]: removed value specification. *)

Definition obtain_elf32_hash_table  (endian : endianness ) (sht : list (elf32_section_header_table_entry )) (bs0 : byte_sequence )  : error ((elf32_word *elf32_word *list (elf32_word )*list (elf32_word )) % type):= 
  let filtered := List.filter (fun (ent : elf32_section_header_table_entry ) => beq_nat    
(nat_of_elf32_word(elf32_sh_type ent)) sht_hash) sht
  in
    match ( filtered) with 
      | []  => fail0 "obtain_elf32_hash_table: no section header table entry of type sht_hash"
      | [x] =>
        let siz := nat_of_elf32_word(elf32_sh_size x) in
        let off := nat_of_elf32_off(elf32_sh_offset  x) in
        byte_sequence.offset_and_cut siz off bs0 >>= (fun (rel : byte_sequence ) =>
        read_elf32_word endian rel >>= 
  (fun (p : (elf32_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (nbucket,  rel)) =>
       read_elf32_word endian rel >>=
       (fun (p : (elf32_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (nchain,  rel)) =>
            error.repeatM' (nat_of_elf32_word nbucket) rel
              (read_elf32_word endian) >>=
            (fun (p : (list (elf32_word )*byte_sequence ) % type) =>
               match ( (p) ) with ( (buckets,  rel)) =>
                 error.repeatM' (nat_of_elf32_word nchain) rel
                   (read_elf32_word endian) >>=
                 (fun (p : (list (elf32_word )*byte_sequence ) % type) =>
                    match ( (p) ) with ( (chain,  _)) =>
                      return0 (nbucket, nchain, buckets, chain) end) end) end)
     end))
      | _   => fail0 "obtain_elf32_hash_table: multiple section header table entries of type sht_hash"
    end.
(* [?]: removed value specification. *)

Definition obtain_elf64_hash_table  (endian : endianness ) (sht : list (elf64_section_header_table_entry )) (bs0 : byte_sequence )  : error ((elf64_word *elf64_word *list (elf64_word )*list (elf64_word )) % type):= 
  let filtered := List.filter (fun (ent : elf64_section_header_table_entry ) => beq_nat    
(nat_of_elf64_word(elf64_sh_type ent)) sht_hash) sht
  in
    match ( filtered) with 
      | []  => fail0 "obtain_elf64_hash_table: no section header table entry of type sht_hash"
      | [x] =>
        let siz := nat_of_elf64_xword(elf64_sh_size x) in
        let off := nat_of_elf64_off(elf64_sh_offset  x) in
        byte_sequence.offset_and_cut siz off bs0 >>= (fun (rel : byte_sequence ) =>
        read_elf64_word endian rel >>= 
  (fun (p : (elf64_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (nbucket,  rel)) =>
       read_elf64_word endian rel >>=
       (fun (p : (elf64_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (nchain,  rel)) =>
            error.repeatM' (nat_of_elf64_word nbucket) rel
              (read_elf64_word endian) >>=
            (fun (p : (list (elf64_word )*byte_sequence ) % type) =>
               match ( (p) ) with ( (buckets,  rel)) =>
                 error.repeatM' (nat_of_elf64_word nchain) rel
                   (read_elf64_word endian) >>=
                 (fun (p : (list (elf64_word )*byte_sequence ) % type) =>
                    match ( (p) ) with ( (chain,  _)) =>
                      return0 (nbucket, nchain, buckets, chain) end) end) end)
     end))
      | _   => fail0 "obtain_elf64_hash_table: multiple section header table entries of type sht_hash"
    end.
(* [?]: removed value specification. *)

Definition elf_special_sections   : fmap (string ) ((nat *nat ) % type):= 
    lem_map.fromList [
      (".bss", (sht_nobits, Coq.Init.Peano.plus shf_alloc shf_write))
    ; (".comment", (sht_progbits, 0))
    ; (".data", (sht_progbits, Coq.Init.Peano.plus shf_alloc shf_write))
    ; (".data1", (sht_progbits, Coq.Init.Peano.plus shf_alloc shf_write))
    ; (".debug", (sht_progbits, 0))
    (* ; (".dynamic", (sht_dynamic, ?)) *)
    ; (".dynstr", (sht_strtab, shf_alloc))
    ; (".dynsym", (sht_dynsym, shf_alloc))
    ; (".fini", (sht_progbits, Coq.Init.Peano.plus shf_alloc shf_execinstr))
    ; (".fini_array", (sht_fini_array, Coq.Init.Peano.plus shf_alloc shf_write))
    (* ; (".got", (sht_progbits, ?)) *)
    ; (".hash", (sht_hash, shf_alloc))
    ; (".init", (sht_progbits, Coq.Init.Peano.plus shf_alloc shf_execinstr))
    ; (".init_array", (sht_init_array, Coq.Init.Peano.plus shf_alloc shf_write))
    (* ; (".interp", (sht_progbits, ?)) *)
    ; (".line", (sht_progbits, 0))
    ; (".note", (sht_note, 0))
    (* ; (".plt", (sht_progbits, ?)) *)
    ; (".preinit_array", (sht_preinit_array, Coq.Init.Peano.plus shf_alloc shf_write))
    (* ; (".relname", (sht_rel, ?)) *)
    (* ; (".relaname", (sht_rela, ?)) *)
    ; (".rodata", (sht_progbits, shf_alloc))
    ; (".rodata1", (sht_progbits, shf_alloc))
    ; (".shstrtab", (sht_strtab, 0))
    (* ; (".strtab", (sht_strtab, ?)) *)
    (* ; (".symtab", (sht_symtab, ?)) *)
    (* ; (".symtab_shndx", (sht_symtab_shndx, ?)) *)
    ; (".tbss", (sht_nobits, Coq.Init.Peano.plus (Coq.Init.Peano.plus shf_alloc shf_write) shf_tls))
    ; (".tdata", (sht_progbits, Coq.Init.Peano.plus (Coq.Init.Peano.plus shf_alloc shf_write) shf_tls))
    ; (".tdata1", (sht_progbits, Coq.Init.Peano.plus (Coq.Init.Peano.plus shf_alloc shf_write) shf_tls))
    ; (".text", (sht_progbits, Coq.Init.Peano.plus shf_alloc shf_execinstr))]
    .
