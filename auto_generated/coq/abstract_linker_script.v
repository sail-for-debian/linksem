(* Generated by Lem from abstract_linker_script.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.


Inductive binary_relation : Type :=
   Eq0: binary_relation 
  | Lt0: binary_relation .
Definition binary_relation_default: binary_relation  := Eq0.

Inductive binary_connective : Type :=
   And0: binary_connective  (** Conjunction *)
  | Or0: binary_connective .
Definition binary_connective_default: binary_connective  := And0.  (** Disjunction *)

(** The type [expression] denotes addresses, whether known or to be ascertained.
  *)
Inductive expression : Type :=
   Var0:    string  -> expression    (** Ranges over memory addresses *)
  | Const:  nat  -> expression .
Definition expression_default: expression  := Var0 string_default.  (** Fixed memory address *)

(* These are *one-place* predicates on unsigned integer solutions (usually representing 
 * addresses). Implicitly, every binary relation is being applied to the solution. HMM: is 
 * this sane? Taking my lead from KLEE / SMT solver formulae. What we're describing is a
 * big SMT instance; it's sane if we can always factor the instances we want into this 
 * form, i.e. into a big conjunction of per-variable formulae where each two-place relation
 * has the variable in one of its places. 
 * 
 * Could try to claim it follows from taking CNF and assigning
 * each conjunct to one of the variables it contains. But what if that conjunct is a big 
 * disjunction including some other binary operators applied to two other variables?
 * Might need to factor those out into a "global" extra conjunct. YES. *)
Inductive value_formula : Type :=
   VFTrue: value_formula 
  | VFFalse: value_formula 
  | VFBinaryRelation:  ((binary_relation  * expression ) % type) -> value_formula 
  | VFBinaryConnective:  ((binary_connective  * value_formula  * value_formula ) % type) -> value_formula 
  | VFNot:  value_formula  -> value_formula .
Definition value_formula_default: value_formula  := VFTrue.

Inductive memory_image_formula : Type :=
   MIFTrue: memory_image_formula 
  | MIFFalse: memory_image_formula 
  | MIFExists:  ((string  * memory_image_formula ) % type) -> memory_image_formula 
  | MIFBinaryRelation:  ((binary_relation  * expression  * expression ) % type) -> memory_image_formula 
  | MIFBinaryConnective:  ((binary_connective  * memory_image_formula  * memory_image_formula ) % type) -> memory_image_formula 
  | MIFAssertValueFormula:  ((expression  * value_formula ) % type) -> memory_image_formula 
  | MIFNot:  memory_image_formula  -> memory_image_formula .
Definition memory_image_formula_default: memory_image_formula  := MIFTrue.

Inductive memory_image0 : Type :=
   MemoryImage:  memory_image_formula  -> memory_image0 .
Definition memory_image0_default: memory_image0  := MemoryImage memory_image_formula_default.
(* [?]: removed value specification. *)

Definition mk_range  (left : nat ) (right : nat )  : value_formula := 
  if beq_nat left right then
    VFTrue
  else if nat_ltb right left then
    VFFalse
  else
    let l := Const left in
    let r := Const right in
    VFBinaryConnective(And0, VFBinaryRelation(Lt0, r), VFNot(VFBinaryRelation(Lt0, l))).
