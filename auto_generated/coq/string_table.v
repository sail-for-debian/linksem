(* Generated by Lem from string_table.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** The [string_table] module implements string tables.  An ELF file may have
  * multiple different string tables used for different purposes.  A string
  * table is a string coupled with a delimiting character.  Strings may be indexed
  * at any position, not necessarily on a delimiter boundary.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import byte_sequence.
Require Export byte_sequence.


Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


(** [string_table] type, represents a string table with a fixed delimiting
  * character and underlying string.
  *)
Inductive string_table : Type :=
   Strings:  ((ascii  * string ) % type) -> string_table .
(* [?]: removed value specification. *)

Definition mk_string_table  (base : string ) (sep : ascii )  : string_table := 
  Strings (sep, base).
(* [?]: removed value specification. *)

Definition string_table_of_byte_sequence  (seq : byte_sequence )  : string_table :=  mk_string_table (string_of_byte_sequence seq) null_char.
(* [?]: removed value specification. *)

Definition empty0   : string_table :=  Strings (null_char, string_from_char_list [null_char]).
(* [?]: removed value specification. *)

Definition get_delimiting_character  (tbl : string_table )  : ascii := 
  match ( tbl) with 
    | Strings (sep,  base) => sep
  end.
(* [?]: removed value specification. *)

Definition get_base_string  (tbl : string_table )  : string := 
  match ( tbl) with 
    | Strings (sep,  base) => base
  end.
(* [?]: removed value specification. *)

Definition size0  (tbl : string_table )  : nat :=   (String.length (get_base_string tbl)).
(* [?]: removed value specification. *)

Definition concat2  (xs : list (string_table ))  : error (string_table ):= 
  match ( xs) with 
    | []    => return0 empty0
    | x::xs =>
      let delim := get_delimiting_character x in
        if (List.forallb (fun (x : string_table ) => (char_equal (get_delimiting_character x) delim)) (x::xs)) then
          let base := List.fold_right String.append "" (List.map get_base_string (x::xs)) in
            return0 (mk_string_table base delim)
        else
          fail0 "concat: string tables must have same delimiting characters"
  end.
(* [?]: removed value specification. *)

Definition get_string_at  (index2 : nat ) (tbl : string_table )  : error (string ):= 
  match ( string_suffix index2 (get_base_string tbl)) with 
    | None     => Fail "get_string_at: index out of range"
    | Some suffix =>
      let delim := get_delimiting_character tbl in
      match ( string_index_of delim suffix) with 
        | Some idx1 =>
          match ( string_prefix idx1 suffix) with 
            | Some s  => Success s
            | None => Fail "get_string_at: index out of range"
          end
        | None => Success suffix
      end
  end.
(* [?]: removed value specification. *)

Definition find_string  (s : string ) (t : string_table )  : option (nat ) :=  
    match ( t) with 
        Strings(delim,  base) => find_substring ( String.append s (string_from_char_list [delim])) base
    end.
(* [?]: removed value specification. *)

Definition insert_string  (s : string ) (t : string_table )  : (nat *string_table ) % type:=  
  (*let _ = errln ("Inserting string `" ^ s ^ "' into a string table") in*)
  match ( match ( find_string s t) with None =>
            match ( t) with Strings(delim,  base) =>
              ( (String.length base), Strings
                                        (delim, String.append base
                                                  (String.append s
                                                     (string_from_char_list
                                                        [delim])))) end
            | Some pos => (pos, t) end) with (inserted_idx,  new_strtab) =>
    (*let _ = errln ("Inserted string at idx " ^ (show inserted_idx) ^ ", see: " ^ (show (find_string s new_strtab)))
    in*)
  (inserted_idx, new_strtab) end.
(* 

Instance x43_Show : Show string_table := {
   show   tbl :=  string_from_char_list (List.map (fun  c => if instance_Basic_classes_Eq_char.= c \000 then \n else c) (string_to_char_list (get_base_string tbl)))
}.
 *)
