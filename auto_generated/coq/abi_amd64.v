(* Generated by Lem from abis/amd64/abi_amd64.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [abi_amd64] contains top-level definition for the AMD64 ABI.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import error.
Require Export error.

Require Import lem_map.
Require Export lem_map.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import elf_header.
Require Export elf_header.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_file.
Require Export elf_file.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.


Require Import endianness.
Require Export endianness.

Require Import memory_image.
Require Export memory_image.

(* open import Elf_memory_image *)

Require Import abi_classes.
Require Export abi_classes.

Require Import abi_amd64_relocation.
Require Export abi_amd64_relocation.

Require Import abi_amd64_elf_header.
Require Export abi_amd64_elf_header.

(* [?]: removed value specification. *)

Definition abi_amd64_compute_program_entry_point  (segs : list (elf64_interpreted_segments )) (entry : elf64_addr )  : error (elf64_addr ):= 
	return0 entry.
(* [?]: removed value specification. *)

Definition header_is_amd64  (h : elf64_header )  : bool :=   
    is_valid_elf64_header h
    && ((maybeEqualBy unsigned_char_eq (lem_list.index(elf64_ident h) (id elf_ii_data)) (Some (unsigned_char_of_nat elf_data_2lsb)))
    && (is_valid_abi_amd64_machine_architecture (nat_of_elf64_half(elf64_machine h))
    && is_valid_abi_amd64_magic_number(elf64_ident h))).

Definition shf_x86_64_large    :  nat :=  ( Coq.Init.Peano.mult( 256)( 1048576)). (* 0x10000000 a.k.a. 2^28 *)

Inductive amd64_abi_feature : Type :=  
    GOT0:   (list  ((string  * (option  symbol_definition  )) % type)) -> amd64_abi_feature 
    | PLT0: amd64_abi_feature .
Definition amd64_abi_feature_default: amd64_abi_feature  := GOT0 DAEMON.
(* [?]: removed value specification. *)

Definition abiFeatureCompare0  (f1 : amd64_abi_feature ) (f2 : amd64_abi_feature )  : ordering :=  
    match ( (f1, f2)) with 
        (GOT0(_),  GOT0(_)) => EQ
        | (GOT0(_),  PLT0) => LT
        | (PLT0,  PLT0) => EQ
        | (PLT0,  GOT0(_)) => GT
    end.
(* [?]: removed value specification. *)

Definition abiFeatureTagEq0  (f1 : amd64_abi_feature ) (f2 : amd64_abi_feature )  : bool := 
    match ( (f1, f2)) with 
        (GOT0(_),  GOT0(_)) => true
        | (PLT0,  PLT0) => true
        | (_,  _) => false
    end.

Instance x114_AbiFeatureTagEquiv : AbiFeatureTagEquiv amd64_abi_feature := {
     abiFeatureTagEquiv  :=  abiFeatureTagEq0
}.


Instance x113_Ord : Ord amd64_abi_feature := {
     compare  :=  abiFeatureCompare0;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (abiFeatureCompare0 f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (abiFeatureCompare0 f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (abiFeatureCompare0 f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (abiFeatureCompare0 f1 f2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

Definition section_is_special1 {abifeature : Type}  (s : elf64_interpreted_section ) (img3 : annotated_memory_image abifeature)  : bool :=  
    elf_section_is_special s img3 ||
    match ((elf64_section_name_as_string s)) with  
        ".eh_frame" => true (* HACK needed because SHT_X86_64_UNWIND is often not used *)
       | _ => false
    end.
