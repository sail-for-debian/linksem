(* Generated by Lem from elf64_file_of_elf_memory_image.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_map.
Require Export lem_map.

Require Import lem_set.
Require Export lem_set.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import default_printing.
Require Export default_printing.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.

Require Import endianness.
Require Export endianness.


Require Import elf_header.
Require Export elf_header.

Require Import elf_file.
Require Export elf_file.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import string_table.
Require Export string_table.


Require Import memory_image.
Require Export memory_image.

Require Import memory_image_orderings.
Require Export memory_image_orderings.


Require Import elf_memory_image.
Require Export elf_memory_image.

Require Import elf_memory_image_of_elf64_file.
Require Export elf_memory_image_of_elf64_file.

Require Import abis.
Require Export abis.


(* Things the caller should do first: *)
(* - create segment annotations *)
(* - create .dynamic-equivalent metadata (but not the section) *)
(* - concretise symbolic elements? actually they pass a function to do this. *)

Definition make_concrete_fn : Type :=  memory_image.element  ->  memory_image.element .
Definition make_concrete_fn_default: make_concrete_fn  := (fun (x142 :  memory_image.element ) => element_default).
(* [?]: removed value specification. *)

Definition elf64_file_of_elf_memory_image  (a : abi (any_abi_feature )) (make_concrete : element  -> element ) (fname1 : string ) (img3 : annotated_memory_image (any_abi_feature ))  : elf64_file :=  
  (* Generate an ELF header, (optionally) SHT and (optionally) PHT, 
     * based on metadata in the image.
     * 
     * How do we decide what kind of ELF file to generate?     see whether we have segment annotations?
                        what architecture/osabi to give?       the ABI tells us
                        
     *)
  match ( elf_memory_image_section_ranges img3) with
      (section_tags,  section_ranges) =>
    let section_tags_bare := List.map
                               (fun (tag : range_tag (any_abi_feature )) =>
                                  match ( tag) with
                                        | FileFeature(ElfSection(idx1,  isec1)) =>
                                    (idx1, isec1) | _ => DAEMON end)
                               section_tags in
  let section_tags_bare_noidx := List.map
                                   (fun (p : (nat *elf64_interpreted_section ) % type) =>
                                      match ( (p) ) with ( (idx1,  isec1)) =>
                                        isec1 end) section_tags_bare in
  let basic_shstrtab := List.fold_left
                          (fun (table : string_table ) =>
                             (fun (str : string ) =>
                                match ( string_table.insert_string str table) with
                                    (_,  t) => t end ))
                          [".shstrtab"; ".symtab"; ".strtab"]
                          string_table.empty0 in
  let shstrtab := List.fold_left
                    (fun (table : string_table ) =>
                       fun (p : (nat *elf64_interpreted_section ) % type) =>
                         match ( (p) ) with ( (idx1,  isec1)) =>
                           match ( string_table.insert_string
                                     (elf64_section_name_as_string isec1)
                                     table) with (_,  t) =>
                             (* let _ = errln ("Adding section name `" ^ isec.elf64_section_name_as_string ^ "' to shstrtab; now has size "
            ^ (show (String_table.size t)))
        in *) t
                           end end ) section_tags_bare basic_shstrtab in
  let phoff := 64 in let max_phnum1 :=(max_phnum (* length phdrs *) a) in
  (* what do we generate? 
         * .eh_frame? no, *should* come from the script
         * .got, .got.plt? HMM. These should have been created,
         * as ABI features, by the time we get here.
         * .comment -- maybe
         * .shstrtab -- YES
         * .symtab -- YES
         * .strtab -- YES.
         * 
         * Do we generate them as elements in the image, or just
         * use them to write the ELF file? The latter.
         *)
  match ( elf_memory_image_symbol_def_ranges img3) with
      (symbol_tags,  symbol_ranges) =>
    let all_sym_names := List.map
                           (fun (tag : range_tag (any_abi_feature )) =>
                              match ( tag) with SymbolDef(sd) =>
                                (def_symname sd) | _ =>
                                "not symbol tag, in symbol tags" end )
                           symbol_tags in
  (*let _ = errln ("All symbol names: " ^ (show all_sym_names))
    in*)
  let strtab := List.fold_left
                  (fun (table : string_table ) =>
                     fun (str : string ) =>
                       match ( string_table.insert_string str table) with
                           (_,  t) => t end ) all_sym_names
                  string_table.empty0 in
  (* If the same address starts >1 section, all but one of those sections
     * must have size zero. These need to come *first* to avoid screwing up
     * the offset calculation. So also sort by size, so that the zero-sizers
     * come first. *)
  let element_section_tag_pairs_sorted_by_address := (* List.stable_sort *) sort_by_ordering
                                                       (fun (p : (elf64_interpreted_section *((string *((nat *nat ) % type)) % type)) % type) =>
                                                          match ( (p) ) with
                                                              ( (isec1,  (el1,  range1))) =>
                                                            (fun (p : (elf64_interpreted_section *((string *((nat *nat ) % type)) % type)) % type) =>
                                                               match ( (p) ) with
                                                                   ( (isec2,  (el2,  range2))) =>
                                                                 (
                                                               match ( 
                                                               match ( (
                                                               fmap_lookup_by
                                                                 (fun (x : string ) (y : string )=>
                                                                    EQ) 
                                                               el1
                                                                 (elements img3))) with
                                                                   Some(e) =>
                                                                 (*let _ = errln ("Size of element " ^ el1 ^ " is " ^ (show e.length))
                    in*)
                                                               ((startpose),(length1 e))
                                                                 | None =>
                                                                 DAEMON end) with
                                                                   (addr1,  sz1) =>
                                                                 match ( 
                                                                 match ( (
                                                                 fmap_lookup_by
                                                                   (fun (x : string ) (y : string )=>
                                                                    EQ) 
                                                                 el2
                                                                   (elements img3))) with
                                                                    Some(e) =>
                                                                   ((startpose),(length1 e))
                                                                   | None =>
                                                                   DAEMON end) with
                                                                    (addr2,  sz2) =>
                                                                   (pairCompare
                                                                    (
                                                                    maybeCompare
                                                                    (
                                                                    genericCompare
                                                                    nat_ltb
                                                                    beq_nat))
                                                                    (
                                                                    maybeCompare
                                                                    (
                                                                    genericCompare
                                                                    nat_ltb
                                                                    beq_nat))
                                                                    (addr1, sz1)
                                                                    (addr2, sz2))
                                                                 end end )
                                                               end) end)
                                                       (zip
                                                          section_tags_bare_noidx
                                                          section_ranges) in
  let sorted_sections := List.map
                           (fun (p : (elf64_interpreted_section *((string *((nat *nat ) % type)) % type)) % type) =>
                              match ( (p) ) with
                                  ( (isec1,  (el,  range1))) => isec1 end)
                           element_section_tag_pairs_sorted_by_address in
  let filesz := (fun (el : element ) =>
                   fun (isec1 : elf64_interpreted_section ) =>
                     (* How can we distinguish progbits from nobits? 
         * A section can be nobits if its representation
         * is all zero or don't-care. But in practice we
         * don't make a section nobits unless its name is .bss. *)
                     let sz :=
                     if (* is_all_zeroes_or_dont_care *) true &&
                        (string_equal (elf64_section_name_as_string isec1)
                           ".bss") then  0 else
                       match ((length1 el)) with None => DAEMON | Some len =>
                         len end in
                     (*let _ = errln ("Filesz of " ^ isec.elf64_section_name_as_string ^ " is 0x" ^ (hex_string_of_natural sz))
        in*)
                     sz ) in
  match ( List.fold_left
            (fun (p : (nat *list (nat )) % type) =>
               match ( (p) ) with ( (current_off,  offs_so_far)) =>
                 (fun (p : (elf64_interpreted_section *((string *((nat *nat ) % type)) % type)) % type) =>
                    match ( (p) ) with ( (isec1,  (el_name,  el_range))) =>
                      (* where can we place this in the file?
         * it's the next offset that's congruent to the section addr, 
         * modulo the biggest page size. *)
                    let el := match ( (fmap_lookup_by
                                         (fun (x : string ) (y : string )=>
                                            EQ) el_name (elements img3))) with
                                  Some e => e | None => DAEMON end in
                    let start_off := match ((startpos el)) with Some addr =>
                                       let this_remainder := Coq.Numbers.Natural.Peano.NPeano.modulo
                                                               current_off
                                                               (maxpagesize a)
                                     in
                                     let target_remainder := Coq.Numbers.Natural.Peano.NPeano.modulo
                                                               addr
                                                               (maxpagesize a)
                                     in let bump := (
                                     if nat_gteb target_remainder
                                          this_remainder then
                                       Coq.Init.Peano.minus target_remainder
                                         this_remainder else
                                       ( Coq.Init.Peano.minus
                                           (Coq.Init.Peano.plus
                                              (maxpagesizea) target_remainder)
                                           this_remainder) )
                                     in Coq.Init.Peano.plus
                                          (*let _ = errln ("For section " ^ isec.elf64_section_name_as_string ^ ", bumping offset by " ^ 
                    (hex_string_of_natural bump) ^ "(remainder " ^ (hex_string_of_natural this_remainder) ^ 
                    ", target remainder " ^ (hex_string_of_natural target_remainder) ^ ") to 0x" ^ 
                    (hex_string_of_natural (current_off + bump)))
                in*)
                                          current_off bump | None =>
                                       (* It has no assigned address. That's okay if it's not allocatable. 
                 * If it's not allocatable, it has no alignment. *)
                                       if flag_is_set shf_alloc
                                            (elf64_section_flags isec1) then
                                         (DAEMON) else current_off (* FIXME: is alignment important in file-offset-space? *)
                                     end in
                    let end_off := Coq.Init.Peano.plus start_off
                                     (filesz el isec1) in
                    (end_off, (@ List.app _) offs_so_far [start_off]) end )
               end) element_section_tag_pairs_sorted_by_address
            (( Coq.Init.Peano.plus phoff
                 ( Coq.Init.Peano.mult max_phnum1 ( 56))), [])) with
      (last_off,  section_file_offsets) =>
    let user_sections_sorted_with_offsets := let x2 := [] in List.fold_right
                                                               (fun (p : (nat *((elf64_interpreted_section *((string *((nat *nat ) % type)) % type)) % type)) % type) (x2 : list (elf64_interpreted_section )) =>
                                                                  match ( (p ,x2) ) with
                                                                    ((off,  (isec1,  (el_name,  el_range))) ,  x2) =>
                                                                    if 
                                                                    true then
                                                                    (let el := 
                                                                    match ( (
                                                                    fmap_lookup_by
                                                                    (
                                                                    fun (x : string ) (y : string )=>
                                                                    EQ)
                                                                    el_name
                                                                    (elements img3))) with
                                                                    Some x =>
                                                                    x
                                                                    | None =>
                                                                    DAEMON
                                                                    end in
                                                                    {|elf64_section_name :=(elf64_section_name isec1) (* ignored *)
                                                                    ;elf64_section_type :=(elf64_section_type isec1)
                                                                    ;elf64_section_flags :=(elf64_section_flags isec1)
                                                                    ;elf64_section_addr := 
                                                                    match ((startpos el)) with
                                                                    Some addr =>
                                                                    addr
                                                                    | None =>
                                                                     0 end
                                                                    ;elf64_section_offset :=
                                                                    (*let _ = errln ("Assigning offset 0x" ^ (hex_string_of_natural off) ^ " to section " ^ 
                    isec.elf64_section_name_as_string)
                in*)
                                                                    off
                                                                    ;elf64_section_size := 
                                                                    match ((length1 el)) with
                                                                    Some len =>
                                                                    len
                                                                    | None =>
                                                                    length
                                                                    (contents el)
                                                                    end
                                                                    ;elf64_section_link :=(elf64_section_link isec1)
                                                                    ;elf64_section_info :=(elf64_section_info isec1)
                                                                    ;elf64_section_align :=(elf64_section_align isec1)
                                                                    ;elf64_section_entsize :=(elf64_section_entsize isec1)
                                                                    ;elf64_section_body :=
                                                                    (let pad_fn1 :=
                                                                    if 
                                                                    flag_is_set
                                                                    shf_execinstr
                                                                    (elf64_section_flags isec1) then
                                                                    (pad_data a)
                                                                    else
                                                                    (pad_code a)
                                                                    in
                                                                    Sequence
                                                                    (
                                                                    concretise_byte_pattern
                                                                    [] 
                                                                    ( 0)
                                                                    (contents (
                                                                    make_concrete
                                                                    el))
                                                                    pad_fn1))
                                                                    ;elf64_section_name_as_string :=(elf64_section_name_as_string isec1)
                                                                    |}) :: 
                                                                    x2 else
                                                                    x2 end)
                                                               x2
                                                               (zip
                                                                  section_file_offsets
                                                                  element_section_tag_pairs_sorted_by_address)
  in let symtab :=
  (* Get all the symbols *) elf64_null_symbol_table_entry ::
  (let x2 := [] in List.fold_right
                     (fun (p : (option (element_range ) *range_tag (any_abi_feature )) % type) (x2 : list (elf64_symbol_table_entry )) =>
                        match ( (p ,x2) ) with ((maybe_range,  tag) ,  x2) =>
                          if true then
                            match ( match ( maybe_range) with
                                        Some(el_name,  (start,  len)) =>
                                      (el_name, (start, len)) | None =>
                                      DAEMON end) with
                                (el_name,  (start,  len)) =>
                              match ( tag) with SymbolDef(d) =>
                                (* CHECK: can we expect these to be these usable, the way we generated them?  *)
                              {|elf64_st_name := match ( string_table.find_string
                                                           (def_symname d)
                                                           strtab) with
                                                     Some idx1 =>
                                                   let v := elf64_word_of_nat
                                                              idx1 in
                                                 (* let _ = errln ("strtab: found `" ^ d.def_symname ^ "' at index " ^ (show v))
                                        in *)
                                                 v | None => DAEMON end
                              ;elf64_st_info :=(elf64_st_info(def_syment d)) (* type, binding, visibility *)
                              ;elf64_st_other :=(elf64_st_other(def_syment d))
                              ;elf64_st_shndx := (elf64_half_of_nat
                                                    ( (* what's the section index of this element? *)
                                                    let maybe_found := 
                                                    mapMaybei
                                                      (fun (i : nat ) =>
                                                         fun (isec1 : elf64_interpreted_section ) =>
                                                           if (string_equal
                                                                 (elf64_section_name_as_string isec1)
                                                                 el_name) then
                                                             Some i else 
                                                           None)
                                                      sorted_sections in
                                                    match ( maybe_found) with
                                                        [i] =>
                                                      Coq.Init.Peano.plus
                                                        ( 1) i | [] =>
                                                      
                                                        (* HMM *) (*let _ = errln ("Couldn't compute section index of symbol " ^ d.def_symname)
                                        in*) 0
                                                      | _ => DAEMON end ))
                              ;elf64_st_value := (elf64_addr_of_nat
                                                    ( Coq.Init.Peano.plus
                                                        start
                                                        match ( (fmap_lookup_by
                                                                   (fun (x : string ) (y : string )=>
                                                                    EQ)
                                                                   el_name
                                                                   (elements img3))) with
                                                            Some x =>
                                                          match ((startpos x)) with
                                                              Some addr =>
                                                            addr | None =>
                                                            DAEMON end
                                                          | None => DAEMON
                                                        end))
                              ;elf64_st_size := (elf64_xword_of_nat len) |}
                              (* FIXME: do we ever get symbolrefs? *) | _ =>
                                DAEMON end end :: x2 else x2 end) x2
                     (zip symbol_ranges symbol_tags)) in
  (*let _ = errln ("Building an ELF file from" ^ (show (length element_section_tag_pairs_sorted_by_address)) ^ " sections")
    in*)
  (* PROBLEM: 
     * sections' offset assignments depend on phnum.
     * BUT
     * phnum depends on sections' offset assignments!
     * How do we break this cycle?
     * We can get an upper bound on the number of phdrs, then 
     * fill them in later.
     *)
  (* How does the GNU BFD output a statically linked executable? 
     * First the ELF header,
     * then program headers,
     * then sections in order of address:
     *      .interp,                 these are all allocatable sections! with addresses!
     * then .note.ABI-tag, 
     * then .note.gnu.build-id,
     * then .gnu.hash,
     * then .dynsym,
     * then .dynstr,
     * then .gnu.version,
     * then .gnu.version_r,
     * then ...
     * 
     * ... and so on ...
     * 
     * then .gnu.debuglink (the only non-allocatable section)
     * then .shstrtab, then SHT. 
     * 
     * So how can we calculate the offset of the SHT?  We have to place
     * all the other sections first. 
     *)
  let shstrndx := Coq.Init.Peano.plus ( 1) (length section_tags) in
  let shstroff := last_off in let shstrsz := string_table.size0 shstrtab in
  let symoff := align_up_to ( 8) ( Coq.Init.Peano.plus shstroff shstrsz) in
  let symsz := Coq.Init.Peano.mult ( 24) (length symtab) in
  let stroff := Coq.Init.Peano.plus symoff symsz in
  let strsz := string_table.size0 strtab in
  let shoff := align_up_to ( 64) ( Coq.Init.Peano.plus stroff strsz) in
  let shnum := Coq.Init.Peano.plus ( 4) (length sorted_sections) (* null, shstrtab, symtab, strtab *)
  in
  let entry := match ( multimap.lookupBy0 memory_image_orderings.tagEquiv
                         (EntryPoint) (by_tag img3)) with
                   [(_,  maybe_el_range)] =>
                 match ( maybe_el_range) with
                     Some (el_name,  (start,  len)) =>
                   address_of_range (el_name, (start, len)) img3 | None =>
                   DAEMON end | [] => DAEMON | _ => DAEMON end in
  let hdr :=(make_elf_header a) elf_ft_exec entry shoff phoff max_phnum1
              shnum shstrndx in let endian :=
  if (maybeEqualBy unsigned_char_eq (index0 elf_ii_data (elf64_ident hdr))
        (Some (unsigned_char_of_nat elf_data_2lsb))) then Little else 
  Big in
  let all_sections_sorted_with_offsets := (@ List.app _)
                                            user_sections_sorted_with_offsets
                                            [
                                            {|elf64_section_name := match ( 
                                                                    string_table.find_string
                                                                    ".shstrtab"
                                                                    shstrtab) with
                                                                    Some n =>
                                                                    n
                                                                    | None =>
                                                                    DAEMON
                                                                    end
                                            ;elf64_section_type := sht_strtab
                                            ;elf64_section_flags :=( 0)
                                            ;elf64_section_addr :=( 0)
                                            ;elf64_section_offset := shstroff
                                            ;elf64_section_size := shstrsz
                                            ;elf64_section_link :=( 0)
                                            ;elf64_section_info :=( 0)
                                            ;elf64_section_align :=( 0)
                                            ;elf64_section_entsize :=(
                                             0)
                                            ;elf64_section_body := (Sequence
                                                                    (
                                                                    List.map
                                                                    byte_of_char
                                                                    (
                                                                    string_to_char_list
                                                                    (
                                                                    string_table.get_base_string
                                                                    shstrtab))))
                                            ;elf64_section_name_as_string := ".shstrtab"
                                            |};
                                            {|elf64_section_name := match ( 
                                                                    string_table.find_string
                                                                    ".symtab"
                                                                    shstrtab) with
                                                                    Some n =>
                                                                    n
                                                                    | None =>
                                                                    DAEMON
                                                                    end
                                            ;elf64_section_type := sht_symtab
                                            ;elf64_section_flags :=( 0)
                                            ;elf64_section_addr :=( 0)
                                            ;elf64_section_offset := symoff
                                            ;elf64_section_size := symsz
                                            ;elf64_section_link := (Coq.Init.Peano.plus
                                                                    (
                                                                    Coq.Init.Peano.plus
                                                                    ( 1)
                                                                    (
                                                                    length
                                                                    user_sections_sorted_with_offsets))
                                                                    ( 2))
                                            ;elf64_section_info :=( 0)
                                            ;elf64_section_align :=( 8)
                                            ;elf64_section_entsize :=(
                                             24)
                                            ;elf64_section_body := (byte_sequence.concat1
                                                                    (
                                                                    List.map
                                                                    (
                                                                    bytes_of_elf64_symbol_table_entry
                                                                    endian)
                                                                    symtab))
                                            ;elf64_section_name_as_string := ".symtab"
                                            |}; (* strtab *)
                                            {|elf64_section_name := match ( 
                                                                    string_table.find_string
                                                                    ".strtab"
                                                                    shstrtab) with
                                                                    Some n =>
                                                                    n
                                                                    | None =>
                                                                    DAEMON
                                                                    end
                                            ;elf64_section_type := sht_strtab
                                            ;elf64_section_flags :=( 0)
                                            ;elf64_section_addr :=( 0)
                                            ;elf64_section_offset := stroff
                                            ;elf64_section_size := strsz
                                            ;elf64_section_link :=( 0)
                                            ;elf64_section_info :=( 0)
                                            ;elf64_section_align :=( 1)
                                            ;elf64_section_entsize :=(
                                             0)
                                            ;elf64_section_body := (Sequence
                                                                    (
                                                                    List.map
                                                                    byte_of_char
                                                                    (
                                                                    string_to_char_list
                                                                    (
                                                                    string_table.get_base_string
                                                                    strtab))))
                                            ;elf64_section_name_as_string := ".strtab"
                                            |}]  in
  let phdrs :=(make_phdrs a) (maxpagesize a) (commonpagesize a) elf_ft_exec
                img3 all_sections_sorted_with_offsets in
  {|elf64_file_header := {|elf64_ident :=(elf64_ident hdr)
  ;elf64_type :=(elf64_type hdr) ;elf64_machine :=(elf64_machine hdr)
  ;elf64_version :=(elf64_version hdr) ;elf64_entry :=(elf64_entry hdr)
  ;elf64_phoff :=(elf64_phoff hdr) ;elf64_shoff :=(elf64_shoff hdr)
  ;elf64_flags :=(elf64_flags hdr) ;elf64_ehsize :=(elf64_ehsize hdr)
  ;elf64_phentsize :=(elf64_phentsize hdr)
  ;elf64_phnum := (elf64_half_of_nat (length phdrs))
  ;elf64_shentsize :=(elf64_shentsize hdr) ;elf64_shnum :=(elf64_shnum hdr)
  ;elf64_shstrndx :=(elf64_shstrndx hdr) |}
  ;elf64_file_program_header_table := phdrs
  ;elf64_file_section_header_table := (elf64_null_section_header ::
                                       ((lem_list.mapi
                                           (fun (i : nat ) =>
                                              fun (isec1 : elf64_interpreted_section ) =>
                                                {|elf64_sh_name := (let s :=(elf64_section_name_as_string isec1) in
                                                match ( string_table.find_string
                                                          s shstrtab) with
                                                    Some n =>
                                                  elf64_word_of_nat n
                                                  | None => DAEMON end)
                                                ;elf64_sh_type := (elf64_word_of_nat
                                                                    (elf64_section_type isec1))
                                                ;elf64_sh_flags := (elf64_xword_of_nat
                                                                    (elf64_section_flags isec1))
                                                ;elf64_sh_addr := (elf64_addr_of_nat
                                                                    (elf64_section_addr isec1))
                                                ;elf64_sh_offset := (
                                                elf64_off_of_nat
                                                  (elf64_section_offset isec1))
                                                ;elf64_sh_size := (elf64_xword_of_nat
                                                                    (elf64_section_size isec1))
                                                ;elf64_sh_link := (elf64_word_of_nat
                                                                    (elf64_section_link isec1))
                                                ;elf64_sh_info := (elf64_word_of_nat
                                                                    (elf64_section_info isec1))
                                                ;elf64_sh_addralign := (
                                                elf64_xword_of_nat
                                                  (elf64_section_align isec1))
                                                ;elf64_sh_entsize := (
                                                elf64_xword_of_nat
                                                  (elf64_section_entsize isec1))
                                                |} ))
                                          (* (zip section_tags_bare section_file_offsets) *) all_sections_sorted_with_offsets))
  ;elf64_file_interpreted_segments := []
  (* do we need to build this? I have HACKed elf_file so that we don't; 
               we assume that all the relevant payload is in the section bodies, 
               as it should be. *)
  ;elf64_file_interpreted_sections := (null_elf64_interpreted_section ::
                                       all_sections_sorted_with_offsets)
  ;elf64_file_bits_and_bobs := [] |} end end end.
