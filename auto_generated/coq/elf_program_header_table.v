(* Generated by Lem from elf_program_header_table.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [elf_program_header_table] contains type, functions and other definitions
  * for working with program header tables and their entries and ELF segments.
  * Related files are [elf_interpreted_segments] which extracts information
  * derived from PHTs presented in this file and converts it into a more usable
  * format for processing.
  *
  * FIXME:
  * Bug in Lem as Lem codebase uses [int] type throughout where [BigInt.t]
  * is really needed, hence chokes on huge constants below, which is why they are
  * written in the way that they are.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_function.
Require Export lem_function.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import lem_set.
Require Export lem_set.


Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import endianness.
Require Export endianness.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


(** Segment types *)

(** Unused array element.  All other members of the structure are undefined. *)
Definition elf_pt_null    :  nat :=  0.
(** A loadable segment. *)
Definition elf_pt_load    :  nat :=  1.
(** Dynamic linking information. *)
Definition elf_pt_dynamic    :  nat :=  2.
(** Specifies the location and size of a null-terminated path name to be used to
  * invoke an interpreter.
  *)
Definition elf_pt_interp    :  nat :=  3.
(** Specifies location and size of auxiliary information. *)
Definition elf_pt_note    :  nat :=  4.
(** Reserved but with unspecified semantics.  If the file contains a segment of
  * this type then it is to be regarded as non-conformant with the ABI.
  *)
Definition elf_pt_shlib    :  nat :=  5.
(** Specifies the location and size of the program header table. *)
Definition elf_pt_phdr    :  nat :=  6.
(** Specifies the thread local storage (TLS) template.  Need not be supported. *)
Definition elf_pt_tls    :  nat :=  7.
(** Start of reserved indices for operating system specific semantics. *)
Definition elf_pt_loos    :  nat :=  Coq.Init.Peano.mult (Coq.Init.Peano.mult (Coq.Init.Peano.mult (Coq.Init.Peano.mult( 128)( 128))( 128))( 256))( 3). (* 1610612736 (* 0x60000000 *) *)
(** End of reserved indices for operating system specific semantics. *)
Definition elf_pt_hios    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 469762047)( 4))( 3). (* 1879048191 (* 0x6fffffff *) *)
(** Start of reserved indices for processor specific semantics. *)
Definition elf_pt_loproc    :  nat :=  ( Coq.Init.Peano.mult( 469762048)( 4)). (* 1879048192 (* 0x70000000 *) *)
(** End of reserved indices for processor specific semantics. *)
Definition elf_pt_hiproc    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 536870911)( 4))( 3).
(* [?]: removed value specification. *)

		
(** Segments permission flags *)

(** Execute bit *)
Definition elf_pf_x           :  nat :=  1.
(** Write bit *)
Definition elf_pf_w           :  nat :=  2.
(** Read bit *)
Definition elf_pf_r           :  nat :=  4.
(** The following two bit ranges are reserved for OS- and processor-specific
  * flags respectively.
  *)
Definition elf_pf_maskos      :  nat :=  267386880.      (* 0x0ff00000 *)
Definition elf_pf_maskproc    :  nat :=  Coq.Init.Peano.mult( 4)( 1006632960).
(* [?]: removed value specification. *)

Definition exact_permissions_of_permission  (m : nat )  : error (nat ):= 
  if beq_nat m( 0) then
    return0( 0)
  else if beq_nat m elf_pf_x then
    return0( 1)
  else if beq_nat m elf_pf_w then
    return0( 2)
  else if beq_nat m elf_pf_r then
    return0( 4)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_w) then
    return0( 3)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_r) then
    return0( 5)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_w elf_pf_r) then
    return0( 6)
  else if beq_nat m (Coq.Init.Peano.plus (Coq.Init.Peano.plus elf_pf_x elf_pf_r) elf_pf_w) then
    return0( 7)
  else
    fail0 "exact_permission_of_permission: invalid permission flag".
(* [?]: removed value specification. *)

Definition allowable_permissions_of_permission  (m : nat )  : error (nat ):= 
  if beq_nat m( 0) then
    return0( 0)
  else if beq_nat m elf_pf_x then
    return0( 5)
  else if beq_nat m elf_pf_w then
    return0( 7)
  else if beq_nat m elf_pf_r then
    return0( 5)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_w) then
    return0( 7)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_r) then
    return0( 5)
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_w elf_pf_r) then
    return0( 7)
  else if beq_nat m (Coq.Init.Peano.plus (Coq.Init.Peano.plus elf_pf_x elf_pf_r) elf_pf_w) then
    return0( 7)
  else
    fail0 "exact_permission_of_permission: invalid permission flag".
(* [?]: removed value specification. *)

Definition string_of_elf_segment_permissions  (m : nat )  : string := 
  if beq_nat m( 0) then
    "  "
  else if beq_nat m elf_pf_x then
    "  E"
  else if beq_nat m elf_pf_w then
    " W "
  else if beq_nat m elf_pf_r then
    "R  "
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_w) then
    " WE"
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_x elf_pf_r) then
    "R E"
  else if beq_nat m (Coq.Init.Peano.plus elf_pf_w elf_pf_r) then
    "RW "
  else if beq_nat m (Coq.Init.Peano.plus (Coq.Init.Peano.plus elf_pf_x elf_pf_r) elf_pf_w) then
    "RWE"
  else
    "Invalid permisssion flag".

(** Program header table entry type *)

(** Type [elf32_program_header_table_entry] encodes a program header table entry
  * for 32-bit platforms.  Each entry describes a segment in an executable or
  * shared object file.
  *)
Record elf32_program_header_table_entry : Type :=
  { elf32_p_type   : elf32_word  (** Type of the segment *)
   ; elf32_p_offset : elf32_off   (** Offset from beginning of file for segment *)
   ; elf32_p_vaddr  : elf32_addr  (** Virtual address for segment in memory *)
   ; elf32_p_paddr  : elf32_addr  (** Physical address for segment *)
   ; elf32_p_filesz : elf32_word  (** Size of segment in file, in bytes *)
   ; elf32_p_memsz  : elf32_word  (** Size of segment in memory image, in bytes *)
   ; elf32_p_flags  : elf32_word  (** Segment flags *)
   ; elf32_p_align  : elf32_word  (** Segment alignment memory for memory and file *)
   }.
Notation "{[ r 'with' 'elf32_p_type' := e ]}" := ({| elf32_p_type := e; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_offset' := e ]}" := ({| elf32_p_offset := e; elf32_p_type := elf32_p_type r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_vaddr' := e ]}" := ({| elf32_p_vaddr := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_paddr' := e ]}" := ({| elf32_p_paddr := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_filesz' := e ]}" := ({| elf32_p_filesz := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_memsz' := e ]}" := ({| elf32_p_memsz := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_flags := elf32_p_flags r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_flags' := e ]}" := ({| elf32_p_flags := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_align := elf32_p_align r |}).
Notation "{[ r 'with' 'elf32_p_align' := e ]}" := ({| elf32_p_align := e; elf32_p_type := elf32_p_type r; elf32_p_offset := elf32_p_offset r; elf32_p_vaddr := elf32_p_vaddr r; elf32_p_paddr := elf32_p_paddr r; elf32_p_filesz := elf32_p_filesz r; elf32_p_memsz := elf32_p_memsz r; elf32_p_flags := elf32_p_flags r |}).
Definition elf32_program_header_table_entry_default: elf32_program_header_table_entry  := {| elf32_p_type := elf32_word_default; elf32_p_offset := elf32_off_default; elf32_p_vaddr := elf32_addr_default; elf32_p_paddr := elf32_addr_default; elf32_p_filesz := elf32_word_default; elf32_p_memsz := elf32_word_default; elf32_p_flags := elf32_word_default; elf32_p_align := elf32_word_default |}.
(* [?]: removed value specification. *)

Definition compare_elf32_program_header_table_entry  (h1 : elf32_program_header_table_entry ) (h2 : elf32_program_header_table_entry )  : ordering :=     
 (lexicographicCompareBy (genericCompare nat_ltb beq_nat) [nat_of_elf32_word(elf32_p_type h1);
    nat_of_elf32_off(elf32_p_offset h1);
    nat_of_elf32_addr(elf32_p_vaddr h1);
    nat_of_elf32_addr(elf32_p_paddr h1);
    nat_of_elf32_word(elf32_p_filesz h1);
    nat_of_elf32_word(elf32_p_memsz h1); 
    nat_of_elf32_word(elf32_p_flags h1);
    nat_of_elf32_word(elf32_p_align h1)]
    [nat_of_elf32_word(elf32_p_type h2);
    nat_of_elf32_off(elf32_p_offset h2);
    nat_of_elf32_addr(elf32_p_vaddr h2);
    nat_of_elf32_addr(elf32_p_paddr h2);
    nat_of_elf32_word(elf32_p_filesz h2);
    nat_of_elf32_word(elf32_p_memsz h2); 
    nat_of_elf32_word(elf32_p_flags h2);
    nat_of_elf32_word(elf32_p_align h2)]).

Instance x61_Ord : Ord elf32_program_header_table_entry := {
     compare  :=  compare_elf32_program_header_table_entry;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf32_program_header_table_entry f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf32_program_header_table_entry f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf32_program_header_table_entry f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf32_program_header_table_entry f1 f2) [GT;  EQ]))
}.


(** Type [elf64_program_header_table_entry] encodes a program header table entry
  * for 64-bit platforms.  Each entry describes a segment in an executable or
  * shared object file.
  *)
Record elf64_program_header_table_entry : Type :=
  { elf64_p_type   : elf64_word   (** Type of the segment *)
   ; elf64_p_flags  : elf64_word   (** Segment flags *)
   ; elf64_p_offset : elf64_off    (** Offset from beginning of file for segment *)
   ; elf64_p_vaddr  : elf64_addr   (** Virtual address for segment in memory *)
   ; elf64_p_paddr  : elf64_addr   (** Physical address for segment *)
   ; elf64_p_filesz : elf64_xword  (** Size of segment in file, in bytes *)
   ; elf64_p_memsz  : elf64_xword  (** Size of segment in memory image, in bytes *)
   ; elf64_p_align  : elf64_xword  (** Segment alignment memory for memory and file *)
   }.
Notation "{[ r 'with' 'elf64_p_type' := e ]}" := ({| elf64_p_type := e; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_flags' := e ]}" := ({| elf64_p_flags := e; elf64_p_type := elf64_p_type r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_offset' := e ]}" := ({| elf64_p_offset := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_vaddr' := e ]}" := ({| elf64_p_vaddr := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_paddr' := e ]}" := ({| elf64_p_paddr := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_filesz' := e ]}" := ({| elf64_p_filesz := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_memsz := elf64_p_memsz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_memsz' := e ]}" := ({| elf64_p_memsz := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_align := elf64_p_align r |}).
Notation "{[ r 'with' 'elf64_p_align' := e ]}" := ({| elf64_p_align := e; elf64_p_type := elf64_p_type r; elf64_p_flags := elf64_p_flags r; elf64_p_offset := elf64_p_offset r; elf64_p_vaddr := elf64_p_vaddr r; elf64_p_paddr := elf64_p_paddr r; elf64_p_filesz := elf64_p_filesz r; elf64_p_memsz := elf64_p_memsz r |}).
Definition elf64_program_header_table_entry_default: elf64_program_header_table_entry  := {| elf64_p_type := elf64_word_default; elf64_p_flags := elf64_word_default; elf64_p_offset := elf64_off_default; elf64_p_vaddr := elf64_addr_default; elf64_p_paddr := elf64_addr_default; elf64_p_filesz := elf64_xword_default; elf64_p_memsz := elf64_xword_default; elf64_p_align := elf64_xword_default |}.
(* [?]: removed value specification. *)

Definition compare_elf64_program_header_table_entry  (h1 : elf64_program_header_table_entry ) (h2 : elf64_program_header_table_entry )  : ordering :=     
 (lexicographicCompareBy (genericCompare nat_ltb beq_nat) [nat_of_elf64_word(elf64_p_type h1);
    nat_of_elf64_off(elf64_p_offset h1);
    nat_of_elf64_addr(elf64_p_vaddr h1);
    nat_of_elf64_addr(elf64_p_paddr h1);
    nat_of_elf64_xword(elf64_p_filesz h1);
    nat_of_elf64_xword(elf64_p_memsz h1); 
    nat_of_elf64_word(elf64_p_flags h1);
    nat_of_elf64_xword(elf64_p_align h1)]
    [nat_of_elf64_word(elf64_p_type h2);
    nat_of_elf64_off(elf64_p_offset h2);
    nat_of_elf64_addr(elf64_p_vaddr h2);
    nat_of_elf64_addr(elf64_p_paddr h2);
    nat_of_elf64_xword(elf64_p_filesz h2);
    nat_of_elf64_xword(elf64_p_memsz h2); 
    nat_of_elf64_word(elf64_p_flags h2);
    nat_of_elf64_xword(elf64_p_align h2)]).

Instance x60_Ord : Ord elf64_program_header_table_entry := {
     compare  :=  compare_elf64_program_header_table_entry;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf64_program_header_table_entry f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf64_program_header_table_entry f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_elf64_program_header_table_entry f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (compare_elf64_program_header_table_entry f1 f2) [GT;  EQ]))
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 
	
Instance x59_Show : Show elf32_program_header_table_entry := {
	 show  :=  string_of_elf32_program_header_table_entry_default
}.
 *)
(* 

Instance x58_Show : Show elf64_program_header_table_entry := {
   show  :=  string_of_elf64_program_header_table_entry_default
}.
 *)
(* [?]: removed value specification. *)

Definition bytes_of_elf32_program_header_table_entry  (endian : endianness ) (entry : elf32_program_header_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf32_word endian(elf32_p_type entry)
  ; bytes_of_elf32_off  endian(elf32_p_offset entry)
  ; bytes_of_elf32_addr endian(elf32_p_vaddr entry)
  ; bytes_of_elf32_addr endian(elf32_p_paddr entry)
  ; bytes_of_elf32_word endian(elf32_p_filesz entry)
  ; bytes_of_elf32_word endian(elf32_p_memsz entry)
  ; bytes_of_elf32_word endian(elf32_p_flags entry)
  ; bytes_of_elf32_word endian(elf32_p_align entry)]
  .
(* [?]: removed value specification. *)

Definition bytes_of_elf64_program_header_table_entry  (endian : endianness ) (entry : elf64_program_header_table_entry )  : byte_sequence := 
  byte_sequence.from_byte_lists [
    bytes_of_elf64_word  endian(elf64_p_type entry)
  ; bytes_of_elf64_word  endian(elf64_p_flags entry)
  ; bytes_of_elf64_off   endian(elf64_p_offset entry)
  ; bytes_of_elf64_addr  endian(elf64_p_vaddr entry)
  ; bytes_of_elf64_addr  endian(elf64_p_paddr entry)
  ; bytes_of_elf64_xword endian(elf64_p_filesz entry)
  ; bytes_of_elf64_xword endian(elf64_p_memsz entry)
  ; bytes_of_elf64_xword endian(elf64_p_align entry)]
  .
(* [?]: removed value specification. *)

Definition read_elf32_program_header_table_entry  (endian : endianness ) (bs : byte_sequence )  : error ((elf32_program_header_table_entry *byte_sequence ) % type):= 
	read_elf32_word endian bs >>= 
  (fun (p : (elf32_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (typ,  bs)) =>
       read_elf32_off endian bs >>=
       (fun (p : (elf32_off *byte_sequence ) % type) =>
          match ( (p) ) with ( (offset,  bs)) =>
            read_elf32_addr endian bs >>=
            (fun (p : (elf32_addr *byte_sequence ) % type) =>
               match ( (p) ) with ( (vaddr,  bs)) =>
                 read_elf32_addr endian bs >>=
                 (fun (p : (elf32_addr *byte_sequence ) % type) =>
                    match ( (p) ) with ( (paddr,  bs)) =>
                      read_elf32_word endian bs >>=
                      (fun (p : (elf32_word *byte_sequence ) % type) =>
                         match ( (p) ) with ( (filesz,  bs)) =>
                           read_elf32_word endian bs >>=
                           (fun (p : (elf32_word *byte_sequence ) % type) =>
                              match ( (p) ) with ( (memsz,  bs)) =>
                                read_elf32_word endian bs >>=
                                (fun (p : (elf32_word *byte_sequence ) % type) =>
                                   match ( (p) ) with ( (flags,  bs)) =>
                                     read_elf32_word endian bs >>=
                                     (fun (p : (elf32_word *byte_sequence ) % type) =>
                                        match ( (p) ) with ( (align,  bs)) =>
                                          return0
                                            ({|elf32_p_type := typ;elf32_p_offset := offset;elf32_p_vaddr := vaddr;elf32_p_paddr := paddr;elf32_p_filesz := filesz;elf32_p_memsz := memsz;elf32_p_flags := flags;elf32_p_align := align |}, bs)
                                        end) end) end) end) end) end) end)
     end).
(* [?]: removed value specification. *)

Definition read_elf64_program_header_table_entry  (endian : endianness ) (bs : byte_sequence )  : error ((elf64_program_header_table_entry *byte_sequence ) % type):= 
  read_elf64_word endian bs >>= 
  (fun (p : (elf64_word *byte_sequence ) % type) =>
     match ( (p) ) with ( (typ,  bs)) =>
       read_elf64_word endian bs >>=
       (fun (p : (elf64_word *byte_sequence ) % type) =>
          match ( (p) ) with ( (flags,  bs)) =>
            read_elf64_off endian bs >>=
            (fun (p : (elf64_off *byte_sequence ) % type) =>
               match ( (p) ) with ( (offset,  bs)) =>
                 read_elf64_addr endian bs >>=
                 (fun (p : (elf64_addr *byte_sequence ) % type) =>
                    match ( (p) ) with ( (vaddr,  bs)) =>
                      read_elf64_addr endian bs >>=
                      (fun (p : (elf64_addr *byte_sequence ) % type) =>
                         match ( (p) ) with ( (paddr,  bs)) =>
                           read_elf64_xword endian bs >>=
                           (fun (p : (elf64_xword *byte_sequence ) % type) =>
                              match ( (p) ) with ( (filesz,  bs)) =>
                                read_elf64_xword endian bs >>=
                                (fun (p : (elf64_xword *byte_sequence ) % type) =>
                                   match ( (p) ) with ( (memsz,  bs)) =>
                                     read_elf64_xword endian bs >>=
                                     (fun (p : (elf64_xword *byte_sequence ) % type) =>
                                        match ( (p) ) with ( (align,  bs)) =>
                                          return0
                                            ({|elf64_p_type := typ;elf64_p_offset := offset;elf64_p_vaddr := vaddr;elf64_p_paddr := paddr;elf64_p_filesz := filesz;elf64_p_memsz := memsz;elf64_p_flags := flags;elf64_p_align := align |}, bs)
                                        end) end) end) end) end) end) end)
     end).

(** Program header table type *)

(** Type [elf32_program_header_table] represents a program header table for 32-bit
  * ELF files.  A program header table is an array (implemented as a list, here)
  * of program header table entries.
  *)
Definition elf32_program_header_table : Type := 
  list  elf32_program_header_table_entry .
Definition elf32_program_header_table_default: elf32_program_header_table  := DAEMON.

(** Type [elf64_program_header_table] represents a program header table for 64-bit
  * ELF files.  A program header table is an array (implemented as a list, here)
  * of program header table entries.
  *)
Definition elf64_program_header_table : Type := 
  list  elf64_program_header_table_entry .
Definition elf64_program_header_table_default: elf64_program_header_table  := DAEMON.

(** [bytes_of_elf32_program_header_table ed tbl] blits an ELF32 program header
  * table into a byte sequence assuming endianness [ed].
  *)
Definition bytes_of_elf32_program_header_table  (endian : endianness ) (tbl : list (elf32_program_header_table_entry ))  : byte_sequence := 
  byte_sequence.concat1 (List.map (bytes_of_elf32_program_header_table_entry endian) tbl).

(** [bytes_of_elf64_program_header_table ed tbl] blits an ELF64 program header
  * table into a byte sequence assuming endianness [ed].
  *)  
Definition bytes_of_elf64_program_header_table  (endian : endianness ) (tbl : list (elf64_program_header_table_entry ))  : byte_sequence := 
  byte_sequence.concat1 (List.map (bytes_of_elf64_program_header_table_entry endian) tbl).

(** [read_elf32_program_header_table' endian bs0] reads an ELF32 program header table from
  * byte_sequence [bs0] assuming endianness [endian].  The byte_sequence [bs0] is assumed
  * to have exactly the correct size for the table.  For internal use, only.  Use
  * [read_elf32_program_header_table] below instead.
  *)
Program Fixpoint read_elf32_program_header_table'  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf32_program_header_table_entry )):= 
	if beq_nat (byte_sequence.length0 bs0)( 0) then
  	return0 []
  else
  	read_elf32_program_header_table_entry endian bs0 >>= 
  (fun (p : (elf32_program_header_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (entry,  bs1)) =>
       read_elf32_program_header_table' endian bs1 >>=
       (fun (tail1 : list (elf32_program_header_table_entry )) =>
          return0 (entry :: tail1)) end).

(** [read_elf64_program_header_table' endian bs0] reads an ELF64 program header table from
  * byte_sequence [bs0] assuming endianness [endian].  The byte_sequence [bs0] is assumed
  * to have exactly the correct size for the table.  For internal use, only.  Use
  * [read_elf32_program_header_table] below instead.
  *)
Program Fixpoint read_elf64_program_header_table'  (endian : endianness ) (bs0 : byte_sequence )  : error (list (elf64_program_header_table_entry )):= 
  if beq_nat (byte_sequence.length0 bs0)( 0) then
    return0 []
  else
    read_elf64_program_header_table_entry endian bs0 >>= 
  (fun (p : (elf64_program_header_table_entry *byte_sequence ) % type) =>
     match ( (p) ) with ( (entry,  bs1)) =>
       read_elf64_program_header_table' endian bs1 >>=
       (fun (tail1 : list (elf64_program_header_table_entry )) =>
          return0 (entry :: tail1)) end).
(* [?]: removed value specification. *)

Definition read_elf32_program_header_table  (table_size : nat ) (endian : endianness ) (bs0 : byte_sequence )  : error ((list (elf32_program_header_table_entry )*byte_sequence ) % type):= 
	partition1 table_size bs0 >>= 
  (fun (p : (byte_sequence *byte_sequence ) % type) =>
     match ( (p) ) with ( (eat,  rest)) =>
       read_elf32_program_header_table' endian eat >>=
       (fun (table : list (elf32_program_header_table_entry )) =>
          return0 (table, rest)) end).
(* [?]: removed value specification. *)

Definition read_elf64_program_header_table  (table_size : nat ) (endian : endianness ) (bs0 : byte_sequence )  : error ((list (elf64_program_header_table_entry )*byte_sequence ) % type):= 
  partition1 table_size bs0 >>= 
  (fun (p : (byte_sequence *byte_sequence ) % type) =>
     match ( (p) ) with ( (eat,  rest)) =>
       read_elf64_program_header_table' endian eat >>=
       (fun (table : list (elf64_program_header_table_entry )) =>
          return0 (table, rest)) end).

(** The [pht_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
Definition pht_print_bundle : Type := ( (nat  ->  string ) * (nat  ->  string )) % type.
Definition pht_print_bundle_default: pht_print_bundle  := ((fun (x56 : nat ) => string_default), (fun (x57 : nat ) => string_default)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition get_elf32_dynamic_linked  (pht : list (elf32_program_header_table_entry ))  : bool := 
  List.existsb (fun (p : elf32_program_header_table_entry ) => beq_nat (nat_of_elf32_word(elf32_p_type p)) elf_pt_interp) pht.
(* [?]: removed value specification. *)

Definition get_elf64_dynamic_linked  (pht : list (elf64_program_header_table_entry ))  : bool := 
  List.existsb (fun (p : elf64_program_header_table_entry ) => beq_nat (nat_of_elf64_word(elf64_p_type p)) elf_pt_interp) pht.
(* [?]: removed value specification. *)

Definition get_elf32_static_linked  (pht : list (elf32_program_header_table_entry ))  : bool := 
  negb (get_elf32_dynamic_linked pht).
(* [?]: removed value specification. *)

Definition get_elf64_static_linked  (pht : list (elf64_program_header_table_entry ))  : bool := 
  negb (get_elf64_dynamic_linked pht).
(* [?]: removed value specification. *)

Definition get_elf32_requested_interpreter  (pent : elf32_program_header_table_entry ) (bs0 : byte_sequence )  : error (string ):= 
  if beq_nat (nat_of_elf32_word(elf32_p_type pent)) elf_pt_interp then
    let off := nat_of_elf32_off(elf32_p_offset  pent) in
    let siz := nat_of_elf32_word(elf32_p_filesz pent) in
      byte_sequence.offset_and_cut off ( Coq.Init.Peano.minus siz( 1)) bs0 >>= (fun (cut : byte_sequence ) =>
      return0 (byte_sequence.string_of_byte_sequence cut))
  else
    fail0 "get_elf32_requested_interpreter: not an INTERP segment header".
(* [?]: removed value specification. *)

Definition get_elf64_requested_interpreter  (pent : elf64_program_header_table_entry ) (bs0 : byte_sequence )  : error (string ):= 
  if beq_nat (nat_of_elf64_word(elf64_p_type pent)) elf_pt_interp then
    let off := nat_of_elf64_off(elf64_p_offset   pent) in
    let siz := nat_of_elf64_xword(elf64_p_filesz pent) in
      byte_sequence.offset_and_cut off ( Coq.Init.Peano.minus siz( 1)) bs0 >>= (fun (cut : byte_sequence ) =>
      return0 (byte_sequence.string_of_byte_sequence cut))
  else
    fail0 "get_elf64_requested_interpreter: not an INTERP segment header".
