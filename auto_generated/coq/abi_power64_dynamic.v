(* Generated by Lem from abis/power64/abi_power64_dynamic.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.


Require Import error.
Require Export error.

Require Import show.
Require Export show.

Require Import string_table.
Require Export string_table.


Require Import elf_dynamic.
Require Export elf_dynamic.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.


Definition abi_power64_dt_ppcgot    :  nat :=  ( Coq.Init.Peano.mult( 939524096)( 2)).
(* [?]: removed value specification. *)

Definition string_of_abi_power64_dynamic_tag  (m : nat )  : string := 
  if beq_nat m abi_power64_dt_ppcgot then
    "PPC64_GLINK"
  else
    "Invalid Power64 dynamic tag".
(* [?]: removed value specification. *)

Definition abi_power64_tag_correspondence_of_tag  (m : nat )  : error (tag_correspondence ):= 
  if beq_nat m abi_power64_dt_ppcgot then
    return0 C_Ptr
  else
    fail0 ("abi_power64_tag_correspondence_of_tag: invalid Power64 dynamic tag").
(* [?]: removed value specification. *)

Definition abi_power64_elf64_value_of_elf64_dyn  (dyn : elf64_dyn ) (stbl : string_table )  : error (dyn_value (elf64_addr ) (elf64_xword )):= 
  let tag := Zabs_nat (int_of_elf64_sxword(elf64_dyn_tag dyn)) in
    if beq_nat tag abi_power64_dt_ppcgot then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "abi_power64_elf64_value_of_elf64_dyn: PPC_GOT must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "abi_power64_elf64_value_of_elf64_dyn: PPC_GOT must be a PTR"
      end >>= (fun (addr : elf64_addr ) =>
      return0 (Address addr))
    else
      fail0 ("abi_power64_elf64_value_of_elf64_dyn: invalid Power64 dynamic tag").
