(* Generated by Lem from missing_pervasives.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import show.
Require Export show.

Require Import lem_sorting.
Require Export lem_sorting.




Require Import elf_types_local.
Require Export elf_types_local.

(* [?]: removed value specification. *)

Definition naturalZero   : nat :=  0.
(* [?]: removed value specification. *)

Definition id {a : Type}  (x : a)  : a:=  x.
(* 

Inductive byte : Type := .
Definition byte_default: byte  := DAEMON. *)
(* [?]: removed value specification. *)


Definition compare_byte  (b1 : elf_types_local.byte ) (b2 : elf_types_local.byte )  : ordering :=  (genericCompare nat_ltb beq_nat (nat_of_byte b1) (nat_of_byte b2)).

Instance x12_Ord : Ord elf_types_local.byte := {
     compare  :=  compare_byte;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_byte f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => let result := compare_byte f1 f2 in (ordering_equal result LT) || (ordering_equal result EQ));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_byte f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => let result := compare_byte f1 f2 in (ordering_equal result GT) || (ordering_equal result EQ))
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Local Open Scope char_scope.

Definition hex_char_of_nibble  (n : nat )  : ascii := 
  if beq_nat n( 0) then
    "0"
  else if beq_nat n( 1) then
    "1"
  else if beq_nat n( 2) then
    "2"
  else if beq_nat n( 3) then
    "3"
  else if beq_nat n( 4) then
    "4"
  else if beq_nat n( 5) then
    "5"
  else if beq_nat n( 6) then
    "6"
  else if beq_nat n( 7) then
    "7"
  else if beq_nat n( 8) then
    "8"
  else if beq_nat n( 9) then
    "9"
  else if beq_nat n( 10) then
    "a"
  else if beq_nat n( 11) then
    "b"
  else if beq_nat n( 12) then
    "c"
  else if beq_nat n( 13) then
    "d"
  else if beq_nat n( 14) then
    "e"
  else if beq_nat n( 15) then
    "f"
   else
     fail.

Definition hex_string_of_byte  (b : elf_types_local.byte )  : string :=  
    string_from_char_list [ hex_char_of_nibble ( Coq.Numbers.Natural.Peano.NPeano.div(nat_of_byte b)( 16))
             ; hex_char_of_nibble ( Coq.Numbers.Natural.Peano.NPeano.modulo(nat_of_byte b)( 16))].
(* 

Instance x11_Show : Show elf_types_local.byte := {
     show  :=  hex_string_of_byte
}.
 *)
(* [?]: removed value specification. *)

Definition natural_of_decimal_digit  (c : ascii )  : option (nat ) := 
  if (char_equal c "0") then
    Some( 0)
  else if (char_equal c "1") then
    Some( 1)
  else if (char_equal c "2") then
    Some( 2)
  else if (char_equal c "3") then
    Some( 3)
  else if (char_equal c "4") then
    Some( 4)
  else if (char_equal c "5") then
    Some( 5)
  else if (char_equal c "6") then
    Some( 6)
  else if (char_equal c "7") then
    Some( 7)
  else if (char_equal c "8") then
    Some( 8)
  else if (char_equal c "9") then
    Some( 9)
  else
    None.
(* [?]: removed value specification. *)

Program Fixpoint natural_of_decimal_string_helper  (acc : nat ) (chars : list (ascii ))  : nat := 
    match ( chars) with  
        [] => acc
        | c :: cs => match ( natural_of_decimal_digit c) with 
            Some dig => natural_of_decimal_string_helper ( Coq.Init.Peano.plus( Coq.Init.Peano.mult( 10) acc) dig) cs
            | None => acc
        end
    end.
(* [?]: removed value specification. *)

Definition natural_of_decimal_string  (s : string )  : nat :=  
    natural_of_decimal_string_helper( 0) (string_to_char_list s).
(* [?]: removed value specification. *)

Lemma lt_mult_plus:
  forall m n o,
    0 < n ->
    0 <= o ->
    m < (n * m) + o.
Admitted (* XXX: come back and address this. *).

Program Fixpoint hex_string_of_natural (n : nat) {measure n} : string :=  
    if nat_ltb n 16 then
      string_from_char_list [hex_char_of_nibble n]
    else
      String.append (hex_string_of_natural (Coq.Numbers.Natural.Peano.NPeano.div n 16)) (string_from_char_list [hex_char_of_nibble (Coq.Numbers.Natural.Peano.NPeano.modulo n 16)]).
Next Obligation.
  generalize (divmod_spec n 15 0 15).
  case (divmod n 15 0 15).
  cut (15 <= 15).
  intro trivial.
  intro n0. intro n1.
  intro H. generalize (H trivial).
  rewrite (mult_0_r 16).
  rewrite <- (plus_n_O n).
  rewrite (minus_diag 15).
  rewrite <- (plus_n_O n).
  clear H. intro H. destruct H.
  rewrite H.
  change (n0 < 16 * n0 + (15 - n1)).
  apply lt_mult_plus.
  auto with arith. auto with arith. auto with arith.
Qed.
(* [?]: removed value specification. *)

Definition natural_of_bool  (b : bool )  : nat := 
  match ( b) with 
    | true  => 1
    | false => 0
  end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition natural_ordering  (left : nat ) (right : nat )  : ordering := 
  if beq_nat left right then
    EQ
  else if nat_ltb left right then
    LT
  else
    GT.
(* [?]: removed value specification. *)

Program Fixpoint merge_by {a : Type}  (comp : a -> a -> ordering ) (xs : list a) (ys : list a) {measure (List.length xs + List.length ys)} : list a:= 
  match ( (xs, ys)) with 
    | ([],  ys)      => ys
    | (xs,  [])     => xs
    | (x::xs,  y::ys) =>
      if (ordering_equal (comp x y) LT) then
        x::(merge_by comp xs (y::ys))
      else
        y::(merge_by comp (x::xs) ys)
  end.
Next Obligation.
  change (S (List.length xs0 + List.length ys0) < S (List.length xs0) + S (List.length ys0)).
  rewrite <- plus_n_Sm.
  auto with arith.
Qed.
(* [?]: removed value specification. *)

Lemma splitAt_length:
  forall {A : Type},
  forall (m : nat),
  forall (xs : list A),
    List.length (fst (splitAt m xs)) = m /\
    List.length (snd (splitAt m xs)) = List.length xs - m.
Admitted.

Lemma take_length:
  forall {A : Type},
  forall (m : nat),
  forall (xs : list A),
    List.length (take m xs) = m.
Proof.
  intros.
  apply (splitAt_length m xs).
Qed.

Lemma drop_length:
  forall {A : Type},
  forall (m : nat),
  forall (xs : list A),
    List.length (drop m xs) = List.length xs - m.
Proof.
  intros.
  apply (splitAt_length m xs).
Qed.

Lemma lt_minus:
  forall m o,
    0 < o ->
    0 < m ->
    m - o < m.
Admitted (* XXX: come back and address this.*).

Lemma lt_S:
  forall m n,
    S m = 2 * n ->
    n <> 0.
Admitted (* XXX: come back and address this. *).

Lemma lt_1_split:
  forall m,
    m <= 1 ->
    m = 0 \/ m = 1.
Admitted (* XXX: come back and address this. *).

Program Fixpoint sort_by {a : Type}  (comp : a -> a -> ordering ) (xs : list a) {measure (List.length xs)} : list a:= 
  match ( xs) with 
    | [] => []
    | [x] => [x]
    | xs =>
      let ls  := lem_list.take ( Coq.Numbers.Natural.Peano.NPeano.div(List.length xs)( 2)) xs in
      let rs  := lem_list.drop ( Coq.Numbers.Natural.Peano.NPeano.div(List.length xs)( 2)) xs in
        merge_by comp (sort_by comp ls) (sort_by comp rs)
  end.
Next Obligation.
  rewrite take_length.
  generalize (divmod_spec (List.length xs) 1 0 1).
  case (divmod (List.length xs) 1 0 1).
  cut (1 <= 1).
  intro trivial.
  intro n0. intro n1.
  intro G. generalize (G trivial).
  rewrite (mult_0_r 2).
  rewrite <- (plus_n_O (List.length xs)).
  rewrite (minus_diag 1).
  rewrite <- (plus_n_O (List.length xs)).
  clear G. intro G. destruct G.
  rewrite H1.
  change (n0 < 2 * n0 + (1 - n1)).
  apply lt_mult_plus.
  auto with arith. auto with arith. auto with arith.
Qed.
Next Obligation.
Admitted.
Next Obligation.
  split. intro x. discriminate. discriminate.
Qed.
(* [?]: removed value specification. *)

Program Fixpoint mapMaybei' {a b : Type}  (f : nat  -> a -> option b ) (idx1 : nat ) (xs : list a)  : list b:= 
  match ( xs) with 
  | []    => []
  | x::xs =>
      match ( f idx1 x) with 
      | None => mapMaybei' f ( Coq.Init.Peano.plus( 1) idx1) xs
      | Some e  => e :: mapMaybei' f ( Coq.Init.Peano.plus( 1) idx1) xs
      end
  end.
(* [?]: removed value specification. *)

    
Definition mapMaybei {a b : Type}  (f : nat  -> a -> option b ) (xs : list a)  : list b:= 
  mapMaybei' f( 0) xs.
(* [?]: removed value specification. *)

Program Fixpoint partitionii' {a : Type}   (offset : nat ) (sorted_is : list (nat )) (xs : list a) (reverse_accum : list ((nat *a) % type)) (reverse_accum_compl : list ((nat *a) % type))  : (list ((nat *a) % type)*list ((nat *a) % type)) % type:=  
    (* offset o means "xs begins at index o, as reckoned by the indices in sorted_is" *)
    match ( sorted_is) with 
      | [] => (List.rev reverse_accum, List.rev reverse_accum_compl)
      | i::more_is => 
        let length_to_split_off := i - offset in
        match (lem_list.splitAt length_to_split_off xs) with
          | (lft, rgt) =>
          let left_indices      := lem_list.genlist (fun (j : nat ) => Coq.Init.Peano.plus j offset) (List.length lft) in
          let left_with_indices := zip left_indices lft in
            match rgt with
              | [] => (* We got to the end of the list before the target index. *)
                  (List.rev reverse_accum, lem_list.reverseAppend reverse_accum_compl left_with_indices)
              | x::more_xs =>
                 (* x is at index i by definition, so more_xs starts with index i + 1 *)
                 partitionii' (Coq.Init.Peano.plus i ( 1)) more_is more_xs
                   ((i, x) :: reverse_accum)
                   (lem_list.reverseAppend left_with_indices reverse_accum_compl)
            end
        end
    end.
(* [?]: removed value specification. *)

Definition filteri {a : Type}  (is : list (nat )) (xs : list a)  : list a:=  
    let sorted_is := (insertSortBy nat_lteb is) in 
  match ( partitionii' ( 0) sorted_is xs [] []) with (accum,  accum_compl) =>
    match ( unzip accum) with (just_indices,  just_items) => just_items end
  end.
(* [?]: removed value specification. *)

Definition filterii {a : Type}  (is : list (nat )) (xs : list a)  : list ((nat *a) % type):=  
    let sorted_is := (insertSortBy nat_lteb is) in 
  match ( partitionii' ( 0) sorted_is xs [] []) with (accum,  accum_compl) =>
    accum end.
(* [?]: removed value specification. *)

Definition partitioni {a : Type}  (is : list (nat )) (xs : list a)  : (list a*list a) % type:=  
    let sorted_is := (insertSortBy nat_lteb is) in 
  match ( partitionii' ( 0) sorted_is xs [] []) with (accum,  accum_compl) =>
    match ( unzip accum) with (just_indices,  just_items) =>
      match ( unzip accum_compl) with
          (just_indices_compl,  just_items_compl) =>
        (just_items, just_items_compl) end end end.
(* [?]: removed value specification. *)

Definition partitionii {a : Type}  (is : list (nat )) (xs : list a)  : (list ((nat *a) % type)*list ((nat *a) % type)) % type:=  
    let sorted_is := (insertSortBy nat_lteb is) in
    partitionii'( 0) sorted_is xs [] [].
(* [?]: removed value specification. *)

Program Fixpoint unzip3 {a b c : Type}  (l : list ((a*b*c) % type))  : (list a*list b*list c) % type:=  match ( l) with 
  | [] => ([], [], [])
  | (x,  y,  z) :: xyzs => 
  match ( unzip3 xyzs) with (xs,  ys,  zs) =>
    ((x :: xs), (y :: ys), (z :: zs)) end
end.
(* [?]: removed value specification. *)

Program Fixpoint zip3 {a b c : Type} (alist : list a) (blist : list b) (clist : list c)
    (prf1: List.length alist = List.length blist) (prf2: List.length blist = List.length clist) : list ((a*b*c) % type):=  
  match ( (alist, blist, clist)) with | ([],  [],  []) => []
    | (x :: morex,  y :: morey,  z :: morez) => let more_xyz := zip3 morex morey morez _ _ in (x, y, z) :: more_xyz
    | ([], [],  _:: _)     => _
    | ([],  _:: _,  _)     => _
    | ( _:: _, [],  _)     => _
    | ( _:: _,  _:: _, []) => _
  end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Program Fixpoint intercalate' {a : Type}  (sep : a) (xs : list a) (accum : list a) {measure (List.length xs)} : list a:= 
	match ( xs) with 
		| []       => List.rev accum
		| [x]      =>  (@ List.app _)(List.rev accum) [x]
		| [x;  y]   =>  (@ List.app _)(List.rev accum) [x; sep; y]
		| x::y::xs => intercalate' sep xs (sep::(y::(sep::(x::accum))))
	end.
Next Obligation.
  case xs0. auto. auto with arith.
  intros. auto with arith.
Qed.
(* [?]: removed value specification. *)

Definition intercalate {a : Type}  (sep : a) (xs : list a)  : list a:=  intercalate' sep xs [].
(* [?]: removed value specification. *)

Definition unlines  (xs : list (string)) : string := 
  List.fold_left String.append (intercalate (String """" EmptyString) xs) (String """" EmptyString).
(* [?]: removed value specification. *)

Definition bracket  (xs : list (string ))  : string := 
   String.append "(" 
    (String.append
      (List.fold_left String.append
        (intercalate (String " " EmptyString) xs)
         (String """" EmptyString)) ")").
(* [?]: removed value specification. *)

(* 

Instance x10_Show{a: Type} `{Show a}: Show (list  a):= {
	 show  :=  string_of_list
}.
 *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition length {a : Type} (xs : list a) : nat := 
  List.fold_left (fun (y : nat) (_ : a) => S y) xs 0.
(* [?]: removed value specification. *)

Program Fixpoint take0 {a : Type}  (m : nat ) (xs : list a)  : list a:= 
  match ( xs) with 
    | []    => []
    | x::xs =>
      if beq_nat m( 0) then
        []
      else
        x::take0 ( Coq.Init.Peano.minus m( 1)) xs
  end.
(* [?]: removed value specification. *)

Program Fixpoint drop0 {a : Type}  (m : nat ) (xs : list a)  : list a:= 
  match ( xs) with 
    | []    => []
    | x::xs =>
      if beq_nat m( 0) then
        x::xs
      else
        drop0 ( Coq.Init.Peano.minus m( 1)) xs
  end.
(* [?]: removed value specification. *)

Definition string_prefix  (m : nat ) (s : string )  : option (string ) := 
  let cs := string_to_char_list s in
    if nat_gtb m (length cs) then
      None
    else
      Some (string_from_char_list (take0 m cs)).
(* [?]: removed value specification. *)

Program Fixpoint string_index_of'  (e : ascii ) (ss : list (ascii )) (idx1 : nat )  : option (nat ) := 
  match ( ss) with 
    | []    => None
    | s::ss =>
      if (char_equal s e) then
        Some idx1
      else
        string_index_of' e ss ( Coq.Init.Peano.plus( 1) idx1)
  end.
(* [?]: removed value specification. *)

Definition string_index_of  (e : ascii ) (s : string )  : option (nat ) :=  string_index_of' e (string_to_char_list s)( 0).
(* [?]: removed value specification. *)

Program Fixpoint index0 {a : Type}  (m : nat ) (xs : list a)  : option a := 
  match ( xs) with 
    | []    => None
    | x::xs =>
        if beq_nat m( 0) then
          Some x
        else
          index0 ( Coq.Init.Peano.minus m( 1)) xs
  end.
(* [?]: removed value specification. *)

Program Fixpoint find_index_helper {a : Type}  (count : nat ) (p : a -> bool ) (xs : list a)  : option (nat ) := 
	match ( xs) with 
		| []    => None
		| y::ys =>
			if p y then
				Some count
			else
				find_index_helper ( Coq.Init.Peano.plus count( 1)) p ys
	end.
(* [?]: removed value specification. *)

Definition find_index {a : Type}  (p : a -> bool ) (xs : list a)  : option (nat ) :=  find_index_helper( 0) p xs.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Program Fixpoint replicate_revacc {a : Type}  (revacc : list a) (len : nat ) (e : a)  : list a:= 
	match ( len) with 
		| 0 => List.rev revacc
		| m => replicate_revacc (e :: revacc) ( Coq.Init.Peano.minus m( 1)) e
	end.
(* [?]: removed value specification. *)

Definition replicate0 {a : Type}  (len : nat ) (e : a)  : list a:= 
	replicate_revacc [] len e.
(* [?]: removed value specification. *)

Definition list_append {a : Type}  (l1 : list a) (l2 : list a)  : list a:= 
    lem_list.reverseAppend (List.rev l1) l2.
(* [?]: removed value specification. *)
 
Definition list_concat {a : Type}  (ll : list (list a))  : list a:=  List.fold_left list_append ll [].
(* [?]: removed value specification. *)

Definition list_concat_map {a b : Type}  (f : a -> list b) (l : list a)  : list b:=  
    list_concat (List.map f l).
(* [?]: removed value specification. *)

Program Fixpoint list_reverse_concat_map_helper {a b : Type}  (f : a -> list b) (acc : list b) (ll : list a)  : list b:=  
    let lcons  := (fun (l : list b) => (fun (i : b) => i :: l))
    in
    match ( ll) with 
      | []      => acc
      | item :: items => 
            (* item is a thing that maps to a list. it needn't be a list yet *)
            let mapped_list  := f item
            in 
            (* let _ = Missing_pervasives.errln ("Map function gave us a list of " ^ (show (List.length mapped_list)) ^ " items") in *)
            list_reverse_concat_map_helper f (List.fold_left lcons (f item) acc) items
    end.
(* [?]: removed value specification. *)

Definition list_reverse_concat_map {a b : Type}  (f : a -> list b) (ll : list a)  : list b:=  list_reverse_concat_map_helper f [] ll.
(* [?]: removed value specification. *)

Program Fixpoint list_take_with_accum {a : Type}  (n : nat ) (reverse_acc : list a) (l : list a)  : list a:= 
  (*  let _ = Missing_pervasives.errs ("Taking a byte; have accumulated " ^ (show (List.length acc) ^ " so far\n"))
   in *)
   match ( n) with 
        0 => List.rev reverse_acc
      | _ => match ( l) with 
            [] => DAEMON
            | x :: xs => list_take_with_accum (Coq.Init.Peano.minus n( 1)) (x :: reverse_acc) xs
        end
    end.
(* [?]: removed value specification. *)

Definition unsafe_string_take  (m : nat ) (str : string )  : string := 
  let m := id m in
    string_from_char_list (lem_list.take m (string_to_char_list str)).
(* [?]: removed value specification. *)

Definition padding_and_maybe_newline  (c : ascii ) (width : nat ) (str : string )  : string :=  
    let padlen := Coq.Init.Peano.minus width ( (String.length str)) in
    
     String.append(if nat_lteb padlen( 1) then "
" else "") (string_from_char_list (replicate0 (if nat_lteb padlen( 1) then width else padlen) c)).
(* [?]: removed value specification. *)

Definition space_padding_and_maybe_newline (width : nat) (str : string) : string :=  
    padding_and_maybe_newline " " width str.
(* [?]: removed value specification. *)

Definition padded_and_maybe_newline  (c : ascii ) (width : nat ) (str : string )  : string :=  
     String.append str (padding_and_maybe_newline c width str).
(* [?]: removed value specification. *)

Definition padding_to  (c : ascii ) (width : nat ) (str : string )  : string :=  
    let padlen := Coq.Init.Peano.minus width ( (String.length str)) in
    if nat_lteb padlen( 0) then (String """" EmptyString) else (string_from_char_list (replicate0 padlen c)).
(* [?]: removed value specification. *)

Definition left_padded_to  (c : ascii ) (width : nat ) (str : string )  : string :=  
     String.append(padding_to c width str) str.
(* [?]: removed value specification. *)

Definition right_padded_to  (c : ascii ) (width : nat ) (str : string )  : string :=  
     String.append str (padding_to c width str).
(* [?]: removed value specification. *)

Definition space_padded_and_maybe_newline  (width : nat ) (str : string )  : string :=  
     String.append str (padding_and_maybe_newline " " width str).
(* [?]: removed value specification. *)

Definition left_space_padded_to  (width : nat ) (str : string )  : string :=  
     String.append(padding_to " " width str) str.
(* [?]: removed value specification. *)

Definition right_space_padded_to  (width : nat ) (str : string )  : string :=  
     String.append str (padding_to " " width str).
(* [?]: removed value specification. *)

Definition left_zero_padded_to  (width : nat ) (str : string )  : string :=  
     String.append (padding_to " " width str) str.
 
