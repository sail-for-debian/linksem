(* Generated by Lem from command_line.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_string_extra.
Require Export lem_string_extra.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_list_extra.
Require Export lem_list_extra.

Require Import lem_set.
Require Export lem_set.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import default_printing.
Require Export default_printing.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


(* Here we try to model the command line of GNU ld.bfd.
 * 
 * Some options are global modifiers affecting the link output. 
 * Others have effect only for some subset of input files.
 * Typically some mutually-exclusive possibilities exist
 * whereby each argument selects one such possibility for all subsequent input files, 
 * until a different argument selects another possibility for ensuring inputs.
 *)

Inductive input_file_spec : Type :=  Filename:  string  -> input_file_spec     (* /path/to/file.{o,a,so,...} -- might be script! *)
                     | Libname:  string  -> input_file_spec .
Definition input_file_spec_default: input_file_spec  := Filename string_default.
(* [?]: removed value specification. *)

Definition string_of_input_file_spec  (spec : input_file_spec )  : string :=  
    match ( spec) with 
        Filename(s) =>  String.append"file `"  (String.append s "'")
        | Libname(s) =>  String.append"library `"  (String.append s "'")
    end.
(* 

Instance x122_Show : Show input_file_spec := {
     show  :=  string_of_input_file_spec
}.
 *)

Record input_file_options : Type := { input_fmt : string 
                           ; input_libpath : list  string 
                           ; input_link_sharedlibs : bool       (* -Bstatic *)
                           ; input_check_sections : bool 
                           ; input_copy_dt_needed : bool 
                           ; input_whole_archive : bool 
                           ; input_as_needed : bool 
                           }.
Notation "{[ r 'with' 'input_fmt' := e ]}" := ({| input_fmt := e; input_libpath := input_libpath r; input_link_sharedlibs := input_link_sharedlibs r; input_check_sections := input_check_sections r; input_copy_dt_needed := input_copy_dt_needed r; input_whole_archive := input_whole_archive r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_libpath' := e ]}" := ({| input_libpath := e; input_fmt := input_fmt r; input_link_sharedlibs := input_link_sharedlibs r; input_check_sections := input_check_sections r; input_copy_dt_needed := input_copy_dt_needed r; input_whole_archive := input_whole_archive r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_link_sharedlibs' := e ]}" := ({| input_link_sharedlibs := e; input_fmt := input_fmt r; input_libpath := input_libpath r; input_check_sections := input_check_sections r; input_copy_dt_needed := input_copy_dt_needed r; input_whole_archive := input_whole_archive r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_check_sections' := e ]}" := ({| input_check_sections := e; input_fmt := input_fmt r; input_libpath := input_libpath r; input_link_sharedlibs := input_link_sharedlibs r; input_copy_dt_needed := input_copy_dt_needed r; input_whole_archive := input_whole_archive r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_copy_dt_needed' := e ]}" := ({| input_copy_dt_needed := e; input_fmt := input_fmt r; input_libpath := input_libpath r; input_link_sharedlibs := input_link_sharedlibs r; input_check_sections := input_check_sections r; input_whole_archive := input_whole_archive r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_whole_archive' := e ]}" := ({| input_whole_archive := e; input_fmt := input_fmt r; input_libpath := input_libpath r; input_link_sharedlibs := input_link_sharedlibs r; input_check_sections := input_check_sections r; input_copy_dt_needed := input_copy_dt_needed r; input_as_needed := input_as_needed r |}).
Notation "{[ r 'with' 'input_as_needed' := e ]}" := ({| input_as_needed := e; input_fmt := input_fmt r; input_libpath := input_libpath r; input_link_sharedlibs := input_link_sharedlibs r; input_check_sections := input_check_sections r; input_copy_dt_needed := input_copy_dt_needed r; input_whole_archive := input_whole_archive r |}).
Definition input_file_options_default: input_file_options  := {| input_fmt := string_default; input_libpath := DAEMON; input_link_sharedlibs := bool_default; input_check_sections := bool_default; input_copy_dt_needed := bool_default; input_whole_archive := bool_default; input_as_needed := bool_default |}.
(* [?]: removed value specification. *)

Definition null_input_file_options   : input_file_options :=  
                      {|input_fmt := ""
                       ;input_libpath := []
                       ;input_link_sharedlibs := false
                       ;input_check_sections := false
                       ;input_copy_dt_needed := false
                       ;input_whole_archive := false
                       ;input_as_needed := false
                       |}.

Inductive output_kind : Type :=  Executable: output_kind 
                 | SharedLibrary: output_kind .
Definition output_kind_default: output_kind  := Executable.

Inductive link_option : Type :=  OutputFilename:  string  -> link_option 
                 | OutputKind:  output_kind  -> link_option 
                 | ForceCommonDefined:  bool  -> link_option         (* -d, -dc, -dp *)
                 | Soname:  string  -> link_option                   (* -soname *)
                 | EntryAddress:  nat  -> link_option 
                 | TextSegmentStart:  nat  -> link_option 
                 | RodataSegmentStart:  nat  -> link_option 
                 | LdataSegmentStart:  nat  -> link_option 
                 | BindFunctionsEarly: link_option                 (* -Bsymbolic-functions *)
                 | BindNonFunctionsEarly: link_option .
Definition link_option_default: link_option  := OutputFilename string_default.
(* [?]: removed value specification. *)

Definition tagEqual  (opt1 : link_option ) (opt2 : link_option )  : bool :=  match ( (opt1, opt2)) with 
    (* FIXME: Lem BUG here! says "duplicate binding" *)
    (OutputFilename(_),  OutputFilename(_)) => true
    | (OutputKind(_),  OutputKind(_)) => true
    (* | (ForceCommonDefined, ForceCommonDefined) -> true *)
    | (Soname(_),  Soname(_)) => true
    (* | (EntryAddress, EntryAddress) -> true *)
    | (TextSegmentStart(_),  TextSegmentStart(_)) => true
    | (RodataSegmentStart(_),  RodataSegmentStart(_)) => true
    | (LdataSegmentStart(_),  LdataSegmentStart(_)) => true
    (* | (BindFunctionsEarly, BindFunctionsEarly) -> true *)
    (* | (BindNonFunctionsEarly, BindNonFunctionsEarly) -> true *)
    | _ => false
end.

(* To allow filtering out a previous setting for a given option, we define
 * an equality relation that is true if options are of the same constructor.
 * Seems like a bit of a HACK. *)
Instance x121_Eq : Eq link_option := {
     isEqual  :=  fun  opt1 => 
        (fun  opt2 => 
            match ( (opt1, opt2)) with  
                | (OutputFilename(_),  OutputFilename(_))        => true
                | (ForceCommonDefined(_),  ForceCommonDefined(_)) => true
                | (Soname(_),  Soname(_)) => true
                | (EntryAddress(_),  EntryAddress(_)) => true
                | _ => false
            end
        );
     isInequal  :=  fun  opt1 => (fun  opt2 => negb ( ((fun  opt1 => 
        (fun  opt2 => 
            match ( (opt1, opt2)) with  
                | (OutputFilename(_),  OutputFilename(_))        => true
                | (ForceCommonDefined(_),  ForceCommonDefined(_)) => true
                | (Soname(_),  Soname(_)) => true
                | (EntryAddress(_),  EntryAddress(_)) => true
                | _ => false
            end
        ))opt1 opt2)))
}.


Definition input_file_and_options : Type := ( input_file_spec  * input_file_options ) % type.
Definition input_file_and_options_default: input_file_and_options  := (input_file_spec_default, input_file_options_default).
Inductive input_unit : Type :=  File:  input_file_and_options  -> input_unit 
                | Group:  list  (input_file_and_options ) -> input_unit    (* NOT recursive *)
                | BuiltinControlScript: input_unit .
Definition input_unit_default: input_unit  := File input_file_and_options_default.
(* [?]: removed value specification. *)

(* 

Instance x120_Show : Show input_unit := {
     show  :=  string_of_input_unit
}.
 *)

(* Reading the command-line: 
 * we encode the meaning of a linker command token 
 * using a reader function interpreting a list of argument definitions.
 * Lookahead is necessary: sometimes the interpretation of an option
 * depends on the next argument (e.g. whether it's a file, directory or another option).
 * The list of argument definitions is from lists of strings to constructor function invocations.
 * We use lists of strings since many options have synonyms.
 * The strings are interpreted as regular expressions and any matched groups are collected together
 * as a second argument list; this is because some arguments are of the form --blah=NUM or similar. *)
 
(* As we read the command line, we keep a current state which is the collection
 * of seen input files, seen whole-link options, and input file options that will
 * apply to any input files we add subsequently. *)
Record command_state : Type := { input_units           : list  input_unit 
                      ; link_options          : set   link_option 
                      ; current_input_options : input_file_options 
                      ; current_group         : option  (list  input_file_and_options ) 
                      }.
Notation "{[ r 'with' 'input_units' := e ]}" := ({| input_units := e; link_options := link_options r; current_input_options := current_input_options r; current_group := current_group r |}).
Notation "{[ r 'with' 'link_options' := e ]}" := ({| link_options := e; input_units := input_units r; current_input_options := current_input_options r; current_group := current_group r |}).
Notation "{[ r 'with' 'current_input_options' := e ]}" := ({| current_input_options := e; input_units := input_units r; link_options := link_options r; current_group := current_group r |}).
Notation "{[ r 'with' 'current_group' := e ]}" := ({| current_group := e; input_units := input_units r; link_options := link_options r; current_input_options := current_input_options r |}).
Definition command_state_default: command_state  := {| input_units := DAEMON; link_options := DAEMON; current_input_options := input_file_options_default; current_group := DAEMON |}.
(* [?]: removed value specification. *)
 (* the stack *)
Definition initial_state   : list (command_state ):=  [{|input_units := []
                     ;link_options := [OutputFilename("a.out");  OutputKind(Executable)]
                     ;current_input_options := {|input_fmt := "elf64-x86-64"   (* FIXME *)
                                                ;input_libpath := ["/usr/lib"] (* FIXME: this probably isn't the right place to supply the default search path *)
                                                ;input_link_sharedlibs := true
                                                ;input_check_sections := true
                                                ;input_copy_dt_needed := false
                                                ;input_whole_archive := false
                                                ;input_as_needed := true (* FIXME *)
                                                |}
                     ;current_group := None
                     |}].

Definition interpreted_command_line : Type := ( list  input_unit  * set  link_option ) % type.
Definition interpreted_command_line_default: interpreted_command_line  := (DAEMON, DAEMON).
(* [?]: removed value specification. *)

Definition add_input_file  (l : list (command_state )) (s : string )  : list (command_state ):= 
  match ( (l,s)) with (( state :: more),  s) =>
    let chars := string_to_char_list s in
  let spec := match ( chars) with - :: l :: more =>
                Libname (string_from_char_list more) | - :: more => DAEMON
                | _ => Filename (s) end in
  if (maybeEqualBy
        (list_equal_by
           ((fun (left : (input_file_spec *input_file_options ) % type) (right : (input_file_spec *input_file_options ) % type)=>
               (tuple_equal_by classical_boolean_equivalence
                  classical_boolean_equivalence left right))))
        (current_group state) None) then
    {|input_units := ((@ List.app _) (input_unitsstate)
                        [File (spec,(current_input_options state))])
    ;link_options :=(link_options state)
    ;current_input_options :=(current_input_options state)
    ;current_group :=(current_group state) |} :: more else
    {|input_units :=(input_units state) ;link_options :=(link_options state)
    ;current_input_options :=(current_input_options state)
    ;current_group := (let toAppend := [(spec,(current_input_options state))] in
    match ((current_group state)) with Some l =>
      Some ( (@ List.app _) l toAppend) | None => Some (toAppend) end) |} ::
    more | ([],  _) =>
    DAEMON (* Incomplete Pattern at File \"command_line.lem\", line 169, character 1 to line 192, character 19 *)
  end.
(* [?]: removed value specification. *)

Definition start_group  (l : list (command_state ))  : list (command_state ):= 
  match ( (l)) with (( state :: more)) =>
    {|input_units :=(input_units state) ;link_options :=(link_options state)
    ;current_input_options :=(current_input_options state)
    ;current_group := match ((current_group state)) with None => Some []
                        | _ => DAEMON end |} :: more | ([]) =>
    DAEMON (* Incomplete Pattern at File \"command_line.lem\", line 195, character 1 to line 203, character 19 *)
  end.
(* [?]: removed value specification. *)

Definition end_group  (l : list (command_state ))  : list (command_state ):= 
  match ( (l)) with (( state :: more)) =>
    {|input_units := ((@ List.app _) (input_unitsstate)
                        (match ((current_group state)) with Some l =>
                           [Group (l)] | None => DAEMON end))
    ;link_options :=(link_options state)
    ;current_input_options :=(current_input_options state)
    ;current_group := None |} :: more | ([]) =>
    DAEMON (* Incomplete Pattern at File \"command_line.lem\", line 206, character 1 to line 214, character 19 *)
  end.

Definition option_token : Type :=  string .
Definition option_token_default: option_token  := string_default.
Definition option_argspecs : Type := ( list  string  * list  string ) % type.
Definition option_argspecs_default: option_argspecs  := (DAEMON, DAEMON).
Definition option_argvals : Type := ( list  string  * list  string ) % type.
Definition option_argvals_default: option_argvals  := (DAEMON, DAEMON).
(* [?]: removed value specification. *)

Definition set_or_replace_option  (opt : link_option ) (state_list : list (command_state ))  : list (command_state ):=  
    match ( state_list) with 
        [] => DAEMON
        | state :: more => 
            {|input_units :=(input_units state)
             ;link_options := (set_add opt (lem_set.filter (fun (existing : link_option ) => ((fun (opt1 : link_option ) => (fun (opt2 : link_option ) => negb ( ((fun (opt1 : link_option ) => 
        (fun (opt2 : link_option ) => 
            match ( (opt1, opt2)) with  
                | (OutputFilename(_),  OutputFilename(_))        => true
                | (ForceCommonDefined(_),  ForceCommonDefined(_)) => true
                | (Soname(_),  Soname(_)) => true
                | (EntryAddress(_),  EntryAddress(_)) => true
                | _ => false
            end
        ))opt1 opt2)))) existing opt))(link_options state)))
             ;current_input_options :=(current_input_options state)
             ;current_group :=(current_group state)
             |} :: more
    end.
(* [?]: removed value specification. *)

Definition find_option_matching_tag  (tag : link_option ) (options : set (link_option ))  : option (link_option ) :=  
    lem_list.find (tagEqual tag) (set_to_list options).
(* [?]: removed value specification. *)

Definition extract_hex_addend  (x : ascii )  : option (nat ) := 
  if (char_equal x 0) then
    Some( 0)
  else if (char_equal x 1) then
    Some( 1)
  else if (char_equal x 2) then
    Some( 2)
  else if (char_equal x 3) then
    Some( 3)
  else if (char_equal x 4) then
    Some( 4)
  else if (char_equal x 5) then
    Some( 5)
  else if (char_equal x 6) then
    Some( 6)
  else if (char_equal x 7) then
    Some( 7)
  else if (char_equal x 8) then
    Some( 8)
  else if (char_equal x 9) then
    Some( 9)
  else if (char_equal x a) then
    Some( 10)
  else if (char_equal x b) then
    Some( 11)
  else if (char_equal x c) then
    Some( 12)
  else if (char_equal x d) then
    Some( 13)
  else if (char_equal x e) then
    Some( 14)
  else if (char_equal x f) then
    Some( 15)
  else
    None.
(* [?]: removed value specification. *)

Program Fixpoint accumulate_hex_chars  (acc : nat ) (chars : list (ascii ))  : nat := 
  match ( chars) with 
    | [] => acc
    | x::xs =>
      match ( extract_hex_addend x) with 
        | None     => acc
        | Some addend =>
            accumulate_hex_chars ( Coq.Init.Peano.plus (Coq.Init.Peano.mult acc( 16)) addend) xs
      end
  end.
(* [?]: removed value specification. *)

Definition extract_dec_addend  (x : ascii )  : option (nat ) := 
  if (char_equal x 0) then
    Some( 0)
  else if (char_equal x 1) then
    Some( 1)
  else if (char_equal x 2) then
    Some( 2)
  else if (char_equal x 3) then
    Some( 3)
  else if (char_equal x 4) then
    Some( 4)
  else if (char_equal x 5) then
    Some( 5)
  else if (char_equal x 6) then
    Some( 6)
  else if (char_equal x 7) then
    Some( 7)
  else if (char_equal x 8) then
    Some( 8)
  else if (char_equal x 9) then
    Some( 9)
  else
    None.
(* [?]: removed value specification. *)

Definition accumulate_dec_chars  (acc : nat ) (chars : list (ascii ))  : nat := 
  match ( chars) with 
    | [] => acc
    | x::xs =>
      match ( extract_dec_addend x) with 
        | None     => acc
        | Some addend =>
            accumulate_hex_chars ( Coq.Init.Peano.plus (Coq.Init.Peano.mult acc( 16)) addend) xs
      end
  end.
(* [?]: removed value specification. *)

Definition parse_address  (s : string )  : nat :=  match ( string_to_char_list s) with 
    0 :: x :: more => accumulate_hex_chars( 0) more
    | chars => accumulate_dec_chars( 0) chars
end.

Definition option_def : Type := ( (list  option_token ) * option_argspecs  * (option_argvals  ->  list  command_state  ->  list  command_state ) * string ) % type.
Definition option_def_default: option_def  := (DAEMON, option_argspecs_default, (fun (x118 : option_argvals ) => (fun (x119 :  list  command_state ) => DAEMON)), string_default).
(* [?]: removed value specification. *)

Definition command_line_table   : list ((list (string )*((list (string )*list (string )) % type)*((list (string )*list (string )) % type -> list (command_state ) -> list (command_state ))*string ) % type):=  [
  (* per-input options *) 
  (["-b"; "--format"],                            (["TARGET"], []),    (fun (args : (list (string )*list (string )) % type) => (fun (state : list (command_state )) => state)), "Specify target for following input files");
  (["-L"; "--library-path"],                      (["DIRECTORY"], []), (fun (args : (list (string )*list (string )) % type) => (fun (state : list (command_state )) => state)), "Add DIRECTORY to library search path");
  (["--as-needed"],                               ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Only set DT_NEEDED for following dynamic libs if used");
  (["--no-as-needed"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Always set DT_NEEDED for dynamic libraries mentioned on the command line");
  (["-Bdynamic"; "-dy"; "-call_shared"],          ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Link against shared libraries");
  (["-Bstatic"; "-dn"; "-non_shared"; "-static"], ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Do not link against shared libraries");
  (["--check-sections"],                          ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Check section addresses for overlaps (default)  **srk** not sure it's per-input!");
  (["--no-check-sections"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Do not check section addresses for overlaps     **srk** not sure it's per-input!");
  (["--copy-dt-needed-entries"],                  ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Copy DT_NEEDED links mentioned inside DSOs that follow");
  (["--no-copy-dt-needed-entries"],               ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Do not copy DT_NEEDED links mentioned inside DSOs that follow");
  (["--no-whole-archive"],                        ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Turn off --whole-archive");
  (["-rpath-link"],                               (["PATH"], []),      (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Set link time shared library search path        **srk** not sure it's per-input!");
  (["--whole-archive"],                           ([], []),            (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Include all objects from following archives");
  (* linker plugin control *)
  (["-plugin"],                                   (["PLUGIN"], []),    (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Load named plugin");
  (["-plugin-opt"],                               (["ARG"], []),       (fun  _ : (list (string )*list (string )) % type    => (fun (state : list (command_state )) => state)), "Send arg to last-loaded plugin");
  (* output / whole-job options (some may be repeated with different args, but most not): *)
  (["-A"; "--architecture"],                      (["ARCH"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set architecture");
  (["-EB"],                                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Link big-endian objects");
  (["-EL"],                                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Link little-endian objects");
  (["-R"; "--just-symbols"],                      (["DIR"], []),       (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "**srk** (if directory, same as --rpath)");
  (["-d"; "-dc"; "-dp"],                          ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Force common symbols to be defined");
  (["-e"; "--entry"],                             (["ADDRESS"], []),   (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set start address");
  (["-E"; "--export-dynamic"],                    ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Export all dynamic symbols");
  (["--no-export-dynamic"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Undo the effect of --export-dynamic");
  (["-f"; "--auxiliary"],                         (["SHLIB"], []),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Auxiliary filter for shared object symbol table");
  (["-F"; "--filter"],                            (["SHLIB"], []),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Filter for shared object symbol table");
  (["-G"; "--gpsize"],                            (["SIZE"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Small data size (if no size, same as --shared) **srk NOTE this quirk!**");
  (["-h"; "-soname"],                             (["FILENAME"], []),  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set internal name of shared library");
  (["-I"; "--dynamic-linker"],                    (["PROGRAM"], []),   (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set PROGRAM as the dynamic linker to use");
  (["--sysroot="],                                ([], ["DIRECTORY"]), (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Override the default sysroot location");
  (["-m"],                                        (["EMULATION"], []), (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set emulation");
  (["-n"; "--nmagic"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not page align data");
  (["-N"; "--omagic"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not page align data, do not make text readonly");
  (["--no-omagic"],                               ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Page align data, make text readonly");
  (["-o"; "--output"],                            (["FILE"], []),      (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (OutputFilename(head ((@ fst _ _) argvals)))), "Set output file name");
  (["-O"],                                        ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Optimise output file");
  (["-q"; "--emit-relocs"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Generate relocations in final output");
  (["-r"; "-i"; "--relocatable"],                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Generate relocatable output");
  (["-s"; "--strip-all"],                         ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Strip all symbols");
  (["-S"; "--strip-debug"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Strip debugging symbols");
  (["--strip-discarded"],                         ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Strip symbols in discarded sections");
  (["--no-strip-discarded"],                      ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not strip symbols in discarded sections");
  (["--default-script"; "-dT"],                   (["FILE"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Read default linker script");
  (["--unique="],                                 ([], ["SECTION"]),   (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't merge input [SECTION | orphan] sections");
  (["-Ur"],                                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Build global constructor/destructor tables ( **srk**: like -r, but... )");
  (["-x"; "--discard-all"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Discard all local symbols");
  (["-X"; "--discard-locals"],                    ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Discard temporary local symbols (default)");
  (["--discard-none"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't discard any local symbols");
  (["-Bsymbolic"],                                ([], []),            (fun (argvals : (list (string )*list (string )) % type) => (fun (state : list (command_state )) => set_or_replace_option BindFunctionsEarly (set_or_replace_option BindNonFunctionsEarly state))), "Bind global references locally");
  (["-Bsymbolic-functions"],                      ([], []),            (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (BindFunctionsEarly)), "Bind global function references locally");
  (["--force-exe-suffix"],                        ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Force generation of file with .exe suffix");
  (["--gc-sections"],                             ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "**srk: uncertain: can repeat?** Remove unused sections (on some targets)");
  (["--no-gc-sections"],                          ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "**srk: uncertain: can repeat?** Don't remove unused sections (default)");
  (["--hash-size="],                              ([], ["NUMBER"]),    (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set default hash table size close to <NUMBER>");
  (["--no-define-common"],                        ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not define Common storage");
  (["--no-undefined"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not allow unresolved references in object files");
  (["--allow-shlib-undefined"],                   ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Allow unresolved references in shared libraries");
  (["--no-allow-shlib-undefined"],                ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not allow unresolved references in shared libs");
  (["--default-symver"],                          ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create default symbol version");
  (["--default-imported-symver"],                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create default symbol version for imported symbols");
  (["-nostdlib"],                                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Only use library directories specified on the command line");
  (["--oformat"],                                 (["TARGET"], []),    (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Specify target of output file");
  (["--relax"],                                   ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Reduce code size by using target specific optimisations");
  (["--no-relax"],                                ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not use relaxation techniques to reduce code size");
  (["--retain-symbols-file"],                     (["FILE"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Keep only symbols listed in FILE");
  (["-rpath"],                                    (["PATH"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set runtime shared library search path");
  (["-shared"; "-Bshareable"],                    ([], []),            (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (OutputKind(SharedLibrary))), "Create a shared library");
  (["-pie"; "--pic-executable"],                  ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create a position independent executable");
  (["--sort-common="],(* (ascending|descending) *)([], ["order"]),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Sort common symbols by alignment [in specified order]");
  (["--sort-section="],(* (name|alignment) *)     ([], ["key"]),       (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Sort sections by name or maximum alignment");
  (["--spare-dynamic-tags"],                      (["COUNT"], []),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "How many tags to reserve in .dynamic section");
  (["--split-by-file="],                          ([], ["SIZE"]),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Split output sections every SIZE octets");
  (["--split-by-reloc="],                         ([], ["COUNT"]),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Split output sections every COUNT relocs");
  (["--traditional-format"],                      ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Use same format as native linker");
  (["--unresolved-symbols="],                     ([], ["method"]),    (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "How to handle unresolved symbols.  <method> is: ignore-all, report-all, ignore-in-object-files, ignore-in-shared-libs");
  (["--dynamic-list-data"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Add data symbols to dynamic list");
  (["--dynamic-list-cpp-new"],                    ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Use C++ operator new/delete dynamic list");
  (["--dynamic-list-cpp-typeinfo "],              ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Use C++ typeinfo dynamic list");
  (["--dynamic-list"],                            (["FILE"], []),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Read dynamic list");
  (["--wrap"],                                    (["SYMBOL"], []),    (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Use wrapper functions for SYMBOL");
  (* the following are specific to ELF emulations *)
  (["--audit=(.*)"],                              ([], ["AUDITLIB"]),  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Specify a library to use for auditing");
  (["-Bgroup"],                                   ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Selects group name lookup rules for DSO");
  (["--build-id="],                               ([], ["STYLE"]),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Generate build ID note");
  (["-P"],                                        (["AUDITLIB"], []),  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Specify a library to use for auditing dependencies");
  (["--depaudit="],                               ([], ["AUDITLIB"]),  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Specify a library to use for auditing dependencies");
  (["--disable-new-dtags"],                       ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Disable new dynamic tags");
  (["--enable-new-dtags"],                        ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Enable new dynamic tags");
  (["--eh-frame-hdr"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create .eh_frame_hdr section");
  (["--exclude-libs="],                           ([], ["LIBS"]),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Make all symbols in LIBS hidden");
  (["--hash-style="],                             ([], ["STYLE"]),     (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set hash style to sysv, gnu or both");
  (* NOTE: for these to work, we hack our word-splitter to merge -z options into a single word with a single space in *)
  (["-z combreloc"],                              ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Merge dynamic relocs into one section and sort");
  (["-z common-page-size="],                      ([], ["SIZE"]),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set common page size to SIZE");
  (["-z defs"],                                   ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Report unresolved symbols in object files.");
  (["-z execstack"],                              ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark executable as requiring executable stack");
  (["-z global"],                                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Make symbols in DSO available for subsequently loaded objects");
  (["-z initfirst"],                              ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark DSO to be initialized first at runtime");
  (["-z interpose"],                              ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object to interpose all DSOs but executable");
  (["-z lazy"],                                   ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object lazy runtime binding (default)");
  (["-z loadfltr"],                               ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object requiring immediate process");
  (["-z max-page-size="],                         ([], ["SIZE"]),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set maximum page size to SIZE");
  (["-z nocombreloc"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't merge dynamic relocs into one section");
  (["-z nocopyreloc"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't create copy relocs");
  (["-z nodefaultlib"],                           ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object not to use default search paths");
  (["-z nodelete"],                               ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark DSO non-deletable at runtime");
  (["-z nodlopen"],                               ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark DSO not available to dlopen");
  (["-z nodump"],                                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark DSO not available to dldump");
  (["-z noexecstack"],                            ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark executable as not requiring executable stack");
  (["-z norelro"],                                ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't create RELRO program header");
  (["-z now"],                                    ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object non-lazy runtime binding");
  (["-z origin"],                                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Mark object requiring immediate $ORIGIN processing at runtime");
  (["-z relro"],                                  ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create RELRO program header");
  (["-z stacksize="],                             ([], ["SIZE"]),      (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set size of stack segment");
  (["-z bndplt"],                                 ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Always generate BND prefix in PLT entries");
  (["--ld-generated-unwind-info"],                ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Generate exception handling info for PLT.");
  (["--no-ld-generated-unwind-info"],             ([], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't do so.");
  (* quasi-input options (can be repeated): *)
  (["-c"; "--mri-script"],                        (["FILE"], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Read MRI format linker script");
  (["-l"; "--library"],                           (["LIBNAME"], []),         (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Search for library LIBNAME");
  (* (["-R" ,"--just-symbols"],                   (["FILE"], []),            fun _ -> (fun state -> state), "Just link symbols"), *) (* Handled above! *)
  (["-T"; "--script"],                            (["FILE"], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Read linker script");
  (["-u"; "--undefined"],                         (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Start with undefined reference to SYMBOL");
  (["-("; "--start-group"],                       ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => start_group state)), "Start a group");
  (["-)"; "--end-group"],                         ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => end_group state)), "End a group");
  (["--defsym"],                                  (["SYMBOL=EXPRESSION"], []), (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Define a symbol");
  (["-fini"],                                     (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Call SYMBOL at unload-time");
  (["-init"],                                     (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Call SYMBOL at load-time");
  (["--section-start"],                           (["SECTION=ADDRESS"], []), (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set address of named section");
  (["-Tbss"],                                     (["ADDRESS"], []),         (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set address of .bss section");
  (["-Tdata"],                                    (["ADDRESS"], []),         (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set address of .data section");
  (["-Ttext"],                                    (["ADDRESS"], []),         (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Set address of .text section");
  (["-Ttext-segment"],                            (["ADDRESS"], []),         (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (TextSegmentStart(parse_address (head ((@ fst _ _) argvals))))), "Set address of text segment");
  (["-Trodata-segment"],                          (["ADDRESS"], []),         (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (RodataSegmentStart(parse_address (head ((@ fst _ _) argvals))))), "Set address of rodata segment");
  (["-Tldata-segment"],                           (["ADDRESS"], []),         (fun (argvals : (list (string )*list (string )) % type) => set_or_replace_option (LdataSegmentStart(parse_address (head ((@ fst _ _) argvals))))), "Set address of ldata segment");
  (["--version-script"],                          (["FILE"], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Read version information script");
  (["--version-exports-section"],                 (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Take export symbols list from .exports, using SYMBOL as the version.");
  (* linker internal debugging/diagnostics and performance tuning *)
  (["-M"; "--print-map"],                         ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print map file on standard output");
  (["-t"; "--trace"],                             ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Trace file opens");
  (["-v"; "--version"],                           ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print version information");
  (["-V"],                                        ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print version and emulation information");
  (["-y"; "--trace-symbol"],                      (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Trace mentions of SYMBOL");
  (["--cref"],                                    ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Output cross reference table");
  (["--demangle="],                               ([], ["STYLE"]),             (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Demangle symbol names [using STYLE]");
  (["--print-gc-sections"],                       ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "List removed unused sections on stderr");
  (["--no-print-gc-sections"],                    ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not list removed unused sections");
  (["-Map"],                                      (["FILE"], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Write a map file");
  (["-Map="],                                     ([], ["FILE"]),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Write a map file");
  (["--help"],                                    ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print option help");
  (["--no-keep-memory"],                          ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Use less memory and more disk I/O");
  (["--no-demangle"],                             ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not demangle symbol names");
  (["--print-output-format"],                     ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print default output format");
  (["--print-sysroot"],                           ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print current sysroot");
  (["--reduce-memory-overheads"],                 ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Reduce memory overheads, possibly taking much longer");
  (["--stats"],                                   ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Print memory usage statistics");
  (["--target-help"],                             ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Display target specific options");
  (["--verbose="],                                ([], ["NUMBER"]),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Output lots of information during link");
  (* unknown *)
  (["--embedded-relocs"],                         ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Generate embedded relocs");
  (["--task-link"],                               (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do task level linking");
  (* compatibility *)
  (["-a"],                                        (["KEYWORD"], []),         (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Shared library control for HP/UX compatibility");
  (["-Y"],                                        (["PATH"], []),            (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Default search path for Solaris compatibility");
  (* permissiveness controls (tightening/loosening) *)
  (["--accept-unknown-input-arch"],               ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Accept input files whose architecture cannot be determined");
  (["--no-accept-unknown-input-arch"],            ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Reject input files whose architecture is unknown");
  (["--fatal-warnings"],                          ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Treat warnings as errors");
  (["--no-fatal-warnings"],                       ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Do not treat warnings as errors (default)");
  (["--allow-multiple-definition"],               ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Allow multiple definitions");
  (["--no-undefined-version"],                    ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Disallow undefined version");
  (["--noinhibit-exec"],                          ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Create an output file even if errors occur");
  (["--error-unresolved-symbols"],                ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Report unresolved symbols as errors");
  (["--ignore-unresolved-symbol"],                (["SYMBOL"], []),          (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Unresolved SYMBOL will not cause an error or warning");
  (* permissiveness, specific to ELF emulation *)
  (["-z muldefs"],                                ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Allow multiple definitions");
  (* warnings (enabling/disabling) *)
  (["--no-warn-mismatch"],                        ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't warn about mismatched input files");
  (["--no-warn-search-mismatch"],                 ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Don't warn on finding an incompatible library");
  (["--warn-common"],                             ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn about duplicate common symbols");
  (["--warn-constructors"],                       ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn if global constructors/destructors are seen");
  (["--warn-multiple-gp"],                        ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn if the multiple GP values are used");
  (["--warn-once"],                               ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn only once per undefined symbol");
  (["--warn-section-align"],                      ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn if start of section changes due to alignment");
  (["--warn-shared-textrel"],                     ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn if shared object has DT_TEXTREL");
  (["--warn-alternate-em"],                       ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Warn if an object has alternate ELF machine code");
  (["--warn-unresolved-symbols"],                 ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Report unresolved symbols as warnings");
  (* meta-options *)
  (["--push-state"],                              ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Push state of flags governing input file handling");
  (["--pop-state"],                               ([], []),                  (fun  _ : (list (string )*list (string )) % type => (fun (state : list (command_state )) => state)), "Pop state of flags governing input file handling") ]
.
(* [?]: removed value specification. *)

Definition delete_trailing_equals  (str : string )  : option (string ) :=  
    let cs := string_to_char_list str
    in
    if (list_equal_by (fun (left : ascii ) (right : ascii )=>(char_equal left right)) [=] (drop0 ( Coq.Init.Peano.minus(length cs)( 1)) cs))
        then Some (string_from_char_list ((take0 ( Coq.Init.Peano.minus(length cs)( 1)) cs)))
        else (* let _ = Missing_pervasives.errln ("No trailing equals: " ^ str)
            in *)
            None.
(* [?]: removed value specification. *)

Definition string_following_equals_at  (pos : nat ) (str : string )  : option (string ) :=  
  match ( lem_list.splitAt pos (string_to_char_list str)) with
      (first,  second) =>
    match ( second) with = :: rest => Some (string_from_char_list rest)
      | _ =>
      (* let _ = Missing_pervasives.errln ("No trailing equals at " ^ (show pos) ^ ": " ^ str)
            in *)
    None end end.
(* [?]: removed value specification. *)

Definition equal_modulo_trailing_equals  (argstr : string ) (argdef : string )  : bool :=  
    (* we allow argdef to have a trailing equals; if it does, 
     * we allow the argstring to have the equals (or not) and trailing stuff,
     * which will become an arg  *)
    let result := match ( (delete_trailing_equals argdef)) with  
        Some matched => 
            let following_equals := string_following_equals_at (String.length matched) argstr
            in
            match ( following_equals) with  
                Some following => (string_equal  (* okay; does the pre-equals part match? *)matched (string_from_char_list (lem_list.take ( Coq.Init.Peano.minus(String.length argdef)( 1)) (string_to_char_list argstr))))
                | _ => (string_equal  (* the argstr is allowed not to have a trailing equals *)argstr matched)
            end
        | None => (string_equal  (* no trailing equals *)argdef argstr)
    end
    in 
    (* let _ = Missing_pervasives.errln ("Do '" ^ argstr ^ "' and '" ^ argdef ^ "' match modulo trailing equals? " ^ (show result))
    in *) result.
(* [?]: removed value specification. *)

Program Fixpoint matching_arg_and_alias  (arg : string ) (options : list ((list (string )*((list (string )*list (string )) % type)*(option_argvals  -> list (command_state ) -> list (command_state ))*string ) % type))  : option ((string *((list (string )*((list (string )*list (string )) % type)*(option_argvals  -> list (command_state ) -> list (command_state ))*string ) % type)) % type) :=  match ( options) with  
    [] => None
    | (aliases,  argspec,  meaning,  doc) :: more_opts => 
        match ( find (fun (alias : string ) => equal_modulo_trailing_equals arg alias) aliases) with  
            Some found_alias => Some (found_alias, (aliases, argspec, meaning, doc))
            | None => matching_arg_and_alias arg more_opts
        end
    end.
(* [?]: removed value specification. *)

Definition read_one_arg  (state_stack : list (command_state )) (args : list (string ))  : (list (command_state )*list (string )) % type:= 
    (* Get the first string and look it up in our table. *)
    match ( args) with 
        [] => (state_stack, [])
    |   some_arg :: more => match ( (matching_arg_and_alias some_arg command_line_table)) with 
            (* We need to handle argdefs that have trailing equals. This means 
             * an extra arg might follow the equals. We need some helper functions. *)
                Some (alias,  (aliases,  (argspec_extras,  argspec_regex),  meaning,  doc)) =>
                    (* Return a new state, by applying the argument's meaning. 
                     * We have to supply the option's argument strings to the meaning function. *)
                    let argstrings := lem_list.take (List.length argspec_extras) more
                    in 
                    let regex_matches := match ( delete_trailing_equals some_arg) with 
                        Some prefix => 
                            match ( (string_following_equals_at ( Coq.Init.Peano.minus(String.length alias)( 1)) some_arg)) with  
                                Some following_equals => [following_equals]
                                | None => DAEMON
                            end
                        | None => []
                    end
                    in 
                    let new_state_stack := meaning (argstrings, regex_matches) state_stack
                    in
                    (new_state_stack, drop0 (length argspec_extras) more)
                | None => 
                    (* If we didn't match any args, we ought to be an input file. *)
                    (add_input_file state_stack some_arg, more)
            end
    end.
(* [?]: removed value specification. *)
 (* originally foldl *)
Program Fixpoint foldl_suffix {a b : Type}  (f : a -> list b -> (a*list b) % type) (a1 : a) (l : list b)  : a:=  match ( l) with 
  | []      => a1
  | x :: xs => match ( f a1 l) with (new_a,  new_list) => foldl_suffix f new_a new_list end
end.
(* [?]: removed value specification. *)

Program Fixpoint cook_argv  (acc : list (string )) (args : list (string ))  : list (string ):=  
    match ( args) with 
        [] => acc
      | "-z" :: more => match ( more) with  
         [] => DAEMON
         | something :: yetmore => cook_argv ( (@ List.app _)acc [ String.append"-z " something]) yetmore
         end
      | something :: more => cook_argv ( (@ List.app _)acc [something]) more
    end.
(* [?]: removed value specification. *)

