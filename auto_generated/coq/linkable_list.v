(* Generated by Lem from linkable_list.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_string_extra.
Require Export lem_string_extra.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_list_extra.
Require Export lem_list_extra.

Require Import lem_set.
Require Export lem_set.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import lem_map.
Require Export lem_map.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import default_printing.
Require Export default_printing.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_memory_image.
Require Export elf_memory_image.

Require Import elf_header.
Require Export elf_header.

Require Import elf_file.
Require Export elf_file.

Require Import memory_image.
Require Export memory_image.

Require Import elf_memory_image.
Require Export elf_memory_image.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import string_table.
Require Export string_table.

Require Import input_list.
Require Export input_list.


Require Import elf_memory_image.
Require Export elf_memory_image.

Require Import elf_memory_image_of_elf64_file.
Require Export elf_memory_image_of_elf64_file.


Definition script : Type :=  byte_sequence .
Definition script_default: script  := byte_sequence_default. (* FIXME *)

Inductive linkable_object : Type :=  RelocELF:  elf_memory_image  -> linkable_object     (* memory image without address assignments *)
                     | SharedELF:  elf_memory_image  -> linkable_object    (* memory image with address assignments *)
                     | ScriptAST:  script  -> linkable_object        (* FIXME: should be elaborated away *)
                     | ControlScriptDefs: linkable_object .
Definition linkable_object_default: linkable_object  := RelocELF elf_memory_image_default.
(* [?]: removed value specification. *)

Definition string_of_linkable_object  (l : linkable_object )  : string :=  match ( l) with 
    RelocELF(_)    => "a relocatable file (...)"
    | SharedELF(_) => "a shared library (...)"
    | ScriptAST(_) => "a linker script (...)"
    | ControlScriptDefs => "the control script"
end.

(* We keep the original input item around, hence the filename and byte sequence
 * and options. *)
Definition linkable_item : Type := ( linkable_object  * input_item  * input_options ) % type.
Definition linkable_item_default: linkable_item  := (linkable_object_default, input_item_default, input_options_default).
(* [?]: removed value specification. *)

Definition short_string_of_linkable_item  (item : (linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)  : string :=  
  match ( item) with (obj,  inp,  opts) => short_string_of_input_item inp end.
(* 

Instance x134_Show : Show linkable_object := {
     show  :=  string_of_linkable_object
}.
 *)

Definition linkable_list : Type :=  list  linkable_item .
Definition linkable_list_default: linkable_list  := DAEMON.

Definition symbol_resolution_oracle : Type :=  linkable_list  ->  nat  ->  string  ->  list  nat .
Definition symbol_resolution_oracle_default: symbol_resolution_oracle  := (fun (x131 :  linkable_list ) => (fun (x132 :  nat ) => (fun (x133 :  string ) => DAEMON))).
Definition binding : Type :=      ( ((nat  * symbol_reference  * linkable_item ) % type) * option  ((nat  * symbol_definition  * linkable_item ) % type) ) % type.
Definition binding_default: binding  := ((nat_default, symbol_reference_default, linkable_item_default), DAEMON).
Definition binding_list : Type :=  list  binding .
Definition binding_list_default: binding_list  := DAEMON.
Definition binding_map : Type :=   fmap  string   (list  ((nat  * binding ) % type)).
Definition binding_map_default: binding_map  := DAEMON.


Definition image_of_linkable_item {a b : Type}  (item : (linkable_object *b*a) % type)  : annotated_memory_image (abis.any_abi_feature ):=  match ( item) with 
    (RelocELF(image),  _,  _) => image
    | (SharedELF(image),  _,  _) => image
    | _ => DAEMON
end.
(* [?]: removed value specification. *)

Definition linkable_item_of_input_item_and_options {abifeature : Type}  (a : abi abifeature) (it : (string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type) (opts : input_options )  : (linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type:=  
    match ( (match ( it) with (fname1,  Reloc(seq),  origin) =>
  (*let _ = Missing_pervasives.errln ("Considering relocatable file " ^ fname) in*)
  elf_file.read_elf64_file seq >>=
  (fun (e : elf64_file ) =>
     return0 (RelocELF (elf_memory_image_of_elf64_file a fname1 e), it, opts))
  | (fname1,  Shared(seq),  origin) =>
  (*let _ = Missing_pervasives.errln ("Skipping shared object " ^ fname) in *)
  fail0 "unsupported input item" | (fname1,  Script(seq),  origin) =>
  (*let _ = Missing_pervasives.errln ("Skipping linker script " ^ fname) in*)
  fail0 "unsupported input item" | ( _, ControlScript,  _) =>
  DAEMON (* Incomplete Pattern at File \"linkable_list.lem\", line 82, character 12 to line 93, character 11 *)
end)) with
    
        Success(item) => item
        | Fail(str) => DAEMON
    end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition add_definition_to_map  (def_idx_and_def_and_linkable : (nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) (m : fmap (string ) (list ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type)))  : fmap (string ) (list ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type)):=  
  match ( def_idx_and_def_and_linkable) with
      (def_idx,  def,  def_linkable) =>
    match ( (fmap_lookup_by (fun (x : string ) (y : string )=> EQ)
               (def_symname def) m)) with Some curlist =>
      fmap_add (def_symname def) ((def_idx, def, def_linkable) :: curlist) m
      | None => fmap_add (def_symname def) [(def_idx, def, def_linkable)] m
    end end.
(* [?]: removed value specification. *)

Definition all_definitions_by_name  (linkables : list ((linkable_object *input_item *input_options ) % type))  : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type)):=  
    (* Now that linkables are ELF memory images, we can make the 
     * list of definitions much more easily. *)
    let list_of_deflists := lem_list.mapi (fun  (idx1 : nat ) => (fun  (item : linkable_item ) =>
        let img3 := image_of_linkable_item item
        in match ( unzip
           (multimap.lookupBy0 memory_image_orderings.tagEquiv
              (SymbolDef (null_symbol_definition)) (by_tag img3))) with
     (all_def_tags,  all_def_ranges) =>
   let all_defs := List.map
                     (fun (tag : range_tag (abis.any_abi_feature )) =>
                        match ( tag) with SymbolDef(def) => (def, item)
                          | _ => DAEMON end) all_def_tags in
 let x2 := [] in List.fold_right
                   (fun (p : (symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) (x2 : list ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type)) =>
                      match ( (p ,x2) ) with ((def,  def_linkable) ,  x2) =>
                        if true then ( idx1, def, def_linkable) :: x2 else x2
                      end) x2 all_defs end
    )) linkables
    in
    List.fold_left (fun (accum : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) => (fun (deflist : list ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type)) => 
        List.fold_left (fun (m : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) => (
  fun (p : (nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) =>
    match ( (p) ) with ( (def_idx,  def,  def_linkable)) =>
      add_definition_to_map (def_idx, def, def_linkable) m end)) deflist accum
    )) list_of_deflists fmap_empty.
 
Definition binding_oracle : Type :=  
    linkable_list  -> 
     fmap  string   (list  ((nat  * symbol_definition  * linkable_item ) % type)) ->
     ((nat  * symbol_reference  * linkable_item ) % type) ->
     option  ((nat  * symbol_definition  * linkable_item ) % type) .
Definition binding_oracle_default: binding_oracle  := (fun (x128 :  
    linkable_list ) => (fun (x129 :  fmap  string   (list  ((nat  * symbol_definition  * linkable_item ) % type))) => (fun (x130 :  ((nat  * symbol_reference  * linkable_item ) % type)) => DAEMON))).
(* [?]: removed value specification. *)

Definition resolve_one_reference_default {abifeature : Type}  (a : abi abifeature) (linkables : list (linkable_item )) (defmap : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) (ref_idx_and_ref_and_linkable : (nat *symbol_reference *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type)  : option ((nat *symbol_definition *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type) :=  
  match ( ref_idx_and_ref_and_linkable) with
      (ref_idx,  ref1,  ref_linkable) =>
    (* Get the list of all definitions whose name matches. 
     * Don't match empty names. 
     * How should we handle common symbols here?
     * A common symbol is a potential definition, so it goes in the def list.
     *)
  let defs_and_linkables_with_matching_name
  := match ( (fmap_lookup_by (fun (x : string ) (y : string )=> EQ)
                (ref_symname ref1) defmap)) with Some l => l | None => [] end
  in
  (* Filter the list by eligibility rules. 
     * Normally, 
     * 
     * - any .o file can supply any other .o file on the command line
     * - any .a file supplies only files appearing to its left
     *      i.e. "it is searched once for definitions"
     * - does a .o file supply a .a file? to both its right and left? Experimentally, YES.
     *
     * So the restrictions are
     * - archives may not supply weak references
     * - archives may only supply to the left, or to themselves, or to objects in the same group
     *)
  match ( ref_linkable) with
      (ref_obj,  (ref_fname,  ref_blob,  (ref_u,  ref_coords)),  ref_options) =>
    let ref_is_weak := beq_nat (get_elf64_symbol_binding (ref_syment ref1))
                         stb_weak in
  let def_is_eligible := (fun (p : (nat *symbol_definition *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type) =>
                            match ( (p) ) with
                                ( (def_idx,  def,  def_linkable)) =>
                              let ref_is_unnamed := ( (string_equal
                                                         (ref_symname ref1)
                                                         "")) in
                            let ref_is_to_defined_or_common_symbol := ( 
                            negb
                              (beq_nat
                                 (nat_of_elf64_half
                                    (elf64_st_shndx(ref_syment ref1)))
                                 stn_undef)) in
                            let def_sym_is_ref_sym := ( beq_nat ref_idx
                                                          def_idx &&
                                                        (beq_nat
                                                           (ref_sym_scn ref1)
                                                           (def_sym_scn def)
                                                         &&
                                                         beq_nat
                                                           (ref_sym_idx ref1)
                                                           (def_sym_idx def)))
                            in
                            match ( def_linkable) with
                                (def_obj,  (def_fname,  def_blob,  def_origin),  def_options) =>
                              match ( def_origin) with
                                  (def_u,  def_coords) =>
                                match ( match ( def_coords) with
                                            InArchive(aid,  aidx,  _,  _) :: InGroup(gid1,  gidx) :: [_] =>
                                          (Some gid1, Some aid)
                                          | InArchive(aid,  aidx,  _,  _) :: [_] =>
                                          (None, Some aid)
                                          | InGroup(gid1,  gidx) :: [_] =>
                                          (Some gid1, None) | [_] =>
                                          (None, None) | _ => DAEMON end) with
                                    (def_in_group,  def_in_archive) =>
                                  let ref_is_leftmore := nat_lteb ref_idx
                                                           def_idx in
                                (* For simplicity we include the case of "same archive" in "in group with". *)
                                let ref_is_in_group_with_def := match ( def_in_group) with
                                                                    None =>
                                                                  false
                                                                  | Some def_gid =>
                                                                  match ( ref_coords) with
                                                                    InArchive(_,  _,  _,  _) :: InGroup(gid1,  _) :: [_] =>
                                                                    beq_nat
                                                                    gid1
                                                                    def_gid
                                                                    | InGroup(gid1,  _) :: [_] =>
                                                                    beq_nat
                                                                    gid1
                                                                    def_gid
                                                                    | _ =>
                                                                    false end
                                                                end in
                                (* but maybe same archive? *)
                                (* DEBUGGING: print some stuff out if we care about this symbol. *) let _ :=
                                if (string_equal ref_fname "backtrace.o") &&
                                   (string_equal (def_symname def)
                                      "_Unwind_GetCFA") then
                                  (*Missing_pervasives.errln ("saw backtrace.o referencing _Unwind_GetCFA; coords are "
                    ^ "def: " ^ (show def_coords) ^ ", ref: " ^ (show ref_coords) ^ "; ref_is_in_group_with_def: " 
                    ^ (show ref_is_in_group_with_def) ^ "; def_in_group: " ^ (show def_in_group))*)
                                  tt else tt in
                                let ref_and_def_are_in_same_archive := 
                                match ( (def_coords, ref_coords)) with
                                    (InArchive(x1,  _,  _,  _) :: _,  InArchive(x2,  _,  _,  _) :: _) =>
                                  beq_nat x1 x2 | _ => false end in
                                let def_is_in_archive := match ( def_in_archive) with
                                                             Some _ => true
                                                           | None => false
                                                         end in
                                if ref_is_to_defined_or_common_symbol then
                                  def_sym_is_ref_sym else
                                  if ref_is_unnamed then false else
                                    if def_is_in_archive then
                                      (negb ref_is_weak) &&
                                      (
                                      ref_is_leftmore ||
                                      (ref_and_def_are_in_same_archive ||
                                       ref_is_in_group_with_def) ) else 
                                    true end end end end ) in
  let eligible_defs := List.filter def_is_eligible
                         defs_and_linkables_with_matching_name in
  match ( match ( eligible_defs) with [] => (None, None, None)
            | [(def_idx,  def,  def_linkable)] =>
            (Some def_idx, Some def, Some def_linkable)
            | (d_idx,  d,  d_l) :: more_pairs =>
            (* Break ties by which definition appeared first in the left-to-right order. *)
          let sorted := insertSortBy
                          (fun (p : (nat *symbol_definition *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type) =>
                             match ( (p) ) with ( (d_idx1,  d1,  d_l1)) =>
                               (fun (p : (nat *symbol_definition *((linkable_object *((string *input_blob *((command_line.input_unit *list (origin_coord )) % type)) % type)*input_options ) % type)) % type) =>
                                  match ( (p) ) with
                                      ( (d_idx2,  d2,  d_l2)) =>
                                    nat_ltb d_idx1 d_idx2 end) end)
                          eligible_defs in
          match ( sorted) with (first_d_idx,  first_d,  first_d_l) :: _ =>
            (Some first_d_idx, Some first_d, Some first_d_l) | _ => DAEMON
          end end) with
      (maybe_target_def_idx,  maybe_target_def,  maybe_target_def_linkable) =>
    (*let refstr = "`" 
                ^ ref.ref_symname ^ "' (" ^ 
                (if (natural_of_elf64_half ref.ref_syment.elf64_st_shndx) = shn_undef then "UND" else "defined") ^ 
                " symbol at index " ^ (show ref.ref_sym_idx) ^ " in symtab "
                ^ (show ref.ref_sym_scn) ^ " in " ^ ref_fname
                ^ ")"
    in
    let _ = Missing_pervasives.errs ("Bound a reference from " ^ refstr ^ " to ")
    in*)
    match ( (maybe_target_def_idx, maybe_target_def, maybe_target_def_linkable)) with
        (Some target_def_idx,  Some target_def,  Some target_def_linkable) =>
      (*let _ = Missing_pervasives.errln (" a definition in "^ (show (target_def_linkable)))
            in*)
      Some (target_def_idx, target_def, target_def_linkable)
      | (None,  None,  None) =>
      (*let _ = Missing_pervasives.errln " no definition"
            in*)
      if ref_is_weak (* || a.symbol_is_generated_by_linker ref.ref_symname *) then
        None else (* failwith ("undefined symbol: " ^ refstr) *) None
    (* FIXME: do a check, *after* the linker script has been interpreted, 
             * that all remaining undefined symbols are permitted by the ABI/policy. *)
      | _ => DAEMON end end end end.
(* [?]: removed value specification. *)

Definition resolve_all  (linkables : list (linkable_item )) (all_defs : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) (oracle : list (linkable_item ) -> fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type)) -> (nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type -> option ((nat *symbol_definition *linkable_item ) % type) ) (refs : list ((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type))  : list ((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type):=  
    List.map (fun (p : (nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type) =>
  match ( (p) ) with ( (ref_idx,  ref1,  ref_linkable)) =>
    ((ref_idx, ref1, ref_linkable), (oracle linkables all_defs
                                       (ref_idx, ref1, ref_linkable))) end) refs.
(* [?]: removed value specification. *)

Definition resolve_undefs_in_one_object  (linkables : list ((linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)) (all_defs : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) (oracle : linkable_list  -> fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type)) -> (nat *symbol_reference *linkable_item ) % type -> option ((nat *symbol_definition *linkable_item ) % type) ) (idx1 : nat )  : list ((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type):= 
    (* Get this object's list of references *)
    let item := match ( lem_list.index linkables ( idx1)) with 
        Some it => it
        | None => DAEMON
    end
    in
    let img3 := image_of_linkable_item item
    in match ( unzip
           (multimap.lookupBy0 memory_image_orderings.tagEquiv
              (SymbolRef (null_symbol_reference_and_reloc_site))
              (by_tag img3))) with (all_ref_tags,  all_ref_ranges) =>
   (* By using SymbolRef, we are extracting and binding each relocation site individually. 
     * since there might be more than one relocation site referencing the same symbol name, 
     * in a given object.
     * 
     * We are also binding SymbolRefs that have no relocation, which occur when there's
     * an UND symbol which is not actually used by a relocation site, but is nevertheless 
     * in need of being resolved.
     * 
     * We don't (for the moment) want to make different decisions for different reloc sites
     * in the same object referencing the same symbol. So we dedup from a list to a set.
     *)
 let all_refs := (set_from_list_by
                    (fun (x : symbol_reference ) (y : symbol_reference )=> EQ)
                    (List.map
                       (fun (tag : range_tag (abis.any_abi_feature )) =>
                          match ( tag) with SymbolRef(r) => (ref r) | _ =>
                            DAEMON end) all_ref_tags)) in
 let ref_triples := let x2 := [] in set_fold
                                      (fun (ref1 : symbol_reference ) (x2 : set ((nat *symbol_reference *((linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)) % type)) =>
                                         if true then
                                           set_add (idx1, ref1, item) x2 else
                                           x2) all_refs x2 in
 (*let _ = Missing_pervasives.errln ("object " ^ (show item) ^ " has " ^ 
        (show (Set.size ref_triples)) ^ " reloc references (symname, sym_scn, sym_idx, st_shndx) (" ^ 
        (show (List.map (fun x -> ("\"" ^ x.ref_symname ^ "\"", x.ref_sym_scn, x.ref_sym_idx, natural_of_elf64_half x.ref_syment.elf64_st_shndx)) (Set_extra.toList all_refs))) ^ ")")
    in*)
 let und_ref_triples := let x2 := [] in set_fold
                                          (fun (p : (nat *symbol_reference *((linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)) % type) (x2 : set ((nat *symbol_reference *((linkable_object *((string *input_blob *input_origin ) % type)*input_options ) % type)) % type)) =>
                                             match ( (p ,x2) ) with
                                                 ((idx1,  ref1,  ref_item) ,  x2) =>
                                               if beq_nat
                                                    (nat_of_elf64_half
                                                       (elf64_st_shndx(ref_syment ref1)))
                                                    shn_undef then
                                                 set_add
                                                   (idx1, ref1, ref_item) 
                                                 x2 else x2 end) ref_triples
                                          x2 in
 (*let _ = Missing_pervasives.errln ("... of which " ^
        (show (Set.size und_ref_triples)) ^ " are to undefined symbols: (symname, sym_scn, sym_idx, st_shndx) (" ^ 
        (show (List.map (fun (idx, x, _) -> ("\"" ^ x.ref_symname ^ "\"", x.ref_sym_scn, x.ref_sym_idx, natural_of_elf64_half x.ref_syment.elf64_st_shndx)) (Set_extra.toList und_ref_triples))) ^ ")")
    in*)
 resolve_all linkables all_defs oracle (set_to_list ref_triples) end.
(* [?]: removed value specification. *)
  (* all accumulated bindings bindings *)
Program Fixpoint accumulate_bindings_bf {abifeature : Type}  (a : abi abifeature) (linkables : list (linkable_item )) (all_defs : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) (fully_bound : set (nat )) (to_bind : list (nat )) (bindings_accum : list ((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type))  : list ((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type):= 
    (* This is like foldl, except that each stage
     * can add stuff to the work list *)
    match ( to_bind) with  
        [] => bindings_accum (* termination *)
        | l_idx :: more_idx =>
            (* Get the new bindings for this object *)
            let new_bindings := resolve_undefs_in_one_object
                linkables
                all_defs
                (resolve_one_reference_default a)
                l_idx
            in
            let new_fully_bound := set_add l_idx fully_bound
            in
            (* Which of the new bindings are to objects 
             * not yet fully bound or not yet in the to-bind list? *)
            let new_bindings_def_idx := list_concat_map (
  fun (p : (((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type) =>
    match ( (p) ) with ( (ref1,  maybe_def_and_idx_and_linkable)) =>
      match ( maybe_def_and_idx_and_linkable) with
          Some (def_idx,  def,  def_linkable) => [def_idx] | None => [] end
    end
            ) new_bindings 
            in
            let new_bindings_def_idx_set := (set_from_list_by (genericCompare nat_ltb beq_nat) new_bindings_def_idx)
            in
            let included_linkables_idx := (set_union_by (genericCompare nat_ltb beq_nat) fully_bound ((set_from_list_by (genericCompare nat_ltb beq_nat) to_bind)))
            in
            let new_l_idx := (set_diff_by (genericCompare nat_ltb beq_nat) new_bindings_def_idx_set included_linkables_idx)
            in
            let new_l_idx_list := set_to_list new_l_idx
            in
            (*let _ = Missing_pervasives.errln (
                if List.null new_l_idx_list 
                then
                    "Fully bound references in  " ^ (show (List.index linkables (natFromNatural l_idx)))
                        ^ " using only already-included linkables (" 
                        ^ (show (List.map (fun i -> List.index linkables (natFromNatural i)) (Set_extra.toList included_linkables_idx)))
                else
                    "Including additional linkables "
                    ^ (show (List.mapMaybe (fun i -> List.index linkables (natFromNatural i)) new_l_idx_list))
                    )
            in*)
            accumulate_bindings_bf
                a
                linkables
                all_defs
                new_fully_bound
                ( (@ List.app _)more_idx new_l_idx_list)
                ( (@ List.app _)bindings_accum new_bindings)
    end.
(* [?]: removed value specification. *)
  (* all accumulated bindings bindings *)
Program Fixpoint accumulate_bindings_objectwise_df {abifeature : Type}  (a : abi abifeature) (linkables : list (linkable_item )) (all_defs : fmap (string ) (list ((nat *symbol_definition *linkable_item ) % type))) (bindings_accum : list ((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)) (blacks : set (nat )) (greys : list (nat ))  : list ((((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type):= 
    match ( greys) with  
        [] => bindings_accum (* termination *)
        | l_idx :: more_idx =>
            (* Get the new bindings for this object *)
            let new_bindings := resolve_undefs_in_one_object
                linkables
                all_defs
                (resolve_one_reference_default a)
                l_idx
            in 
            (* We pull in the whole object at a time ("objectwise"), so by definition,
             * we have created bindings for everything in this object; it's now black. *)
            let new_fully_bound := set_add l_idx blacks
            in
            (* Which of the new bindings are to objects 
             * not yet fully bound or not yet in the to-bind list? *)
            let new_bindings_def_idx := list_concat_map (
  fun (p : (((nat *symbol_reference *linkable_item ) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type) =>
    match ( (p) ) with ( (ref1,  maybe_def_and_idx_and_linkable)) =>
      match ( maybe_def_and_idx_and_linkable) with
          Some (def_idx,  def,  def_linkable) => [def_idx] | None => [] end
    end
            ) new_bindings 
            in
            let new_bindings_def_idx_set := (set_from_list_by (genericCompare nat_ltb beq_nat) new_bindings_def_idx)
            in
            (* this is the "black or grey" set. *)
            let included_linkables_idx := (set_union_by (genericCompare nat_ltb beq_nat) blacks ((set_from_list_by (genericCompare nat_ltb beq_nat) greys)))
            in
            (* these are the white ones that we're adjacent to *)
            let new_l_idx := (set_diff_by (genericCompare nat_ltb beq_nat) new_bindings_def_idx_set included_linkables_idx)
            in
            let new_l_idx_list := set_to_list new_l_idx
            in
            (* What is the new grey-alike list? (This is the list we tail-recurse down.)
             * It's
             * - the existing grey-alike list
             * - with any new (were-white) objects prepended
             * - ... and filtered to *remove* these from the existing list (avoid duplication).
             *)
            let new_grey_list :=  (@ List.app _)new_l_idx_list (List.filter (fun (x : nat ) => negb ( (set_member_by (genericCompare nat_ltb beq_nat)x new_l_idx))) more_idx)
            in
            (* whether or not we've not uncovered any new white nodes, we tail-recurse  *)
            (*let _ = (if List.null new_l_idx_list then
                Missing_pervasives.errln ("Fully bound references in  " ^ (show (List.index linkables (natFromNatural l_idx)))
                    ^ " using only already-included linkables (" 
                    ^ (show (List.map (fun i -> List.index linkables (natFromNatural i)) (Set_extra.toList included_linkables_idx)))
                ) else Missing_pervasives.errln ("Including additional linkables "
            ^ (show (List.mapMaybe (fun i -> List.index linkables (natFromNatural i)) new_l_idx_list))))
            in*)
            accumulate_bindings_objectwise_df
                a
                linkables
                all_defs
                ( (@ List.app _)bindings_accum new_bindings)
                (new_fully_bound :  set  nat )
                (new_grey_list :  list  nat )
   end.

(* Rather than recursively expanding the link by searching for definitions of undefs, 
 * the GNU linker works by recursing/looping along the list of *linkables*, testing whether
 * any of the defs satisfies a currently-undef'd thing. On adding a new undef'd thing, 
 * we re-search only from the current archive, not from the beginning (i.e. the 
 * "def_is_leftmore or def_in_same_archive" logic).
 *
 * Why is this not the same as depth-first? One example is if we pull in a new object
 * which happens to have two undefs: one satisfied by the *first* element in the current archive,
 * and one satisfied by the last. 
 * 
 * In the GNU algorithm, we'll pull in the first archive element immediately afterwards, because
 * we'll re-traverse the archive and find it's needed.
 * 
 * In the depth-first algorithm, it depends entirely on the ordering of the new bindings, i.e.
 * the symtab ordering of the two undefs. If the later-in-archive def was bound *first*, we'll
 * recurse down *that* object's dependencies first.
 * 
 * So if we sort the new grey list
 * so that bindings formed in order of *current archive def pos*,
 * will we get the same behaviour?
 * We can't really do this, because we have no "current archive".
 * 
 * Need to rewrite the algorithm to fold along the list of linkables.
 *)
