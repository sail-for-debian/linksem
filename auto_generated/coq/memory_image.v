(* Generated by Lem from memory_image.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_map.
Require Export lem_map.

Require Import lem_map_extra.
Require Export lem_map_extra.

Require Import lem_set.
Require Export lem_set.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import multimap.
Require Export multimap.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import show.
Require Export show.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import elf_file.
Require Export elf_file.

Require Import elf_header.
Require Export elf_header.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_program_header_table.
Require Export elf_program_header_table.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_relocation.
Require Export elf_relocation.


Require Import missing_pervasives.
Require Export missing_pervasives.




(* Now we can define memory images *)

Definition byte_pattern_element : Type :=  option  elf_types_local.byte  .
Definition byte_pattern_element_default: byte_pattern_element  := DAEMON.
Definition byte_pattern : Type :=  list  byte_pattern_element .
Definition byte_pattern_default: byte_pattern  := DAEMON.

(* An element might have an address/offset, and it has some contents. *)
Record element : Type := { startpos : option  nat   
                ; length1   : option  nat  
                ; contents : byte_pattern 
                }.
Notation "{[ r 'with' 'startpos' := e ]}" := ({| startpos := e; length1 := length1 r; contents := contents r |}).
Notation "{[ r 'with' 'length1' := e ]}" := ({| length1 := e; startpos := startpos r; contents := contents r |}).
Notation "{[ r 'with' 'contents' := e ]}" := ({| contents := e; startpos := startpos r; length1 := length1 r |}).
Definition element_default: element  := {| startpos := DAEMON; length1 := DAEMON; contents := byte_pattern_default |}.

(* HMM -- ideally I want to fold these into the memory image notion
 * and the startpos thingy. *)
Definition allocated_symbols_map : Type :=  fmap  string   ((nat  * nat ) % type).
Definition allocated_symbols_map_default: allocated_symbols_map  := DAEMON. (* start, length *)

(* Instead of modelling address calculations (in linker scripts) like so:

type address_expr = natural -> allocated_symbols_map -> natural
                  ( pos     -> environment           -> result address )
                  
   ... we model it as expressions in terms of CursorPosition. HMM.
*) 

Inductive expr_operand : Type :=  Var:  string  -> expr_operand 
                   | CursorPosition: expr_operand           (* only valid in certain expressions... HMM *)
                   | Constant:  nat  -> expr_operand 
                   | UnOp:  ((expr_unary_operation  * expr_operand ) % type) -> expr_operand 
                   | BinOp:  ((expr_binary_operation  * expr_operand  * expr_operand ) % type) -> expr_operand 
with
expr_unary_operation : Type :=  Neg:  expr_operand  ->
expr_unary_operation 
                           | BitwiseInverse:  expr_operand  ->
expr_unary_operation 
with 
expr_binary_operation : Type :=  Add:  ((expr_operand  * expr_operand ) % type) -> 
expr_binary_operation 
                           | Sub:  ((expr_operand  * expr_operand ) % type) -> 
expr_binary_operation 
                           | BitwiseAnd:  ((expr_operand  * expr_operand ) % type) -> 
expr_binary_operation 
                           | BitwiseOr:  ((expr_operand  * expr_operand ) % type) -> 
expr_binary_operation .
Definition expr_operand_default: expr_operand  := Var string_default.
Definition expr_unary_operation_default: expr_unary_operation  := Neg expr_operand_default.
Definition expr_binary_operation_default: expr_binary_operation  := Add (expr_operand_default, expr_operand_default).

Inductive expr_binary_relation : Type :=  
    Lt: expr_binary_relation 
    | Lte: expr_binary_relation 
    | Gt: expr_binary_relation 
    | Gte: expr_binary_relation 
    | Eq: expr_binary_relation 
    | Neq: expr_binary_relation .
Definition expr_binary_relation_default: expr_binary_relation  := Lt.

Inductive expr : Type :=  
    False: expr 
    | True: expr 
    | Not:  expr  -> expr 
    | And:  ((expr  * expr ) % type) -> expr 
    | Or:  ((expr  * expr ) % type) -> expr 
    | BinRel:  ((expr_binary_relation  * expr_operand ) % type) -> expr .
Definition expr_default: expr  := False.  (* LH operand is the expr's value *)

(*
val cond_expr : expr -> expr -> expr -> expr
let cond_expr expr1 expr2 expr3 = (Or((And(expr1, expr2)), (And((Not(expr1)), expr3))))
*)

(* Memory image elements all have identities. For convenience
 * we make the identities strings. The string contents are arbitrary,
 * and only their equality is relevant, but choosing friendly names
 * like "ELF header" is good practice.*)
Definition memory_image : Type :=  fmap  string   element .
Definition memory_image_default: memory_image  := DAEMON.

Definition range : Type := ( nat  * nat ) % type.
Definition range_default: range  := (nat_default, nat_default). (* start, length *)

Definition element_range : Type := ( string  * range ) % type.
Definition element_range_default: element_range  := (string_default, range_default).

(* An "element" of an ELF image, in the linking phase, is either a section,
 * the ELF header, the section header table or the program header table.
 * 
 * PROBLEM: We'd like to use section names as the identifiers
 * for those elements that are sections.
 * but we can't, because they are not guaranteed to be unique. 
 * 
 * SOLUTION: Names that are unique in the file are used as keys. 
 * If not unique, the sections are treated as anonymous and given
 * gensym'd string ids (FIXME: implement this).
 *)

(* Currently, our elements have unique names, which are strings.
 * We *don't* want to encode any meaning onto these strings.
 * All meaning should be encoded into labelled ranges.
 * We want to be able to look up 
 *
 * - elements
 * - ranges within elements
 * 
 * ... by their *labels* -- or sometimes just *part* of their labels.
 *)

(* ELF file features with which we can label ranges of the memory image. *)
Inductive elf_file_feature : Type :=  
    ElfHeader:  elf64_header  -> elf_file_feature 
    | ElfSectionHeaderTable:  elf64_section_header_table  -> elf_file_feature  (* do we want to expand these? *)
    | ElfProgramHeaderTable:  elf64_program_header_table  -> elf_file_feature 
    | ElfSection:  ((nat  * elf64_interpreted_section ) % type) -> elf_file_feature  (* SHT idx *)
    | ElfSegment:  ((nat  * elf64_interpreted_segment ) % type) -> elf_file_feature .
Definition elf_file_feature_default: elf_file_feature  := ElfHeader elf64_header_default. (* PHT idx *)

Record symbol_definition : Type
 := { def_symname : string 
    ; def_syment : elf64_symbol_table_entry  (* definition's symtab entry *)
    ; def_sym_scn : nat                  (* symtab section index, to disamiguate dynsym *)
    ; def_sym_idx : nat                  (* index of symbol into the symtab *)
    ; def_linkable_idx : nat             (* used to propagate origin linkable information to linked image *)
    }.
Notation "{[ r 'with' 'def_symname' := e ]}" := ({| def_symname := e; def_syment := def_syment r; def_sym_scn := def_sym_scn r; def_sym_idx := def_sym_idx r; def_linkable_idx := def_linkable_idx r |}).
Notation "{[ r 'with' 'def_syment' := e ]}" := ({| def_syment := e; def_symname := def_symname r; def_sym_scn := def_sym_scn r; def_sym_idx := def_sym_idx r; def_linkable_idx := def_linkable_idx r |}).
Notation "{[ r 'with' 'def_sym_scn' := e ]}" := ({| def_sym_scn := e; def_symname := def_symname r; def_syment := def_syment r; def_sym_idx := def_sym_idx r; def_linkable_idx := def_linkable_idx r |}).
Notation "{[ r 'with' 'def_sym_idx' := e ]}" := ({| def_sym_idx := e; def_symname := def_symname r; def_syment := def_syment r; def_sym_scn := def_sym_scn r; def_linkable_idx := def_linkable_idx r |}).
Notation "{[ r 'with' 'def_linkable_idx' := e ]}" := ({| def_linkable_idx := e; def_symname := def_symname r; def_syment := def_syment r; def_sym_scn := def_sym_scn r; def_sym_idx := def_sym_idx r |}).
Definition symbol_definition_default: symbol_definition  := {| def_symname := string_default; def_syment := elf64_symbol_table_entry_default; def_sym_scn := nat_default; def_sym_idx := nat_default; def_linkable_idx := nat_default |}.

Definition symDefCompare  (x1 : symbol_definition ) (x2 : symbol_definition )  : ordering :=         
(quadrupleCompare (fun (x : string ) (y : string )=>EQ) elf64_symbol_table_entry_compare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) ((def_symnamex1),(def_syment x1),(def_sym_scn x1),(def_sym_idx x1))
                ((def_symnamex2),(def_syment x2),(def_sym_scn x2),(def_sym_idx x2))).

Instance x108_Ord : Ord symbol_definition := {
     compare  :=  symDefCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symDefCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symDefCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symDefCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symDefCompare f1 f2) [GT;  EQ]))
}.


Record symbol_reference : Type
 := { ref_symname : string                   (* symbol name *)
    ; ref_syment : elf64_symbol_table_entry  (* likely-undefined (referencing) symbol *)
    ; ref_sym_scn : nat                  (* symtab section idx *) 
    ; ref_sym_idx : nat                  (* index into symbol table *)
    }.
Notation "{[ r 'with' 'ref_symname' := e ]}" := ({| ref_symname := e; ref_syment := ref_syment r; ref_sym_scn := ref_sym_scn r; ref_sym_idx := ref_sym_idx r |}).
Notation "{[ r 'with' 'ref_syment' := e ]}" := ({| ref_syment := e; ref_symname := ref_symname r; ref_sym_scn := ref_sym_scn r; ref_sym_idx := ref_sym_idx r |}).
Notation "{[ r 'with' 'ref_sym_scn' := e ]}" := ({| ref_sym_scn := e; ref_symname := ref_symname r; ref_syment := ref_syment r; ref_sym_idx := ref_sym_idx r |}).
Notation "{[ r 'with' 'ref_sym_idx' := e ]}" := ({| ref_sym_idx := e; ref_symname := ref_symname r; ref_syment := ref_syment r; ref_sym_scn := ref_sym_scn r |}).
Definition symbol_reference_default: symbol_reference  := {| ref_symname := string_default; ref_syment := elf64_symbol_table_entry_default; ref_sym_scn := nat_default; ref_sym_idx := nat_default |}.

Definition symRefCompare  (x1 : symbol_reference ) (x2 : symbol_reference )  : ordering :=         
(quadrupleCompare (fun (x : string ) (y : string )=>EQ) elf64_symbol_table_entry_compare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) ((ref_symnamex1),(ref_syment x1),(ref_sym_scn x1),(ref_sym_idx x1))
                ((ref_symnamex2),(ref_syment x2),(ref_sym_scn x2),(ref_sym_idx x2))).
                
Instance x107_Ord : Ord symbol_reference := {
     compare  :=  symRefCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symRefCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symRefCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symRefCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symRefCompare f1 f2) [GT;  EQ]))
}.


Record reloc_site : Type := {
      ref_relent  : elf64_relocation_a  
    ; ref_rel_scn : nat   (* the relocation section idx *)
    ; ref_rel_idx : nat   (* the index of the relocation rec *)
    ; ref_src_scn : nat   (* the section *from which* the reference logically comes *)
}.
Notation "{[ r 'with' 'ref_relent' := e ]}" := ({| ref_relent := e; ref_rel_scn := ref_rel_scn r; ref_rel_idx := ref_rel_idx r; ref_src_scn := ref_src_scn r |}).
Notation "{[ r 'with' 'ref_rel_scn' := e ]}" := ({| ref_rel_scn := e; ref_relent := ref_relent r; ref_rel_idx := ref_rel_idx r; ref_src_scn := ref_src_scn r |}).
Notation "{[ r 'with' 'ref_rel_idx' := e ]}" := ({| ref_rel_idx := e; ref_relent := ref_relent r; ref_rel_scn := ref_rel_scn r; ref_src_scn := ref_src_scn r |}).
Notation "{[ r 'with' 'ref_src_scn' := e ]}" := ({| ref_src_scn := e; ref_relent := ref_relent r; ref_rel_scn := ref_rel_scn r; ref_rel_idx := ref_rel_idx r |}).
Definition reloc_site_default: reloc_site  := {| ref_relent := elf64_relocation_a_default; ref_rel_scn := nat_default; ref_rel_idx := nat_default; ref_src_scn := nat_default |}.

Definition relocSiteCompare  (x1 : reloc_site ) (x2 : reloc_site )  : ordering :=         
(tripleCompare elf64_relocation_a_compare (genericCompare nat_ltb beq_nat) (genericCompare nat_ltb beq_nat) ((ref_relentx1),(ref_rel_idx x1),(ref_src_scn x1))
                ((ref_relentx2),(ref_rel_idx x2),(ref_src_scn x2))).
                
Instance x106_Ord : Ord reloc_site := {
     compare  :=  relocSiteCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (relocSiteCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (relocSiteCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (relocSiteCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (relocSiteCompare f1 f2) [GT;  EQ]))
}.

    
Inductive reloc_decision : Type :=  LeaveReloc: reloc_decision 
                    | ApplyReloc:  option  ((nat  * symbol_reference  * reloc_site ) % type)  -> reloc_decision  (* change before apply *)
                    | ChangeRelocTo:  ((nat  * symbol_reference  * reloc_site ) % type) -> reloc_decision .
Definition reloc_decision_default: reloc_decision  := LeaveReloc.
                    (* | MakePIC    -- is now a kind of ChangeRelocTo *)

Record symbol_reference_and_reloc_site : Type := {
      ref         : symbol_reference 
    ; maybe_reloc : option  reloc_site  
    ; maybe_def_bound_to : option  ((reloc_decision  * option  symbol_definition  ) % type) 
    }.
Notation "{[ r 'with' 'ref' := e ]}" := ({| ref := e; maybe_reloc := maybe_reloc r; maybe_def_bound_to := maybe_def_bound_to r |}).
Notation "{[ r 'with' 'maybe_reloc' := e ]}" := ({| maybe_reloc := e; ref := ref r; maybe_def_bound_to := maybe_def_bound_to r |}).
Notation "{[ r 'with' 'maybe_def_bound_to' := e ]}" := ({| maybe_def_bound_to := e; ref := ref r; maybe_reloc := maybe_reloc r |}).
Definition symbol_reference_and_reloc_site_default: symbol_reference_and_reloc_site  := {| ref := symbol_reference_default; maybe_reloc := DAEMON; maybe_def_bound_to := DAEMON |}.

Definition symRefAndRelocSiteCompare  (x1 : symbol_reference_and_reloc_site ) (x2 : symbol_reference_and_reloc_site )  : ordering :=         
(pairCompare symRefCompare (maybeCompare relocSiteCompare) ((refx1),(maybe_reloc x1))
                ((refx2),(maybe_reloc x2))).

Instance x105_Ord : Ord symbol_reference_and_reloc_site := {
     compare  :=  symRefAndRelocSiteCompare;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symRefAndRelocSiteCompare f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symRefAndRelocSiteCompare f1 f2) [LT;  EQ]));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (symRefAndRelocSiteCompare f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => (set_member_by (fun  x  y=>EQ) (symRefAndRelocSiteCompare f1 f2) [GT;  EQ]))
}.


(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella "ELF" type to the relevant types in each case? *)
Inductive range_tag (abifeature : Type) : Type :=  (*  forall 'abifeature . *)
                 ImageBase: range_tag abifeature
               | EntryPoint: range_tag abifeature
               | SymbolDef:  symbol_definition  -> range_tag abifeature
               | SymbolRef:  symbol_reference_and_reloc_site  -> range_tag abifeature
               | FileFeature:  elf_file_feature  -> range_tag abifeature (* file feature other than symdef and reloc *)
               | AbiFeature:  abifeature -> range_tag abifeature.
Definition range_tag_default{abifeature: Type} : range_tag abifeature := ImageBase.

Record annotated_memory_image (abifeature: Type) : Type := {
      elements         : memory_image  
    ; by_range         : set  (((option  element_range  ) * (range_tag  abifeature)) % type)
    ; by_tag           : multimap  (range_tag  abifeature)  (option  element_range  )
}.
Notation "{[ r 'with' 'elements' := e ]}" := ({| elements := e; by_range := by_range r; by_tag := by_tag r |}).
Notation "{[ r 'with' 'by_range' := e ]}" := ({| by_range := e; elements := elements r; by_tag := by_tag r |}).
Notation "{[ r 'with' 'by_tag' := e ]}" := ({| by_tag := e; elements := elements r; by_range := by_range r |}).
Definition annotated_memory_image_default{abifeature: Type} : annotated_memory_image abifeature := {| elements := memory_image_default; by_range := DAEMON; by_tag := DAEMON |}.
(* [?]: removed value specification. *)

Definition get_empty_memory_image {abifeature : Type}   : unit  -> annotated_memory_image abifeature:=  fun  _ : unit  => {|elements := fmap_empty
    ;by_range := set_empty
    ;by_tag   := set_empty
|}.

(* Basic ELFy and ABI-y things. *)
(* FIXME: shouldn't really be here, but need to be in some low-lying module, and 
 * keeping out of elf_* for now to avoid duplication into elf64_, elf32_. *)
Definition elf_section_is_special {a : Type}  (s : elf64_interpreted_section ) (f : a)  : bool :=  negb (beq_nat(elf64_section_type s) sht_progbits)
                     && negb (beq_nat(elf64_section_type s) sht_nobits).

(* This record collects things that ABIs may or must define. 
 * 
 * Since we want to put all ABIs in a list and select one at run time, 
 * we can't maintain a type-level distinction between ABIs; we have to
 * use elf_memory_image any_abi_feature. To avoid a reference cycle,
 * stay polymorphic in the ABI feature type until we define specific ABIs.
 * In practice we'll use only any_abi_feature, because we need to pull
 * the ABI out of a list at run time.
 *)
Definition null_abi_feature : Type :=  unit .
Definition null_abi_feature_default: null_abi_feature  := unit_default.

(* The reloc calculation is complicated, so we split up the big function
 * type into smaller ones. *)

(* Q. Do we want "existing", or is it a kind of addend? 
 * A. We do want it -- modelling both separately is necessary, 
 * because we model relocations bytewise, but some arches
 * do bitfield relocations (think ARM). *)
Definition reloc_calculate_fn : Type :=     nat  ->  Z  ->  nat  ->  nat .
Definition reloc_calculate_fn_default: reloc_calculate_fn  := (fun (x102 :  nat ) => (fun (x103 :  Z ) => (fun (x104 :  nat ) => nat_default))). (* symaddr -> addend -> existing -> relocated *)

Definition reloc_apply_fn (abifeature: Type) : Type :=  
                                (* elf memory image: the context in which the relocation is being applied *)
                                annotated_memory_image  abifeature -> 
                               (* the site address *)
                                nat  -> 
                                (* Typically there are two symbol table entries involved in a relocation.
                                 * One is the reference, and is usually undefined.
                                 * The other is the definition, and is defined (else absent, when we use 0).
                                 * However, sometimes the reference is itself a defined symbol.
                                 * Almost always, if so, *that* symbol *is* "the definition".
                                 * However, copy relocs are an exception.
                                 * 
                                 * In the case of copy relocations being fixed up by the dynamic
                                 * linker, the dynamic linker must figure out which definition to
                                 * copy from. This can't be as simple as "the first definition in
                                 * link order", because *our* copy of that symbol is a definition
                                 * (typically in bss). It could be as simple as "the first *after us*
                                 * in link order". FIXME: find the glibc code that does this.
                                 * 
                                 * Can we dig this stuff out of the memory image? If we pass the address
                                 * being relocated, we can find the tags. But I don't want to pass
                                 * the symbol address until the very end. It seems better to pass the symbol
                                 * name, since that's the key that the dynamic linker uses to look for
                                 * other definitions.
                                 * 
                                 * Do we want to pass a whole symbol_reference? This has not only the
                                 * symbol name but also syment, scn and idx. The syment is usually UND, 
                                 * but *could* be defined (and is for copy relocs). The scn and idx are
                                 * not relevant, but it seems cleaner to pass the whole thing anyway.
                                 *)
                                symbol_reference_and_reloc_site  ->  
                                (* Should we pass a symbol_definition too? Implicitly, we pass part of it
                                 * by passing the symaddr argument (below). I'd prefer not to depend on
                                 * others -- relocation calculations should look like "mostly address 
                                 * arithmetic", i.e. only the weird ones do something else. *)
                                 (* How wide, in bytes, is the relocated field? this may depend on img 
                                 * and on the wider image (copy relocs), so it's returned *by* the reloc function. *)
                                ((nat  (* width *) * reloc_calculate_fn ) % type).
Definition reloc_apply_fn_default{abifeature: Type} : reloc_apply_fn abifeature := (fun (x99 :  
                                (* elf memory image: the context in which the relocation is being applied *)
                                annotated_memory_image  abifeature) => (fun (x100 : 
                               (* the site address *)
                                nat ) => (fun (x101 : 
                                (* Typically there are two symbol table entries involved in a relocation.
                                 * One is the reference, and is usually undefined.
                                 * The other is the definition, and is defined (else absent, when we use 0).
                                 * However, sometimes the reference is itself a defined symbol.
                                 * Almost always, if so, *that* symbol *is* "the definition".
                                 * However, copy relocs are an exception.
                                 * 
                                 * In the case of copy relocations being fixed up by the dynamic
                                 * linker, the dynamic linker must figure out which definition to
                                 * copy from. This can't be as simple as "the first definition in
                                 * link order", because *our* copy of that symbol is a definition
                                 * (typically in bss). It could be as simple as "the first *after us*
                                 * in link order". FIXME: find the glibc code that does this.
                                 * 
                                 * Can we dig this stuff out of the memory image? If we pass the address
                                 * being relocated, we can find the tags. But I don't want to pass
                                 * the symbol address until the very end. It seems better to pass the symbol
                                 * name, since that's the key that the dynamic linker uses to look for
                                 * other definitions.
                                 * 
                                 * Do we want to pass a whole symbol_reference? This has not only the
                                 * symbol name but also syment, scn and idx. The syment is usually UND, 
                                 * but *could* be defined (and is for copy relocs). The scn and idx are
                                 * not relevant, but it seems cleaner to pass the whole thing anyway.
                                 *)
                                symbol_reference_and_reloc_site ) => (nat_default, reloc_calculate_fn_default)))).

(* Some kinds of relocation necessarily give us back a R_*_RELATIVE reloc.
 * We don't record this explicitly. Instead, the "bool" is a flag recording whether
 * the field represents an absolute address.
 * Similarly, some relocations can "fail" according to their ABI manuals.
 * This just means that the result can't be represented in the field width.
 * We detect this when actually applying the reloc in the memory image content
 * (done elsewhere). *)
Definition reloc_fn (abifeature: Type) : Type :=  nat  ->  ((bool  * reloc_apply_fn  abifeature) % type).
Definition reloc_fn_default{abifeature: Type} : reloc_fn abifeature := (fun (x98 :  nat ) => (bool_default, DAEMON)).
(* [?]: removed value specification. *)

Definition noop_reloc_calculate  (symaddr : nat ) (addend : Z ) (existing : nat )  : nat :=  existing.
(* [?]: removed value specification. *)

Definition noop_reloc_apply {abifeature : Type}  (img3 : annotated_memory_image abifeature) (site_addr : nat ) (ref1 : symbol_reference_and_reloc_site )  : (nat *(nat  -> Z  -> nat  -> nat )) % type:=  ( 0, noop_reloc_calculate).
(* [?]: removed value specification. *)

Definition noop_reloc {abifeature : Type}  (k : nat )  : (bool *(annotated_memory_image abifeature -> nat  -> symbol_reference_and_reloc_site  -> (nat *reloc_calculate_fn ) % type)) % type:=  (false, noop_reloc_apply).

Record abi (abifeature: Type) : Type := (* forall 'abifeature. *)
   { is_valid_elf_header : elf64_header  ->  bool  (* doesn't this generalise outrageously? is_valid_elf_file? *)
    ; make_elf_header    : nat  ->  nat  ->  nat  ->  nat  ->  nat  ->  nat  ->  nat  ->  elf64_header 
                           (* t entry shoff phoff phnum shnum shstrndx *)
    ; reloc              : reloc_fn  abifeature
    ; section_is_special : elf64_interpreted_section  ->  annotated_memory_image  abifeature ->  bool 
    ; section_is_large   : elf64_interpreted_section  ->  annotated_memory_image  abifeature ->  bool 
    ; maxpagesize        : nat 
    ; minpagesize        : nat 
    ; commonpagesize     : nat 
    ; symbol_is_generated_by_linker : string  ->  bool 
    (*; link_inputs_tap    : 
    ; link_output_sections_tap   : 
    ; link_output_image_tap      : *)
    ; make_phdrs         : nat  ->  nat  ->  nat  -> (* file type *)  annotated_memory_image  abifeature ->  list  elf64_interpreted_section  ->  list  elf64_program_header_table_entry 
    ; max_phnum          : nat 
    ; guess_entry_point  : annotated_memory_image  abifeature ->  option  nat  
    ; pad_data           : nat  ->  list  elf_types_local.byte 
    ; pad_code           : nat  ->  list  elf_types_local.byte 
    ; generate_support   : (* list (list reloc_site_resolution) ->  *)list  ((string  * annotated_memory_image  abifeature) % type) ->  annotated_memory_image  abifeature
    ; concretise_support : annotated_memory_image  abifeature ->  annotated_memory_image  abifeature
    }.
Notation "{[ r 'with' 'is_valid_elf_header' := e ]}" := ({| is_valid_elf_header := e; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'make_elf_header' := e ]}" := ({| make_elf_header := e; is_valid_elf_header := is_valid_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'reloc' := e ]}" := ({| reloc := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'section_is_special' := e ]}" := ({| section_is_special := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'section_is_large' := e ]}" := ({| section_is_large := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'maxpagesize' := e ]}" := ({| maxpagesize := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'minpagesize' := e ]}" := ({| minpagesize := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'commonpagesize' := e ]}" := ({| commonpagesize := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'symbol_is_generated_by_linker' := e ]}" := ({| symbol_is_generated_by_linker := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'make_phdrs' := e ]}" := ({| make_phdrs := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'max_phnum' := e ]}" := ({| max_phnum := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'guess_entry_point' := e ]}" := ({| guess_entry_point := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'pad_data' := e ]}" := ({| pad_data := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_code := pad_code r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'pad_code' := e ]}" := ({| pad_code := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; generate_support := generate_support r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'generate_support' := e ]}" := ({| generate_support := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; concretise_support := concretise_support r |}).
Notation "{[ r 'with' 'concretise_support' := e ]}" := ({| concretise_support := e; is_valid_elf_header := is_valid_elf_header r; make_elf_header := make_elf_header r; reloc := reloc r; section_is_special := section_is_special r; section_is_large := section_is_large r; maxpagesize := maxpagesize r; minpagesize := minpagesize r; commonpagesize := commonpagesize r; symbol_is_generated_by_linker := symbol_is_generated_by_linker r; make_phdrs := make_phdrs r; max_phnum := max_phnum r; guess_entry_point := guess_entry_point r; pad_data := pad_data r; pad_code := pad_code r; generate_support := generate_support r |}).
Definition abi_default{abifeature: Type} : abi abifeature := {| is_valid_elf_header := (fun (x75 :  elf64_header ) => bool_default); make_elf_header := (fun (x76 :  nat ) => (fun (x77 :  nat ) => (fun (x78 :  nat ) => (fun (x79 :  nat ) => (fun (x80 :  nat ) => (fun (x81 :  nat ) => (fun (x82 :  nat ) => elf64_header_default))))))); reloc := DAEMON; section_is_special := (fun (x83 :  elf64_interpreted_section ) => (fun (x84 :  annotated_memory_image  abifeature) => bool_default)); section_is_large := (fun (x85 :  elf64_interpreted_section ) => (fun (x86 :  annotated_memory_image  abifeature) => bool_default)); maxpagesize := nat_default; minpagesize := nat_default; commonpagesize := nat_default; symbol_is_generated_by_linker := (fun (x87 :  string ) => bool_default); make_phdrs := (fun (x88 :  nat ) => (fun (x89 :  nat ) => (fun (x90 :  nat ) => (fun (x91 :  annotated_memory_image  abifeature) => (fun (x92 :  list  elf64_interpreted_section ) => DAEMON))))); max_phnum := nat_default; guess_entry_point := (fun (x93 :  annotated_memory_image  abifeature) => DAEMON); pad_data := (fun (x94 :  nat ) => DAEMON); pad_code := (fun (x95 :  nat ) => DAEMON); generate_support := (fun (x96 :  (* list (list reloc_site_resolution) ->  *)list  ((string  * annotated_memory_image  abifeature) % type)) => DAEMON); concretise_support := (fun (x97 :  annotated_memory_image  abifeature) => DAEMON) |}.
(* [?]: removed value specification. *)

Definition align_up_to  (align : nat ) (addr : nat )  : nat :=  
    let quot := Coq.Numbers.Natural.Peano.NPeano.div addr align
    in
    if beq_nat (Coq.Init.Peano.mult quot align) addr then addr else Coq.Init.Peano.mult ( Coq.Init.Peano.plus quot( 1)) align.
(* [?]: removed value specification. *)

Definition round_down_to  (align : nat ) (addr : nat )  : nat :=  
    let quot := Coq.Numbers.Natural.Peano.NPeano.div addr align
    in Coq.Init.Peano.mult
    quot align.
(* [?]: removed value specification. *)

Definition uint32_max   : nat :=  Coq.Init.Peano.minus ( nat_power( 2)( 32))( 1).
(* [?]: removed value specification. *)

Definition uint64_max   : nat :=  Coq.Init.Peano.plus (Coq.Init.Peano.minus (Coq.Init.Peano.mult
    (* HACK around Lem's inability to parse 18446744073709551615: 
     * the square of uint32_max is 
     *       (2**32 - 1) (2**32 - 1)
     * i.e.   2**64 - 2**32 - 2**32 + 1
     * So
     * 2**64 - 1 =  uint32_max * uint32_max  + 2**32 + 2**32 - 2
     *)
    uint32_max uint32_max)( 2)) (nat_power( 2)( 33)).
(* [?]: removed value specification. *)

Definition compl64  (v : nat )  : nat :=  Coq.Init.Peano.plus( 1) (nat_lxor v uint64_max).
(* [?]: removed value specification. *)

Program Fixpoint gcd  (a : nat ) (b : nat )  : nat :=  
    if beq_nat b( 0) then a else gcd b ( Coq.Numbers.Natural.Peano.NPeano.modulo a b).
(* [?]: removed value specification. *)

Definition lcm  (a : nat ) (b : nat )  : nat :=  Coq.Numbers.Natural.Peano.NPeano.div 
    (* let _ = errln ("lcm of " ^ (show a) ^ " and " ^ (show b) ^ "?")
    in *)
    ( Coq.Init.Peano.mult a b) (gcd a b).
(* [?]: removed value specification. *)

Definition address_of_range {abifeature : Type}  (el_range : (string *((nat *nat ) % type)) % type) (img3 : annotated_memory_image abifeature)  : nat :=  
  match ( el_range) with (el_name,  (start,  len)) =>
    match ( (fmap_lookup_by (fun (x : string ) (y : string )=> EQ) el_name
               (elements img3))) with Some el =>
      match ((startpos el)) with Some addr => Coq.Init.Peano.plus addr start
        | None => DAEMON end | None => DAEMON end end.
(* [?]: removed value specification. *)

Definition range_contains  (p : (nat *nat ) % type) (p0 : (nat *nat ) % type)  : bool := 
  match ( (p,p0)) with ( (r1begin,  r1len),  (r2begin,  r2len)) =>
    nat_gteb r2begin r1begin &&
    nat_lteb ( Coq.Init.Peano.plus r2begin r2len)
      ( Coq.Init.Peano.plus r1begin r1len) end.
(* [?]: removed value specification. *)

Definition range_overlaps  (p : (nat *nat ) % type) (p0 : (nat *nat ) % type)  : bool := 
  match ( (p,p0)) with ( (r1begin,  r1len),  (r2begin,  r2len)) =>
    ( nat_ltb r1begin ( Coq.Init.Peano.plus r2begin r2len) &&
      nat_gtb ( Coq.Init.Peano.plus r1begin r1len) r2begin) ||
    ( nat_ltb r2begin ( Coq.Init.Peano.plus r1begin r1len) &&
      nat_gtb ( Coq.Init.Peano.plus r2begin r2len) r1begin) end.
(* [?]: removed value specification. *)

Definition is_partition  (rs : list ((nat *nat ) % type)) (ranges : list ((nat *nat ) % type))  : bool :=  
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     := fun (r : (nat *nat ) % type) => List.fold_left (fun x y => x || y) (List.map (fun (range1 : (nat *nat ) % type) => range_contains range1 r) ranges) false
    in
    List.forallb (fun (r : (nat *nat ) % type) => r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    List.forallb (fun (r : (nat *nat ) % type) => List.forallb (fun (r2 : (nat *nat ) % type) => ( ((tuple_equal_by beq_nat beq_nat r  (* should be "=="? *)r2))) || (negb (range_overlaps r r2))) rs) rs.
(* [?]: removed value specification. *)

Program Fixpoint nat_range  (base : nat ) (len : nat )  : list (nat ):= 
    match ( len) with  
        0 => []
    |   _ => base :: (nat_range ( Coq.Init.Peano.plus base( 1)) ( Coq.Init.Peano.minus len( 1)))
    end.
(* [?]: removed value specification. *)

Program Fixpoint expand_sorted_ranges  (sorted_ranges : list ((nat *nat ) % type)) (min_length : nat ) (accum : list (bool ))  : list (bool ):= 
    match ( sorted_ranges) with 
        [] =>  (@ List.app _)accum (
            let pad_length := nat_max( 0) ( Coq.Init.Peano.minus min_length (missing_pervasives.length accum))
            in
            (* let _ = Missing_pervasives.errln (
                "padding ranges cares list with " ^ (show pad_length) ^ 
                " cares (accumulated " ^ (show (Missing_pervasives.length accum)) ^ 
                ", min length " ^ (show min_length) ^ ")")
            in *)
            missing_pervasives.replicate0 pad_length true)
     |  (base,  len) :: more => 
            (* pad the accum so that it reaches up to base *)
            let up_to_base := (missing_pervasives.replicate0 ( Coq.Init.Peano.minus base (missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range :=  (@ List.app _)up_to_base (missing_pervasives.replicate0 len false)
            in
            expand_sorted_ranges more min_length ( (@ List.app _)accum up_to_end_of_range)
    end.
(* [?]: removed value specification. *)

Definition expand_unsorted_ranges  (unsorted_ranges : list ((nat *nat ) % type)) (min_length : nat ) (accum : list (bool ))  : list (bool ):= 
    expand_sorted_ranges (insertSortBy (
  fun (p : (nat *nat ) % type) =>
    match ( (p) ) with ( (base1,  len1)) =>
      (fun (p : (nat *nat ) % type) =>
         match ( (p) ) with ( (base2,  len2)) => nat_ltb base1 base2 end) end) unsorted_ranges) min_length accum.
(* [?]: removed value specification. *)

Program Fixpoint make_byte_pattern_revacc  (revacc : list (option (elf_types_local.byte ) )) (bytes : list (elf_types_local.byte )) (cares : list (bool ))  : list (option (elf_types_local.byte ) ):=  
    match ( bytes) with 
          [] => List.rev revacc
        | b :: bs => match ( cares) with  
                care :: more => make_byte_pattern_revacc ((if negb care then None else Some b) :: revacc) bs more
              | _ => DAEMON
              end
    end.
(* [?]: removed value specification. *)

Definition make_byte_pattern  (bytes : list (elf_types_local.byte )) (cares : list (bool ))  : list (option (elf_types_local.byte ) ):=  
    make_byte_pattern_revacc [] bytes cares.
(* [?]: removed value specification. *)

Program Fixpoint relax_byte_pattern_revacc  (revacc : list (option (elf_types_local.byte ) )) (bytes : list (option (elf_types_local.byte ) )) (cares : list (bool ))  : list (option (elf_types_local.byte ) ):=  
    match ( bytes) with 
          [] => List.rev revacc
        | b :: bs => match ( cares) with  
                care :: more => relax_byte_pattern_revacc ((if negb care then None else b) :: revacc) bs more
              | _ => DAEMON
              end
    end.
(* [?]: removed value specification. *)

Definition relax_byte_pattern  (bytes : list (option (elf_types_local.byte ) )) (cares : list (bool ))  : list (option (elf_types_local.byte ) ):=  
    relax_byte_pattern_revacc [] bytes cares.

Definition pad_fn : Type :=  nat  ->  list  elf_types_local.byte .
Definition pad_fn_default: pad_fn  := (fun (x74 :  nat ) => DAEMON).
(* [?]: removed value specification. *)

Program Fixpoint concretise_byte_pattern  (rev_acc : list (elf_types_local.byte )) (acc_pad : nat ) (bs : list (option (elf_types_local.byte ) )) (pad : nat  -> list (elf_types_local.byte ))  : list (elf_types_local.byte ):=  
    match ( bs) with 
        [] => 
            let padding_bytes := if nat_gtb acc_pad( 0) then pad acc_pad else []
            in List.rev ( (@ List.app _)(List.rev padding_bytes) rev_acc)
        | Some(b) :: more => 
            (* flush accumulated padding *)
            let padding_bytes := if nat_gtb acc_pad( 0) then pad acc_pad else []
            in
            concretise_byte_pattern (b :: ( (@ List.app _)(List.rev padding_bytes) rev_acc))( 0) more pad
        | None :: more => 
            concretise_byte_pattern rev_acc (Coq.Init.Peano.plus acc_pad( 1)) more pad
    end.
(* [?]: removed value specification. *)

Definition byte_option_matches_byte  (optb : option (elf_types_local.byte ) ) (b : elf_types_local.byte )  : bool := 
    match ( optb) with  
            None => true 
        |   Some some => classical_boolean_equivalence some b 
    end.
(* [?]: removed value specification. *)

Program Fixpoint byte_list_matches_pattern  (pattern : list (option (elf_types_local.byte ) )) (bytes : list (elf_types_local.byte ))  : bool :=  
    match ( pattern) with  
        [] => true
        | optbyte :: more => match ( bytes) with  
                [] => false
                | abyte :: morebytes => 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end.
(* [?]: removed value specification. *)

Definition append_to_byte_pattern_at_offset  (offset : nat ) (pat1 : list (option (elf_types_local.byte ) )) (pat2 : list (option (elf_types_local.byte ) ))  : list (option (elf_types_local.byte ) ):= 
    let pad_length := Coq.Init.Peano.minus offset (missing_pervasives.length pat1)
    in
    if nat_ltb pad_length( 0) then DAEMON
    else  (@ List.app _) ((@ List.app _)pat1 (lem_list.replicate (id pad_length) None)) pat2.
(* [?]: removed value specification. *)

Program Fixpoint accum_pattern_possible_starts_in_one_byte_sequence  (pattern : list (option (elf_types_local.byte ) )) (pattern_len : nat ) (seq : list (elf_types_local.byte )) (seq_len : nat ) (offset : nat ) (accum : list (nat ))  : list (nat ):= 
    (* let _ = Missing_pervasives.errs ("At offset " ^ (show offset) ^ "... ")
    in *)
    match ( pattern) with 
        [] => (* let _ = Missing_pervasives.errs ("terminating with hit (empty pattern)\n") in *)
            offset :: accum
        | bpe :: more_bpes => (* nonempty, so check for nonempty seq *)
            match ( seq) with  
                [] => (*let _ = Missing_pervasives.errs ("terminating with miss (empty pattern)\n") 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte1 :: more_bytes => let matched_this_byte := 
                            byte_option_matches_byte bpe byte1
                       in
                       (* let _ = Missing_pervasives.errs ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in *)
                       let sequence_long_enough := ( nat_gteb seq_len pattern_len) 
                       in
                       (* let _ = Missing_pervasives.errs ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in *)
                       let matched_here := matched_this_byte && (sequence_long_enough &&
                        byte_list_matches_pattern more_bpes more_bytes)
                       in
                       (* let _ = Missing_pervasives.errs ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes ( Coq.Init.Peano.minus seq_len( 1)) 
                           ( Coq.Init.Peano.plus offset( 1)) 
                           (if matched_here then offset :: accum else accum)
            end
    end.

Definition swap_pairs {a b : Type} `{SetType a} `{SetType b}  (s : set ((b*a) % type))  : set ((a*b) % type):=  let x2  := 
  [] in set_fold
   (fun (p : (b*a) % type) (x2 : set ((a*b) % type)) =>
      match ( (p ,x2) ) with ((k,  v) ,  x2) =>
        if true then set_add (v, k) x2 else x2 end) s x2.

Definition by_range_from_by_tag {a b : Type} `{SetType a} `{SetType b}   : set ((a*b) % type) -> set ((b*a) % type):=  swap_pairs.

Definition by_tag_from_by_range {a b : Type} `{SetType a} `{SetType b}   : set ((a*b) % type) -> set ((b*a) % type):=  swap_pairs.
(* [?]: removed value specification. *)

Definition filter_elements {abifeature : Type}  (pred : (string *element ) % type -> bool ) (img3 : annotated_memory_image abifeature)  : annotated_memory_image abifeature:=  
    let new_elements := lem_map.fromList (let x2 := [] in 
  List.fold_right
    (fun (p : (string *element ) % type) (x2 : list ((string *element ) % type)) =>
       match ( (p ,x2) ) with ((n,  r) ,  x2) =>
         if
         let result := pred (n, r) in
         if negb result then
           (*let _ = Missing_pervasives.outln ("Discarding element named " ^ n) in*) result
         else result then (n, r) :: x2 else x2 end) x2
    (set_to_list (id (elements img3))))
    in
    let new_by_range  :=  lem_set.filter (
  fun (p : (option ((string *((nat *nat ) % type)) % type) *range_tag abifeature) % type) =>
    match ( (p) ) with ( (maybe_range,  tag)) =>
      match ( maybe_range) with None => true | Some (el_name,  el_range) =>
        (set_member_by (fun (x : string ) (y : string )=> EQ) el_name
           (fmap_domain_by (fun (x : string ) (y : string )=> EQ)
              new_elements)) end end)(by_range img3)
    in
    let new_by_tag  := let x2  := 
  [] in set_fold
   (fun (p : (option ((string *((nat *nat ) % type)) % type) *range_tag abifeature) % type) (x2 : set ((range_tag abifeature*option ((string *((nat *nat ) % type)) % type) ) % type)) =>
      match ( (p ,x2) ) with ((k,  v) ,  x2) =>
        if true then set_add (v, k) x2 else x2 end) new_by_range x2
    in
    {|elements := new_elements
     ;by_range := new_by_range
     ;by_tag   := new_by_tag
     |}.
(* [?]: removed value specification. *)

Definition tag_image {abifeature : Type}  (t : range_tag abifeature) (el_name : string ) (el_offset : nat ) (tag_len : nat ) (img3 : annotated_memory_image abifeature)  : annotated_memory_image abifeature:=  
  match ( (Some (el_name, (el_offset, tag_len)), t)) with (k,  v) =>
    let new_by_range  := set_add (k, v) (by_range img3) in
  let new_by_tag  := set_add (v, k) (by_tag img3) in
  {|elements :=(elements img3) ;by_range := new_by_range
  ;by_tag := new_by_tag |} end.
(* [?]: removed value specification. *)

Definition address_to_element_and_offset {abifeature : Type}  (addr : nat ) (img3 : annotated_memory_image abifeature)  : option ((string *nat ) % type) :=  
    (* Find the element with the highest address <= addr *)
    let maybe_highest_le
     := List.fold_left (fun (maybe_current_max_le : option ((nat *string *element ) % type) ) => (
  fun (p : (string *element ) % type) =>
    match ( (p) ) with ( (el_name,  el_rec)) =>
      (* let _ = errln ("Saw element named `" ^ el_name ^ " with startpos " ^ (
            match el_rec.startpos with Just addr -> ("0x" ^ (hex_string_of_natural addr)) | Nothing -> "(none)" end))
        in *)
      match ( (maybe_current_max_le,(startpos el_rec))) with (None,  None) =>
        None | (None,  Some pos) =>
        if nat_lteb pos addr then Some (pos, el_name, el_rec) else None
        | (Some (cur,  cur_el_name,  cur_el_rec),  None) =>
        maybe_current_max_le
        | (Some (cur,  cur_el_name,  cur_el_rec),  Some pos) =>
        if nat_lteb pos addr && nat_gtb pos cur then
          Some (pos, el_name, el_rec) else maybe_current_max_le end end
    )) (fmap_elements(elements img3)) None
    in
    match ( maybe_highest_le) with 
        Some (el_def_startpos,  el_name,  el_rec) =>
            (* final sanity check: is the length definite, and if so, does the
             * element span far enough? *)
            match ((length1 el_rec)) with 
                Some l => if nat_gteb (Coq.Init.Peano.plus el_def_startpos l) addr 
                    then Some (el_name, Coq.Init.Peano.minus addr el_def_startpos) 
                    else 
                        (*let _ = errln ("Discounting " ^ el_name ^ " because length is too short") in*) None
                | None => (*let _ = errln ("Gave up because element has unknown length") in*) None
            end
        | None => 
            (* no elements with a low enough assigned address, so nothing *)
            None
    end.
(* [?]: removed value specification. *)

Definition element_and_offset_to_address {abifeature : Type}  (p : (string *nat ) % type) (img3 : annotated_memory_image abifeature)  : option (nat ) := 
  match ( (p,img3)) with ( (el_name,  el_off),  img3) =>
    match ( (fmap_lookup_by (fun (x : string ) (y : string )=> EQ) el_name
               (elements img3))) with Some el =>
      match ((startpos el)) with Some addr =>
        Some ( Coq.Init.Peano.plus addr el_off) | None => None end | None =>
      DAEMON end end.

Definition null_symbol_reference   : symbol_reference :=  {|ref_symname := ""
    ;ref_syment := elf64_null_symbol_table_entry
    ;ref_sym_scn :=( 0)
    ;ref_sym_idx :=( 0)
|}.

Definition null_elf_relocation_a   : elf64_relocation_a := 
  {|elf64_ra_offset := (elf64_addr_of_nat( 0))  
   ;elf64_ra_info   := (elf64_xword_of_nat( 0)) 
   ;elf64_ra_addend := (elf64_sxword_of_int((Zpred (Zpos (P_of_succ_nat 0)))))
   |}.


Definition null_symbol_reference_and_reloc_site   : symbol_reference_and_reloc_site :=  {|ref := null_symbol_reference
    ;maybe_reloc :=        
 (Some   {|ref_relent := null_elf_relocation_a
                ;ref_rel_scn :=( 0)
                ;ref_rel_idx :=( 0)
                ;ref_src_scn :=( 0)
                |})
    ;maybe_def_bound_to := None
    |}.

Definition null_symbol_definition   : symbol_definition :=  {|def_symname := ""
    ;def_syment := elf64_null_symbol_table_entry
    ;def_sym_scn :=( 0)
    ;def_sym_idx :=( 0)
    ;def_linkable_idx :=( 0)
|}.
(* [?]: removed value specification. *)

Definition pattern_possible_starts_in_one_byte_sequence  (pattern : list (option (elf_types_local.byte ) )) (seq : list (elf_types_local.byte )) (offset : nat )  : list (nat ):= 
    (* let _ = Missing_pervasives.errs ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset [].
(* [?]: removed value specification. *)

Definition byte_pattern_of_byte_sequence  (seq : byte_sequence )  : list (option (elf_types_local.byte ) ):=  match ( seq) with 
    Sequence(bs) => List.map (fun (b : elf_types_local.byte ) => Some b) bs
end.
(* [?]: removed value specification. *)

Definition compute_virtual_address_adjustment  (max_page_size : nat ) (offset : nat ) (vaddr : nat )  : nat :=  Coq.Numbers.Natural.Peano.NPeano.modulo
  ( Coq.Init.Peano.minus vaddr offset) max_page_size.
(* [?]: removed value specification. *)

Definition extract_natural_field  (width : nat ) (element1 : element ) (offset : nat )  : nat :=  
    (* Read n bytes from the contents *)
    let maybe_bytes := take0 width (drop0 offset(contents element1))
    in
    let bytes := List.map (fun (mb : option (elf_types_local.byte ) ) => match ( mb) with  None => byte_of_nat( 0) | Some mb => mb end) maybe_bytes
    in
    (* FIXME: do we want little- or big-endian? *)
    List.fold_left (fun (acc : nat ) => fun (next_byte : elf_types_local.byte ) => Coq.Init.Peano.plus (Coq.Init.Peano.mult
        acc( 256)) (nat_of_byte next_byte)
    ) bytes ( 0 :  nat ).
(* [?]: removed value specification. *)

Program Fixpoint natural_to_le_byte_list  (n : nat )  : list (elf_types_local.byte ):=  
    (byte_of_nat ( Coq.Numbers.Natural.Peano.NPeano.modulo n( 256))) :: (let d :=Coq.Numbers.Natural.Peano.NPeano.div n( 256) in if beq_nat d( 0) then [] else natural_to_le_byte_list ( Coq.Numbers.Natural.Peano.NPeano.div n( 256))).
(* [?]: removed value specification. *)

Definition write_natural_field  (new_field_value : nat ) (width : nat ) (element1 : element ) (offset : nat )  : element :=  
    let pre_bytes := take0 offset(contents element1)
    in
    let post_bytes := drop0 ( Coq.Init.Peano.plus offset width)(contents element1)
    in
    (* FIXME: avoid hard-coding little-endian *)
    let field_bytes := natural_to_le_byte_list new_field_value
    in
    if nat_gtb (length field_bytes) width then DAEMON
    else
    {|contents :=  ((@ List.app _)            
((@ List.app _) ((@ List.app _)pre_bytes (let x2 := [] in 
  List.fold_right
    (fun (b : elf_types_local.byte ) (x2 : list (option (elf_types_local.byte ) )) =>
       if true then Some b :: x2 else x2) x2 field_bytes)) (replicate0 ( Coq.Init.Peano.minus width (length field_bytes)) (Some (byte_of_nat( 0))))) post_bytes)
        ;startpos :=(startpos element1)
        ;length1 :=(length1 element1)
     |}.
