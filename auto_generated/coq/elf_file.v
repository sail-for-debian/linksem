(* Generated by Lem from elf_file.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** Module [elf_file] packages all components of an ELF file up into a single
  * record, provides I/O routines for this record, as well as other utility
  * functions that operate on an entire ELF file.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_string.
Require Export lem_string.


Require Import elf_header.
Require Export elf_header.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.

Require Import elf_interpreted_segment.
Require Export elf_interpreted_segment.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_program_header_table.
Require Export elf_program_header_table.


Require Import string_table.
Require Export string_table.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


(** [elf32_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
Record elf32_file : Type :=
  { elf32_file_header               : elf32_header                    (** The file header. *)
   ; elf32_file_program_header_table : elf32_program_header_table      (** The program header table. *)
   ; elf32_file_section_header_table : elf32_section_header_table      (** The section header table. *)
   ; elf32_file_interpreted_segments : elf32_interpreted_segments      (** A more usable interpretation of the file's segments. *)
   ; elf32_file_interpreted_sections : elf32_interpreted_sections      (** A more usable interpretation of the file's sections. *)
   ; elf32_file_bits_and_bobs        : list  ((nat  * byte_sequence ) % type) (** The uninterpreted "rubbish" that may appear in gaps in the binary file. *)
   }.
Notation "{[ r 'with' 'elf32_file_header' := e ]}" := ({| elf32_file_header := e; elf32_file_program_header_table := elf32_file_program_header_table r; elf32_file_section_header_table := elf32_file_section_header_table r; elf32_file_interpreted_segments := elf32_file_interpreted_segments r; elf32_file_interpreted_sections := elf32_file_interpreted_sections r; elf32_file_bits_and_bobs := elf32_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf32_file_program_header_table' := e ]}" := ({| elf32_file_program_header_table := e; elf32_file_header := elf32_file_header r; elf32_file_section_header_table := elf32_file_section_header_table r; elf32_file_interpreted_segments := elf32_file_interpreted_segments r; elf32_file_interpreted_sections := elf32_file_interpreted_sections r; elf32_file_bits_and_bobs := elf32_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf32_file_section_header_table' := e ]}" := ({| elf32_file_section_header_table := e; elf32_file_header := elf32_file_header r; elf32_file_program_header_table := elf32_file_program_header_table r; elf32_file_interpreted_segments := elf32_file_interpreted_segments r; elf32_file_interpreted_sections := elf32_file_interpreted_sections r; elf32_file_bits_and_bobs := elf32_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf32_file_interpreted_segments' := e ]}" := ({| elf32_file_interpreted_segments := e; elf32_file_header := elf32_file_header r; elf32_file_program_header_table := elf32_file_program_header_table r; elf32_file_section_header_table := elf32_file_section_header_table r; elf32_file_interpreted_sections := elf32_file_interpreted_sections r; elf32_file_bits_and_bobs := elf32_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf32_file_interpreted_sections' := e ]}" := ({| elf32_file_interpreted_sections := e; elf32_file_header := elf32_file_header r; elf32_file_program_header_table := elf32_file_program_header_table r; elf32_file_section_header_table := elf32_file_section_header_table r; elf32_file_interpreted_segments := elf32_file_interpreted_segments r; elf32_file_bits_and_bobs := elf32_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf32_file_bits_and_bobs' := e ]}" := ({| elf32_file_bits_and_bobs := e; elf32_file_header := elf32_file_header r; elf32_file_program_header_table := elf32_file_program_header_table r; elf32_file_section_header_table := elf32_file_section_header_table r; elf32_file_interpreted_segments := elf32_file_interpreted_segments r; elf32_file_interpreted_sections := elf32_file_interpreted_sections r |}).
Definition elf32_file_default: elf32_file  := {| elf32_file_header := elf32_header_default; elf32_file_program_header_table := elf32_program_header_table_default; elf32_file_section_header_table := elf32_section_header_table_default; elf32_file_interpreted_segments := elf32_interpreted_segments_default; elf32_file_interpreted_sections := elf32_interpreted_sections_default; elf32_file_bits_and_bobs := DAEMON |}.
(* [?]: removed value specification. *)

Definition bytes_of_elf32_file  (ef : elf32_file )  : error (byte_sequence ):= 
  let endian      := get_elf32_header_endianness(elf32_file_header ef) in
  let hdr_bytes   := bytes_of_elf32_header(elf32_file_header ef) in
  let hdr_layout  := ( 0, hdr_bytes) in
  let pht_bytes   := bytes_of_elf32_program_header_table endian(elf32_file_program_header_table ef) in
  let sht_bytes   := bytes_of_elf32_section_header_table endian(elf32_file_section_header_table ef) in
  let pht_off     := nat_of_elf32_off(elf32_phoff(elf32_file_header ef)) in
  let sht_off     := nat_of_elf32_off(elf32_shoff(elf32_file_header ef)) in
  let pht_layout  := (pht_off, pht_bytes) in
  let sht_layout  := (sht_off, sht_bytes) in
  let bab_layout  :=(elf32_file_bits_and_bobs ef) in
  if beq_nat (List.length(elf32_file_program_header_table ef))    
(List.length(elf32_file_interpreted_segments ef)) then
    if beq_nat (List.length(elf32_file_section_header_table ef))      
(List.length(elf32_file_interpreted_sections ef)) then
      let segs_zip  := lem_list.zip(elf32_file_program_header_table ef)(elf32_file_interpreted_segments ef) in
      let sects_zip := lem_list.zip(elf32_file_section_header_table ef)(elf32_file_interpreted_sections ef) in
      let segs_layout :=
        List.map (fun (p : (elf32_program_header_table_entry *elf32_interpreted_segment ) % type) =>
  match ( (p) ) with ( (seg,  interp_seg)) =>
    (nat_of_elf32_off (elf32_p_offset seg),(elf32_segment_body interp_seg))
  end
        ) (List.filter (
  fun (p : (elf32_program_header_table_entry *elf32_interpreted_segment ) % type) =>
    match ( (p) ) with ( (x,  _)) =>
      negb (elf32_word_equal (elf32_p_filesz x) (elf32_word_of_nat ( 0))) end) segs_zip)
      in
      let sects_layout :=
        List.map (fun (p : (elf32_section_header_table_entry *elf32_interpreted_section ) % type) =>
  match ( (p) ) with ( (sect,  interp_sect)) =>
    (nat_of_elf32_off (elf32_sh_offset sect),(elf32_section_body interp_sect))
  end
        ) (List.filter (
  fun (p : (elf32_section_header_table_entry *elf32_interpreted_section ) % type) =>
    match ( (p) ) with ( (x,  _)) =>
      negb
        (elf32_word_equal (elf32_sh_type x) (elf32_word_of_nat sht_nobits))
    end) sects_zip)
      in
      let pre_layout :=  (@ List.app _) ((@ List.app _) ((@ List.app _)[hdr_layout; pht_layout; sht_layout] sects_layout) segs_layout) bab_layout in
      let final_layout :=
        sort_by (fun (p : (nat *byte_sequence ) % type) (p0 : (nat *byte_sequence ) % type) =>
  match ( (p ,p0) ) with ( (off_x,  _) ,  (off_y,  _)) =>
    natural_ordering off_x off_y end)
          pre_layout
      in
      let concats :=
        foldM (fun (x : (nat *byte_sequence ) % type) (y : (nat *byte_sequence ) % type) =>
  match ( x) with (current_offset,  so_far) =>
    match ( y) with (point_to_add,  body) =>
      if nat_ltb point_to_add current_offset then
        let diff := Coq.Init.Peano.minus current_offset point_to_add in
        (* Completely contained inside other segment *)
        if nat_ltb (byte_sequence.length0 body) diff then
          return0 (current_offset, so_far) else
          byte_sequence.partition1 diff body >>=
          (fun (p : (byte_sequence *byte_sequence ) % type) =>
             match ( (p) ) with ( (_,  cut)) =>
               let concat4 := byte_sequence.concat1 [so_far; cut] in
             let delta := Coq.Init.Peano.plus current_offset
                            (byte_sequence.length0 cut) in
             return0 (delta, concat4) end) else
        let diff := Coq.Init.Peano.minus point_to_add current_offset in
        let reps := byte_sequence.create diff null_byte in
        let concat4 := byte_sequence.concat1 [so_far; reps; body] in
        let delta := Coq.Init.Peano.plus point_to_add
                       (byte_sequence.length0 body) in
        return0 (delta, concat4) end end
        ) ( 0, byte_sequence.empty) final_layout
      in
        concats >>= (fun (p : (nat *byte_sequence ) % type) =>
    match ( (p) ) with ( (offset,  body)) => return0 body end)
    else
      fail0 "bytes_of_elf32_file: interpreted sections and section header table must have same length"
  else
    fail0 "bytes_of_elf32_file: interpreted segments and program header table must have same length".

(** [elf64_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
Record elf64_file : Type :=
  { elf64_file_header               : elf64_header                    (** The file header. *)
   ; elf64_file_program_header_table : elf64_program_header_table      (** The program header table. *)
   ; elf64_file_section_header_table : elf64_section_header_table      (** The section header table. *)
   ; elf64_file_interpreted_segments : elf64_interpreted_segments      (** A more usable interpretation of the file's segments. *)
   ; elf64_file_interpreted_sections : elf64_interpreted_sections      (** A more usable interpretation of the file's sections. *)
   ; elf64_file_bits_and_bobs        : list  ((nat  * byte_sequence ) % type) (** The uninterpreted "rubbish" that may appear in gaps in the binary file. *)
   }.
Notation "{[ r 'with' 'elf64_file_header' := e ]}" := ({| elf64_file_header := e; elf64_file_program_header_table := elf64_file_program_header_table r; elf64_file_section_header_table := elf64_file_section_header_table r; elf64_file_interpreted_segments := elf64_file_interpreted_segments r; elf64_file_interpreted_sections := elf64_file_interpreted_sections r; elf64_file_bits_and_bobs := elf64_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf64_file_program_header_table' := e ]}" := ({| elf64_file_program_header_table := e; elf64_file_header := elf64_file_header r; elf64_file_section_header_table := elf64_file_section_header_table r; elf64_file_interpreted_segments := elf64_file_interpreted_segments r; elf64_file_interpreted_sections := elf64_file_interpreted_sections r; elf64_file_bits_and_bobs := elf64_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf64_file_section_header_table' := e ]}" := ({| elf64_file_section_header_table := e; elf64_file_header := elf64_file_header r; elf64_file_program_header_table := elf64_file_program_header_table r; elf64_file_interpreted_segments := elf64_file_interpreted_segments r; elf64_file_interpreted_sections := elf64_file_interpreted_sections r; elf64_file_bits_and_bobs := elf64_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf64_file_interpreted_segments' := e ]}" := ({| elf64_file_interpreted_segments := e; elf64_file_header := elf64_file_header r; elf64_file_program_header_table := elf64_file_program_header_table r; elf64_file_section_header_table := elf64_file_section_header_table r; elf64_file_interpreted_sections := elf64_file_interpreted_sections r; elf64_file_bits_and_bobs := elf64_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf64_file_interpreted_sections' := e ]}" := ({| elf64_file_interpreted_sections := e; elf64_file_header := elf64_file_header r; elf64_file_program_header_table := elf64_file_program_header_table r; elf64_file_section_header_table := elf64_file_section_header_table r; elf64_file_interpreted_segments := elf64_file_interpreted_segments r; elf64_file_bits_and_bobs := elf64_file_bits_and_bobs r |}).
Notation "{[ r 'with' 'elf64_file_bits_and_bobs' := e ]}" := ({| elf64_file_bits_and_bobs := e; elf64_file_header := elf64_file_header r; elf64_file_program_header_table := elf64_file_program_header_table r; elf64_file_section_header_table := elf64_file_section_header_table r; elf64_file_interpreted_segments := elf64_file_interpreted_segments r; elf64_file_interpreted_sections := elf64_file_interpreted_sections r |}).
Definition elf64_file_default: elf64_file  := {| elf64_file_header := elf64_header_default; elf64_file_program_header_table := elf64_program_header_table_default; elf64_file_section_header_table := elf64_section_header_table_default; elf64_file_interpreted_segments := elf64_interpreted_segments_default; elf64_file_interpreted_sections := elf64_interpreted_sections_default; elf64_file_bits_and_bobs := DAEMON |}.
(* [?]: removed value specification. *)

Definition bytes_of_elf64_file  (ef : elf64_file )  : error (byte_sequence ):= 
  let endian      := get_elf64_header_endianness(elf64_file_header ef) in
  let hdr_bytes   := bytes_of_elf64_header(elf64_file_header ef) in
  let hdr_layout  := ( 0, hdr_bytes) in
  let pht_bytes   := bytes_of_elf64_program_header_table endian(elf64_file_program_header_table ef) in
  let sht_bytes   := bytes_of_elf64_section_header_table endian(elf64_file_section_header_table ef) in
  let pht_off     := nat_of_elf64_off(elf64_phoff(elf64_file_header ef)) in
  let sht_off     := nat_of_elf64_off(elf64_shoff(elf64_file_header ef)) in
  let pht_layout  := (pht_off, pht_bytes) in
  let sht_layout  := (sht_off, sht_bytes) in
  let bab_layout  :=(elf64_file_bits_and_bobs ef) in
  if (* List.length ef.elf64_file_program_header_table =
    List.length ef.elf64_file_interpreted_segments *) true then
    if beq_nat (List.length(elf64_file_section_header_table ef))      
(List.length(elf64_file_interpreted_sections ef)) then
      let segs_zip  := lem_list.zip(elf64_file_program_header_table ef)(elf64_file_interpreted_segments ef) in
      let sects_zip := lem_list.zip(elf64_file_section_header_table ef)(elf64_file_interpreted_sections ef) in
      let segs_layout := [] (*
        List.map (fun (seg, interp_seg) ->
          (natural_of_elf64_off seg.elf64_p_offset, interp_seg.elf64_segment_body)
        ) (List.filter (fun (x, _) -> x.elf64_p_filesz <> elf64_xword_of_natural 0) segs_zip) *)
      in
      let sects_layout :=
        List.map (fun (p : (elf64_section_header_table_entry *elf64_interpreted_section ) % type) =>
  match ( (p) ) with ( (sect,  interp_sect)) =>
    (nat_of_elf64_off (elf64_sh_offset sect),(elf64_section_body interp_sect))
  end
        ) (List.filter (
  fun (p : (elf64_section_header_table_entry *elf64_interpreted_section ) % type) =>
    match ( (p) ) with ( (x,  _)) =>
      negb
        (elf64_word_equal (elf64_sh_type x) (elf64_word_of_nat sht_nobits))
    end) sects_zip)
      in
      let pre_layout :=  (@ List.app _) ((@ List.app _) ((@ List.app _)[hdr_layout; pht_layout; sht_layout] sects_layout) segs_layout) bab_layout in
      let final_layout :=
        sort_by (fun (p : (nat *byte_sequence ) % type) (p0 : (nat *byte_sequence ) % type) =>
  match ( (p ,p0) ) with ( (off_x,  _) ,  (off_y,  _)) =>
    natural_ordering off_x off_y end)
          pre_layout
      in
      let concats :=
        foldM (fun (x : (nat *byte_sequence ) % type) (y : (nat *byte_sequence ) % type) =>
  match ( x) with (current_offset,  so_far) =>
    match ( y) with (point_to_add,  body) =>
      if nat_ltb point_to_add current_offset then
        let diff := Coq.Init.Peano.minus current_offset point_to_add in
        (* Completely contained inside other segment *)
        if nat_ltb (byte_sequence.length0 body) diff then
          return0 (current_offset, so_far) else
          byte_sequence.partition1 diff body >>=
          (fun (p : (byte_sequence *byte_sequence ) % type) =>
             match ( (p) ) with ( (_,  cut)) =>
               let concat4 := byte_sequence.concat1 [so_far; cut] in
             let delta := Coq.Init.Peano.plus current_offset
                            (byte_sequence.length0 cut) in
             return0 (delta, concat4) end) else
        let diff := Coq.Init.Peano.minus point_to_add current_offset in
        let reps := byte_sequence.create diff null_byte in
        let concat4 := byte_sequence.concat1 [so_far; reps; body] in
        let delta := Coq.Init.Peano.plus point_to_add
                       (byte_sequence.length0 body) in
        return0 (delta, concat4) end end
        ) ( 0, byte_sequence.empty) final_layout
      in
        concats >>= (fun (p : (nat *byte_sequence ) % type) =>
    match ( (p) ) with ( (offset,  body)) => return0 body end)
    else
      fail0 "bytes_of_elf64_file: interpreted sections and section header table must have same length"
  else
    fail0 "bytes_of_elf64_file: interpreted segments and program header table must have same length".
(* [?]: removed value specification. *)

Definition obtain_elf32_program_header_table  (hdr : elf32_header ) (bs0 : byte_sequence )  : error (list (elf32_program_header_table_entry )):= 
  let endian      := get_elf32_header_endianness hdr in
  let pentries    := nat_of_elf32_half(elf32_phnum hdr)     in
  let pentry_size := nat_of_elf32_half(elf32_phentsize hdr) in
  let psize       := Coq.Init.Peano.mult pentries pentry_size in
    if beq_nat psize( 0) then
      return0 []
    else
      let poffset := nat_of_elf32_off(elf32_phoff hdr) in
      byte_sequence.offset_and_cut poffset psize bs0 >>= (fun (pexact : byte_sequence ) =>
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_program_header_table psize endian pexact >>= 
  (fun (p : (list (elf32_program_header_table_entry )*byte_sequence ) % type) =>
     match ( (p) ) with ( (pht,  _)) => return0 pht end)).
(* [?]: removed value specification. *)

Definition obtain_elf64_program_header_table  (hdr : elf64_header ) (bs0 : byte_sequence )  : error (list (elf64_program_header_table_entry )):= 
  let endian      := get_elf64_header_endianness hdr in
  let pentries    := nat_of_elf64_half(elf64_phnum hdr)     in
  let pentry_size := nat_of_elf64_half(elf64_phentsize hdr) in
  let psize       := Coq.Init.Peano.mult pentries pentry_size in
    if beq_nat psize( 0) then
      return0 []
    else
      let poffset := nat_of_elf64_off(elf64_phoff hdr) in
      byte_sequence.offset_and_cut poffset psize bs0 >>= (fun (pexact : byte_sequence ) =>
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_program_header_table psize endian pexact >>= 
  (fun (p : (list (elf64_program_header_table_entry )*byte_sequence ) % type) =>
     match ( (p) ) with ( (pht,  _)) => return0 pht end)).
(* [?]: removed value specification. *)

Definition obtain_elf32_section_header_table  (hdr : elf32_header ) (bs0 : byte_sequence )  : error (list (elf32_section_header_table_entry )):= 
  let endian      := get_elf32_header_endianness hdr in
  let sentries    := nat_of_elf32_half(elf32_shnum hdr) in
  let sentry_size := nat_of_elf32_half(elf32_shentsize hdr) in
  let ssize       := Coq.Init.Peano.mult sentries sentry_size in
    if beq_nat ssize( 0) then
      return0 []
    else
      let soffset := nat_of_elf32_off(elf32_shoff hdr) in
      byte_sequence.offset_and_cut soffset ssize bs0 >>= (fun (sexact : byte_sequence ) =>
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_section_header_table ssize endian sexact >>= 
  (fun (p : (list (elf32_section_header_table_entry )*byte_sequence ) % type) =>
     match ( (p) ) with ( (sht,  _)) => return0 sht end)).
(* [?]: removed value specification. *)

Definition obtain_elf64_section_header_table  (hdr : elf64_header ) (bs0 : byte_sequence )  : error (list (elf64_section_header_table_entry )):= 
  let endian      := get_elf64_header_endianness hdr in
  let sentries    := nat_of_elf64_half(elf64_shnum hdr) in
  let sentry_size := nat_of_elf64_half(elf64_shentsize hdr) in
  let ssize       := Coq.Init.Peano.mult sentries sentry_size in
    if beq_nat ssize( 0) then
      return0 []
    else
      let soffset := nat_of_elf64_off(elf64_shoff hdr) in
      byte_sequence.offset_and_cut soffset ssize bs0 >>= (fun (sexact : byte_sequence ) =>
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_section_header_table ssize endian sexact >>= 
  (fun (p : (list (elf64_section_header_table_entry )*byte_sequence ) % type) =>
     match ( (p) ) with ( (sht,  _)) => return0 sht end)).
(* [?]: removed value specification. *)

Definition obtain_elf32_section_header_string_table  (hdr : elf32_header ) (sht : list (elf32_section_header_table_entry )) (bs0 : byte_sequence )  : error (string_table ):= 
  match ( index0 (nat_of_elf32_half(elf32_shstrndx hdr)) sht) with  
    None => fail0 "no section header string table"
    | Some x => return0 x
  end >>= (fun (sh : elf32_section_header_table_entry ) =>
  byte_sequence.offset_and_cut (nat_of_elf32_off(elf32_sh_offset sh)) (nat_of_elf32_word(elf32_sh_size sh)) bs0 >>= (fun (sexact : byte_sequence ) =>
  return0 (string_table_of_byte_sequence sexact))).
(* [?]: removed value specification. *)

Definition obtain_elf64_section_header_string_table  (hdr : elf64_header ) (sht : list (elf64_section_header_table_entry )) (bs0 : byte_sequence )  : error (string_table ):= 
  match ( index0 (nat_of_elf64_half(elf64_shstrndx hdr)) sht) with  
    None => fail0 "no section header string table"
    | Some x => return0 x
  end >>= (fun (sh : elf64_section_header_table_entry ) =>
  byte_sequence.offset_and_cut (nat_of_elf64_off(elf64_sh_offset sh)) (nat_of_elf64_xword(elf64_sh_size sh)) bs0 >>= (fun (sexact : byte_sequence ) =>
  return0 (string_table_of_byte_sequence sexact))).
(* [?]: removed value specification. *)

Definition obtain_elf32_interpreted_segments  (pht : list (elf32_program_header_table_entry )) (bdy : byte_sequence )  : error (list (elf32_interpreted_segment )):= 
  mapM (fun (ph : elf32_program_header_table_entry ) =>
    let offset   := nat_of_elf32_off(elf32_p_offset ph)  in
    let size2     := nat_of_elf32_word(elf32_p_filesz ph) in
      (if beq_nat size2( 0) then
         return0 byte_sequence.empty
       else
         byte_sequence.offset_and_cut offset size2 bdy) >>= (fun (relevant : byte_sequence ) =>
    let vaddr    := nat_of_elf32_addr(elf32_p_vaddr ph) in
    let paddr    := nat_of_elf32_addr(elf32_p_paddr ph) in
    let memsz    := nat_of_elf32_word(elf32_p_memsz ph) in
    let typ      := nat_of_elf32_word(elf32_p_type ph)  in
    let align    := nat_of_elf32_word(elf32_p_align ph) in
    let flags    := elf32_interpret_program_header_flags(elf32_p_flags ph) in
      if nat_ltb memsz size2 then
        fail0 "obtain_elf32_interpreted_segments: memory size of segment cannot be less than file size"
      else
        return0 {|elf32_segment_body := relevant;elf32_segment_type := typ;elf32_segment_size := size2;elf32_segment_memsz := memsz;elf32_segment_base  := vaddr;elf32_segment_flags := flags;elf32_segment_paddr := paddr;elf32_segment_align := align;elf32_segment_offset := offset |})
    ) pht.
(* [?]: removed value specification. *)

Definition obtain_elf64_interpreted_segments  (pht : list (elf64_program_header_table_entry )) (bdy : byte_sequence )  : error (list (elf64_interpreted_segment )):= 
  mapM (fun (ph : elf64_program_header_table_entry ) =>
    let offset   := nat_of_elf64_off(elf64_p_offset   ph)  in
    let size2     := nat_of_elf64_xword(elf64_p_filesz ph) in
      (if beq_nat size2( 0) then
         return0 byte_sequence.empty
       else
         byte_sequence.offset_and_cut offset size2 bdy) >>= (fun (relevant : byte_sequence ) =>
    let vaddr    := nat_of_elf64_addr(elf64_p_vaddr  ph) in
    let paddr    := nat_of_elf64_addr(elf64_p_paddr  ph) in
    let memsz    := nat_of_elf64_xword(elf64_p_memsz ph) in
    let typ      := nat_of_elf64_word(elf64_p_type  ph)  in
    let align    := nat_of_elf64_xword(elf64_p_align ph) in
    let flags    := elf64_interpret_program_header_flags(elf64_p_flags ph) in
      if nat_ltb memsz size2 then
        fail0 "obtain_elf64_interpreted_segments: memory size of segment cannot be less than file size"
      else
        return0 {|elf64_segment_body := relevant;elf64_segment_type := typ;elf64_segment_size := size2;elf64_segment_memsz := memsz;elf64_segment_base  := vaddr;elf64_segment_flags := flags;elf64_segment_align := align;elf64_segment_paddr := paddr;elf64_segment_offset := offset |})
    ) pht.
(* [?]: removed value specification. *)

Definition obtain_elf32_interpreted_sections  (shstrtab : string_table ) (sht : list (elf32_section_header_table_entry )) (bs0 : byte_sequence )  : error (list (elf32_interpreted_section )):= 
  mapM (fun (sh : elf32_section_header_table_entry ) =>
    let offset := nat_of_elf32_off(elf32_sh_offset  sh) in
    let size2   := nat_of_elf32_word(elf32_sh_size sh) in
    let name1   := nat_of_elf32_word(elf32_sh_name sh) in
    let typ    := nat_of_elf32_word(elf32_sh_type sh) in
    let filesz := if beq_nat typ sht_nobits then 0 else size2 in
    let flags  := nat_of_elf32_word(elf32_sh_flags sh) in
    let base   := nat_of_elf32_addr(elf32_sh_addr sh) in
    let link1   := nat_of_elf32_word(elf32_sh_link sh) in
    let info   := nat_of_elf32_word(elf32_sh_info sh) in
    let align  := nat_of_elf32_word(elf32_sh_addralign sh) in
    let entry_size := nat_of_elf32_word(elf32_sh_entsize sh) in
    let name_string := match ( (get_string_at name1 shstrtab)) with  Success n => n | Fail _ => "" end in
      (if beq_nat filesz( 0) then
        return0 byte_sequence.empty
      else
        byte_sequence.offset_and_cut offset filesz bs0) >>= (fun (relevant : byte_sequence ) =>
      return0 {|elf32_section_name := name1;elf32_section_type := typ;elf32_section_size := size2;elf32_section_offset := offset;elf32_section_flags := flags;elf32_section_addr := base;elf32_section_link := link1;elf32_section_info := info;elf32_section_align := align;elf32_section_body := relevant;elf32_section_entsize := entry_size;elf32_section_name_as_string := name_string |})
  ) sht.
(* [?]: removed value specification. *)

Definition obtain_elf64_interpreted_sections  (shstrtab : string_table ) (sht : list (elf64_section_header_table_entry )) (bs0 : byte_sequence )  : error (list (elf64_interpreted_section )):= 
  mapM (fun (sh : elf64_section_header_table_entry ) =>
    let offset := nat_of_elf64_off(elf64_sh_offset   sh) in
    let size2   := nat_of_elf64_xword(elf64_sh_size sh) in
    let name1   := nat_of_elf64_word(elf64_sh_name  sh) in
    let typ    := nat_of_elf64_word(elf64_sh_type  sh) in
    let filesz := if beq_nat typ sht_nobits then 0 else size2 in
    let flags  := nat_of_elf64_xword(elf64_sh_flags sh) in
    let base   := nat_of_elf64_addr(elf64_sh_addr  sh) in
    let link1   := nat_of_elf64_word(elf64_sh_link  sh) in
    let info   := nat_of_elf64_word(elf64_sh_info  sh) in
    let align  := nat_of_elf64_xword(elf64_sh_addralign sh) in
    let entry_size := nat_of_elf64_xword(elf64_sh_entsize sh) in
    let name_string := match ( (get_string_at name1 shstrtab)) with  Success n => n | Fail _ => "" end in 
      (if beq_nat filesz( 0) then
        return0 byte_sequence.empty
      else
        byte_sequence.offset_and_cut offset filesz bs0) >>= (fun (relevant : byte_sequence ) =>
      return0 {|elf64_section_name := name1;elf64_section_type := typ;elf64_section_size := size2;elf64_section_offset := offset;elf64_section_flags := flags;elf64_section_addr := base;elf64_section_link := link1;elf64_section_info := info;elf64_section_align := align;elf64_section_body := relevant;elf64_section_entsize := entry_size;elf64_section_name_as_string := name_string |})
  ) sht.
(* [?]: removed value specification. *)

Program Fixpoint find_first_not_in_range  (start : nat ) (ranges : list ((nat *nat ) % type))  : nat := 
  match ( List.filter (
  fun (p : (nat *nat ) % type) =>
    match ( (p) ) with ( (x,  y)) => nat_gteb start x && nat_lteb start y end) ranges) with 
    | [] => start
    | _  => find_first_not_in_range ( Coq.Init.Peano.plus start( 1)) ranges
  end.
(* [?]: removed value specification. *)

Program Fixpoint find_first_in_range  (start : nat ) (ranges : list ((nat *nat ) % type))  : nat := 
  match ( List.filter (
  fun (p : (nat *nat ) % type) =>
    match ( (p) ) with ( (x,  y)) => nat_gteb start x && nat_lteb start y end) ranges) with 
    | [] => find_first_in_range ( Coq.Init.Peano.plus start( 1)) ranges
    | _  => start
  end.
(* [?]: removed value specification. *)

Program Fixpoint compute_differences  (start : nat ) (max : nat ) (ranges : list ((nat *nat ) % type))  : error (list ((nat *nat ) % type)):= 
  if beq_nat start max then
    return0 []
  else if nat_gtb start max then
    fail0 "compute_differences: passed maximum"
  else
    let first := find_first_not_in_range start ranges in
      if nat_gteb first max then
        return0 []
      else
        let last1 := find_first_in_range first ranges in
          if nat_gtb last1 max then
            return0 [(first, max)]
          else
            compute_differences last1 max ranges >>= (fun (tail1 : list ((nat *nat ) % type)) =>
            return0 ((first, last1)::tail1)).
(* [?]: removed value specification. *)

Definition obtain_elf32_bits_and_bobs  (hdr : elf32_header ) (segs : list (elf32_program_header_table_entry )) (interp_segs : list (elf32_interpreted_segment )) (sects : list (elf32_section_header_table_entry )) (interp_sects : list (elf32_interpreted_section )) (bs0 : byte_sequence )  : error (list ((nat *byte_sequence ) % type)):= 
  let hdr_off_len  := ( 0, nat_of_elf32_half(elf32_ehsize hdr)) in
  let pht_off      := nat_of_elf32_off(elf32_phoff hdr) in
  let pht_len      := Coq.Init.Peano.mult (nat_of_elf32_half(elf32_phentsize hdr)) (nat_of_elf32_half(elf32_phnum hdr)) in
  let pht_off_len  := (pht_off, Coq.Init.Peano.plus pht_off pht_len) in
  let sht_off      := nat_of_elf32_off(elf32_shoff hdr) in
  let sht_len      := Coq.Init.Peano.mult (nat_of_elf32_half(elf32_shentsize hdr)) (nat_of_elf32_half(elf32_shnum hdr)) in
  let sht_off_len  := (sht_off, Coq.Init.Peano.plus sht_off sht_len) in
    if beq_nat (List.length interp_segs) (List.length segs) then
      let seg_zip := lem_list.zip segs interp_segs in
      if beq_nat (List.length interp_sects) (List.length sects) then
        let sect_zip := lem_list.zip sects interp_sects in
        let seg_off_len  :=
          List.map (fun (p : (elf32_program_header_table_entry *elf32_interpreted_segment ) % type) =>
  match ( (p) ) with ( (seg,  interp_seg)) =>
    let start := nat_of_elf32_off (elf32_p_offset seg) in
  let len :=(elf32_segment_size interp_seg) in
  (start, Coq.Init.Peano.plus start len) end) seg_zip
        in
        let sect_off_len :=
          List.map (fun (p : (elf32_section_header_table_entry *elf32_interpreted_section ) % type) =>
  match ( (p) ) with ( (sect,  interp_sect)) =>
    let start := nat_of_elf32_off (elf32_sh_offset sect) in
  let len :=(elf32_section_size interp_sect) in
  (start, Coq.Init.Peano.plus start len) end) sect_zip
        in
        let pre_layout   := hdr_off_len :: (pht_off_len :: (sht_off_len ::  (@ List.app _)seg_off_len sect_off_len)) in
        let layout       :=
          sort_by (fun (p : (nat *nat ) % type) (p0 : (nat *nat ) % type) =>
  match ( (p ,p0) ) with ( (off_x,  _) ,  (off_y,  _)) =>
    natural_ordering off_x off_y end
          ) pre_layout
        in
          compute_differences( 0) (byte_sequence.length0 bs0) layout >>= (fun (diffs : list ((nat *nat ) % type)) =>
            mapM (fun (p : (nat *nat ) % type) =>
  match ( (p) ) with ( (start,  len)) =>
    byte_sequence.offset_and_cut start ( Coq.Init.Peano.minus len start) bs0
    >>= (fun (rel : byte_sequence ) => return0 (start, rel)) end
            ) diffs)
      else
        fail0 "obtain_elf32_bits_and_bobs: section header table and interpreted section differ in length"
    else
      fail0 "obtain_elf32_bits_and_bobs: program header table and interpreted segments differ in length".
(* [?]: removed value specification. *)

Definition obtain_elf64_bits_and_bobs  (hdr : elf64_header ) (segs : list (elf64_program_header_table_entry )) (interp_segs : list (elf64_interpreted_segment )) (sects : list (elf64_section_header_table_entry )) (interp_sects : list (elf64_interpreted_section )) (bs0 : byte_sequence )  : error (list ((nat *byte_sequence ) % type)):= 
  let hdr_off_len  := ( 0, nat_of_elf64_half(elf64_ehsize hdr)) in
  
  let pht_off      := nat_of_elf64_off(elf64_phoff hdr) in
  let pht_len      := Coq.Init.Peano.mult (nat_of_elf64_half(elf64_phentsize hdr)) (nat_of_elf64_half(elf64_phnum hdr)) in
  let pht_off_len  := (pht_off, Coq.Init.Peano.plus pht_off pht_len) in
  let sht_off      := nat_of_elf64_off(elf64_shoff hdr) in
  let sht_len      := Coq.Init.Peano.mult (nat_of_elf64_half(elf64_shentsize hdr)) (nat_of_elf64_half(elf64_shnum hdr)) in
  let sht_off_len  := (sht_off, Coq.Init.Peano.plus sht_off sht_len) in
    if beq_nat (List.length interp_segs) (List.length segs) then
      let seg_zip := lem_list.zip segs interp_segs in
      if beq_nat (List.length interp_sects) (List.length sects) then
        let sect_zip := lem_list.zip sects interp_sects in
        let seg_off_len  :=
          List.map (fun (p : (elf64_program_header_table_entry *elf64_interpreted_segment ) % type) =>
  match ( (p) ) with ( (seg,  interp_seg)) =>
    let start := nat_of_elf64_off (elf64_p_offset seg) in
  let len :=(elf64_segment_size interp_seg) in
  (start, Coq.Init.Peano.plus start len) end) seg_zip
        in
        let sect_off_len :=
          List.map (fun (p : (elf64_section_header_table_entry *elf64_interpreted_section ) % type) =>
  match ( (p) ) with ( (sect,  interp_sect)) =>
    let start := nat_of_elf64_off (elf64_sh_offset sect) in
  let len :=(elf64_section_size interp_sect) in
  (start, Coq.Init.Peano.plus start len) end) sect_zip
        in
        let pre_layout   := hdr_off_len :: (pht_off_len :: (sht_off_len ::  (@ List.app _)seg_off_len sect_off_len)) in
        let layout       :=
          sort_by (fun (p : (nat *nat ) % type) (p0 : (nat *nat ) % type) =>
  match ( (p ,p0) ) with ( (off_x,  _) ,  (off_y,  _)) =>
    natural_ordering off_x off_y end
          ) pre_layout
        in
          compute_differences( 0) (byte_sequence.length0 bs0) layout >>= (fun (diffs : list ((nat *nat ) % type)) =>
            mapM (fun (p : (nat *nat ) % type) =>
  match ( (p) ) with ( (start,  finish)) =>
    byte_sequence.offset_and_cut start ( Coq.Init.Peano.minus finish start)
      bs0 >>= (fun (rel : byte_sequence ) => return0 (start, rel)) end
            ) diffs)
      else
        fail0 "obtain_elf64_bits_and_bobs: section header table and interpreted section differ in length"
    else
      fail0 "obtain_elf64_bits_and_bobs: program header table and interpreted segments differ in length".
(* [?]: removed value specification. *)

Definition read_elf32_file  (bs0 : byte_sequence )  : error (elf32_file ):= 
  read_elf32_header bs0 >>= 
  (fun (p : (elf32_header *byte_sequence ) % type) =>
     match ( (p) ) with ( (hdr,  bs1)) =>
       obtain_elf32_program_header_table hdr bs0 >>=
       (fun (pht : list (elf32_program_header_table_entry )) =>
          obtain_elf32_section_header_table hdr bs0 >>=
          (fun (sht : list (elf32_section_header_table_entry )) =>
             obtain_elf32_section_header_string_table hdr sht bs0 >>=
             (fun (shstrtab : string_table ) =>
                obtain_elf32_interpreted_segments pht bs0 >>=
                (fun (segs : list (elf32_interpreted_segment )) =>
                   obtain_elf32_interpreted_sections shstrtab sht bs0 >>=
                   (fun (sects : list (elf32_interpreted_section )) =>
                      obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0
                      >>=
                      (fun (bits_and_bobs : list ((nat *byte_sequence ) % type)) =>
                         return0
                           {|elf32_file_header := hdr;elf32_file_program_header_table := pht;elf32_file_section_header_table := sht;elf32_file_interpreted_segments := segs;elf32_file_interpreted_sections := sects;elf32_file_bits_and_bobs := bits_and_bobs |}))))))
     end).
(* [?]: removed value specification. *)

Definition read_elf64_file  (bs0 : byte_sequence )  : error (elf64_file ):= 
  read_elf64_header bs0 >>= 
  (fun (p : (elf64_header *byte_sequence ) % type) =>
     match ( (p) ) with ( (hdr,  bs1)) =>
       obtain_elf64_program_header_table hdr bs0 >>=
       (fun (pht : list (elf64_program_header_table_entry )) =>
          obtain_elf64_section_header_table hdr bs0 >>=
          (fun (sht : list (elf64_section_header_table_entry )) =>
             obtain_elf64_section_header_string_table hdr sht bs0 >>=
             (fun (shstrtab : string_table ) =>
                obtain_elf64_interpreted_segments pht bs0 >>=
                (fun (segs : list (elf64_interpreted_segment )) =>
                   obtain_elf64_interpreted_sections shstrtab sht bs0 >>=
                   (fun (sects : list (elf64_interpreted_section )) =>
                      obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0
                      >>=
                      (fun (bits_and_bobs : list ((nat *byte_sequence ) % type)) =>
                         return0
                           {|elf64_file_header := hdr;elf64_file_program_header_table := pht;elf64_file_section_header_table := sht;elf64_file_interpreted_segments := segs;elf64_file_interpreted_sections := sects;elf64_file_bits_and_bobs := bits_and_bobs |}))))))
     end).
(* [?]: removed value specification. *)

Definition get_elf32_file_section_header_string_table  (f3 : elf32_file )  : error (string_table ):= 
  let hdr  :=(elf32_file_header f3) in
  let sht  :=(elf32_file_section_header_table f3) in
  let segs :=(elf32_file_interpreted_segments f3) in
  let idx1  := nat_of_elf32_half(elf32_shstrndx hdr) in
  bytes_of_elf32_file f3 >>= (fun (bs0 : byte_sequence ) =>
    match ( missing_pervasives.index0 idx1 sht) with 
      | None => fail0 "obtain_elf32_string_table: invalid offset into section header table"
      | Some sect =>
          let offset := nat_of_elf32_off(elf32_sh_offset sect) in
          let size2   := nat_of_elf32_word(elf32_sh_size sect) in
          byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (rel : byte_sequence ) =>
          let strings  := byte_sequence.string_of_byte_sequence rel in
          return0 (string_table.mk_string_table strings null_char))
    end).
(* [?]: removed value specification. *)

Definition get_elf64_file_section_header_string_table  (f3 : elf64_file )  : error (string_table ):= 
  let hdr  :=(elf64_file_header f3) in
  let sht  :=(elf64_file_section_header_table f3) in
  let segs :=(elf64_file_interpreted_segments f3) in
  let idx1  := nat_of_elf64_half(elf64_shstrndx hdr) in
  bytes_of_elf64_file f3 >>= (fun (bs0 : byte_sequence ) =>
    match ( missing_pervasives.index0 idx1 sht) with 
      | None => fail0 "obtain_elf64_string_table: invalid offset into section header table"
      | Some sect =>
          let offset := nat_of_elf64_off(elf64_sh_offset   sect) in
          let size2   := nat_of_elf64_xword(elf64_sh_size sect) in
          byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (rel : byte_sequence ) =>
          let strings  := byte_sequence.string_of_byte_sequence rel in
          return0 (string_table.mk_string_table strings null_char))
    end).
(* [?]: removed value specification. *)

Definition find_elf32_symbols_by_symtab_idx  (sec_idx : nat ) (f : elf32_file )  : error ((list (elf32_symbol_table_entry )*string_table *nat ) % type):= 
    match ( lem_list.index(elf32_file_interpreted_sections f) ( sec_idx)) with 
        None => fail0 "impossible: interpreted section found but not indexable"
        | Some sec => return0 sec
    end >>= (fun (sec : elf32_interpreted_section ) => 
    match ( lem_list.index(elf32_file_interpreted_sections f) ((elf32_section_link sec))) with 
        None => fail0 "no associated strtab"
        | Some strs => return0 strs
    end >>= (fun (strs : elf32_interpreted_section ) => 
    let strings := byte_sequence.string_of_byte_sequence(elf32_section_body strs) in
    let strtab := string_table.mk_string_table strings null_char in
    let endian := get_elf32_header_endianness(elf32_file_header f) in
    read_elf32_symbol_table endian(elf32_section_body sec) >>= (fun (symtab : list (elf32_symbol_table_entry )) =>
    return0 (symtab, strtab, sec_idx)))).
(* [?]: removed value specification. *)

Definition find_elf32_symtab_by_type  (t : nat ) (f : elf32_file )  : error ((elf32_symbol_table *string_table *nat ) % type):= 
    let found_symtab_index := find_index (fun (sh : elf32_interpreted_section ) => beq_nat(elf32_section_type sh) t)(elf32_file_interpreted_sections f) in
    match ( found_symtab_index) with  
        None => fail0 "no such symtab"
        | Some sec_idx => return0 sec_idx
    end >>= (fun (sec_idx : nat ) => find_elf32_symbols_by_symtab_idx sec_idx f).
(* [?]: removed value specification. *)

Definition find_elf64_symbols_by_symtab_idx  (sec_idx : nat ) (f : elf64_file )  : error ((list (elf64_symbol_table_entry )*string_table *nat ) % type):= 
    match ( lem_list.index(elf64_file_interpreted_sections f) ( sec_idx)) with 
        None => fail0 "impossible: interpreted section found but not indexable"
        | Some sec => return0 sec
    end >>= (fun (sec : elf64_interpreted_section ) => 
    match ( lem_list.index(elf64_file_interpreted_sections f) ((elf64_section_link sec))) with 
        None => fail0 "no associated strtab"
        | Some strs => return0 strs
    end >>= (fun (strs : elf64_interpreted_section ) => 
    let strings := byte_sequence.string_of_byte_sequence(elf64_section_body strs) in
    let strtab := string_table.mk_string_table strings null_char in
    let endian := get_elf64_header_endianness(elf64_file_header f) in
    read_elf64_symbol_table endian(elf64_section_body sec) >>= (fun (symtab : list (elf64_symbol_table_entry )) =>
    return0 (symtab, strtab, sec_idx)))).
(* [?]: removed value specification. *)

Definition find_elf64_symtab_by_type  (t : nat ) (f : elf64_file )  : error ((elf64_symbol_table *string_table *nat ) % type):= 
    let found_symtab_index := find_index (fun (sh : elf64_interpreted_section ) => beq_nat(elf64_section_type sh) t)(elf64_file_interpreted_sections f) in
    match ( found_symtab_index) with  
        None => fail0 "no such symtab"
        | Some sec_idx => return0 sec_idx
    end >>= (fun (sec_idx : nat ) => find_elf64_symbols_by_symtab_idx sec_idx f).
(* [?]: removed value specification. *)

Definition get_elf32_file_symbol_string_table  (f3 : elf32_file )  : error (string_table ):= 
  let hdr     :=(elf32_file_header f3) in
  let sht     :=(elf32_file_section_header_table f3) in
  let segs    :=(elf32_file_interpreted_segments f3) in
  let strtabs := missing_pervasives.mapMaybei (fun (index2 : nat ) (sect : elf32_section_header_table_entry ) =>
    if beq_nat (nat_of_elf32_word(elf32_sh_type sect)) sht_strtab then
      if beq_nat index2 (nat_of_elf32_half(elf32_shstrndx hdr)) then
        None
      else
        Some sect
    else
      None) sht
  in
    bytes_of_elf32_file f3 >>= (fun (bs0 : byte_sequence ) =>
    mapM (fun (sect : elf32_section_header_table_entry ) =>
      let offset  := nat_of_elf32_off(elf32_sh_offset  sect) in
      let size2    := nat_of_elf32_word(elf32_sh_size sect) in
      byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (bs1 : byte_sequence ) =>
      let strings := byte_sequence.string_of_byte_sequence bs1 in
      return0 (string_table.mk_string_table strings null_char))) strtabs
    >>= (fun (strings : list (string_table )) =>
      string_table.concat2 strings)).
(* [?]: removed value specification. *)

Definition get_elf64_file_symbol_string_table  (f3 : elf64_file )  : error (string_table ):= 
  let hdr     :=(elf64_file_header f3) in
  let sht     :=(elf64_file_section_header_table f3) in
  let segs    :=(elf64_file_interpreted_segments f3) in
  let strtabs := missing_pervasives.mapMaybei (fun (index2 : nat ) (sect : elf64_section_header_table_entry ) =>
    if beq_nat (nat_of_elf64_word(elf64_sh_type sect)) sht_strtab then
      if beq_nat index2 (nat_of_elf64_half(elf64_shstrndx hdr)) then
        None
      else
        Some sect
    else
      None) sht
  in
    bytes_of_elf64_file f3 >>= (fun (bs0 : byte_sequence ) =>
    mapM (fun (sect : elf64_section_header_table_entry ) =>
      let offset  := nat_of_elf64_off(elf64_sh_offset   sect) in
      let size2    := nat_of_elf64_xword(elf64_sh_size sect) in
      byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (bs1 : byte_sequence ) =>
      let strings := byte_sequence.string_of_byte_sequence bs1 in
      return0 (string_table.mk_string_table strings null_char))) strtabs
    >>= (fun (strings : list (string_table )) =>
      string_table.concat2 strings)).
(* [?]: removed value specification. *)

Definition get_elf32_file_symbol_table  (f3 : elf32_file )  : error (list (elf32_symbol_table_entry )):= 
  let hdr     :=(elf32_file_header f3) in
  let sht     :=(elf32_file_section_header_table f3) in
  let segs    :=(elf32_file_interpreted_segments f3) in
  let endian  := get_elf32_header_endianness hdr in
  let symtabs := List.filter (fun (sect : elf32_section_header_table_entry ) => beq_nat    
(nat_of_elf32_word(elf32_sh_type sect)) sht_symtab
    ) sht
  in
    match ( symtabs) with 
      | [] => return0 []
      | [symtab] =>
        let offset := nat_of_elf32_off(elf32_sh_offset symtab) in
        let size2   := nat_of_elf32_word(elf32_sh_size symtab) in
        bytes_of_elf32_file f3 >>= (fun (bs0 : byte_sequence ) =>
        byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (relevant : byte_sequence ) =>
        read_elf32_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf32_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB"
    end.
(* [?]: removed value specification. *)

Definition get_elf64_file_symbol_table  (f3 : elf64_file )  : error (list (elf64_symbol_table_entry )):= 
  let hdr     :=(elf64_file_header f3) in
  let sht     :=(elf64_file_section_header_table f3) in
  let segs    :=(elf64_file_interpreted_segments f3) in
  let endian  := get_elf64_header_endianness hdr in
  let symtabs := List.filter (fun (sect : elf64_section_header_table_entry ) => beq_nat    
(nat_of_elf64_word(elf64_sh_type sect)) sht_symtab
    ) sht
  in
    match ( symtabs) with 
      | [] => return0 []
      | [symtab] =>
        let offset := nat_of_elf64_off(elf64_sh_offset   symtab) in
        let size2   := nat_of_elf64_xword(elf64_sh_size symtab) in
        bytes_of_elf64_file f3 >>= (fun (bs0 : byte_sequence ) =>
        byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (relevant : byte_sequence ) =>
        read_elf64_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf64_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB"
    end.
(* [?]: removed value specification. *)

Definition get_elf32_file_dynamic_symbol_table  (ef : elf32_file )  : error (list (elf32_symbol_table_entry )):= 
  let hdr     :=(elf32_file_header ef) in
  let sht     :=(elf32_file_section_header_table ef) in
  let segs    :=(elf32_file_interpreted_segments ef) in
  let endian  := get_elf32_header_endianness hdr in
  let symtabs := List.filter (fun (sect : elf32_section_header_table_entry ) => beq_nat    
(nat_of_elf32_word(elf32_sh_type sect)) sht_dynsym
    ) sht
  in
    match ( symtabs) with 
      | [] => return0 []
      | [symtab] =>
        let offset := nat_of_elf32_off(elf32_sh_offset symtab) in
        let size2   := nat_of_elf32_word(elf32_sh_size symtab) in
        bytes_of_elf32_file ef >>= (fun (bs0 : byte_sequence ) =>
        byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (relevant : byte_sequence ) =>
        read_elf32_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf32_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM"
    end.
(* [?]: removed value specification. *)

Definition get_elf64_file_dynamic_symbol_table  (ef : elf64_file )  : error (list (elf64_symbol_table_entry )):= 
  let hdr     :=(elf64_file_header ef) in
  let sht     :=(elf64_file_section_header_table ef) in
  let segs    :=(elf64_file_interpreted_segments ef) in
  let endian  := get_elf64_header_endianness hdr in
  let symtabs := List.filter (fun (sect : elf64_section_header_table_entry ) => beq_nat    
(nat_of_elf64_word(elf64_sh_type sect)) sht_dynsym
    ) sht
  in
    match ( symtabs) with 
      | [] => return0 []
      | [symtab] =>
        let offset := nat_of_elf64_off(elf64_sh_offset   symtab) in
        let size2   := nat_of_elf64_xword(elf64_sh_size symtab) in
        bytes_of_elf64_file ef >>= (fun (bs0 : byte_sequence ) =>
        byte_sequence.offset_and_cut offset size2 bs0 >>= (fun (relevant : byte_sequence ) =>
        read_elf64_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf64_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM"
    end.
(* [?]: removed value specification. *)

Definition get_elf32_symbol_table_by_index  (ef : elf32_file ) (link1 : nat )  : error (elf32_symbol_table ):= 
  let hdr     :=(elf32_file_header ef) in
  let sht     :=(elf32_file_section_header_table ef) in
  let sects   :=(elf32_file_interpreted_sections ef) in
  let endian  := get_elf32_header_endianness hdr in
    match ( lem_list.index sects (id link1)) with 
      | None  => fail0 "get_elf32_symbol_table_by_index: invalid index"
      | Some sym =>
        read_elf32_symbol_table endian(elf32_section_body sym)
    end.
(* [?]: removed value specification. *)

Definition get_elf32_string_table_by_index  (ef : elf32_file ) (link1 : nat )  : error (string_table ):= 
  let hdr     :=(elf32_file_header ef) in
  let sht     :=(elf32_file_section_header_table ef) in
  let sects   :=(elf32_file_interpreted_sections ef) in
    match ( lem_list.index sects (id link1)) with 
      | None  => fail0 "get_elf32_string_table_by_index: invalid index"
      | Some sym => return0 (mk_string_table (byte_sequence.string_of_byte_sequence(elf32_section_body sym)) null_char)
    end.
(* [?]: removed value specification. *)

Definition get_elf64_symbol_table_by_index  (ef : elf64_file ) (link1 : nat )  : error (elf64_symbol_table ):= 
  let hdr     :=(elf64_file_header ef) in
  let sht     :=(elf64_file_section_header_table ef) in
  let sects   :=(elf64_file_interpreted_sections ef) in
  let endian  := get_elf64_header_endianness hdr in
    match ( lem_list.index sects (id link1)) with 
      | None  => fail0 "get_elf64_symbol_table_by_index: invalid index"
      | Some sym =>
        read_elf64_symbol_table endian(elf64_section_body sym)
    end.
(* [?]: removed value specification. *)

Definition get_elf64_string_table_by_index  (ef : elf64_file ) (link1 : nat )  : error (string_table ):= 
  let hdr     :=(elf64_file_header ef) in
  let sht     :=(elf64_file_section_header_table ef) in
  let sects   :=(elf64_file_interpreted_sections ef) in
    match ( lem_list.index sects (id link1)) with 
      | None  => fail0 "get_elf64_string_table_by_index: invalid index"
      | Some sym => return0 (mk_string_table (byte_sequence.string_of_byte_sequence(elf64_section_body sym)) null_char)
    end.

(** [segment_provenance] records whether a segment that appears in an executable
  * process image has been derived directly from an ELF file, or was automatically
  * created when the image calculation process noticed a segment with a memory
  * size greater than its file size.
  * Really a PPCMemism and not strictly needed for the ELF model itself.
  *)
Inductive segment_provenance : Type :=
   FromELF: segment_provenance        (** Segment derived directly from the source ELF file. *)
  | AutoGenerated: segment_provenance .
Definition segment_provenance_default: segment_provenance  := FromELF. (** Automatically generated during process extraction as memory size is greater than file size. *)

(** [elf32_executable_process_image] is a process image for ELF32 files.  Contains
  * all that is necessary to load the executable components of an ELF32 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
Definition elf32_executable_process_image : Type := 
  ((list  ((elf32_interpreted_segment  * segment_provenance ) % type) * nat  * nat ) % type).
Definition elf32_executable_process_image_default: elf32_executable_process_image  := (DAEMON, nat_default, nat_default).

(** [elf64_executable_process_image] is a process image for ELF64 files.  Contains
  * all that is necessary to load the executable components of an ELF64 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
Definition elf64_executable_process_image : Type := 
  ((list  ((elf64_interpreted_segment  * segment_provenance ) % type) * nat  * nat ) % type).
Definition elf64_executable_process_image_default: elf64_executable_process_image  := (DAEMON, nat_default, nat_default).
(* [?]: removed value specification. *)

Definition get_elf32_executable_image  (f3 : elf32_file )  : error ((list ((elf32_interpreted_segment *segment_provenance ) % type)*nat *nat ) % type):= 
  if is_elf32_executable_file(elf32_file_header f3) then
    let entr :=(elf32_entry(elf32_file_header f3)) in
    let segs :=(elf32_file_interpreted_segments f3) in
    let mach :=(elf32_machine(elf32_file_header f3)) in
      match ( List.filter (fun (sg : elf32_interpreted_segment ) => beq_nat(elf32_segment_type sg) elf_pt_load) segs) with 
        | []    => fail0 "get_elf32_executable_image: an executable ELF file must have at least one loadable segment"
        | load  =>
            mapM (fun (sg : elf32_interpreted_segment ) =>
              if beq_nat(elf32_segment_memsz sg)( 0) then
                return0 []
              else if beq_nat(elf32_segment_memsz sg)(elf32_segment_size sg) then
                return0 [(sg, FromELF)]
              else if nat_ltb(elf32_segment_size sg)(elf32_segment_memsz sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                let diff  := Coq.Init.Peano.minus(elf32_segment_memsz sg)(elf32_segment_size sg) in
                let zeros1 := byte_sequence.zeros diff in
                let addr  := Coq.Init.Peano.plus(elf32_segment_base sg)(elf32_segment_size sg) in
                let align :=(elf32_segment_align sg) in
                let paddr :=(elf32_segment_paddr sg) in
                let seg   :=
                  {|elf32_segment_body := zeros1;elf32_segment_type :=(elf32_segment_type sg);elf32_segment_size := diff;elf32_segment_memsz := diff;elf32_segment_base := addr;elf32_segment_flags :=(elf32_segment_flags sg);elf32_segment_align := align;elf32_segment_paddr := paddr;elf32_segment_offset :=(elf32_segment_offset sg) |}
                in
                  return0 [(sg, FromELF); (seg, AutoGenerated)]
              else
                fail0 "get_elf32_executable_image: invariant invalidated") load >>= (fun (bs_base : list (list ((elf32_interpreted_segment *segment_provenance ) % type))) =>
            return0 (lem_list.concat bs_base, nat_of_elf32_addr entr, nat_of_elf32_half mach))
      end
  else
    fail0 "get_elf32_executable_image: not an ELF executable file".
(* [?]: removed value specification. *)

Definition get_elf64_executable_image  (f3 : elf64_file )  : error ((list ((elf64_interpreted_segment *segment_provenance ) % type)*nat *nat ) % type):=  
  if is_elf64_executable_file(elf64_file_header f3) then
    let entr :=(elf64_entry(elf64_file_header f3)) in
    let segs :=(elf64_file_interpreted_segments f3) in
    let mach :=(elf64_machine(elf64_file_header f3)) in
      match ( List.filter (fun (sg : elf64_interpreted_segment ) => beq_nat(elf64_segment_type sg) elf_pt_load) segs) with 
        | []    => fail0 "get_elf64_executable_image: an executable ELF file must have at least one loadable segment"
        | load  =>
            mapM (fun (sg : elf64_interpreted_segment ) =>
              if beq_nat(elf64_segment_memsz sg)( 0) then
                return0 []
              else if beq_nat(elf64_segment_memsz sg)(elf64_segment_size sg) then
                return0 [(sg, FromELF)]
              else if nat_ltb(elf64_segment_size sg)(elf64_segment_memsz sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                let diff  := Coq.Init.Peano.minus(elf64_segment_memsz sg)(elf64_segment_size sg) in
                let zeros1 := byte_sequence.zeros diff in
                let addr  := Coq.Init.Peano.plus(elf64_segment_base sg)(elf64_segment_size sg) in
                let align :=(elf64_segment_align sg) in
                let paddr :=(elf64_segment_paddr sg) in
                let seg   :=
                  {|elf64_segment_body := zeros1;elf64_segment_type :=(elf64_segment_type sg);elf64_segment_size := diff;elf64_segment_memsz := diff;elf64_segment_base := addr;elf64_segment_flags :=(elf64_segment_flags sg);elf64_segment_align := align;elf64_segment_paddr := paddr;elf64_segment_offset :=(elf64_segment_offset sg) |}
                in
                  return0 [(sg, FromELF); (seg, AutoGenerated)]
              else
                fail0 "get_elf64_executable_image: invariant invalidated") load >>= (fun (bs_base : list (list ((elf64_interpreted_segment *segment_provenance ) % type))) =>
            return0 (lem_list.concat bs_base, nat_of_elf64_addr entr, nat_of_elf64_half mach))
      end
  else
    fail0 "elf64_get_executable_image: not an executable ELF file".

(** [global_symbol_init_info] records the name, type, size, address, chunk
  * of initialisation data (if relevant for that symbol), and binding, of every
  * global symbol in an ELF file.
  * Another PPCMemism.
  *)
Definition global_symbol_init_info : Type :=
   list  ((string  * ((nat  * nat  * nat  * option  byte_sequence   * nat ) % type)) % type).
Definition global_symbol_init_info_default: global_symbol_init_info  := DAEMON.
(* [?]: removed value specification. *)

Definition get_elf32_file_global_symbol_init  (f3 : elf32_file )  : error (list ((string *((nat *nat *nat *option (byte_sequence ) *nat ) % type)) % type)):= 
  if is_elf32_executable_file(elf32_file_header f3) then
    let segs   :=(elf32_file_interpreted_segments f3) in
    bytes_of_elf32_file f3 >>= (fun (bs0 : byte_sequence ) =>
    get_elf32_file_symbol_table f3 >>= (fun (symtab : list (elf32_symbol_table_entry )) =>
    get_elf32_file_symbol_string_table f3 >>= (fun (strtab : string_table ) =>
    elf_symbol_table.get_elf32_symbol_image_address symtab strtab >>= (fun (strs : list ((string *((nat *nat *nat *nat ) % type)) % type)) =>
      let mapped := mapM (
  fun (p : (string *((nat *nat *nat *nat ) % type)) % type) =>
    match ( (p) ) with ( (symbol,  (typ,  size2,  addr,  bind1))) =>
      if beq_nat typ elf_symbol_table.stt_object then
        get_elf32_executable_image f3 >>=
        (fun (p : (list ((elf32_interpreted_segment *segment_provenance ) % type)*nat *nat ) % type) =>
           match ( (p) ) with ( (img3,  entry,  mach)) => let chunks :=
           List.filter
             (fun (p : (elf32_interpreted_segment *segment_provenance ) % type) =>
                match ( (p) ) with ( (chunk,  _)) =>
                  nat_gteb addr (elf32_segment_base chunk) &&
                  nat_lteb (Coq.Init.Peano.plus addr size2)
                    (Coq.Init.Peano.plus (elf32_segment_base chunk)
                       (elf32_segment_size chunk)) end ) img3 in
           match ( chunks) with | [] =>
             fail0
               "get_elf32_global_symbol_init: global variable not present in executable image"
             | [(x,  _)] =>
             let rebase := Coq.Init.Peano.minus addr (elf32_segment_base x) in
           byte_sequence.offset_and_cut rebase size2 (elf32_segment_body x)
           >>=
           (fun (relevant : byte_sequence ) =>
              return0 (symbol, (typ, size2, addr, Some relevant, bind1)))
             | x::xs =>
             fail0
               "get_elf32_global_symbol_init: invariant failed, global variable appears in multiple segments"
           end end) else return0 (symbol, (typ, size2, addr, None, bind1))
    end) strs
      in
        mapped))))
  else
    fail0 "get_elf32_file_global_symbol_init: not an executable ELF file".
(* [?]: removed value specification. *)

Definition get_elf64_file_global_symbol_init  (f3 : elf64_file )  : error (list ((string *((nat *nat *nat *option (byte_sequence ) *nat ) % type)) % type)):= 
  if is_elf64_executable_file(elf64_file_header f3) then
    let segs   :=(elf64_file_interpreted_segments f3) in
    bytes_of_elf64_file f3 >>= (fun (bs0 : byte_sequence ) =>
    get_elf64_file_symbol_table f3 >>= (fun (symtab : list (elf64_symbol_table_entry )) =>
    get_elf64_file_symbol_string_table f3 >>= (fun (strtab : string_table ) =>
    elf_symbol_table.get_elf64_symbol_image_address symtab strtab >>= (fun (strs : list ((string *((nat *nat *nat *nat ) % type)) % type)) =>
      let mapped := mapM (
  fun (p : (string *((nat *nat *nat *nat ) % type)) % type) =>
    match ( (p) ) with ( (symbol,  (typ,  size2,  addr,  bind1))) =>
      if beq_nat typ elf_symbol_table.stt_object then
        get_elf64_executable_image f3 >>=
        (fun (p : (list ((elf64_interpreted_segment *segment_provenance ) % type)*nat *nat ) % type) =>
           match ( (p) ) with ( (img3,  entry,  mach)) => let chunks :=
           List.filter
             (fun (p : (elf64_interpreted_segment *segment_provenance ) % type) =>
                match ( (p) ) with ( (chunk,  _)) =>
                  nat_gteb addr (elf64_segment_base chunk) &&
                  nat_lteb (Coq.Init.Peano.plus addr size2)
                    (Coq.Init.Peano.plus (elf64_segment_base chunk)
                       (elf64_segment_size chunk)) end ) img3 in
           match ( chunks) with | [] =>
             fail0
               "get_elf64_global_symbol_init: global variable not present in executable image"
             | [(x,  _)] =>
             let rebase := Coq.Init.Peano.minus addr (elf64_segment_base x) in
           byte_sequence.offset_and_cut rebase size2 (elf64_segment_body x)
           >>=
           (fun (relevant : byte_sequence ) =>
              return0 (symbol, (typ, size2, addr, Some relevant, bind1)))
             | x::xs =>
             fail0
               "get_elf64_global_symbol_init: invariant failed, global variable appears in multiple segments"
           end end) else return0 (symbol, (typ, size2, addr, None, bind1))
    end) strs
      in
        mapped))))
  else
    fail0 "get_elf64_global_symbol_init: not an executable ELF file".
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition flag_is_set  (flag : nat ) (v : nat )  : bool := 
    elf64_xword_equal    
( 
    (* HACK: convert to elf64_xword first. Flags never live 
     * in objects bigger than 64 bits. *)elf64_xword_land 
            (elf64_xword_of_nat v) 
            (elf64_xword_of_nat flag)) (elf64_xword_of_nat flag).
