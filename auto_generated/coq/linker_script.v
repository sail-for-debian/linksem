(* Generated by Lem from linker_script.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_function.
Require Export lem_function.

Require Import lem_string.
Require Export lem_string.

Require Import lem_tuple.
Require Export lem_tuple.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_sorting.
Require Export lem_sorting.

Require Import lem_num.
Require Export lem_num.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_assert_extra.
Require Export lem_assert_extra.

Require Import lem_set.
Require Export lem_set.

Require Import lem_map.
Require Export lem_map.


Require Import byte_sequence.
Require Export byte_sequence.

Require Import default_printing.
Require Export default_printing.

Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.


Require Import elf_header.
Require Export elf_header.

Require Import elf_file.
Require Export elf_file.

Require Import elf_interpreted_section.
Require Export elf_interpreted_section.


Require Import abis.
Require Export abis.

Require Import command_line.
Require Export command_line.

Require Import input_list.
Require Export input_list.

Require Import linkable_list.
Require Export linkable_list.

Require Import memory_image.
Require Export memory_image.

Require Import elf_memory_image.
Require Export elf_memory_image.
 (* HMM -- ideally we'd be ELF-agnostic in this file. 
     But Abstract_abi is now merged into Elf_memory_image, so never mind. *)
Require Import elf_memory_image_of_elf64_file.
Require Export elf_memory_image_of_elf64_file.

Require Import elf_relocation.
Require Export elf_relocation.

Require Import elf_symbol_table.
Require Export elf_symbol_table.

Require Import elf_section_header_table.
Require Export elf_section_header_table.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.


(* We model two kinds of linker script: "implicit scripts", which are supplied 
 * on the command line as input objects, and "control scripts" of which there
 * is exactly one per link job. The abstract syntax of each script comes from the
 * same grammar. 
 * 
 * We define the control script as a bunch of functions, to allow for
 * link jobs where we don't have an AST and the script behaviour is hard-coded. 
 *)

(* Input sections come from individual (relocatable) ELF files. 
 * The name of this file is important! 
 * 
 * Each input "section" is always an identified section or common symbol 
 * *within* some ELF memory image. *)

Record input_section_rec : Type := { 
    idx   : nat     (* linkable idx *)
;   fname : string 
;   img   : elf_memory_image 
;   shndx : nat 
;   secname: string 
;   isec : elf64_interpreted_section 
}.
Notation "{[ r 'with' 'idx' := e ]}" := ({| idx := e; fname := fname r; img := img r; shndx := shndx r; secname := secname r; isec := isec r |}).
Notation "{[ r 'with' 'fname' := e ]}" := ({| fname := e; idx := idx r; img := img r; shndx := shndx r; secname := secname r; isec := isec r |}).
Notation "{[ r 'with' 'img' := e ]}" := ({| img := e; idx := idx r; fname := fname r; shndx := shndx r; secname := secname r; isec := isec r |}).
Notation "{[ r 'with' 'shndx' := e ]}" := ({| shndx := e; idx := idx r; fname := fname r; img := img r; secname := secname r; isec := isec r |}).
Notation "{[ r 'with' 'secname' := e ]}" := ({| secname := e; idx := idx r; fname := fname r; img := img r; shndx := shndx r; isec := isec r |}).
Notation "{[ r 'with' 'isec' := e ]}" := ({| isec := e; idx := idx r; fname := fname r; img := img r; shndx := shndx r; secname := secname r |}).
Definition input_section_rec_default: input_section_rec  := {| idx := nat_default; fname := string_default; img := elf_memory_image_default; shndx := nat_default; secname := string_default; isec := elf64_interpreted_section_default |}.

Inductive input_spec : Type :=
  Common:  ((nat  * string  * elf_memory_image  * symbol_definition ) % type) -> input_spec  (* string is symbol name -- must be a COMMON symbol *)
 | InputSection:  input_section_rec  -> input_spec .
Definition input_spec_default: input_spec  := Common (nat_default, string_default, elf_memory_image_default, symbol_definition_default).

(* A control script defines
 * - output sections
 * - a mapping from output sections to (ordered) input sections
 * - extra symbols
 * - output format etc. (skip this for now)
 *)

(* We will have to deal with merging etc. at some point, somewhere
 * (maybe here, maybe not); for now we just produce an ordered list 
 * of sections. 
 *)
 
(* We can't model linker scripts as plain Lem functions without writing
 * them to a very different structure than that of scripts. The reason is that
 * certain features of the script language necessitate multiple passes
 * over the script structure. For example, to figure out how big an
 * output section is, hence where to begin the next section, you need to 
 * know which of the input sections are marked for KEEP. For that, you need 
 * a def-use graph over input sections. But for that, you also need to account 
 * for *all* symbol definitions, and the script itself is allowed to add new 
 * ones (right in among its input sections). So we have to do one pass to
 * enumerate the symbol additions, and another pass to eliminate sections
 * that we don't want to KEEP.
 *
 * Other gotchas include:
 * 
 * - symbol provision and address advancement can occur in among the input 
 * section queries, but also outside any output section. 
 * 
 * - semantics of DATA_SEGMENT_ALIGN depend on future script contents
 * 
 * - ONLY_IF_RO and ONLY_IF_RW are tricky: need to evaluate the input section
 * queries
 * 
 * - semantics of empty sections are subtle (". = ." will force an empty section
 * to be emitted, but ". = . + 0" will not do so).
 * 
 * Our approach is to define an interpreter for (at present) most of the script 
 * language.
 *)

Inductive symbol_def_policy : Type :=  AlwaysDefine: symbol_def_policy 
                        | ProvideIfUsed: symbol_def_policy .
Definition symbol_def_policy_default: symbol_def_policy  := AlwaysDefine.

Definition input_selector : Type :=   list  input_spec  ->  list  input_spec .
Definition input_selector_default: input_selector  := (fun (x137 :  list  input_spec ) => DAEMON).

Definition address_expr : Type :=  memory_image.expr .
Definition address_expr_default: address_expr  := expr_default.

Inductive output_guard : Type :=  AlwaysOutput: output_guard 
                  | OnlyIfRo: output_guard 
                  | OnlyIfRw: output_guard .
Definition output_guard_default: output_guard  := AlwaysOutput.
                  
Definition symbol_spec : Type :=  ((nat  * unsigned_char  * unsigned_char ) % type).
Definition symbol_spec_default: symbol_spec  := (nat_default, unsigned_char_default, unsigned_char_default). (* size, info, other *)

Inductive retain_policy : Type :=
   DefaultKeep: retain_policy 
  | KeepEvenWhenGC: retain_policy .
Definition retain_policy_default: retain_policy  := DefaultKeep.

Inductive output_section_composition_element : Type :=
   IncludeInputSection:  ((retain_policy  * input_section_rec ) % type) -> output_section_composition_element 
  | IncludeCommonSymbol:  ((retain_policy  * string  (* file *) * nat  (* linkable_idx *) * symbol_definition  * elf_memory_image ) % type) -> output_section_composition_element 
  (*| Hole of address_expr_fn (* compute the next addr to continue layout at *)*)
  | ProvideSymbol:  ((symbol_def_policy  * string  * symbol_spec ) % type) -> output_section_composition_element .
Definition output_section_composition_element_default: output_section_composition_element  := IncludeInputSection (retain_policy_default, input_section_rec_default).

Inductive sort_policy : Type :=
   DefaultSort: sort_policy  (* Use command line sort option, else "seen" order *)
  | SeenOrder: sort_policy  (* Always use "seen" order *)
  | ByName: sort_policy 
  | ByNameThenAlignment: sort_policy 
  | ByAlignment: sort_policy 
  | ByAlignmentThenName: sort_policy 
  | ByInitPriority: sort_policy .
Definition sort_policy_default: sort_policy  := DefaultSort.

(* This mirrors the OutputSection constructor, except that the script elements have become
 * output_section_composition_elements, and we might store the size here. *)
Inductive output_section_spec : Type := 
  OutputSectionSpec:  ((output_guard  * option  nat   * string  * (list  output_section_composition_element )) % type) -> output_section_spec .
Definition output_section_spec_default: output_section_spec  := OutputSectionSpec (output_guard_default, DAEMON, string_default, DAEMON).

Definition allocated_sections_map : Type := 
  fmap  string   ((output_section_spec  (* OutputSection element idx *) * nat ) % type).
Definition allocated_sections_map_default: allocated_sections_map  := DAEMON.

Inductive address_expr_fn : Type :=
   AddressExprFn:  (nat  ->  allocated_sections_map  ->  nat ) -> address_expr_fn .
Definition address_expr_fn_default: address_expr_fn  := AddressExprFn (fun (x135 : nat ) => (fun (x136 :  allocated_sections_map ) => nat_default)).

Inductive script_element : Type := 
  DefineSymbol:  ((symbol_def_policy  * string  * symbol_spec ) % type) -> script_element 
| AdvanceAddress:  address_expr_fn  -> script_element 
| MarkAndAlignDataSegment:  ((nat  * nat ) % type) -> script_element  (* maxpagesize, commonpagesize *)
| MarkDataSegmentEnd: script_element 
| MarkDataSegmentRelroEnd: script_element  (*of (allocated_sections_map -> (natural * (natural -> natural))) DPM: commented out because of positivity constrains in Isabelle *)
| OutputSection:  ((output_guard  * (option  (* address_expr *) address_expr_fn  ) * string  * list  script_element ) % type) -> script_element 
| DiscardInput:  input_selector  -> script_element  
  (* Input queries can only occur within an output section. 
     Output sections may not nest within other output sections. 
     (Ideally we would use something like polymorphic variants to encode this.)
   *)
| InputQuery:  ((retain_policy  * sort_policy  * input_selector ) % type) -> script_element .
Definition script_element_default: script_element  := DefineSymbol (symbol_def_policy_default, string_default, symbol_spec_default).

(* A linker control script is a function from inputs to output elements. 
 * We can define them in syntax (using an interpreter) 
 * or in Lem directly (as functions). *)
Definition linker_control_script : Type :=  list  script_element .
Definition linker_control_script_default: linker_control_script  := DAEMON.
Definition labelled_linker_control_script : Type :=  list  ((script_element  * nat ) % type).
Definition labelled_linker_control_script_default: labelled_linker_control_script  := DAEMON.
(* [?]: removed value specification. *)

Program Fixpoint all_suffixes  (chars : list (ascii ))  : list (list (ascii )):= 
    match ( chars) with  
        [] => [[]]
        | c :: morecs => chars :: (all_suffixes morecs)
    end.
(* [?]: removed value specification. *)

Program Fixpoint glob_match  (pat : list (ascii )) (str : list (ascii ))  : bool :=  
    match ( (pat, str)) with 
        ([],  []) => true
        | (?:: morepat,  _ :: morestr) => glob_match morepat morestr
        | (*:: morepat,  _) =>
            (* if any suffix of the remaining string matches
             * the remaining pattern, we've matched the pattern 
             * from '*' onwards. *)
            let or_suffix_match := fun (matched : bool ) => (fun (newlist : list (ascii )) =>
                matched || glob_match morepat newlist)
            in 
            List.fold_left (or_suffix_match) (all_suffixes str) false
        | (patc :: morepat,  c :: morestr) => (char_equal patc c) && glob_match morepat morestr
        | ([],  _) => (* ran out of pattern *) false
        | (_,  []) => (* ran out of str *) false
    end.
(* [?]: removed value specification. *)

Definition default_symbol_spec   : (nat *unsigned_char *unsigned_char ) % type:=  ( 0, unsigned_char_of_nat( 0), unsigned_char_of_nat( 0)).
(* [?]: removed value specification. *)
 
Definition only_sections  (inputs : list (input_spec ))  : list (input_spec ):=  lem_list.mapMaybe
    (fun (i : input_spec ) => match ( i) with  
      | InputSection(_) => Some(i)
      | _ => None
    end) inputs.
(* [?]: removed value specification. *)
 (* a.k.a. list input_spec -> list input_spec *)
Definition filter_and_concat  (p : input_spec  -> bool ) (inputs : list (input_spec ))  : list (input_spec ):=  List.filter p inputs.
(* [?]: removed value specification. *)

Definition name_matches  (pat : string ) (input : input_spec )  : bool := 
    match ( input) with 
        InputSection(inp) => glob_match (string_to_char_list pat) (string_to_char_list(secname inp))
        | _ => false
    end.
(* [?]: removed value specification. *)

Definition file_matches  (pat : string ) (input : input_spec )  : bool :=  
    match ( input) with 
        InputSection(inp) => glob_match (string_to_char_list pat) (string_to_char_list(fname inp))
        | _ => false
    end.

Definition compareInputSpecByNameThenAlignment  (i1 : input_spec ) (i2 : input_spec )  : ordering :=  
    let toPair := fun (is : input_spec ) => (match ( is) with 
         Common(idx1,  fname1,  img3,  def) => ("COMMON" (* FIXME: is this right? *), nat_of_elf64_addr(elf64_st_value(def_syment def)))
         | InputSection(isrec) => ((elf64_section_name_as_string(isecisrec)),(elf64_section_align(isec isrec)))
    end)
    in (pairCompare (fun (x : string ) (y : string )=>EQ) (genericCompare nat_ltb beq_nat) (toPair i1) (toPair i2)).

Definition compareInputSpecByAlignment  (i1 : input_spec ) (i2 : input_spec )  : ordering :=  
    let toNatural := fun (is : input_spec ) => (match ( is) with 
         Common(idx1,  fname1,  img3,  def) => nat_of_elf64_addr(elf64_st_value(def_syment def))
         | InputSection(isrec) =>(elf64_section_align(isec isrec))
    end)
    in (genericCompare nat_ltb beq_nat (toNatural i1) (toNatural i2)).

Definition compareInputSpecByName  (i1 : input_spec ) (i2 : input_spec )  : ordering :=  
    let toString := fun (is : input_spec ) => (match ( is) with 
         Common(idx1,  fname1,  img3,  def) => "COMMON"
         | InputSection(isrec) =>(elf64_section_name_as_string(isec isrec))
    end)
    in EQ.

Definition compareInputSpecByAlignmentThenName  (i1 : input_spec ) (i2 : input_spec )  : ordering := 
    let toPair := fun (is : input_spec ) => (match ( is) with 
         Common(idx1,  fname1,  img3,  def) => (nat_of_elf64_addr(elf64_st_value(def_syment def)), 
            "COMMON") (* FIXME: is this right? *)
         | InputSection(isrec) => ((elf64_section_align(isecisrec)),(elf64_section_name_as_string(isec isrec)))
    end)
    in (pairCompare (genericCompare nat_ltb beq_nat) (fun (x : string ) (y : string )=>EQ) (toPair i1) (toPair i2)).

Definition compareInputSpecByInitPriority {a b : Type}  (i1 : a) (i2 : b)  : ordering :=  EQ. (* FIXME *)

(* DATA_SEGMENT_ALIGN is defined by two formulae 
 * (over pos and commonpagesize/maxpagesize)
 * "... depending on whether the latter uses fewer COMMONPAGESIZE sized
  pages for the data segment (area between the result of this
  expression and `DATA_SEGMENT_END') than the former or not.  If the
  latter form is used, it means COMMONPAGESIZE bytes of runtime
  memory will be saved at the expense of up to COMMONPAGESIZE wasted
  bytes in the on-disk file."

  So the amount of padding that gets inserted here depends on the location
  of something that comes *later*, namely DATA_SEGMENT_END. 
  So, we can't model it as a function of the current position. 
  Instead, we add MarkDataSegmentEnd and friends 
  to the script_element ADT.
 *)

Definition has_writability {a : Type}   : a -> input_spec  -> bool :=  fun (writable : a) => (fun (input_sec : input_spec ) => (
    match ( input_sec) with 
        Common(_,  _,  _,  _)
            => (* all common symbols are potentially writable *) true
        | InputSection(inp)
            => let flags := match ( elf_memory_image_section_by_index(shndx inp)(img inp)) with  
                          Some x =>(elf64_section_flags x)
                        | None => DAEMON
                     end
                in 
                flag_is_set shf_write flags
    end
)).
(* [?]: removed value specification. *)

Definition address_zero   : address_expr_fn :=  AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => 0)).
(* [?]: removed value specification. *)

Definition do_output_section_layout_starting_at_addr  (start_addr : nat ) (secs : fmap (string ) ((output_section_spec *nat ) % type)) (comps : list (output_section_composition_element ))  : (nat *list (nat )) % type:=  
    (* map out where we plumb in each section, accounting for their alignment *)
    List.fold_left (fun (p : (nat *list (nat )) % type) =>
  match ( (p) ) with ( (next_free_addr,  addr_list)) =>
    (fun (comp_el : output_section_composition_element ) =>
       match ( comp_el) with
           IncludeInputSection(retain_pol,  irec) (* fname, linkable_idx, shndx, isec, img *) =>
         let aligned_next_free := align_up_to
                                    (elf64_section_align(isec irec))
                                    next_free_addr in
       ( Coq.Init.Peano.plus aligned_next_free
           (elf64_section_size(isec irec)), (@ List.app _) addr_list
                                              [aligned_next_free])
         | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) =>
         let aligned_next_free := align_up_to
                                    (nat_of_elf64_addr
                                       (elf64_st_value(def_syment def)))
                                    next_free_addr in
       ( Coq.Init.Peano.plus aligned_next_free
           (nat_of_elf64_xword (elf64_st_size(def_syment def))), (@ List.app
                                                                    _)
                                                                   addr_list
                                                                   [aligned_next_free])
       (*| Hole(AddressExprFn f) -> (f next_free_addr secs, addr_list ++ [next_free_addr])*)
         | ProvideSymbol(pol,  name1,  spec) =>
         (next_free_addr, (@ List.app _) addr_list [next_free_addr]) end )
  end) comps (start_addr, []).
(* [?]: removed value specification. *)

Definition output_sec_composition_size_given_start_addr  (start_addr : nat ) (secs : fmap (string ) ((output_section_spec *nat ) % type)) (comp : list (output_section_composition_element ))  : nat :=  
  match ( do_output_section_layout_starting_at_addr start_addr secs comp) with
      (end_addr,  comp_addrs) => Coq.Init.Peano.minus end_addr start_addr end.
(* [?]: removed value specification. *)

Definition sizeof  (secname1 : string ) (secs : fmap (string ) ((output_section_spec *nat ) % type))  : nat :=  
    match ( (fmap_lookup_by (fun (x : string ) (y : string )=>EQ) secname1 secs)) with 
        Some(OutputSectionSpec (_,  maybe_addr,  _,  comp),  _) => match ( maybe_addr) with 
            Some addr => output_sec_composition_size_given_start_addr addr secs comp
            | None => DAEMON
        end
        | None => DAEMON
    end.
(* [?]: removed value specification. *)

Definition alignof_output_section_composition_element  (comp : output_section_composition_element )  : nat :=  
    match ( comp) with 
        IncludeInputSection(_,  irec) =>(elf64_section_align(isec irec))
        | IncludeCommonSymbol(_,  _,  _,  def,  _) => nat_of_elf64_addr(elf64_st_value(def_syment def))
        | _ => 1 (* CHECK *)
    end.
(* [?]: removed value specification. *)

Definition alignof_output_section  (comps : list (output_section_composition_element ))  : nat :=  
    let aligns := List.map alignof_output_section_composition_element comps
    in
    List.fold_left (fun (acc_lcm : nat ) => fun (next : nat ) => lcm acc_lcm next) aligns ( 1).
(* [?]: removed value specification. *)

Definition default_linker_control_script  (a : abi (any_abi_feature )) (user_text_segment_start : option (nat ) ) (user_data_segment_start : option (nat ) ) (user_rodata_segment_start : option (nat ) ) (elf_headers_size : nat )  : list (script_element ):=  
    let segment_start := (
  fun (name1 : string ) (default : nat ) =>
    match ( name1) with "ldata-segment" =>
      match ( user_data_segment_start) with None => default | Some addr =>
        (* fun _ -> *) addr end | "text-segment" =>
      match ( user_text_segment_start) with None => default | Some addr =>
        (* fun _ -> *) addr end | _ =>
      nat_default (* Incomplete Pattern at File \"linker_script.lem\", line 356, character 38 to line 365, character 7 *)
    end)
    in
    let is_large_common := (fun (inp : input_spec ) => (* FIXME: treat large commons separately *) false
    )
    in
    let is_common := (fun (isec1 : input_spec ) => match ( isec1) with  
        Common(idx1,  fname1,  img3,  def) => (*let _ = errln ("Common or large-common symbol: " ^ def.def_symname) in *)
             negb (is_large_common isec1)
         | _ => false
    end)
    in
    [
        (* For now, we base our script on the GNU bfd linker's scripts. 
           Here's the static -z combreloc one.
           
/* Script for -z combreloc: combine and sort reloc sections */
/* Copyright (C) 2014 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
              "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib");
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.* )
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.* )
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.* )
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.* )
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.* )
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.* )
      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.* )
      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.* )
      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.* )
      *(.rela.ifunc)
    }
  .rela.plt       :
    {
      *(.rela.plt)
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  .init           :
  {
    KEEP ( *(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
  .plt.bnd        : { *(.plt.bnd) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.* )
    *(.text.exit .text.exit.* )
    *(.text.startup .text.startup.* )
    *(.text.hot .text.hot.* )
    *(.text .stub .text.* .gnu.linkonce.t.* )
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP ( *(SORT_NONE(.fini)))
  }
   PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.* ) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame       : ONLY_IF_RO { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table
  .gcc_except_table.* ) }
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges
  .exception_ranges* ) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN (CONSTANT (MAXPAGESIZE)) - ((CONSTANT (MAXPAGESIZE) - .) & (CONSTANT (MAXPAGESIZE) - 1)); . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */
  .eh_frame       : ONLY_IF_RW { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.* ) }
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges .exception_ranges* ) }
  /* Thread Local Storage sections  */
  .tdata          : { *(.tdata .tdata.* .gnu.linkonce.td.* ) }
  .tbss           : { *(.tbss .tbss.* .gnu.linkonce.tb.* ) *(.tcommon) }
  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP ( *(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array     :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.init_array.* ) SORT_BY_INIT_PRIORITY(.ctors.* )))
    KEEP ( *(.init_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array     :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.fini_array.* ) SORT_BY_INIT_PRIORITY(.dtors.* )))
    KEEP ( *(.fini_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP ( *crtbegin.o(.ctors))
    KEEP ( *crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .ctors))
    KEEP ( *(SORT(.ctors.* )))
    KEEP ( *(.ctors))
  }
  .dtors          :
  {
    KEEP ( *crtbegin.o(.dtors))
    KEEP ( *crtbegin?.o(.dtors))
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .dtors))
    KEEP ( *(SORT(.dtors.* )))
    KEEP ( *(.dtors))
  }
  .jcr            : { KEEP ( *(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.* ) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.* ) }
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) *(.igot) }
  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);
  .got.plt        : { *(.got.plt)  *(.igot.plt) }
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.* )
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.* )
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we don't
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  .lbss   :
  {
    *(.dynlbss)
    *(.lbss .lbss.* .gnu.linkonce.lb.* )
    *(LARGE_COMMON)
  }
  . = ALIGN(64 / 8);
  . = SEGMENT_START("ldata-segment", .);
  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.lrodata .lrodata.* .gnu.linkonce.lr.* )
  }
  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.ldata .ldata.* .gnu.linkonce.l.* )
    . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  . = ALIGN(64 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.* ) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
  .gnu.attributes 0 : { KEEP ( *(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_* ) }
}
         *)
         
         (*  function from 
                  inputs and configuration
             to
                  output sections-with-address-and-policy, output symbols-with-address-and-attributes, 
                      discards, orphans
             BUT
                   1. policy is not a property of output sections, but of *inputs within outputs*
                         i.e. KEEP( *(.init))
         
             what's helpful for writing such functions?
             
             e.g. only_if_ro (input_query) (output ): 
             
             i.e.    ++ only_if_ro OutputSection(AlwaysOutput, Nothing, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])

                 want to take a bunch of outputs
                         and return a bunch of outputs?
                         
                         if so, need to return a "current address"
             
          *)
    (DefineSymbol(ProvideIfUsed, "__executable_start", default_symbol_spec))
  ; AdvanceAddress((* BinRel(Eq, Constant( *) AddressExprFn (fun  _ : nat  => (fun  _ : fmap (string ) ((output_section_spec *nat ) % type) => Coq.Init.Peano.plus 
        (segment_start "text-segment" ( Coq.Init.Peano.mult( 4)( 1048576))) elf_headers_size)))
  ; OutputSection(AlwaysOutput, None, ".interp", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".interp"))])
  ; OutputSection(AlwaysOutput, None, ".note.gnu.build-id", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".note.gnu.build-id"))])
  ; OutputSection(AlwaysOutput, None, ".hash", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".hash"))])
  ; OutputSection(AlwaysOutput, None, ".gnu.hash", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.hash"))])
  ; OutputSection(AlwaysOutput, None, ".dynsym", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynsym"))])
  ; OutputSection(AlwaysOutput, None, ".dynstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynstr"))])
  ; OutputSection(AlwaysOutput, None, ".gnu.version", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version"))])
  ; OutputSection(AlwaysOutput, None, ".gnu.version_d", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version_d"))])
  ; OutputSection(AlwaysOutput, None, ".gnu.version_r", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version_r"))])
  ; OutputSection(AlwaysOutput, None, ".rela.dyn", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.init"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.text" s || (name_matches ".rela.text.*" s || name_matches ".rela.gnu.linkonce.t.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.rodata" s || (name_matches ".rela.rodata.*" s || name_matches ".rela.gnu.linkonce.r.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.data" s || (name_matches ".rela.data.*" s || name_matches ".rela.gnu.linkonce.d.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.tdata" s || (name_matches ".rela.tdata.*" s || name_matches ".rela.gnu.linkonce.td.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.tbss" s || (name_matches ".rela.tbss.*" s || name_matches ".rela.gnu.linkonce.tb.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.ctors"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.got"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.bss" s || (name_matches ".rela.bss.*" s || name_matches ".rela.gnu.linkonce.b.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.ldata" s || (name_matches ".rela.ldata.*" s || name_matches ".rela.gnu.linkonce.l.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun (s : input_spec ) => name_matches ".rela.lbss" s || (name_matches ".rela.lbss.*" s || name_matches ".rela.gnu.linkonce.lb.*" s)))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.ifunc"))]
    )
  ; OutputSection(AlwaysOutput, None, ".rela.plt", [
      InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.plt"))
    ; DefineSymbol(ProvideIfUsed, "__rela_iplt_start", ( 0, make_symbol_info stb_local stt_notype (* FIXME *), make_symbol_other stv_hidden))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.iplt"))
    ; DefineSymbol(ProvideIfUsed, "__rela_iplt_end", ( 0, make_symbol_info stb_local stt_notype (* FIXME *), make_symbol_other stv_hidden))]
    )
  ; OutputSection(AlwaysOutput, None, ".init", [
      InputQuery(KeepEvenWhenGC, SeenOrder, filter_and_concat (name_matches ".init"))]
    )
  ; OutputSection(AlwaysOutput, None, ".plt", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".plt"))
                         ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".iplt"))]
    )
  ; OutputSection(AlwaysOutput, None, ".plt.bnd", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".plt.bnd"))])
  ; OutputSection(AlwaysOutput, None, ".text", [
      InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".text.unlikely" s || (name_matches ".text.*_unlikely" s || name_matches ".text.unlikely.*" s)
       ))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (  
        fun (s : input_spec ) => name_matches ".text.exit" s || name_matches ".text.exit.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".text.startup" s || name_matches ".text.startup.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".text.hot" s || name_matches ".text.hot.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".text" s || (name_matches ".stub" s || (name_matches ".text.*" s || name_matches ".gnu.linkonce.t.*" s))))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
         (* ".gnu.warning sections are handled specially by elf32.em."
          * GAH. That means that what we specify here is not (completely) what 
          * needs to happen with these sections. *)
        fun (s : input_spec ) => name_matches ".gnu_warning" s))]
    )
  ; OutputSection(AlwaysOutput, None, ".fini", [
      InputQuery(KeepEvenWhenGC, SeenOrder, filter_and_concat (name_matches ".fini"))]
    )
  ; DefineSymbol(ProvideIfUsed, "__etext", default_symbol_spec)
  ; DefineSymbol(ProvideIfUsed, "_etext", default_symbol_spec)
  ; DefineSymbol(ProvideIfUsed, "etext", default_symbol_spec)
  ; OutputSection(AlwaysOutput, None, ".rodata", [
    InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".rodata" s || (name_matches ".rodata.*" s || name_matches ".gnu.linkonce.r.*" s)
    ))])
  ; OutputSection(AlwaysOutput, None, ".eh_frame_hdr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame_hdr"))] )
  ; OutputSection(OnlyIfRo, None, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])
  ; OutputSection(OnlyIfRo, None, ".gcc_except_table", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun (s : input_spec ) => name_matches ".gcc_except_table" s || name_matches ".gcc_except_table.*" s))])
  ; OutputSection(OnlyIfRo, None, ".exception_ranges", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun (s : input_spec ) => name_matches ".exception_ranges" s || name_matches ".exception_ranges*" s))])
  ; AdvanceAddress(AddressExprFn (fun (addr : nat ) => (fun  _ : fmap (string ) ((output_section_spec *nat ) % type) => Coq.Init.Peano.minus 
    (* (align_up_to a.maxpagesize addr) - (natural_land (a.maxpagesize - addr) (a.maxpagesize - 1)) *)
    (*
    FIXME: understand the intention of this assignment.
    Evaluating a simple example of this (from true-static-uClibc)

    (ALIGN (0x200000) - ((0x200000 - .) & 0x1fffff))

    starting from 0x00000000004017dc
    means 
    0x600000 - ((0x200000 - 0x4017dc) & 0x1fffff)
    i.e. 
    0x600000 - (((-0x2017dc)) & 0x1fffff)
    i.e.
    0x600000 - (     -0x2017dc   
                    & 0x1fffff )

    which really does come to (according to bash) 0x4017dc
    i.e. we subtract 0x1fe824 from 0x600000
    and end up back where we started.

    What does ANDing a negative number mean?
    It doesn't seem to work for us.
    Well, to take the negation we flip every bit and add one.
    So if we don't want to do a subtraction that might go negative, 
    we can instead add the complement.    
    *)
        (align_up_to(maxpagesize a) addr) (nat_land ( Coq.Init.Peano.plus(maxpagesizea) (compl64 addr)) ( Coq.Init.Peano.minus(maxpagesizea)( 1)))
    )))
  ; MarkAndAlignDataSegment( Coq.Init.Peano.mult (Coq.Init.Peano.mult( (* a.maxpagesize *)2)( 1024))( 1024) (* <-- for some reason binutils assumes 2MB max page size,
    even if ABI says smaller *),(commonpagesize a))
  ; OutputSection(OnlyIfRw, None, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])
  ; OutputSection(OnlyIfRw, None, ".gcc_except_table", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun (s : input_spec ) => name_matches ".gcc_except_table" s || name_matches ".gcc_except_table.*" s))])
  ; OutputSection(OnlyIfRw, None, ".exception_ranges", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun (s : input_spec ) => name_matches ".exception_ranges" s || name_matches ".exception_ranges*" s))])
  ; OutputSection(AlwaysOutput, None, ".tdata", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat 
        (fun (s : input_spec ) => name_matches ".tdata" s || (name_matches ".tdata.*" s || name_matches ".gnu.linkonce.td.*" s)))])
  ; OutputSection(AlwaysOutput, None, ".tbss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat 
        (fun (s : input_spec ) => name_matches ".tbss" s || (name_matches ".tbss.*" s || name_matches ".gnu.linkonce.tb.*" s)))
        ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".tcommon"))])
  ; OutputSection(AlwaysOutput, None, ".preinit_array", [
        DefineSymbol(ProvideIfUsed, "__preinit_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun (s : input_spec ) => name_matches ".preinit_array" s))
      ; DefineSymbol(ProvideIfUsed, "__preinit_array_end", default_symbol_spec)]
    )
  ; OutputSection(AlwaysOutput, None, ".init_array", [
        DefineSymbol(ProvideIfUsed, "__init_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun (s : input_spec ) => name_matches ".init_array.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun (s : input_spec ) => name_matches ".ctors.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat 
            (fun (s : input_spec ) => name_matches ".init_array" s
            || (name_matches ".ctors" s && negb (file_matches "*crtbegin.o" s || (file_matches "*crtbegin?.o" s
                 || (file_matches "*crtend.o" s || file_matches "*crtend?.o " s))))))
            
      ; DefineSymbol(ProvideIfUsed, "__init_array_end", default_symbol_spec)]
    )
  ; OutputSection(AlwaysOutput, None, ".fini_array", [
        DefineSymbol(ProvideIfUsed, "__fini_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun (s : input_spec ) => name_matches ".fini_array.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun (s : input_spec ) => name_matches ".dtors.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat 
            (fun (s : input_spec ) => name_matches ".fini_array" s
            || (name_matches ".dtors" s && negb (file_matches "*crtbegin.o" s || (file_matches "*crtbegin?.o" s
                 || (file_matches "*crtend.o" s || file_matches "*crtend?.o " s))))))
            
      ; DefineSymbol(ProvideIfUsed, "__fini_array_end", default_symbol_spec)]
    )
   ; OutputSection(AlwaysOutput, None, ".ctors", [
        InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun (s : input_spec ) => file_matches "*crtbegin.o" s && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun (s : input_spec ) => file_matches "*crtbegin?.o" s && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
            (fun (s : input_spec ) => negb (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, ByName, filter_and_concat (fun (s : input_spec ) => name_matches ".ctors.*" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
        (fun (s : input_spec ) => (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".ctors" s))]
        (* NOTE: this exclusion is implicit in the usual linker script, 
         * because it won't match an input section more than once. We should
         * just replicate this behaviour, since other parts of the script might rely on it
         * less obviously. *)
    )
   ; OutputSection(AlwaysOutput, None, ".dtors", [
        InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun (s : input_spec ) => file_matches "*crtbegin.o" s && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun (s : input_spec ) => file_matches "*crtbegin?.o" s && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
            (fun (s : input_spec ) => negb (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, ByName, filter_and_concat (fun (s : input_spec ) => name_matches ".dtors.*" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
        (fun (s : input_spec ) => (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".dtors" s))]
    )
   ; OutputSection(AlwaysOutput, None, ".jcr", [InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (name_matches ".jcr"))])
   ; OutputSection(AlwaysOutput, None, ".data.rel.ro", [
        InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun (s : input_spec ) => name_matches ".data.rel.ro.local*" s || name_matches ".gnu.linkonce.d.rel.ro.local.*" s
        ));
        InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun (s : input_spec ) => name_matches ".data.rel.ro" s || (name_matches ".data.rel.ro.*" s || name_matches ".gnu.linkonce.d.rel.ro.*" s)
        ))]
     )
    ; OutputSection(AlwaysOutput, None, ".dynamic", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynamic"))])
    ; OutputSection(AlwaysOutput, None, ".got",     [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".got"))
                               ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".igot"))]
                               )
    ; MarkDataSegmentRelroEnd (*(fun secs -> (if (sizeof ".got.plt" secs) >= 24 then 24 else 0, (fun pos -> pos)))*)
    ; OutputSection(AlwaysOutput, None, ".got.plt", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".got.plt"))
                               ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".igot.plt"))]
     )
    ; OutputSection(AlwaysOutput, None, ".data", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".data" s || (name_matches ".data.*" s || name_matches ".gnu.linkonce.d.*" s)))]
        (* the script also has SORT(CONSTRUCTORS) here, but it has no effect for ELF (I think) *)
        )
    ; OutputSection(AlwaysOutput, None, ".data1", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".data1"))])
    ; DefineSymbol(AlwaysDefine, "_edata", default_symbol_spec)
    ; DefineSymbol(ProvideIfUsed, "edata", default_symbol_spec)
    ; (* . = .;    <-- does this do anything? YES! It forces an output section to be emitted. 
         Since it occurs *outside* any output section, 
         it is assumed to start 
       *) 
      DefineSymbol(AlwaysDefine, "__bss_start", default_symbol_spec)
    ; OutputSection(AlwaysOutput, None, ".bss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynbss"))
                           ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
                                fun (s : input_spec ) => name_matches ".bss" s || (name_matches ".bss.*" s || name_matches ".gnu.linkonce.b.*" s)))
                           ; InputQuery(DefaultKeep, DefaultSort, (fun (inputlist : list (input_spec )) => 
                                (*let _ = errln "Looking for commons" in *)
                                let result := filter_and_concat is_common inputlist
                                in
                                (*let _ = errln ("Got " ^ (show (length (result))) ^ " commons; sanity check: input list contains " ^
                                    (show (length inputlist)) ^ " of which " ^
                                    (show (length (List.filter (fun inp -> match inp with
                                        Common _ -> true
                                        | _ -> false
                                    end) inputlist))) ^ " are commons."
                                ) 
                                in*) result))
                            ]
      )
    ; AdvanceAddress(AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => align_up_to (if beq_nat pos( 0) then (Coq.Numbers.Natural.Peano.NPeano.div( 64)( 8)) else 1) pos)))
    ; OutputSection(AlwaysOutput, None, ".lbss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynlbss"))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynlbss"))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
                                fun (s : input_spec ) => name_matches ".lbss" s || (name_matches ".lbss.*" s || name_matches ".gnu.linkonce.lb.*" s)
                                ))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (is_large_common))]
      )
    ; AdvanceAddress(AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => align_up_to (Coq.Numbers.Natural.Peano.NPeano.div( 64)( 8)) pos)))
    ; AdvanceAddress(AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => segment_start "ldata-segment" pos)))
    ; OutputSection(AlwaysOutput, Some (AddressExprFn (fun (pos : nat ) => fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => align_up_to ( Coq.Init.Peano.plus(maxpagesizea) ( Coq.Init.Peano.minus(nat_land pos(maxpagesize a))( 1))) pos)), 
         ".lrodata",
         [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun (s : input_spec ) => name_matches ".lrodata" s || (name_matches ".lrodata.*" s || name_matches ".gnu.linkonce.lr.*" s)
            ))
        ; AdvanceAddress(AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => (if negb (beq_nat pos( 0)) then Coq.Numbers.Natural.Peano.NPeano.div( 64)( 8) else 1))))]
        )
    ; AdvanceAddress(AddressExprFn (fun (pos : nat ) => (fun (secs : fmap (string ) ((output_section_spec *nat ) % type)) => align_up_to (Coq.Numbers.Natural.Peano.NPeano.div( 64)( 8)) pos)))
    ; DefineSymbol(AlwaysDefine, "_end", default_symbol_spec)
    ; DefineSymbol(ProvideIfUsed, "end", default_symbol_spec)
    ; MarkDataSegmentEnd
    ; OutputSection(AlwaysOutput, Some address_zero, ".stab", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".stabstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stabstr"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".stab.excl", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.excl"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".stab.exclstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.exclstr"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".stab.index", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.index"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".stab.indexstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.indexstr"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".comment", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".comment"))])
      (* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  *)
      (* DWARF 1 *)
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".line", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".line"))])
      (* GNU DWARF 1 extensions *)
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_srcinfo", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_srcinfo"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_sfnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_sfname"))])
      (* DWARF 1.1 and DWARF 2 *)
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_aranges", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_aranges"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_pubnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_pubnames"))])
      (* DWARF 2 *)
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_info", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".debug_info" s || name_matches ".gnu.linkonce.wi.*" s))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_abbrev", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_abbrev"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_line", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun (s : input_spec ) => name_matches ".debug_line" s || (name_matches ".debug_line.*" s || name_matches ".debug_line_end" s)))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_frame"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_str", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_str"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_loc", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_loc"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_macinfo", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_macinfo"))])
      (* SGI/MIPS DWARF 2 extensions *)
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_weaknames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_weaknames"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_funcnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_funcnames"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_typenames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_typenames"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_varnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_varnames"))])
      (* DWARF 3 *) 
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_pubtypes", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_pubtypes"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_ranges", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_ranges"))])
      (* DWARF Extension.  *) 
    ; OutputSection(AlwaysOutput, Some address_zero, ".debug_macro", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_macro"))])
    ; OutputSection(AlwaysOutput, Some address_zero, ".gnu.attributes", [InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (name_matches ".gnu.attributes"))])
    ; DiscardInput(filter_and_concat (fun (s : input_spec ) => name_matches ".note.GNU-stack" s || (name_matches ".gnu_debuglink" s || name_matches ".gnu.lto_*" s)))]
    (* FIXME: orphan sections? This 
       probably needs to go in the core linking logic,
       not the script. *)
    .

Definition interpret_guard {a : Type}  (guard : output_guard ) (comp : list (output_section_composition_element )) (name1 : a)  : bool :=  
  match ( guard) with Always => true end.
(* [?]: removed value specification. *)

Definition label_script_aux  (start : nat ) (script1 : list (script_element ))  : list ((script_element *nat ) % type):=  
    mapi (fun (i : nat ) => fun (el : script_element ) => (el, ( Coq.Init.Peano.plus start ( i)))) script1.
(* [?]: removed value specification. *)

Definition label_script  (script1 : list (script_element ))  : list ((script_element *nat ) % type):=  label_script_aux( 0) script1.

Definition input_output_assignment : Type :=  ((list  input_spec  * list  ((output_section_spec  * nat ) % type)) % type).
Definition input_output_assignment_default: input_output_assignment  := (DAEMON, DAEMON).
(* [?]: removed value specification. *)
     (* accumulated result *)
Program Fixpoint assign_inputs_to_output_sections  (acc : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type) (inputs : list (input_spec ))  (cur_output_sec : option  ((output_section_spec  * nat ) % type) ) (last_input_sec : option (input_spec ) ) (seen_ordering : input_spec  -> input_spec  -> ordering ) (script1 : list ((script_element *nat ) % type))  : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type:=  
  match ( acc) with (rev_discards,  rev_outputs) => let flush_output_sec
  := fun (maybe_output_sec_and_idx : option ((output_section_spec *nat ) % type) ) =>
       match ( (maybe_output_sec_and_idx : option  ((output_section_spec  * nat ) % type) )) with
           Some (OutputSectionSpec (guard,  addr,  name1,  comp),  script_idx) =>
         (*let _ = errln ("Guardedly flushing output section named " ^ name ^ " with " ^ (
                match addr with Nothing -> "no address yet" | Just a -> "address 0x" ^ (hex_string_of_natural a) end
            ))
            in*)
         (* evaluate the guard *) if interpret_guard guard comp name1 then
           (* do it     *) (rev_discards, (((OutputSectionSpec
                                               (guard, addr, name1, comp)), script_idx)
                                           :: rev_outputs)) else
           (* ignore it *) acc | None =>
         (* for convenience, make this a no-op rather than error *)
       (* failwith "internal error: flushing output section with no current output section" *)
       acc end in
  match ( script1) with [] => flush_output_sec cur_output_sec
    | (element1,  idx1) :: more_elements_and_idx =>
    let do_nothing := (acc, cur_output_sec, last_input_sec) in
  match ( match ( element1) with
              DefineSymbol(symdefpol,  name1,  (symsize,  syminfo,  symother)) =>
            (* Label the current section in the image 
                     * with a new symbol definition. If there isn't
                     * a current section, use the ABS section (what is that labelling?). *)
          (acc,
          match ( (cur_output_sec : option  ((output_section_spec  * nat ) % type) )) with
              None =>
            (*let _ = errln "FIXME: ABS symbol defs not yet supported" in*) None
            | Some ((OutputSectionSpec (guard,  maybe_addr,  secname1,  comp)),  output_script_idx) =>
            Some
              ((OutputSectionSpec
                  (guard, maybe_addr, secname1,
                  (@ List.app _) comp
                    [ProvideSymbol
                       (symdefpol, name1, (symsize, syminfo, symother))]))
              , output_script_idx) end, last_input_sec)
            | AdvanceAddress(AddressExprFn advance_fn) =>
            (* If we're inside a section, insert a hole, 
                      * else just update the logical address *)
            match ( cur_output_sec) with None => do_nothing
            (* This assignment is setting a new LMA. *) (* (acc,  *)
              | Some (sec,  idx1) => do_nothing end
            | MarkAndAlignDataSegment(maxpagesize1,  commonpagesize1) =>
            (* The "data segment end" is a distinguished label, 
                      * so we can encode the whole thing into a conditional. *)
          do_nothing | MarkDataSegmentEnd => do_nothing
            | MarkDataSegmentRelroEnd(*(fun_from_secs_to_something)*) =>
            do_nothing
            | OutputSection(outputguard,  maybe_expr,  name1,  sub_elements) =>
            (* If we have a current output section, finish it and add it to the image.
                     * Q. Where do guards ("ONLY_IF_RO" etc) get evaluated?
                     * A. Inside flush_output_sec. *)
          let acc_with_output_sec := flush_output_sec cur_output_sec in
          let new_cur_output_sec := Some
                                      ((OutputSectionSpec
                                          (outputguard, (* maybe_expr pos secs *) None, name1, [])), idx1)
          in
          (* Recurse down the list of input queries, assigning them to this output sec
                     * Note that output sections may not nest within other output sections. 
                     * At the end of the list of sub_elements, we will flush the section we built up. 
                     *)
          let final_acc
          := assign_inputs_to_output_sections acc inputs new_cur_output_sec
               last_input_sec seen_ordering (label_script sub_elements) in
          (* NOTE that this sub-accumulation will never add a new output section
                     * because output sections can't nest. *)
          (final_acc, (* cur_output_sec *) None, last_input_sec)
            | DiscardInput(selector) => let selected := selector inputs in
          match ( acc) with (rev_discards,  rev_outputs) =>
            (*let _ = Missing_pervasives.errln ("Processing discard rule; selected " ^ (show (length selected))
                        ^ " inputs.")
                    in*)
          (( (@ List.app _)
               (List.rev
                  (let x2 := [] in List.fold_right
                                     (fun (i : input_spec ) (x2 : list (input_spec )) =>
                                        if true then i :: x2 else x2) 
                                   x2 selected)) rev_discards, rev_outputs), cur_output_sec, last_input_sec)
          end | InputQuery(retainpol,  sortpol,  selector) =>
            (* Input queries can only occur within an output section. *)
            match ( cur_output_sec) with None => DAEMON
              | Some ((OutputSectionSpec (output_guard1,  output_sec_addr,  output_sec_name,  output_composition)),  output_script_idx) =>
              (* Add them to the current output spec. We have to be careful about ordering:
                             * according to the GNU ld manual (and observed behaviour), by default
                             * "the linker will place files and sections matched by wildcards in the order
                             * in which they are seen during the link". For .o files on the command line,
                             * this means the command line order. But for members of archives, it means
                             * the order in which they were "pulled in" during input enumeration. We 
                             * actually don't compute this here; it is passed in from our caller in link.lem. *)
            let sortfun := match ( sortpol) with DefaultSort =>
                             sort_by_ordering seen_ordering (* FIXME: pay attention to command line *)
                             | SeenOrder => sort_by_ordering seen_ordering
                             | ByName =>
                             sort_by_ordering compareInputSpecByName
                             | ByNameThenAlignment =>
                             sort_by_ordering
                               compareInputSpecByNameThenAlignment
                             | ByAlignment =>
                             sort_by_ordering compareInputSpecByAlignment
                             | ByAlignmentThenName =>
                             sort_by_ordering
                               compareInputSpecByAlignmentThenName
                             | ByInitPriority =>
                             sort_by_ordering compareInputSpecByInitPriority
                           end in
            (* Search input memory images for matching sections. *)
            let sorted_selected_inputs := sortfun (selector inputs) in
            let sectionMatchList := lem_list.mapMaybe
                                      (fun (inp : input_spec ) =>
                                         match ( inp) with InputSection(x) =>
                                           (*let _ = errln ("Matched an input section named " ^ x.isec.elf64_section_name_as_string ^ 
                                            " in a file " ^ x.fname ^ " with first 20 bytes " ^ (show (take 20 
                                                (let maybe_elname = elf_memory_image_element_coextensive_with_section x.shndx x.img 
                                                 in
                                                 match maybe_elname with
                                                    Nothing -> failwith ("impossible: no such element (matching shndx " ^ (show x.shndx) ^ ")")
                                                    | Just idstr -> 
                                                        match Map.lookup idstr x.img.elements with
                                                            Just el -> el.contents
                                                            | Nothing -> failwith "no such element"
                                                        end
                                                end
                                                ))))
                                            in*)
                                           Some x | _ => None end)
                                      sorted_selected_inputs in
            let commonMatchList := lem_list.mapMaybe
                                     (fun (inp : input_spec ) =>
                                        match ( inp) with
                                              | Common(idx1,  fname1,  img3,  def) =>
                                          Some (idx1, fname1, img3, def)
                                          | _ => None end)
                                     sorted_selected_inputs in (acc,
            Some
              (
              (OutputSectionSpec
                 (output_guard1, output_sec_addr, output_sec_name,
                 (@ List.app _)
                   ((@ List.app _) output_composition
                      (let x2 := [] in List.fold_right
                                         (fun (input_sec : input_section_rec ) (x2 : list (output_section_composition_element )) =>
                                            if true then
                                              IncludeInputSection
                                                (retainpol, (* input_sec.fname, input_sec.idx, input_sec.shndx, input_sec.isec, input_sec.img *) input_sec)
                                              :: x2 else x2) x2
                                         sectionMatchList))
                   (let x2 := [] in List.fold_right
                                      (fun (p : (nat *string *annotated_memory_image (any_abi_feature )*symbol_definition ) % type) (x2 : list (output_section_composition_element )) =>
                                         match ( (p ,x2) ) with
                                             ((idx1,  fname1,  img3,  def) ,  x2) =>
                                           if true then
                                             IncludeCommonSymbol
                                               (DefaultKeep, fname1, idx1, def, img3)
                                             :: x2 else x2 end) x2
                                      commonMatchList)) ), output_script_idx),
            last_input_sec) end end) with
      (new_acc,  new_cur_output_sec,  new_last_input_sec) =>
    assign_inputs_to_output_sections new_acc (inputs : list  input_spec )
      (new_cur_output_sec) (new_last_input_sec : option  input_spec  )
      seen_ordering (more_elements_and_idx : labelled_linker_control_script )
  end end end.
(* [?]: removed value specification. *)

Definition compute_def_use_and_gc  (outputs_by_name : fmap (string ) ((output_section_spec *nat ) % type))  : fmap (string ) ((output_section_spec *nat ) % type):=  outputs_by_name. (* FIXME: implement GC *)

Definition output_section_type  (comp : list (output_section_composition_element ))  : nat :=  
   (* are we composed entirely of nobits sections and common symbols? *)
        let all_nobits := List.forallb (fun (comp_el : output_section_composition_element ) => 
            match ( comp_el) with  
                IncludeInputSection(retain_pol, (*  fname, linkable_idx, shndx, isec, img *) irec) => beq_nat(elf64_section_type(isec 
                    irec)) sht_nobits
                | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) => true
                | _ => (* padding and symdefs can be nobits *) true
            end) comp
        in
        if all_nobits then sht_nobits else sht_progbits.

Definition output_section_flags  (comp : list (output_section_composition_element ))  : nat :=  
    let writable := List.existsb (fun (comp_el : output_section_composition_element ) => 
        match ( comp_el) with  
            IncludeInputSection(retain_pol,  (* fname, linkable_idx, shndx, isec, img *) irec) => 
                flag_is_set shf_write(elf64_section_flags(isec irec))
            | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) => 
                (* assume common symbols are writable *) true
            | _ => (* padding and symdefs do not make a section writable *) false
        end) comp
    in
    let executable := List.existsb (fun (comp_el : output_section_composition_element ) => 
        match ( comp_el) with  
            IncludeInputSection(retain_pol, (* fname, linkable_idx, shndx, isec, img *) irec) => 
                flag_is_set shf_execinstr(elf64_section_flags(isec irec))
            | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) => 
                (* assume common symbols are not executable, since they're zeroed *) false
            | _ => (* padding and symdefs do not make a section executable -- HMM *) false
        end) comp
    in
    let alloc := List.existsb (
  fun (comp_el : output_section_composition_element ) =>
    match ( comp_el) with
        IncludeInputSection(retain_pol,  (* fname, linkable_idx, shndx, isec, img *) irec) =>
      flag_is_set shf_alloc (elf64_section_flags(isec irec))
      | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) =>
      (* common symbols are allocatable *) true
      | ProvideSymbol(pol,  name1,  spec) =>
      (* symbols make a section allocatable? HMM *) true end) comp
    in
    let is_thread_local_yesnomaybe := (
  fun (comp_el : output_section_composition_element ) =>
    match ( comp_el) with
        IncludeInputSection(retain_pol,  (* fname, linkable_idx, shndx, isec, img *) irec) =>
      Some (flag_is_set shf_tls (elf64_section_flags(isec irec)))
      | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) =>
      (* FIXME: support tcommon *) Some (false)
      | ProvideSymbol(pol,  name1,  spec) =>
      (* linker script symbols shouldn't be defined here, unless they can be declared thread-local (FIXME: can they?) *)
      Some false end
    )
    in
    let thread_local := (
        (* Is any element positively thread-local? *)
        let v := List.fold_left (fun (acc_ynm : option (bool ) ) => fun (comp_el : output_section_composition_element ) => 
            let new_ynm := is_thread_local_yesnomaybe comp_el
            in match ( (acc_ynm, new_ynm)) with (None,  None) => None | (None,  Some x) =>
   Some x | (Some x,  None) => Some x | (Some true,  Some false) => Some true
   | (Some true,  Some true) => Some true | (Some false,  Some false) =>
   Some false | (Somefalse, Sometrue) =>
   DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1199, character 13 to line 1207, character 15 *)
 end) comp None
        in
        if (maybeEqualBy eqb v (Some(true))) && negb ( (maybeEqualBy eqb(Some(true)) (* are *all* either don't-care or positively thread-local? *)
            (List.fold_left (fun (acc_ynm : option (bool ) ) => fun (comp_el : output_section_composition_element ) => 
            let new_ynm := is_thread_local_yesnomaybe comp_el
            in match ( (acc_ynm, new_ynm)) with (None,  None) => None | (None,  Some x) =>
   Some x | (Some x,  None) => Some x | (Some true,  Some false) =>
   Some false | (Some true,  Some true) => Some true
   | (Some false,  Some false) => Some false | (Somefalse, Sometrue) =>
   DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1213, character 13 to line 1221, character 15 *)
 end) comp None))) then DAEMON
        else match ( v) with 
            None => false
            | Some x => x
        end
    )
    in
    nat_lor
        (if thread_local then shf_tls else 0)
        (nat_lor
            (if executable then shf_execinstr else 0)
            (nat_lor 
                (if writable then shf_write else 0)
                (if alloc then    shf_alloc else 0)
            )
        ).

Definition symbol_def_for_provide_symbol  (name1 : string ) (size2 : nat ) (info : unsigned_char ) (other : unsigned_char ) (linker_script_linkable_idx : nat )  : symbol_definition :=  
    {|def_symname := (*let _ = errln ("Linker script is defining symbol called `" ^ name ^ "'") in*) name1
        ;def_syment := {|elf64_st_name  := (elf64_word_of_nat( 0)) (* ignored *)
           ;elf64_st_info  := info
           ;elf64_st_other := other
           ;elf64_st_shndx := (elf64_half_of_nat( 0))
           ;elf64_st_value := (elf64_addr_of_nat( 0)) (* ignored *)
           ;elf64_st_size  := (elf64_xword_of_nat size2)
           |}
        ;def_sym_scn :=( 0)
        ;def_sym_idx :=( 0)
        ;def_linkable_idx := linker_script_linkable_idx
    |}.
(* [?]: removed value specification. *)
            (* accumulated result *)
Program Fixpoint build_image  (acc : annotated_memory_image (any_abi_feature )) (pos : nat ) (outputs_by_name : fmap (string ) ((output_section_spec *nat ) % type)) (bindings_by_name : fmap (string ) (list ((nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)) % type))) (script1 : list ((script_element *nat ) % type)) (linker_script_linkable_idx : nat )  : (annotated_memory_image (any_abi_feature )*fmap (string ) ((output_section_spec *nat ) % type)) % type:=  
     let add_output_section
     := fun (p : (nat *annotated_memory_image (any_abi_feature )) % type) =>
   match ( (p) ) with ( ((*scn_idx, *) pos,  acc_img)) =>
     (fun (o : output_section_spec ) =>
        match ( (o) ) with
            (( OutputSectionSpec (guard,  addr,  secname1,  comp))) =>
          (* let _ = errln ("Computing composition of output section `" ^ secname ^ "' from " ^ (show (length comp)) ^ " elements")
            in *)
        let unaligned_start_addr := match ( addr) with Some a => DAEMON
                                      | None => pos end in
        let align := alignof_output_section comp in
        (*let _ = errln ("Aligning section " ^ secname ^ " up to a " ^ (show align) ^ "-byte address boundary")
            in*)
        let start_addr := align_up_to align unaligned_start_addr in
        match ( do_output_section_layout_starting_at_addr start_addr
                  outputs_by_name comp) with (end_addr,  comp_addrs) =>
          let size2 := Coq.Init.Peano.minus end_addr start_addr in
        (*let _ = Missing_pervasives.outln (
                if List.null comp then secname else (
                    ((space_padded_and_maybe_newline 16 secname) ^
                    ("0x" ^ (left_zero_padded_to 16 (hex_string_of_natural start_addr))) ^ " " ^
                    (left_space_padded_to 10 ("0x" ^ (hex_string_of_natural size))))
                )
            )
            in*)
        match ( List.fold_left
                  (fun (p : (list (option (elf_types_local.byte ) )*nat *set ((option ((string *((nat *nat ) % type)) % type) *range_tag (any_abi_feature )) % type)) % type) =>
                     match ( (p) ) with ( (accum_pat,  addr,  accum_meta)) =>
                       (fun (p : (output_section_composition_element *nat ) % type) =>
                          match ( (p) ) with ( (comp_el,  comp_addr)) =>
                            (* let _ = errln ("Adding an element to composition of output section `" ^ secname ^ "'")
                in *)
                          let make_line := fun (namestr : string ) =>
                                             (fun (addrstr : string ) =>
                                                (fun (szstr : string ) =>
                                                   (fun (rhs : string ) => (
                                                      String.append
                                                        (space_padded_and_maybe_newline
                                                           ( 16)
                                                           ( String.append
                                                               " " namestr))
                                                        (String.append
                                                           ( String.append
                                                               "0x"
                                                               (left_zero_padded_to
                                                                  ( 16)
                                                                  addrstr))
                                                           (String.append 
                                                            " "
                                                              (String.append
                                                                 (left_space_padded_to
                                                                    ( 10)
                                                                    ( 
                                                                    String.append
                                                                    "0x"
                                                                    szstr))
                                                                 (String.append
                                                                    " " 
                                                                  rhs)))) ))))
                          in
                          match ( match ( comp_el) with
                                        | IncludeInputSection(retainpolicy,  (* fname, linkable_idx, shndx, isec, img *) irec) =>
                                    (* We want to get the input section as a byte pattern *)
                                  let maybe_secname := elf_memory_image_element_coextensive_with_section
                                                         (shndx irec)
                                                         (img irec) in
                                  match ( maybe_secname) with None => 
                                  DAEMON | Some idstr =>
                                    (*let _ = errln ("Found element named " ^ idstr ^ " coextensive with section named " ^ 
                                    irec.isec.elf64_section_name_as_string ^ " in file " ^ irec.fname)
                                in*)
                                    match ( (fmap_lookup_by
                                               (fun (x : string ) (y : string )=>
                                                  EQ) idstr
                                               (elements(img irec)))) with
                                        Some el =>
                                      (*let _ = Missing_pervasives.outln (make_line irec.isec.elf64_section_name_as_string
                                        (hex_string_of_natural comp_addr) (hex_string_of_natural irec.isec.elf64_section_size)
                                        irec.fname)
                                    in*)
                                    let range_or_sym_is_in_this_sec := (
                                    fun (maybe_range : option ((string *((nat *nat ) % type)) % type) ) =>
                                      (fun (tag : range_tag (any_abi_feature )) =>
                                         (* is it within the section we're outputting? 
                                         * first we needs its element name. *)
                                         let section_el_name := get_unique_name_for_section_from_index
                                                                  (shndx irec)
                                                                  (isec irec)
                                                                  (img irec)
                                         in
                                         (* filter out ones that don't overlap *)
                                         match ( maybe_range) with
                                             Some(el_name,  (start,  len)) =>
                                           (string_equal
                                              (* img and shndx came as a unit, so they're definitely 
                                                 * talking about the same file *)
                                              (* shndx = sym_shndx *) section_el_name
                                              el_name) | None =>
                                           (* ABS symbols have this property *)
                                           match ( tag) with
                                               SymbolDef(def) =>
                                             (* don't match section symbols, or we'll be inundated *)
                                           let sym_shndx := nat_of_elf64_half
                                                              (elf64_st_shndx(def_syment def))
                                           in
                                           if negb
                                                (beq_nat sym_shndx shn_abs)
                                              ||
                                              ( negb
                                                  (beq_nat
                                                     (get_elf64_symbol_type
                                                        (def_syment def))
                                                     stt_section)) then 
                                           false else
                                             (
                                             let abs_address := nat_of_elf64_addr
                                                                  (elf64_st_value(def_syment def))
                                             in
                                             (* check it against our section *)
                                             let section_end_addr := 
                                             Coq.Init.Peano.plus addr
                                               (elf64_section_size(isec irec))
                                             in nat_gteb abs_address addr &&
                                                nat_ltb abs_address
                                                  section_end_addr
                                             (* FIXME: argument that this should be <=, i.e. can mark end addr *)
                                             ) | _ => false end end )) in
                                    let ranges_and_tags := let x2 := [] in 
                                    List.fold_right
                                      (fun (p : (option (element_range ) *range_tag (any_abi_feature )) % type) (x2 : list ((option (element_range ) *range_tag (any_abi_feature )) % type)) =>
                                         match ( (p ,x2) ) with
                                             ((maybe_range,  tag) ,  x2) =>
                                           if
                                           range_or_sym_is_in_this_sec
                                             maybe_range tag then
                                             (maybe_range, tag) :: x2 else 
                                           x2 end) x2
                                      (set_to_list (by_range(img irec))) in
                                    let included_defs := let x2 := [] in 
                                    List.fold_right
                                      (fun (p : (option (element_range ) *symbol_definition ) % type) (x2 : list (symbol_definition )) =>
                                         match ( (p ,x2) ) with
                                             ((maybe_range,  def) ,  x2) =>
                                           if range_or_sym_is_in_this_sec
                                                maybe_range (SymbolDef (def)) then
                                             def :: x2 else x2 end) x2
                                      (elf_memory_image_defined_symbols_and_ranges
                                         (img irec)) in
                                    let included_global_defs := let x2 := [] in 
                                    List.fold_right
                                      (fun (def : symbol_definition ) (x2 : list (symbol_definition )) =>
                                         if negb
                                              (beq_nat
                                                 (
                                                 (* filter out locals *) get_elf64_symbol_binding
                                                   (def_syment def))
                                                 stb_local) then def :: x2
                                         else x2) x2 included_defs in
                                    (* What symbol defs are being included? *)
                                    (* For each global symbol defined in the section, output a line. *)
                                    (*let _ = Missing_pervasives.outs (List.foldl (^) "" (
                                        List.map (fun def -> (make_line ""
                                                (hex_string_of_natural (comp_addr + (natural_of_elf64_addr def.def_syment.elf64_st_value)))
                                                (hex_string_of_natural (natural_of_elf64_xword def.def_syment.elf64_st_size))
                                                ("    " ^ def.def_symname)) ^ "\n"
                                        ) included_global_defs
                                    ))
                                    in*)
                                    let new_ranges_and_tags
                                    := lem_set.setMapMaybe
                                         (fun (p : (option ((string *((nat *nat ) % type)) % type) *range_tag (any_abi_feature )) % type) =>
                                            match ( (p) ) with
                                                ( (maybe_range,  tag)) =>
                                              (* How do we update existing metadata? In general,
                                         * we get a new range. *)
                                            let new_range := match ( maybe_range) with
                                                                 None => None
                                                               | Some(el_name,  (start,  len)) =>
                                                               Some
                                                                 (secname1 (* FIXME: pass this through a section-to-element gensym. 
                                                                We can just (for now) define output element names
                                                                to equal the section names, since we have no unnamed
                                                                output sections and no output common symbols. *) ,
                                                                 ( Coq.Init.Peano.plus
                                                                    start
                                                                    ( 
                                                                    Coq.Init.Peano.minus
                                                                    addr
                                                                    start_addr),
                                                                 len)) end in
                                            match ( tag) with
                                                (* If it's a section, we discard it.
                                             * We will add a new section record at the end. (FIXME)  *)
                                              | FileFeature(ElfSection(idx1,  isec1)) =>
                                              None
                                            (* If it's a symbol def, we propagate it.
                                             * We record its linkable idx, so we can
                                             * match it later with the bindings we formed
                                             * earlier.
                                             * FIXME: this is a bit nasty. Perhaps we 
                                             * should replace syment with a minimal structure
                                             * that avoids duplication. Same for isecs. *)
                                              | SymbolDef(def) =>
                                              (*let _ = if def.def_symname = "_start" then errln ("Saw def of _start, "
                                                    ^ "in section " ^ irec.isec.elf64_section_name_as_string ^ " of linkable " ^ (show irec.idx)
                                                    ^ ", destined for output section `" ^ irec.secname ^ "'")
                                                 else ()
                                                in*) Some
                                                (new_range, SymbolDef
                                                              ({|def_symname :=(def_symname def)
                                                              ;def_syment :=(def_syment def)
                                                              ;def_sym_scn :=(def_sym_scn def)
                                                              ;def_sym_idx :=(def_sym_idx def)
                                                              ;def_linkable_idx :=(idx irec)
                                                              |}))
                                              | AbiFeature(x) =>
                                              Some
                                                (new_range, AbiFeature (x))
                                            (* If it's a symbol ref with no reloc site, we discard it? *)
                                              | SymbolRef(r) =>
                                              (*let _ = if r.ref.ref_symname = "_start" then errln ("Saw ref to _start, " 
                                                    ^ "in section " ^ irec.isec.elf64_section_name_as_string ^ " of linkable " ^ (show irec.idx))
                                                else ()
                                                in*)
                                            let get_binding_for_ref := (
                                            fun (symref : symbol_reference ) =>
                                              (fun (linkable_idx : nat ) =>
                                                 (fun (fname1 : string ) =>
                                                    let name_matches1 := 
                                                    match ( (fmap_lookup_by
                                                               (fun (x : string ) (y : string )=>
                                                                  EQ)
                                                               (ref_symname symref)
                                                               bindings_by_name)) with
                                                        Some x => x | None =>
                                                      [] end in
                                                    match ( List.filter
                                                              (fun (p : (nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *linkable_item ) % type) ) % type)) % type) =>
                                                                 match ( (p) ) with
                                                                    ( (bi,  ((r_idx,  r,  r_item),  m_d))) =>
                                                                   beq_nat
                                                                    r_idx
                                                                    linkable_idx
                                                                   &&
                                                                   classical_boolean_equivalence
                                                                    r 
                                                                   symref end)
                                                              name_matches1) with
                                                        [(b_idx,  b)] =>
                                                      (b_idx, b) | [] =>
                                                      DAEMON | _ => DAEMON
                                                    end ))) in
                                            match ( get_binding_for_ref
                                                      (ref r) (idx irec)
                                                      (fname irec)) with
                                                (bi,  b) =>
                                              match ( b) with
                                                  ((ref_idx,  ref1,  ref_linkable),  maybe_def) =>
                                                match ((maybe_reloc r)) with
                                                    None => None
                                                (* If it's a reloc site, we need to somehow point it
                                                     * at the *definition* that it was bound to. YES. 
                                                     * reloc_sites are 
                                                     
                                                     type reloc_site = <|
                                                      ref_relent  : elf64_relocation_a 
                                                    ; ref_rel_scn : natural  --the relocation section idx
                                                    ; ref_rel_idx : natural  --the index of the relocation rec
                                                    ; ref_src_scn : natural  --the section *from which* the reference logically comes
                                                    |>
                                                    
                                                    type elfNN_relocation_a =
                                                      <| elfNN_ra_offset : elf32_addr  --Address at which to relocate
                                                       ; elfNN_ra_info   : elf32_word  --Symbol table index/type of relocation to apply
                                                       ; elfNN_ra_addend : elf32_sword --Addend used to compute value to be stored
                                                       |>
                                                    
                                                     * ... of which ref_src_scn, ref_rel_idx, 
                                                     * ref_rel_scn and elfNN_ra_offset can be ignored.
                                                     * 
                                                     * What *is* important is that we somehow point at
                                                     * the symbol definition (or perhaps *un*definition,
                                                     * if we're generating a shared library) that it
                                                     * refers to. 
                                                     *
                                                     * For that, we update ra_info use the 1 + binding_idx,
                                                     * i.e. consider that there is a fresh symbol table
                                                     * and that it has a distinct entry for each binding.
                                                     * 
                                                     * FIXME: we also need to account for 
                                                     * reloc decisions -- MakePIC etc.
                                                     *)
                                                  | Some(rs) =>
                                                  Some
                                                    (new_range, SymbolRef
                                                                  (
                                                                  {|ref := {|ref_symname :=(ref_symname ref1)
                                                                  ;ref_syment :=
                                                                  {|elf64_st_name := (
                                                                  elf64_word_of_nat
                                                                    ( 0)) (* unused *)
                                                                  ;elf64_st_info :=(elf64_st_info(ref_syment ref1))
                                                                  ;elf64_st_other :=(elf64_st_other(ref_syment ref1))
                                                                  ;elf64_st_shndx := (
                                                                  elf64_half_of_nat
                                                                    (
                                                                    
                                                                    (* shn_abs *) 0))
                                                                  ;elf64_st_value := (
                                                                  elf64_addr_of_nat
                                                                    ( 0))
                                                                  ;elf64_st_size := (
                                                                  elf64_xword_of_nat
                                                                    ( 0)) |}
                                                                  ;ref_sym_scn :=(
                                                                   0)
                                                                  ;ref_sym_idx :=(
                                                                   0)
                                                                  (* match maybe_def with Just _ -> 1+bi | Nothing -> 0 end *)
                                                                  |}
                                                                  ;maybe_reloc := (
                                                                  Some
                                                                    {|ref_relent := {|elf64_ra_offset := (
                                                                    elf64_addr_of_nat
                                                                    ( 0)) (* ignored *)
                                                                    ;elf64_ra_info := (
                                                                    elf64_xword_lor
                                                                    (* HACK: use bi as the symbol index. *)
                                                                    (
                                                                    elf64_xword_of_nat
                                                                    (
                                                                    get_elf64_relocation_a_type
                                                                    (ref_relent rs)))
                                                                    (
                                                                    elf64_xword_lshift
                                                                    (* ... actually, don't, now we have maybe_def_bound_to *)
                                                                    (
                                                                    elf64_xword_of_nat
                                                                    (
                                                                    
                                                                    (* (1+bi) *) 0))
                                                                    ( 32) ) )
                                                                    ;elf64_ra_addend :=(elf64_ra_addend(ref_relent rs))
                                                                    |}
                                                                    ;ref_rel_scn :=(
                                                                     
                                                                    0)
                                                                    ;ref_rel_idx :=(
                                                                     
                                                                    0)
                                                                    ;ref_src_scn :=(
                                                                     
                                                                    0) |})
                                                                  ;maybe_def_bound_to :=
                                                                  (
                                                                  (* Re-search the bindings list for a match, because we might have
                                                             * re-bound this symbol since we created the image. FIXME: since
                                                             * we do this, is there anything gained from populating this field
                                                             * earlier? Probably best not to. *) let possible_bindings
                                                                  := 
                                                                  match ( (
                                                                  fmap_lookup_by
                                                                    (
                                                                    fun (x : string ) (y : string )=>
                                                                    EQ)
                                                                    (ref_symname ref1)
                                                                    bindings_by_name)) with
                                                                    Some l =>
                                                                    if 
                                                                    (
                                                                    string_equal
                                                                    (ref_symname ref1)
                                                                    "__fini_array_end") then
                                                                    (*let _ = errln ("Found " ^ (show (length l)) ^ " bindings for __fini_array_end, of which " ^
                                                                        (show (length (List.filter (fun (bi, (r, maybe_d)) -> maybe_d <> Nothing) l))) ^ 
                                                                        " are with definition")
                                                                        in*) l
                                                                    else 
                                                                    l
                                                                    | None =>
                                                                    [] end in
                                                                  (* what's the actual binding? *)
                                                                  match ((maybe_def_bound_to r)) with
                                                                    None =>
                                                                    DAEMON
                                                                    | Some(decision,  _) =>
                                                                    (* Search the list of bindings for a possibly-updated 
                                                                     * binding for this reference. *)
                                                                  let matching_possibles := 
                                                                  List.filter
                                                                    (
                                                                    fun (p : (nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)) % type) =>
                                                                    match ( (p) ) with
                                                                    ( (bi,  ((ref_idx,  ref1,  ref_item),  maybe_d))) =>
                                                                    match ( maybe_d) with
                                                                    None =>
                                                                    false
                                                                    | Some (def_idx,  def,  def_item) =>
                                                                    beq_nat
                                                                    (idx
                                                                    (* match the *reference*, whose linkable we're processing now *)
                                                                    irec)
                                                                    ref_idx
                                                                    &&
                                                                    (
                                                                    beq_nat
                                                                    (ref_sym_scn(ref r))
                                                                    (ref_sym_scn ref1)
                                                                    &&
                                                                    beq_nat
                                                                    (ref_sym_idx(ref r))
                                                                    (ref_sym_idx ref1))
                                                                    (* 
                                                                                     def.def_syment  = sd.def_syment
                                                                                  && def.def_sym_scn = sd.def_sym_scn
                                                                                  && def.def_sym_idx = sd.def_sym_idx
                                                                                  && def_idx         = sd.def_linkable_idx *)
                                                                    end end )
                                                                    possible_bindings
                                                                  in
                                                                  (*let _ = errln ("For a ref to `" ^ ref.ref_symname ^ 
                                                                            "', possibles list is: " ^ (
                                                                                List.foldl (fun x -> fun y -> x ^ ", " ^ y) "" (List.map (fun (bi, ((_, _, _), maybe_d)) -> 
                                                                                    match maybe_d with
                                                                                        Just(def_idx, def, def_item) -> 
                                                                                            "in linkable " ^ (show def_idx) ^ 
                                                                                            ", section " ^ (show def.def_sym_scn) ^
                                                                                            ", sym idx " ^ (show def.def_sym_idx)
                                                                                        | _ -> failwith "impossible: just filtered out no-def bindings"
                                                                                    end
                                                                                ) matching_possibles)
                                                                            ))
                                                                    in*)
                                                                  let new_bound_to := 
                                                                  match ( matching_possibles) with
                                                                    [] =>
                                                                    Some
                                                                    (
                                                                    ApplyReloc
                                                                    (None), None)
                                                                    | [(bi,  ((rl,  r,  ri),  maybe_d))] =>
                                                                    Some
                                                                    (decision,
                                                                    match ( maybe_d) with
                                                                    Some (def_idx,  def,  def_item) =>
                                                                    Some
                                                                    {|def_symname :=(def_symname def)
                                                                    ;def_syment :=(def_syment def)
                                                                    ;def_sym_scn :=(def_sym_scn def)
                                                                    ;def_sym_idx :=(def_sym_idx def)
                                                                    ;def_linkable_idx := def_idx
                                                                    |}
                                                                    | None =>
                                                                    None end)
                                                                    | _ =>
                                                                    DAEMON
                                                                  end in
                                                                  if 
                                                                  negb
                                                                    ((
                                                                    maybeEqualBy
                                                                    (
                                                                    (
                                                                    fun (left : (reloc_decision *option (symbol_definition ) ) % type) (right : (reloc_decision *option (symbol_definition ) ) % type)=>
                                                                    (tuple_equal_by
                                                                    classical_boolean_equivalence
                                                                    (
                                                                    maybeEqualBy
                                                                    classical_boolean_equivalence)
                                                                    left
                                                                    right)))
                                                                    new_bound_to
                                                                    (maybe_def_bound_to r))) then
                                                                    (*let _ = errln ("Changed binding for reference to `" ^ ref.ref_symname ^ 
                                                                            "' in linkable " ^ (show irec.idx))
                                                                        in*)
                                                                    new_bound_to
                                                                  else
                                                                    if 
                                                                    (
                                                                    maybeEqualBy
                                                                    (
                                                                    (
                                                                    fun (left : (reloc_decision *option (symbol_definition ) ) % type) (right : (reloc_decision *option (symbol_definition ) ) % type)=>
                                                                    (tuple_equal_by
                                                                    classical_boolean_equivalence
                                                                    (
                                                                    maybeEqualBy
                                                                    classical_boolean_equivalence)
                                                                    left
                                                                    right)))
                                                                    new_bound_to
                                                                    None) then
                                                                    DAEMON
                                                                    else
                                                                    new_bound_to
                                                                  end)
                                                                  (*
                                                            if irec.fname = "libc.a(__uClibc_main.os)"
                                                                && irec.isec.elf64_section_name_as_string = ".data.rel.local"
                                                                then
                                                                let _ = errln ("Saw the bugger: " ^ (match r.maybe_def_bound_to with
                                                                    Just(decision, Just(sd)) -> show sd.def_syment
                                                                    | _ -> "(not complete)"
                                                                end))
                                                                in r.maybe_def_bound_to
                                                            else r.maybe_def_bound_to
                                                            *)
                                                                  |} )) end
                                              end end | ImageBase =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *)
                                              | EntryPoint =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *)
                                              | FileFeature(ElfHeader _) =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *)
                                              | FileFeature(ElfSectionHeaderTable _) =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *)
                                              | FileFeature(ElfProgramHeaderTable _) =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *)
                                              | FileFeature(ElfSegment _) =>
                                              DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 1395, character 41 to line 1605, character 47 *) (* match maybe_reloc *)
                                            end end (* match tag *) )
                                         ((set_from_list_by
                                             (pairCompare
                                                (maybeCompare
                                                   (pairCompare
                                                      (fun (x : string ) (y : string )=>
                                                         EQ)
                                                      (pairCompare
                                                         (genericCompare
                                                            nat_ltb beq_nat)
                                                         (genericCompare
                                                            nat_ltb beq_nat))))
                                                (fun (x : range_tag (any_abi_feature )) (y : range_tag (any_abi_feature ))=>
                                                   EQ)) ranges_and_tags)) (* end mapMaybe fn *)
                                    in
                                    ((elf64_section_size(isecirec)),(contents
                                    (*let _ = errln ("Saw first 20 bytes of section " ^ irec.isec.elf64_section_name_as_string ^
                                            " from " ^ irec.fname ^ " as " ^ (show (take 20 el.contents)))
                                        in*)
                                    el), new_ranges_and_tags) | _ => 
                                    DAEMON end (* match Map.lookup idstr img.elements *)
                                  end (* match maybe_secname *)
                                    | IncludeCommonSymbol(retain_pol,  fname1,  linkable_idx,  def,  img3) =>
                                    (*let _ = errln ("Including common symbol called `" ^ def.def_symname ^ "'")
                        in*)
                                  (* We want to get the common symbol as a byte pattern *)
                                  let sz := nat_of_elf64_xword
                                              (elf64_st_size(def_syment def))
                                  in
                                  let content := missing_pervasives.replicate0
                                                   sz
                                                   (Some (byte_of_nat ( 0)))
                                  in
                                  (*let _ = Missing_pervasives.outln (make_line "COMMON" (hex_string_of_natural comp_addr)
                             (hex_string_of_natural sz) fname)
                        in*)
                                  (sz, content, [(Some (secname1, ( 0, sz)), 
                                                SymbolDef
                                                  ({|def_symname :=(def_symname def)
                                                  ;def_syment :=(def_syment def)
                                                  ;def_sym_scn :=(def_sym_scn def)
                                                  ;def_sym_idx :=(def_sym_idx def)
                                                  ;def_linkable_idx := linkable_idx
                                                  |}))])
                                  (*                    | Hole(AddressExprFn f) -> 
                        let next_addr = f addr (AllocatedSectionsMap outputs_by_name)
                        in
                        let n = next_addr - addr
                        in
                        let content = Missing_pervasives.replicate n Nothing
                        in 
                        (*let _ = Missing_pervasives.outln (make_line "*fill*" (hex_string_of_natural comp_addr)
                             (hex_string_of_natural n)
                             "")
                        in*)
                        (next_addr - addr, content, {}) *)
                                    | ProvideSymbol(pol,  name1,  (size2,  info,  other)) =>
                                    let symaddr := pos (* FIXME: support others *)
                                  in
                                  (*let _ = Missing_pervasives.outln (make_line "" (hex_string_of_natural symaddr) "" ("PROVIDE (" ^ name ^ ", .)"))
                        in*)
                                  ( (* sz *) 0, (* comp_el_pat *) [], 
                                  (* this_el_meta *) [(
                                  Some
                                    (secname1, (( Coq.Init.Peano.minus 
                                                  pos start_addr), 0)),
                                  SymbolDef
                                    (symbol_def_for_provide_symbol name1
                                       size2 info other
                                       linker_script_linkable_idx)) ]) end) with
                              (sz,  comp_el_pat,  this_el_meta) =>
                            (*let _ = errln ("Appending byte pattern to section " ^ secname ^ ", first 20 bytes: " ^ 
                    (show (take 20 comp_el_pat)))
                in*)
                          let new_content := append_to_byte_pattern_at_offset
                                               ( Coq.Init.Peano.minus
                                                   comp_addr start_addr)
                                               accum_pat comp_el_pat in
                          let new_addr := Coq.Init.Peano.plus comp_addr sz in
                          let new_meta := (set_union_by
                                             (pairCompare
                                                (maybeCompare
                                                   (pairCompare
                                                      (fun (x : string ) (y : string )=>
                                                         EQ)
                                                      (pairCompare
                                                         (genericCompare
                                                            nat_ltb beq_nat)
                                                         (genericCompare
                                                            nat_ltb beq_nat))))
                                                (fun (x : range_tag (any_abi_feature )) (y : range_tag (any_abi_feature ))=>
                                                   EQ)) accum_meta
                                             this_el_meta) in
                          (new_content, new_addr, new_meta) (* match comp_el_pat *)
                          end end ) end) (zip comp comp_addrs)
                  ([], start_addr, [])) with
            (concatenated_content,  final_addr,  new_range_tag_pairs) =>
          let concat_sec_el := {|startpos := (Some (start_addr))
        ;length1 := (Some (size2)) ;contents := concatenated_content |} in
        (*let _ = Missing_pervasives.outln "" in*)
        (* Make a new element in the image, also transferring metadata from input elements 
             * as appropriate. *)
        let new_by_range_list :=
        (Some (secname1, ( 0, size2)), FileFeature
                                         (ElfSection
                                            (
                                               (* We don't yet konw where this'll come in the output file, so ...  *) (* scn_idx *) 0,
                                            {|elf64_section_name :=( 0) (* ignored *)
                                            ;elf64_section_type := (output_section_type
                                                                    comp)
                                            ;elf64_section_flags := (
                                            output_section_flags comp)
                                            ;elf64_section_addr :=( 0) (* ignored -- covered by element *)
                                            ;elf64_section_offset :=(
                                             0) (* ignored -- will be replaced when file offsets are assigned *)
                                            ;elf64_section_size :=( 0) (* ignored *)
                                            ;elf64_section_link :=( 0) (* HMM *)
                                            ;elf64_section_info :=( 0) (* HMM *)
                                            ;elf64_section_align := (
                                            alignof_output_section comp)
                                            ;elf64_section_entsize :=(
                                             0) (* HMM *)
                                            ;elf64_section_body := byte_sequence.empty (* ignored *)
                                            ;elf64_section_name_as_string := secname1 (* can't rely on this being ignored *)
                                            |}) )) ::
        set_to_list new_range_tag_pairs in
        (* let _ = errln ("Metadata for new section " ^ secname ^ " consists of " ^ (show (length new_by_range_list)) ^ " tags.")
            in *)
        let new_by_range := List.fold_left
                              (fun (m : set ((option (element_range ) *range_tag (any_abi_feature )) % type)) =>
                                 fun (p : (option (element_range ) *range_tag (any_abi_feature )) % type) =>
                                   match ( (p) ) with
                                       ( (maybe_range,  tag)) =>
                                     let new_s := set_add (maybe_range, tag)
                                                    m in
                                   (* let _ = errln ("Inserting an element into by_range; before: " ^ (show (Set.size m)) ^ "; after: " ^ (show (Set.size new_s)))
                in *)
                                   new_s end ) new_by_range_list
                              (by_range acc_img) in
        let new_by_tag := by_tag_from_by_range new_by_range in let _ :=
        let section_tags_bare := List.filter
                                   (fun (p : (option (element_range ) *range_tag (any_abi_feature )) % type) =>
                                      match ( (p) ) with
                                          ( (maybe_range,  tag)) =>
                                        match ( tag) with
                                              | FileFeature(ElfSection(idx1,  isec1)) =>
                                          true | _ => false end end)
                                   (set_to_list new_by_range) in
        (* errln ("Total metadata now includes " ^ (show (length section_tags_bare)) ^ " sections; are by_range and "
                    ^ "by_tag consistent? " ^ (show (new_by_tag = by_tag_from_by_range new_by_range))) *) tt
        in (* this expression is the return value of add_output_section *)
        ( Coq.Init.Peano.plus (* new_pos *) start_addr size2,
        (* new_acc *) {|elements := (fmap_add secname1 concat_sec_el
                                       (elements acc_img))
        (* tag it as a section, and transfer any tags *)
        ;by_range := (* let _ = errln ("Returning from add_output_section a by_range with " ^ 
                                (show (Set.size new_by_range))) in *) new_by_range
        ;by_tag := new_by_tag |}, (* sec_sz *) size2,
        (* replacement_output_sec *) (OutputSectionSpec
                                        (guard, Some (start_addr), secname1, comp)))
        end end end ) end (* end add_output_section *)
    in
    match ( script1) with 
        [] => (acc, outputs_by_name)
        | (element1,  el_idx) :: more_elements_and_idx =>
             let do_nothing := (acc, pos, outputs_by_name) in 
  match (
  match ( element1) with
      DefineSymbol(symdefpol,  name1,  (symsize,  syminfo,  symother)) =>
    (* We've already added this to the output composition. *) do_nothing
    | AdvanceAddress(AddressExprFn advance_fn) =>
    let new_pos := advance_fn pos outputs_by_name in
  (acc, new_pos, outputs_by_name)
  (* FIXME: the allocated sections map is the subset of the outputs_by_name map 
                     * that has been allocated -- meaning *both* sized *and* placed. 
                     * Since we're a multi-pass interpreter, we've sized everything already, but 
                     * only a subset has been placed. So we need to weed out all elements from
                     * outputs_by_name that don't correspond to a section in the accumulated image.
                     * We should probably include the section's range_tag in the allocated_sections_map,
                     * which would force us to do this, but at the moment neither of these is done. *)
    | MarkAndAlignDataSegment(maxpagesize1,  commonpagesize1) =>
    (* GNU linker manual says:
                    
                    "DATA_SEGMENT_ALIGN(MAXPAGESIZE, COMMONPAGESIZE)
                            is equivalent to either
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - 1)))
                      or
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - COMMONPAGESIZE)))
                      depending on whether the latter uses fewer COMMONPAGESIZE sized
                      pages for the data segment (area between the result of this
                      expression and `DATA_SEGMENT_END') than the former or not.  If the
                      latter form is used, it means COMMONPAGESIZE bytes of runtime
                      memory will be saved at the expense of up to COMMONPAGESIZE wasted
                      bytes in the on-disk file."
                      
                        In other words, we're marking the beginning of the data segment
                        by aligning our position upwards by an amount that 
                        
                        - guarantees we're on a new page...
                        
                        - ... but (option 1) at an address that's congruent, modulo the max page size
                                  (e.g. for 64kB maxpage, 4kB commonpage, we AND with 0xffff)
                        
                        - ... (option 2) at an offset that's at the commonpagesize boundary
                                  immediately preceding the lowest congruent address
                                  (e.g. for 64kB maxpage, 4kB commonpage, we AND with 0xf000,
                                  so if we're at pos 0x1234, we bump up to 0x11000).
                                  
                                  FIXME:
                                  
                                  The GNU linker seems to bump up to 0x12000 here, not 0x11000.
                                  Specifically, 
                                  
                                    DATA_SEGMENT_ALIGN (0x200000, 0x1000)
                                    
                                    bumps 0x4017dc up to 0x602000.
                                    
                                  This is indeed better, because it allows the next section
                                  to be output without a big gap in the file.
                                  
                                  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                                                 0x00000000000017dc 0x00000000000017dc  R E    200000
                                  LOAD           0x0000000000002000 0x0000000000602000 0x0000000000602000
                                                 0x0000000000000120 0x0000000000000ce8  RW     200000
                                  
                                  ... whereas if the second LOAD began at address 0x601000,
                                  the file offset of its first section would have to be 0x11000.
                                  
                                  So what *should* the formula be?
                                  It needs to calculate the next address which
                                  
                                  - is a commonpagesize boundary;
                                  
                                  - is minimally >= the current address, modulo the commonpagesize
                                  
                                  - is minimally >= the current address, modulo the maxpagesize.
                                  
                                  The AND operation gives us something that is minimally *below*
                                  the commonpagesize boundary. I think we need to add COMMONPAGESIZE.
                                  
                                  The code does this (in ldexp.c around line 478 as of binutils 2.25):
                                  
                                        expld.result.value = align_n (expld.dot, maxpage);
                                        /* omit relro phase */
                                        if (expld.dataseg.phase == exp_dataseg_adjust)
                                        {
                                          if (commonpage < maxpage)
                                            expld.result.value += ((expld.dot + commonpage - 1)
                                                                   & (maxpage - commonpage));
                                        }
                                        else 
                                        {
                                          expld.result.value += expld.dot & (maxpage - 1);
                                        
                                  Which amounts to:
                                       
                                       1. first, align up to maxpage. So for our example, we're now 0x10000.
                                          or for our real example, we're now 0x600000
                                       
                                          THEN since the first phase (expld_dataseg_none) 
                                          hits the final "else" case,
                                          we immediately restore the modulus of the address,
                                          giving 0x60188c.
                                           or 0x6019ac  the second time around (FIXME: why two?)
                                       
                                       2. next, on the relevant phase (pass) of the script interpreter,
                                          i.e. OPTION 2
                                          if commonpage < maxpage,
                                          bump up the *non-maxpage-aligned non-modulo-restored* address
                                          by 
                                              (. + commonpage - 1)  &  (maxpage - commonpage)
                                            
                                          i.e. for our example earlier
                                              (0x01234 + 0x1000 - 1) &  (0xf000)
                                              = 
                                               0x02233               &   0xf000
                                              =
                                               0x02000
                                               
                                         i.e. for our real example
                                              (0x4019ac + 0x1000 - 1) &  (0x1ff000)
                                              = 
                                               0x4019ac + 0x1000 - 1) &   0x1ff000
                                              =
                                               0x002000
                                               
                                        3. OPTION 1 is implemented by the trailing "else {"
                                           -- it restores the modulus.
                                           
                                  So the problem with our original logic (below) was that 
                                  it did what the manual says, not what the code does.
                                  Specifically, the code for option 2 does
                                  
                                    (. + commonpagesize - 1) & (maxpagesize - commonpagesize)
                                    
                                    and NOT simply
                                    
                                    . & (maxpagesize - commonpagesize).
                                    
                                  FIXME: report this bug.
                                  
                        
                        Note that intervening commands can do arbitrary things to the location
                        counter, so we can't do any short-cut arithmetic based on section sizes;
                        we actually have to run the layout procedure til we hit the end of the 
                        data segment, and then see how we do. 
                        
                        We run this function *forward* with the first option on a subset
                        of the script ending with the end of the data segment.
                        We then see what comes back. 
                    
                     *)
  (* let num_pages_used *)
  (*let _ = errln ("Option 1 congruence add-in from pos 0x" ^ (hex_string_of_natural pos) ^ ", maxpagesize 0x" ^ 
                        (hex_string_of_natural maxpagesize) ^ " is 0x" ^ (hex_string_of_natural (natural_land pos (maxpagesize - 1))))
                    in*)
  let option1 := Coq.Init.Peano.plus (align_up_to maxpagesize1 pos)
                   (nat_land pos ( Coq.Init.Peano.minus maxpagesize1 ( 1)))
  in
  (*let _ = errln ("Mark/align data segment: option 1 is to bump pos to 0x" ^ (hex_string_of_natural option1))
                    in*)
  let option2 := Coq.Init.Peano.plus (align_up_to maxpagesize1 pos)
                   (nat_land
                      ( Coq.Init.Peano.minus
                          (Coq.Init.Peano.plus pos commonpagesize1) ( 1))
                      ( Coq.Init.Peano.minus maxpagesize1 commonpagesize1))
  in
  (*let _ = errln ("Mark/align data segment: option 2 is to bump pos to 0x" ^ (hex_string_of_natural option2))
                    in*)
  let data_segment_endpos := (fun (startpos1 : nat ) =>
                                (* run forward from here until MarkDataSegmentEnd, 
                         * accumulating the actually-made outputs by name and their sizes *)
                                match ( List.fold_left
                                          (fun (p : (nat *bool ) % type) =>
                                             match ( (p) ) with
                                                 ( (curpos,  seen_end)) =>
                                               fun (p : (script_element *nat ) % type) =>
                                                 match ( (p) ) with
                                                     ( (new_script_item,  new_script_item_idx)) =>
                                                   (* let _ = errln ("Folding at pos 0x" ^ (hex_string_of_natural curpos))
                            in *)
                                                   if seen_end then
                                                     (curpos, true) else
                                                     match ( match ( new_script_item) with
                                                                   | MarkDataSegmentEnd =>
                                                               (* let _ = errln "data segment end"
                                    in *)
                                                             (* break the loop early here *)
                                                             (curpos, true)
                                                               | OutputSection(outputguard,  maybe_expr,  name1,  sub_elements) =>
                                                               (* let _ = errln ("output section " ^ name)
                                    in *)
                                                             let maybe_found := (
                                                             fmap_lookup_by
                                                               (fun (x : string ) (y : string )=>
                                                                  EQ) 
                                                             name1
                                                               outputs_by_name)
                                                             in
                                                             match ( 
                                                             match ( maybe_found) with
                                                                 Some (f,  seen_script_el_idx) =>
                                                               (f, seen_script_el_idx)
                                                               | None =>
                                                               DAEMON end) with
                                                                 (OutputSectionSpec (guard,  addr,  secname1,  comp),  seen_script_el_idx) =>
                                                               (* Sometimes a given output section name, say .eh_frame, can come from multiple 
                                     * script elements with disjoint guard conditions (only_if_ro and only_if_rw, say). 
                                     * Only one of them will actually be selected when the guard is being evaluated.
                                     * So when we "replay" the sections' output here, we want to skip the ones whose
                                     * guards were false. The way we implement this is to store the originating script
                                     * element idx in the allocated_output_sections map. We can test that against our 
                                     * current script element_idx here *)
                                                             let replay_output := ( 
                                                             beq_nat
                                                               seen_script_el_idx
                                                               el_idx) in
                                                             if replay_output
                                                             then
                                                               (
                                                               let unaligned_start_addr := curpos
                                                               in
                                                               let start_addr := 
                                                               align_up_to
                                                                 (alignof_output_section
                                                                    comp)
                                                                 unaligned_start_addr
                                                               in
                                                               match ( 
                                                               do_output_section_layout_starting_at_addr
                                                                 start_addr
                                                                 outputs_by_name
                                                                 comp) with
                                                                   (end_addr,  comp_addrs) =>
                                                                 let size2 := 
                                                               Coq.Init.Peano.minus
                                                                 end_addr
                                                                 start_addr
                                                               in
                                                               (end_addr, (* seen_end *) false)
                                                               end ) else
                                                               (curpos, (* seen_end *) false)
                                                             end
                                                               | AdvanceAddress(AddressExprFn advance_fn) =>
                                                               (* let _ = errln "Advance address"
                                    in *)
                                                             let new_pos := 
                                                             advance_fn
                                                               curpos
                                                               outputs_by_name
                                                             in
                                                             (new_pos, false)
                                                               | _ =>
                                                               (curpos, seen_end)
                                                             end) with
                                                         (newpos,  new_seen) =>
                                                       if nat_ltb newpos
                                                            curpos then
                                                         DAEMON else
                                                         (newpos, new_seen)
                                                     end end end )
                                          more_elements_and_idx
                                          (startpos1, false)) with
                                    (endpos,  _) => endpos end ) in
  let endpos_option1 := data_segment_endpos option1 in
  let endpos_option2 := data_segment_endpos option2 in
  (*let _ = errln ("Mark/align data segment: option 1 gives an endpos of 0x" ^ (hex_string_of_natural endpos_option1))
                    in*)
  (*let _ = errln ("Mark/align data segment: option 2 gives an endpos of 0x" ^ (hex_string_of_natural endpos_option2))
                    in*)
  let npages := (fun (startpos1 : nat ) =>
                   (fun (endpos : nat ) =>
                      Coq.Numbers.Natural.Peano.NPeano.div
                        ( Coq.Init.Peano.minus
                            (align_up_to commonpagesize1 endpos)
                            (round_down_to commonpagesize1 startpos1))
                        commonpagesize1 )) in
  let npages_option1 := npages option1 endpos_option1 in
  let npages_option2 := npages option2 endpos_option1 in
  (*let _ = errln ("Mark/align data segment: option 1 uses " ^ (show npages_option1) ^ " COMMONPAGESIZE-sized pages")
                    in*)
  (*let _ = errln ("Mark/align data segment: option 2 uses " ^ (show npages_option2) ^ " COMMONPAGESIZE-sized pages")
                    in*)
  if nat_ltb npages_option1 npages_option2 then
    (*let _ = errln "Choosing option 1" in*) (acc, option1, outputs_by_name)
  else
    (*let _ = errln "Choosing option 2" in*) (acc, option2, outputs_by_name)
    | MarkDataSegmentEnd => do_nothing
    | MarkDataSegmentRelroEnd(*(fun_from_secs_to_something)*) => do_nothing
    | OutputSection(outputguard,  maybe_expr,  name1,  sub_elements) =>
    (* Get the composition we computed earlier, and actually put it in
                     * the image, assigning an address to it. *)
  let maybe_found := (fmap_lookup_by (fun (x : string ) (y : string )=> EQ)
                        name1 outputs_by_name) in
  match ( match ( maybe_found) with Some (f,  saved_idx) => (f, saved_idx)
            | None => DAEMON end) with (found,  seen_script_el_idx) =>
    match ( found) with
        ( OutputSectionSpec (guard,  addr,  secname1,  comp)) =>
      (* let next_free_section_idx = 1 + naturalFromNat (Map.size outputs_by_name)
                    in *)
    let count_sections_in_image := fun (img3 : annotated_memory_image (any_abi_feature )) =>
                                     (
                                     match ( elf_memory_image_section_ranges
                                               img3) with
                                         (section_tags,  section_ranges) =>
                                       let section_tags_bare := List.map
                                                                  (fun (tag : range_tag (any_abi_feature )) =>
                                                                    match ( tag) with
                                                                    | FileFeature(ElfSection(idx1,  isec1)) =>
                                                                    true
                                                                    | _ =>
                                                                    false end)
                                                                  section_tags
                                     in length section_tags_bare end ) in
    (* Do we actually want to add an output section? Skip empty sections. 
                     * FIXME: actually heed the proper ld semantics for empty sections (e.g. ". = ." will
                     * force output). *)
    (* See note in MarkDataSegmentEnd case about script element idx. Short version:
                     * multiple output section stanzas, for a given section name, may be in the script,
                     * but only one was activated by the section composition pass. Ignore the others. *)
    let do_output := ( beq_nat seen_script_el_idx el_idx) &&
                     nat_gtb (length comp) ( 0) in
    if do_output then
      (
      (* let _ = errln ("Before adding output section, we have " ^ (show (count_sections_in_image acc))
                            ^ " sections.")
                        in *)
      (*let _ = errln ("At pos 0x" ^ (hex_string_of_natural pos) ^ ", adding output section " ^ name)
                        in*)
      match ( add_output_section ((* next_free_section_idx, *) pos, acc)
                found) with
          (new_pos,  new_acc,  sec_sz,  replacement_output_sec) =>
        (* let _ = errln ("Received from add_output_section a by_range with " ^ (show (Set.size new_acc.by_range))
                            ^ " metadata records of which " ^ (show (Set.size {
                                (r, t)
                                | forall ((r, t) IN new_acc.by_range)
                                | match t with FileFeature(ElfSection(x)) -> true | _ -> false end
                            }
                            )) ^ " are ELF sections; one more time: " ^ (show (Set.size {
                                (t, r)
                                | forall ((t, r) IN new_acc.by_tag)
                                | match t with FileFeature(ElfSection(x)) -> true | _ -> false end
                            }
                            )) ^ "; count_sections_in_image says " ^ (show (
                                length (Multimap.lookupBy Memory_image_orderings.tagEquiv (FileFeature(ElfSection(0, null_elf64_interpreted_section))) new_acc.by_tag)
                                )) 
                            )
                        in *)
      (* let _ = errln ("After adding output section, we have " ^ (show (count_sections_in_image new_acc))
                            ^ " sections.")
                        in *)
      (new_acc, new_pos, (fmap_add name1 (replacement_output_sec, el_idx)
                            ((fmap_delete_by
                                (fun (x : string ) (y : string )=> EQ) 
                              name1 outputs_by_name)))) end ) else
      (acc, pos, outputs_by_name) end end | DiscardInput(selector) =>
    do_nothing | InputQuery(retainpol,  sortpol,  selector) => do_nothing end) with
      (new_acc,  new_pos,  new_outputs_by_name) =>
    (* recurse *) build_image new_acc new_pos new_outputs_by_name
      bindings_by_name more_elements_and_idx linker_script_linkable_idx end
    end.
(* [?]: removed value specification. *)

Definition default_place_orphans  (p : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type) (inputs : list (input_spec ))  : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type:= 
  match ( (p,inputs)) with ( (discards,  outputs),  inputs) =>
    let output_irecs := List.fold_left
                          (fun (acc : set (input_section_rec )) =>
                             fun (outp : (output_section_spec *nat ) % type) =>
                               (match ( outp) with
                                    (OutputSectionSpec(guard,  maybe_addr,  name1,  comp),  script_el_idx) =>
                                  let all_irecs := List.fold_left
                                                     (fun (inner_acc : set (input_section_rec )) =>
                                                        fun (comp_el : output_section_composition_element ) =>
                                                          match ( comp_el) with
                                                              IncludeInputSection(_,  irec) =>
                                                            set_add irec
                                                              inner_acc
                                                            | _ => inner_acc
                                                          end) comp []
                                in (set_union_by
                                      (fun (x : input_section_rec ) (y : input_section_rec )=>
                                         EQ) all_irecs acc) end)) outputs 
                        [] in
  let orphans := List.filter
                   (fun (inp : input_spec ) =>
                      match ( inp) with InputSection(irec) =>
                        let v := negb
                                   ( (set_member_by
                                        (fun (x : input_section_rec ) (y : input_section_rec )=>
                                           EQ) irec output_irecs))
                      in (*let _ = if v then errln ("Saw an orphan input section: " ^ 
                                    irec.secname ^ " in " ^ irec.fname) else ()
                                   in*) v
                        | _ => false end) inputs in
  let place_one_orphan := fun (acc : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type) =>
                            fun (input : input_spec ) => (
                              let irec := match ( input) with
                                              InputSection(irec) => irec
                                            | _ => DAEMON end in
                              match ( acc) with (discards,  outputs) =>
                                let find_output := fun (maybe_name : option (string ) ) =>
                                                     fun (maybe_type : option (nat ) ) =>
                                                       fun (flags_must_have : set (nat )) =>
                                                         fun (flags_must_not_have : set (nat )) =>
                                                           (
                                                           missing_pervasives.find_index
                                                             (fun (p : (output_section_spec *nat ) % type) =>
                                                                match ( (p) ) with
                                                                    ( (OutputSectionSpec (guard,  maybe_addr,  name1,  comp),  script_el_idx)) =>
                                                                  let flags := 
                                                                output_section_flags
                                                                  comp in
                                                                match ( maybe_name) with
                                                                    Some n =>
                                                                  (string_equal
                                                                    n 
                                                                   name1)
                                                                  | None =>
                                                                  true end &&
                                                                (match ( maybe_type) with
                                                                    Some t =>
                                                                   beq_nat
                                                                    (
                                                                    output_section_type
                                                                    comp) 
                                                                   t
                                                                   | None =>
                                                                   true end
                                                                 &&
                                                                 (set_for_all
                                                                    (
                                                                    fun (x : nat ) =>
                                                                    flag_is_set
                                                                    x 
                                                                    flags)
                                                                    flags_must_have
                                                                  &&
                                                                  set_for_all
                                                                    (
                                                                    fun (x : nat ) =>
                                                                    negb
                                                                    (
                                                                    flag_is_set
                                                                    x 
                                                                    flags))
                                                                    flags_must_not_have))
                                                                end ) 
                                                           outputs ) in
                              let place_after_nonalloc := find_output 
                                                          None None []
                                                            [ shf_alloc ] in
                              let place_after_interp := find_output
                                                          (Some (".interp"))
                                                          (Some
                                                             (sht_progbits))
                                                          [ shf_alloc ] 
                                                        [] in
                              let place_after_bss := find_output
                                                       (Some (".bss"))
                                                       (Some (sht_nobits))
                                                       [ shf_alloc;  shf_write]
                                                       [] in
                              let place_after_rodata := find_output
                                                          (Some (".rodata"))
                                                          (Some
                                                             (sht_progbits))
                                                          [ shf_alloc ]
                                                          [ shf_write ] in
                              let place_after_rel := find_output
                                                       (Some (".rela.dyn"))
                                                       (Some (sht_rela)) 
                                                     [] [] in
                              let place_after_data := find_output
                                                        (Some (".data"))
                                                        (Some (sht_progbits))
                                                        [ shf_alloc;  shf_write ]
                                                        [] in
                              let place_after_text := find_output
                                                        (Some (".text"))
                                                        (Some (sht_progbits))
                                                        [ shf_alloc;  shf_execinstr ]
                                                        [] in
                              let place_after := match ( input) with
                                                     InputSection(irec) =>
                                                   (* HACK: simulates GNU linker, but this logic ought to go elsewhere *)
                                                   if (string_equal
                                                         (elf64_section_name_as_string(isec irec))
                                                         ".note.GNU-stack") then
                                                     None else
                                                     if negb
                                                          (flag_is_set
                                                             shf_alloc
                                                             (elf64_section_flags(isec irec)))
                                                        &&
                                                        (* not flag_is_set shf_alloc irec.isec.elf64_section_flags *) (* no debugging, for now *) true
                                                     then
                                                       place_after_nonalloc
                                                     else
                                                       (* FIXME: reinstate alloc-debugging case *)
                                                       if beq_nat
                                                            (elf64_section_type(isec irec))
                                                            sht_note
                                                          (* FIXME: replicate iself logic *)
                                                          ||
                                                          (string_equal
                                                             (elf64_section_name_as_string(isec irec))
                                                             ".note") then
                                                         place_after_interp
                                                       else
                                                         if beq_nat
                                                              (elf64_section_type(isec irec))
                                                              sht_nobits then
                                                           place_after_bss
                                                         else
                                                           (* FIXME: implement thread-local case *)
                                                           if negb
                                                                (flag_is_set
                                                                   shf_write
                                                                   (elf64_section_flags(isec irec)))
                                                              &&
                                                              negb
                                                                (flag_is_set
                                                                   shf_execinstr
                                                                   (elf64_section_flags(isec irec)))
                                                           then
                                                             place_after_rodata
                                                           else
                                                             if flag_is_set
                                                                  shf_write
                                                                  (elf64_section_flags(isec irec))
                                                                &&
                                                                negb
                                                                  (flag_is_set
                                                                    shf_execinstr
                                                                    (elf64_section_flags(isec irec)))
                                                             then
                                                               place_after_data
                                                             else
                                                               place_after_text
                                                   | Common _ =>
                                                   DAEMON (* Incomplete Pattern at File \"linker_script.lem\", line 2192, character 46 to line 2214, character 11 *)
                                                 end in
                              match ( acc) with (discards,  outputs) =>
                                match ( place_after) with Some idx1 =>
                                  (* The section exists and has the flags we expected, and is at output idx *)
                                (discards, mapi
                                             (fun (i : nat ) =>
                                                fun (output : (output_section_spec *nat ) % type) =>
                                                  (* FIXME: also fix up flags, alignment etc. *)
                                                  match ( output) with
                                                      (OutputSectionSpec (guard,  maybe_addr,  name1,  comp),  script_el_idx) =>
                                                    if beq_nat ( i) idx1 then
                                                      (OutputSectionSpec
                                                         (guard, maybe_addr, name1, 
                                                         (@ List.app _) 
                                                         comp
                                                           [IncludeInputSection
                                                              (DefaultKeep, irec)]), script_el_idx)
                                                    else output end ) 
                                           outputs) | None =>
                                  (*let _ = errln ("Warning: discarding orphan section")
                    in*)
                                ( (@ List.app _) discards [input], outputs)
                                end end end ) in
  List.fold_left place_one_orphan orphans (discards, outputs) end.
(* [?]: removed value specification. *)

Definition interpret_linker_control_script  (script1 : list (script_element )) (linker_script_linkable_idx : nat ) (a : abi (any_abi_feature )) (inputs : list (input_spec )) (seen_ordering : input_spec  -> input_spec  -> ordering ) (place_orphans : (list (input_spec )*list ((output_section_spec *nat ) % type)) % type -> list (input_spec ) -> (list (input_spec )*list ((output_section_spec *nat ) % type)) % type) (initial_bindings_by_name : fmap (string ) (list ((nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)) % type)))  : (annotated_memory_image (any_abi_feature )*fmap (string ) (list ((nat *binding ) % type))) % type:= 
    let labelled_script := label_script script1
    in match ( assign_inputs_to_output_sections ([], []) inputs None None
           seen_ordering labelled_script) with
     (discards_before_orphans,  outputs_before_orphans) =>
   (* place orphans *)
   match ( place_orphans (discards_before_orphans, outputs_before_orphans)
             inputs) with (discards,  outputs) =>
     (* In assigning inputs to outputs, we may also have defined some symbols. These affect the 
     * bindings that are formed. So, we rewrite the bindings here. Note that we have to do so here,
     * not in the caller, because these extra bindings can affect the reachability calculation 
     * during GC. *)
   let bindings_by_name := ( let script_defs_by_name
   := List.fold_left
        (fun (acc : fmap (string ) (list ((symbol_definition *symbol_def_policy ) % type))) =>
           (fun (p : (output_section_spec *nat ) % type) =>
              match ( (p) ) with
                  ( ((OutputSectionSpec (guard,  maybe_addr,  secname1,  comp)),  script_el_idx)) =>
                List.fold_left
                  (fun (inner_acc : fmap (string ) (list ((symbol_definition *symbol_def_policy ) % type))) =>
                     fun (comp_el : output_section_composition_element ) => (
                       match ( comp_el) with
                           ProvideSymbol(pol,  name1,  (size2,  info,  other)) =>
                         (*let _ = errln ("Linker script defining symbol `" ^ name ^ "'")
                        in*)
                       let def := symbol_def_for_provide_symbol name1 
                                  size2 info other linker_script_linkable_idx
                       in
                       let v := match ( (fmap_lookup_by
                                           (fun (x : string ) (y : string )=>
                                              EQ) name1 inner_acc)) with
                                    None => [(def, pol)] | Some l =>
                                  (def, pol) :: l end in
                       fmap_add name1 v inner_acc | _ => inner_acc end ))
                  comp
                  (acc : fmap  string   (list  ((symbol_definition  * symbol_def_policy ) % type)))
              end )) outputs fmap_empty in
   (* Now that we've made these definitions, what bindings are affected? *)
   fmap_map
     (fun (b_list_initial : list ((nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)) % type)) =>
        List.map
          (fun (p : (nat *((((nat *symbol_reference *((linkable_object *input_item *input_options ) % type)) % type)*option ((nat *symbol_definition *((linkable_object *input_item *input_options ) % type)) % type) ) % type)) % type) =>
             match ( (p) ) with ( (b_idx,  b_initial)) =>
               match ( b_initial) with
                   ((iref_idx,  iref,  iref_item),  maybe_idef) =>
                 (*let _ = errln ("Looking for linker script defs of symbol `" ^ iref.ref_symname ^ "'")
                in*)
               let possible_script_defs := match ( (fmap_lookup_by
                                                      (fun (x : string ) (y : string )=>
                                                         EQ)
                                                      (ref_symname iref)
                                                      script_defs_by_name)) with
                                               Some l => l | None => [] end
               in let control_script_input_item := (
               "(built-in control script)", ControlScript,
               (BuiltinControlScript, [Builtin])) in
               let control_script_linkable_item := (
               ControlScriptDefs, control_script_input_item, {|item_fmt := ""
               ;item_check_sections := false ;item_copy_dt_needed := false
               ;item_force_output := true |}) in
               (* If the binding has no def, we always use the def we have. 
                 * If the binding has a def, we use our def only if the policy is AlwaysDefine. *)
               (*let _ = errs ("Do we override binding " ^ (show b_idx) ^ ", symbol named `" ^ 
                    iref.ref_symname ^ "'? ")
                in*)
               let new_b := match ( (maybe_idef, possible_script_defs)) with
                                  | (_,  []) =>
                              (*let _ = errln "no" in*) ((iref_idx, iref, iref_item), maybe_idef)
                              | (_,  [(def,  AlwaysDefine)]) =>
                              (*let _ = errln "yes" in*)
                            ((iref_idx, iref, iref_item),
                            Some
                              (linker_script_linkable_idx, def, control_script_linkable_item))
                              | (Some existing_def, ( [(def,  ProvideIfUsed)])) =>
                              (*let _ = errln "no" in*)
                            ((iref_idx, iref, iref_item), Some existing_def)
                              | (None,  [(def,  ProvideIfUsed)]) =>
                              (*let _ = errln "yes" in*)
                            ((iref_idx, iref, iref_item),
                            Some
                              (linker_script_linkable_idx, def, control_script_linkable_item))
                              | (_,  pair1 :: pair2 :: more) =>
                              (*let _ = errln "error" in*) DAEMON end in
               (b_idx, new_b) end end ) b_list_initial )
     initial_bindings_by_name ) in
   (*let _ = errln ("For __fini_array_end, we have " ^ 
        (let all_bs = match Map.lookup "__fini_array_end" bindings_by_name with
            Just l -> l
            | Nothing -> []
        end
        in
        ((show (length all_bs)) ^ 
        " bindings, of which " ^ 
        (show (length (List.filter (fun (bi, ((ref_idx, ref, ref_item), maybe_def)) -> 
            match maybe_def with
                Just _ -> true
                | _ -> false
            end
        ) all_bs))) ^ " have defs")))
    in*)
   let outputs_by_name :=
   (let insert_fun := fun (m : fmap (string ) ((output_section_spec *nat ) % type)) =>
                        (fun (p : (output_section_spec *nat ) % type) =>
                           match ( (p) ) with
                               ( (OutputSectionSpec(guard,  maybe_addr,  name1,  compos),  script_idx)) =>
                             fmap_add name1
                               ((OutputSectionSpec
                                   (guard, maybe_addr, name1, compos)), script_idx)
                               m end) in
   List.fold_left insert_fun outputs fmap_empty) in
   (* Print the link map's "discarded input sections" output. *)
   (*let _ = Missing_pervasives.outln "\nDiscarded input sections\n"
    in*)
   let discard_line := fun (i : input_spec ) =>
                         (match ( i) with InputSection(s) =>
                            let lpadded_secname := ( String.append " "
                                                       (secname s)) in
                          String.append lpadded_secname
                            (String.append
                               (space_padding_and_maybe_newline ( 16)
                                  lpadded_secname)
                               ( (* FIXME *) String.append
                                   "0x0000000000000000"
                                   (String.append "        0x"
                                      (String.append
                                         (hex_string_of_natural
                                            (elf64_section_size(isec s)))
                                         (String.append " "
                                            (String.append (fnames) "
"))))))
                            | Common(idx1,  fname1,  img3,  def) =>
                            "" (* don't print discard lines for discarded commons *)
                          end) in
   (*let _ = Missing_pervasives.outs (List.foldl (fun str -> (fun input -> (str ^ (discard_line input)))) "" (reverse discards))
    in*)
   let outputs_by_name_after_gc := compute_def_use_and_gc outputs_by_name in
   (*let _ = Missing_pervasives.outs "\nMemory Configuration\n\nName             Origin             Length             Attributes\n*default*        0x0000000000000000 0xffffffffffffffff\n"
    in*)
   (*let _ = Missing_pervasives.outln "\nLinker script and memory map\n"
    in*)
   (* FIXME: print LOAD and START_GROUP trace *)
   match ( build_image empty_elf_memory_image ( 0) outputs_by_name_after_gc
             bindings_by_name labelled_script linker_script_linkable_idx) with
       (img3,  outputs_by_name_with_position) =>
     (*let _ = errln ("Final image has " ^ (show (Map.size img.elements)) ^ " elements and " 
        ^ (show (Set.size img.by_tag)) ^ " metadata tags, of which " ^ (
            let (section_tags, section_ranges) = elf_memory_image_section_ranges img
            in
            let section_tags_bare = List.map (fun tag -> 
                match tag with 
                    | FileFeature(ElfSection(idx, isec)) -> (idx, isec)
                    | _ -> failwith "not section tag"
                end) section_tags
            in
            show (length section_tags_bare)
        ) ^ " are sections.")
    in*)
   (* The link map output for the section/address assignment basically mirrors our notion of 
     * output section composition.  In the following:
     
                0x0000000000400000                PROVIDE (__executable_start, 0x400000)
                0x0000000000400190                . = (0x400000 + SIZEOF_HEADERS)

.interp
 *(.interp)

.note.ABI-tag   0x0000000000400190       0x20
 .note.ABI-tag  0x0000000000400190       0x20 crt1.o

.note.gnu.build-id
                0x00000000004001b0       0x24
 *(.note.gnu.build-id)
 .note.gnu.build-id
                0x00000000004001b0       0x24 crt1.o

.hash
 *(.hash)

.gnu.hash
 *(.gnu.hash)

... we can see that 

        - symbol provision, holes and output sections all get lines
        
        - each output section appears with its name left-aligned, and its address,
             if any, appearing afterwards; if so, the section's total size also follows.
        
        - each input query is printed verbatim, e.g. "*(.note.gnu.build-id)"
        
        - underneath this, a line is printed for each input section that was included,
             with its address and size. This can spill onto a second line in the usual way.
        
        - holes are shown as "*fill*"
        
        - provided symbols are shown as in the linker script source.
        
    PROBLEM: we don't have the script in source form, so we can't print the queries verbatim.
    I should really annotate each query with its source form; when the script is parsed from source,
    this can be inserted automatically. For the moment, what to do? I could annotate each script
    element manually. For the moment, for diffing purposes, filter out lines with asterisks.
     
     *)
   (img3, bindings_by_name) end end end.
