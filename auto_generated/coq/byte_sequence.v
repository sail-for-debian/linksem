(* Generated by Lem from byte_sequence.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [byte_sequence.lem], a list of bytes used for ELF I/O and other basic tasks
  * in the ELF model.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_list.
Require Export lem_list.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import lem_assert_extra.
Require Export lem_assert_extra.


Require Import error.
Require Export error.

Require Import missing_pervasives.
Require Export missing_pervasives.

Require Import show.
Require Export show.

Require Import elf_types_local.
Require Export elf_types_local.


(** A [byte_sequence], [bs], denotes a consecutive list of bytes.  Can be read
  * from or written to a binary file.  Most basic type in the ELF formalisation.
  *)
Inductive byte_sequence : Type := 
  Sequence:  (list  elf_types_local.byte ) -> byte_sequence .
Definition byte_sequence_default: byte_sequence  := Sequence DAEMON.
(* [?]: removed value specification. *)

Definition byte_list_of_byte_sequence  (bs0 : byte_sequence )  : list (elf_types_local.byte ):= 
  match ( bs0) with 
    | Sequence xs => xs
  end.
(* [?]: removed value specification. *)

Definition compare_byte_sequence  (s1 : byte_sequence ) (s2 : byte_sequence )  : ordering :=   
(lexicographicCompareBy compare_byte (byte_list_of_byte_sequence s1) (byte_list_of_byte_sequence s2)).

Instance x19_Ord : Ord byte_sequence := { 
     compare  :=  compare_byte_sequence;
     isLess  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_byte_sequence f1 f2) LT)));
     isLessEqual  :=  fun  f1 => (fun  f2 => let result := compare_byte_sequence f1 f2 in (ordering_equal result LT) || (ordering_equal result EQ));
     isGreater  :=  fun  f1 => (fun  f2 => ( (ordering_equal (compare_byte_sequence f1 f2) GT)));
     isGreaterEqual  :=  fun  f1 => (fun  f2 => let result := compare_byte_sequence f1 f2 in (ordering_equal result GT) || (ordering_equal result EQ))
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition empty   : byte_sequence :=  Sequence [].
(* [?]: removed value specification. *)

Definition read_char  (b : byte_sequence )  : error ((elf_types_local.byte *byte_sequence ) % type):= 
  match ( (b)) with (( Sequence ts)) =>
    match ( ts) with | [] => fail0 "read_char: sequence is empty" | x::xs =>
      return0 (x, Sequence xs) end end.
(* [?]: removed value specification. *)

Program Fixpoint repeat  (count : nat ) (c : elf_types_local.byte )  : list (elf_types_local.byte ):= 
  match ( count) with 
    | 0 => []
    | S m => c::repeat m c
  end.
(* [?]: removed value specification. *)

Definition create  (count : nat ) (c : elf_types_local.byte )  : byte_sequence := 
  Sequence (repeat count c).
(* [?]: removed value specification. *)

Definition zeros  (m : nat )  : byte_sequence := 
  create m null_byte.
(* [?]: removed value specification. *)

Definition length0  (b : byte_sequence )  : nat := 
  match ( (b)) with (( Sequence ts)) =>  (List.length ts) end.

(* [?]: removed value specification. *)

Program Fixpoint concat1  (ts : list (byte_sequence ))  : byte_sequence := 
  match ( ts) with 
    | []                 => Sequence []
    |( (Sequence x)::xs) =>
      match ( concat1 xs) with 
        | Sequence tail1 => Sequence ( (@ List.app _)x tail1)
      end
  end.
(* [?]: removed value specification. *)

Definition zero_pad_to_length  (len : nat ) (bs : byte_sequence )  : byte_sequence :=  
  let curlen := length0 bs in 
    if nat_gteb curlen len then
      bs
    else
      concat1 [bs ; (zeros ( Coq.Init.Peano.minus len curlen))].
(* [?]: removed value specification. *)

Definition from_byte_lists  (ts : list (list (elf_types_local.byte )))  : byte_sequence := 
  Sequence (lem_list.concat ts).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition string_of_byte_sequence  (b : byte_sequence )  : string := 
  match ( (b)) with (( Sequence ts)) =>
    let cs := char_list_of_byte_list ts in string_from_char_list cs end.
(* [?]: removed value specification. *)

Program Fixpoint equal (left : byte_sequence ) (right : byte_sequence) {measure ((length0 left) + (length0 right))} : bool := 
  match ( (left, right)) with 
    | (Sequence [],  Sequence []) => true
    | (Sequence( x::xs),  Sequence( y::ys)) => classical_boolean_equivalence
        x y && equal (Sequence xs) (Sequence ys)
    | (_,  _) => false
  end.
Next Obligation.
  change (List.length xs + List.length ys < S (List.length xs) + S (List.length ys)).
  omega.
Qed.
Next Obligation.
  split. discriminate. discriminate.
Qed.
Next Obligation.
  split. discriminate. discriminate.
Qed.
(* [?]: removed value specification. *)

Program Fixpoint dropbytes  (count : nat ) (b : byte_sequence ) {measure (length0 b)} : error (byte_sequence ):= 
  match ( (count,b)) with ( count, ( Sequence ts)) =>
    if beq_nat count missing_pervasives.naturalZero then
      return0 (Sequence ts) else
      match ( ts) with | [] =>
        fail0
          "dropbytes: cannot drop more bytes than are contained in sequence"
        | x::xs => dropbytes ( Coq.Init.Peano.minus count ( 1)) (Sequence xs)
      end end.
(* [?]: removed value specification. *)

Definition takebytes_r_with_length  (count : nat ) (ts_length : nat ) (b : byte_sequence )  : error (byte_sequence ):= 
  match ( (count,ts_length,b)) with ( count,  ts_length, ( Sequence ts)) =>
    if nat_gteb ts_length ( count) then
      return0 (Sequence (list_take_with_accum count [] ts)) else
      fail0
        "takebytes: cannot take more bytes than are contained in sequence"
  end.
(* [?]: removed value specification. *)

Definition takebytes  (count : nat ) (b : byte_sequence )  : error (byte_sequence ):= 
  match ( (count,b)) with ( count, ( Sequence ts)) =>
    let result := takebytes_r_with_length (id count)
                    (missing_pervasives.length ts) (Sequence ts) in result
  end.
(* [?]: removed value specification. *)

Definition takebytes_with_length  (count : nat ) (ts_length : nat ) (b : byte_sequence )  : error (byte_sequence ):= 
  match ( (count,ts_length,b)) with ( count,  ts_length, ( Sequence ts)) =>
    let result := takebytes_r_with_length (id count) ts_length (Sequence ts) in
  (*let _ = Missing_pervasives.errs ("Succeeded\n") in *) result end.
(* [?]: removed value specification. *)

Definition read_2_bytes_le  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) => return0 ((b1, b0), bs2) end) end).
(* [?]: removed value specification. *)

Definition read_2_bytes_be  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) => return0 ((b0, b1), bs2) end) end).
(* [?]: removed value specification. *)

Definition read_4_bytes_le  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) =>
           read_char bs2 >>=
           (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
              match ( (p) ) with ( (b2,  bs3)) =>
                read_char bs3 >>=
                (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                   match ( (p) ) with ( (b3,  bs4)) =>
                     return0 ((b3, b2, b1, b0), bs4) end) end) end) end).
(* [?]: removed value specification. *)

Definition read_4_bytes_be  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) =>
           read_char bs2 >>=
           (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
              match ( (p) ) with ( (b2,  bs3)) =>
                read_char bs3 >>=
                (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                   match ( (p) ) with ( (b3,  bs4)) =>
                     return0 ((b0, b1, b2, b3), bs4) end) end) end) end).
(* [?]: removed value specification. *)

Definition read_8_bytes_le  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) =>
           read_char bs2 >>=
           (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
              match ( (p) ) with ( (b2,  bs3)) =>
                read_char bs3 >>=
                (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                   match ( (p) ) with ( (b3,  bs4)) =>
                     read_char bs4 >>=
                     (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                        match ( (p) ) with ( (b4,  bs5)) =>
                          read_char bs5 >>=
                          (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                             match ( (p) ) with ( (b5,  bs6)) =>
                               read_char bs6 >>=
                               (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                                  match ( (p) ) with ( (b6,  bs7)) =>
                                    read_char bs7 >>=
                                    (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                                       match ( (p) ) with ( (b7,  bs8)) =>
                                         return0
                                           ((b7, b6, b5, b4, b3, b2, b1, b0), bs8)
                                       end) end) end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition read_8_bytes_be  (bs0 : byte_sequence )  : error ((((elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte *elf_types_local.byte ) % type)*byte_sequence ) % type):= 
  read_char bs0 >>= (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
    match ( (p) ) with ( (b0,  bs1)) =>
      read_char bs1 >>=
      (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
         match ( (p) ) with ( (b1,  bs2)) =>
           read_char bs2 >>=
           (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
              match ( (p) ) with ( (b2,  bs3)) =>
                read_char bs3 >>=
                (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                   match ( (p) ) with ( (b3,  bs4)) =>
                     read_char bs4 >>=
                     (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                        match ( (p) ) with ( (b4,  bs5)) =>
                          read_char bs5 >>=
                          (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                             match ( (p) ) with ( (b5,  bs6)) =>
                               read_char bs6 >>=
                               (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                                  match ( (p) ) with ( (b6,  bs7)) =>
                                    read_char bs7 >>=
                                    (fun (p : (elf_types_local.byte *byte_sequence ) % type) =>
                                       match ( (p) ) with ( (b7,  bs8)) =>
                                         return0
                                           ((b0, b1, b2, b3, b4, b5, b6, b7), bs8)
                                       end) end) end) end) end) end) end) end).
(* [?]: removed value specification. *)

Definition partition1  (idx1 : nat ) (bs0 : byte_sequence )  : error ((byte_sequence *byte_sequence ) % type):= 
  takebytes idx1 bs0 >>= (fun (l : byte_sequence ) =>
  dropbytes idx1 bs0 >>= (fun (r : byte_sequence ) =>
  return0 (l, r))).
(* [?]: removed value specification. *)

Definition partition_with_length  (idx1 : nat ) (bs0_length : nat ) (bs0 : byte_sequence )  : error ((byte_sequence *byte_sequence ) % type):= 
  takebytes_with_length idx1 bs0_length bs0 >>= (fun (l : byte_sequence ) =>
  dropbytes idx1 bs0 >>= (fun (r : byte_sequence ) =>
  return0 (l, r))).
(* [?]: removed value specification. *)

Definition offset_and_cut  (off : nat ) (cut : nat ) (bs0 : byte_sequence )  : error (byte_sequence ):= 
  dropbytes off bs0 >>= (fun (bs1 : byte_sequence ) =>
  takebytes cut bs1 >>= (fun (res : byte_sequence ) =>
  return0 res)).
(* 

Instance x18_Show : Show byte_sequence := {
   show  :=  string_of_byte_sequence
}.
 *)

Instance x17_Eq : Eq byte_sequence := {
   isEqual  := equal;
   isInequal   l  r :=  negb (equal l r)
}.

