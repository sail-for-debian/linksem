(* Generated by Lem from gnu_extensions/gnu_ext_dynamic.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(** [gnu_ext_dynamic] contains GNU extension specific definitions related to the
  * .dynamic section of an ELF file.
  *)

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_bool.
Require Export lem_bool.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.


Require Import error.
Require Export error.

Require Import show.
Require Export show.

Require Import string_table.
Require Export string_table.


Require Import elf_dynamic.
Require Export elf_dynamic.

Require Import elf_types_native_uint.
Require Export elf_types_native_uint.


(** Additional dynamic entries, see LSB section 11.3.2.2.
  * All values taken from elf.c from binutils and GLIBC as the LSB does not
  * specify them.
  *
  *  98 #define OLD_DT_LOOS     0x60000000
  *  99 #define DT_LOOS         0x6000000d
  * 100 #define DT_HIOS         0x6ffff000
  * 101 #define DT_VALRNGLO     0x6ffffd00
  * 102 #define DT_VALRNGHI     0x6ffffdff
  * 103 #define DT_ADDRRNGLO    0x6ffffe00
  * 104 #define DT_ADDRRNGHI    0x6ffffeff
  * 105 #define DT_VERSYM       0x6ffffff0
  * 106 #define DT_RELACOUNT    0x6ffffff9
  * 107 #define DT_RELCOUNT     0x6ffffffa
  * 108 #define DT_FLAGS_1      0x6ffffffb
  * 109 #define DT_VERDEF       0x6ffffffc
  * 110 #define DT_VERDEFNUM    0x6ffffffd
  * 111 #define DT_VERNEED      0x6ffffffe
  * 112 #define DT_VERNEEDNUM   0x6fffffff
  * 113 #define OLD_DT_HIOS     0x6fffffff
  * 114 #define DT_LOPROC       0x70000000
  * 115 #define DT_HIPROC       0x7fffffff
  *)

Definition elf_dt_gnu_addrrnghi     :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523967)( 2))( 1).  (*0x6ffffeff*)
Definition elf_dt_gnu_addrrnglo     :  nat :=  Coq.Init.Peano.mult( 939523840)( 2).        (*0x6ffffe00*)
Definition elf_dt_gnu_auxiliary     :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 1073741822)( 2))( 1). (*0x7ffffffd*)
Definition elf_dt_gnu_filter        :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 1073741823)( 2))( 1). (*0x7fffffff*)
(** The following is "specified" in the LSB document but is not present in the
  * elf.c file so taken from elf.h from GLIBC:
  *)
Definition elf_dt_gnu_num           :  nat :=  32. (** ??? This should match something *)
Definition elf_dt_gnu_posflag_1     :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523838)( 2))( 1). (*0x6ffffdfd*)
Definition elf_dt_gnu_relcount      :  nat :=  Coq.Init.Peano.mult( 939524093)( 2).       (*0x6ffffffa*)
Definition elf_dt_gnu_relacount     :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939524092)( 2))( 1). (*0x6FFFFFF9*)
Definition elf_dt_gnu_syminent      :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523839)( 2))( 1). (*0x6ffffdff*)
Definition elf_dt_gnu_syminfo       :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523967)( 2))( 1). (*0x6ffffeff*)
Definition elf_dt_gnu_syminsz       :  nat :=  Coq.Init.Peano.mult( 939523839)( 2).       (*0x6ffffdfe*)
Definition elf_dt_gnu_valrnghi      :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523839)( 2))( 1). (*0x6ffffdff*)
Definition elf_dt_gnu_valrnglo      :  nat :=  ( Coq.Init.Peano.mult( 939523712)( 2)).     (*0x6ffffd00*)
Definition elf_dt_gnu_verdef        :  nat :=  Coq.Init.Peano.mult( 939524094)( 2).       (*0x6ffffffc*)
Definition elf_dt_gnu_verdefnum     :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939524094)( 2))( 1). (*0x6ffffffd*)
Definition elf_dt_gnu_verneed       :  nat :=  Coq.Init.Peano.mult( 939524095)( 2).       (*0x6ffffffe*)
Definition elf_dt_gnu_verneednum    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939524095)( 2))( 1). (*0x6fffffff*)
Definition elf_dt_gnu_versym        :  nat :=  Coq.Init.Peano.mult( 939524088)( 2).       (*0x6ffffff0*)

(** Not present in the LSB but turns up in "real" ELF files... *)

Definition elf_dt_gnu_hash         :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939523962)( 2))( 1). (*0x6ffffef5*)
Definition elf_dt_gnu_flags_1      :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 939524093)( 2))( 1). (*0x6ffffffb*)
Definition elf_dt_gnu_checksum     :  nat :=  ( Coq.Init.Peano.mult( 939523836)( 2)).     (* 0x6FFFFDF8 *)
Definition elf_dt_gnu_prelinked    :  nat :=  Coq.Init.Peano.plus ( Coq.Init.Peano.mult( 2)( 939523834))( 1). (* 0x6FFFFDF5 *)

(** Extended DT flags for FLAGS_1 dynamic section types.  Taken from GLibC source
  * as they appear to be completely unspecified!
  *)
  
Definition gnu_df_1_now           :  nat :=  1.     (*0x00000001*)
Definition gnu_df_1_global        :  nat :=  2.     (*0x00000002*)
Definition gnu_df_1_group         :  nat :=  4.     (*0x00000004*)
Definition gnu_df_1_nodelete      :  nat :=  8.     (*0x00000008*)
Definition gnu_df_1_loadfltr      :  nat :=  16.    (*0x00000010*)
Definition gnu_df_1_initfirst     :  nat :=  32.    (*0x00000020*)
Definition gnu_df_1_noopen        :  nat :=  64.    (*0x00000040*)
Definition gnu_df_1_origin        :  nat :=  128.   (*0x00000080*)
Definition gnu_df_1_direct        :  nat :=  256.   (*0x00000100*)
Definition gnu_df_1_trans         :  nat :=  512.   (*0x00000200*)
Definition gnu_df_1_interpose     :  nat :=  1024.  (*0x00000400*)
Definition gnu_df_1_nodeflib      :  nat :=  2048.  (*0x00000800*)
Definition gnu_df_1_nodump        :  nat :=  4096.  (*0x00001000*)
Definition gnu_df_1_confalt       :  nat :=  8192.  (*0x00002000*)
Definition gnu_df_1_endfiltee     :  nat :=  16384. (*0x00004000*)
Definition gnu_df_1_dispreldne    :  nat :=  32768. (*0x00008000*)
Definition gnu_df_1_disprelpnd    :  nat :=  65536.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition gnu_ext_os_additional_ranges  (m : nat )  : bool := 
  if nat_gteb m elf_dt_gnu_addrrnglo && nat_lteb m elf_dt_gnu_addrrnghi then
    true
  else beq_nat (* ad hoc extensions go here... *)
    m elf_dt_gnu_verneed || (beq_nat
    m elf_dt_gnu_verneednum || (beq_nat
    m elf_dt_gnu_versym || (beq_nat
    m elf_dt_gnu_verdef || (beq_nat
    m elf_dt_gnu_verdefnum || (beq_nat
    m elf_dt_gnu_flags_1 || (beq_nat
    m elf_dt_gnu_relcount || (beq_nat
    m elf_dt_gnu_relacount || (beq_nat
    m elf_dt_gnu_checksum || beq_nat
    m elf_dt_gnu_prelinked)))))))).
(* [?]: removed value specification. *)

Definition gnu_ext_tag_correspondence_of_tag0  (m : nat )  : error (tag_correspondence ):= 
  if beq_nat m elf_dt_gnu_hash then
    return0 C_Ptr
  else if beq_nat m elf_dt_gnu_flags_1 then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_versym then
    return0 C_Ptr
  else if beq_nat m elf_dt_gnu_verneednum then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_verneed then
    return0 C_Ptr
  else if beq_nat m elf_dt_gnu_verdef then
    return0 C_Ptr
  else if beq_nat m elf_dt_gnu_verdefnum then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_relcount then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_relacount then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_checksum then
    return0 C_Val
  else if beq_nat m elf_dt_gnu_prelinked then
    return0 C_Val
  else
    fail0 "gnu_ext_tag_correspondence_of_tag0: invalid dynamic tag".
(* [?]: removed value specification. *)

Definition gnu_ext_tag_correspondence_of_tag  (m : nat )  : error (tag_correspondence ):= 
  if nat_gteb m elf_dt_gnu_addrrnglo && nat_lteb m elf_dt_gnu_addrrnghi then
    return0 C_Ptr
  else if nat_gteb m elf_dt_gnu_valrnglo && nat_lteb m elf_dt_gnu_valrnghi then
    return0 C_Val
  else if gnu_ext_os_additional_ranges m then
    gnu_ext_tag_correspondence_of_tag0 m
  else if beq_nat m elf_dt_gnu_syminsz then
    return0 C_Val (** unsure *)
  else if beq_nat m elf_dt_gnu_syminfo then
    return0 C_Ptr (** unsure *)
  else if beq_nat m elf_dt_gnu_syminent then
    return0 C_Val (** unsure *)
  else if beq_nat m elf_dt_gnu_posflag_1 then
    return0 C_Val (** unsure *)
  else if beq_nat m elf_dt_gnu_num then
    return0 C_Ignored
  else if beq_nat m elf_dt_gnu_filter then
    return0 C_Val (** unsure *)
  else if beq_nat m elf_dt_gnu_auxiliary then
    return0 C_Val (** unsure *)
  else
    fail0 ("gnu_ext_tag_correspondence_of_tag: unrecognised GNU dynamic tag").
(* [?]: removed value specification. *)

Definition gnu_ext_elf32_value_of_elf32_dyn0  (dyn : elf32_dyn ) (stbl : string_table )  : error (dyn_value (elf32_addr ) (elf32_word )):= 
  let tag := Zabs_nat (int_of_elf32_sword(elf32_dyn_tag dyn)) in
    if beq_nat tag elf_dt_gnu_hash then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf32_value_of_elf32_dyn: GNU_HASH must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: GNU_HASH must be a PTR"
      end >>= (fun (addr : elf32_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_flags_1 then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: FLAGS_1 must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: FlAGS_1 must be a Val"
      end >>= (fun (f : elf32_word ) =>
      return0 (Flags1 (nat_of_elf32_word f)))
    else if beq_nat tag elf_dt_gnu_versym then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERSYM must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERSYM must be a PTR"
      end >>= (fun (addr : elf32_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_verdef then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERDEF must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERDEF must be a PTR"
      end >>= (fun (addr : elf32_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_verdefnum then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERDEFNUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERDEFNUM must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Numeric (nat_of_elf32_word sz)))
    else if beq_nat tag elf_dt_gnu_verneednum then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERNEEDNUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERNEEDNUM must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Numeric (nat_of_elf32_word sz)))
    else if beq_nat tag elf_dt_gnu_verneed then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERNEED must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: VERNEED must be a PTR"
      end >>= (fun (addr : elf32_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_relcount then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: RELCOUNT must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: RELCOUNT must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Numeric (nat_of_elf32_word sz)))
    else if beq_nat tag elf_dt_gnu_relacount then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: RELACOUNT must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: RELACOUNT must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Numeric (nat_of_elf32_word sz)))
    else if beq_nat tag elf_dt_gnu_checksum then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: CHECKSUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: CHECKSUM must be a Val"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Checksum (nat_of_elf32_word sz)))
    else if beq_nat tag elf_dt_gnu_prelinked then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: GNU_PRELINKED must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: GNU_PRELINKED must be a Val"
      end >>= (fun (off : elf32_word ) =>
      return0 (Timestamp (nat_of_elf32_word off)))
    else
      fail0 "gnu_ext_elf32_value_of_elf32_dyn0: unrecognised GNU dynamic tag".
(* [?]: removed value specification. *)

Definition gnu_ext_elf64_value_of_elf64_dyn0  (dyn : elf64_dyn ) (stbl : string_table )  : error (dyn_value (elf64_addr ) (elf64_xword )):= 
  let tag := Zabs_nat (int_of_elf64_sxword(elf64_dyn_tag dyn)) in
    if beq_nat tag elf_dt_gnu_hash then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf64_value_of_elf64_dyn: GNU_HASH must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: GNU_HASH must be a PTR"
      end >>= (fun (addr : elf64_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_flags_1 then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: FLAGS_1 must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: FlAGS_1 must be a Val"
      end >>= (fun (f : elf64_xword ) =>
      return0 (Flags1 (nat_of_elf64_xword f)))
    else if beq_nat tag elf_dt_gnu_versym then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERSYM must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERSYM must be a PTR"
      end >>= (fun (addr : elf64_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_verdef then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERDEF must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERDEF must be a PTR"
      end >>= (fun (addr : elf64_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_verdefnum then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf64_dyn: VERDEFNUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf64_dyn: VERDEFNUM must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Numeric (nat_of_elf64_xword sz)))
    else if beq_nat tag elf_dt_gnu_verneednum then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERNEEDNUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERNEEDNUM must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Numeric (nat_of_elf64_xword sz)))
    else if beq_nat tag elf_dt_gnu_verneed then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERNEED must be a PTR"
        | D_Ptr     p => return0 p
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: VERNEED must be a PTR"
      end >>= (fun (addr : elf64_addr ) =>
      return0 (Address addr))
    else if beq_nat tag elf_dt_gnu_relcount then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: RELCOUNT must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: RELCOUNT must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Numeric (nat_of_elf64_xword sz)))
    else if beq_nat tag elf_dt_gnu_relacount then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: RELACOUNT must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: RELACOUNT must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Numeric (nat_of_elf64_xword sz)))
    else if beq_nat tag elf_dt_gnu_checksum then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: CHECKSUM must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: CHECKSUM must be a Val"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Checksum (nat_of_elf64_xword sz)))
    else if beq_nat tag elf_dt_gnu_prelinked then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: GNU_PRELINKED must be a Val"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: GNU_PRELINKED must be a Val"
      end >>= (fun (off : elf64_xword ) =>
      return0 (Timestamp (nat_of_elf64_xword off)))
    else
      fail0 "gnu_ext_elf64_value_of_elf64_dyn0: unrecognised GNU dynamic tag".
(* [?]: removed value specification. *)

Definition gnu_ext_elf32_value_of_elf32_dyn  (dyn : elf32_dyn ) (stbl : string_table )  : error (elf32_dyn_value ):= 
  let tag := Zabs_nat (int_of_elf32_sword(elf32_dyn_tag dyn)) in
    if gnu_ext_os_additional_ranges tag then (* this should cover valrngs and addrrngs *)
      gnu_ext_elf32_value_of_elf32_dyn0 dyn stbl
    else if beq_nat tag elf_dt_gnu_syminsz then
      match ((elf32_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf32_value_of_elf32_dyn: SYMINSZ must be a VAL"
        | D_Ignored i => fail0 "gnu_ext_elf32_value_of_elf32_dyn: SYMINSZ must be a VAL"
      end >>= (fun (sz : elf32_word ) =>
      return0 (Size sz))
    else if beq_nat tag elf_dt_gnu_syminfo then
      fail0 "SYMINFO" (* XXX: never seen in 32-bit ELF *)
    else if beq_nat tag elf_dt_gnu_syminent then
      fail0 "SYMINENT" (* XXX: never seen in 32-bit ELF *)
    else if beq_nat tag elf_dt_gnu_posflag_1 then
      fail0 "POSFLAG_1" (* XXX: never seen in 32-bit ELF *)
    else if beq_nat tag elf_dt_gnu_num then
      fail0 "NUM" (* XXX: never seen in 32-bit ELF *)
    else if beq_nat tag elf_dt_gnu_filter then
      fail0 "FILTER" (* XXX: never seen in 32-bit ELF *)
    else if beq_nat tag elf_dt_gnu_auxiliary then
      fail0 "AUXILIARY" (* XXX: never seen in 32-bit ELF *)
    else
      fail0 "gnu_ext_elf32_value_of_elf32_dyn: unrecognised GNU dynamic tag".
(* [?]: removed value specification. *)

Definition gnu_ext_elf64_value_of_elf64_dyn  (dyn : elf64_dyn ) (stbl : string_table )  : error (elf64_dyn_value ):= 
  let tag := Zabs_nat (int_of_elf64_sxword(elf64_dyn_tag dyn)) in
    if gnu_ext_os_additional_ranges tag then (* this should cover valrngs and addrrngs *)
      gnu_ext_elf64_value_of_elf64_dyn0 dyn stbl
    else if beq_nat tag elf_dt_gnu_syminsz then
      match ((elf64_dyn_d_un dyn)) with 
        | D_Val     v => return0 v
        | D_Ptr     p => fail0 "gnu_ext_elf64_value_of_elf64_dyn: SYMINSZ must be a VAL"
        | D_Ignored i => fail0 "gnu_ext_elf64_value_of_elf64_dyn: SYMINSZ must be a VAL"
      end >>= (fun (sz : elf64_xword ) =>
      return0 (Size sz))
    else if beq_nat tag elf_dt_gnu_syminfo then
      fail0 "SYMINFO" (* XXX: fill in as seen *)
    else if beq_nat tag elf_dt_gnu_syminent then
      fail0 "SYMINENT" (* XXX: fill in as seen *)
    else if beq_nat tag elf_dt_gnu_posflag_1 then
      fail0 "POSFLAG_1" (* XXX: fill in as seen *)
    else if beq_nat tag elf_dt_gnu_num then
      fail0 "NUM" (* XXX: fill in as seen *)
    else if beq_nat tag elf_dt_gnu_filter then
      fail0 "FILTER" (* XXX: fill in as seen *)
    else if beq_nat tag elf_dt_gnu_auxiliary then
      fail0 "AUXILIARY" (* XXX: fill in as seen *)
    else
      fail0 "gnu_ext_elf64_value_of_elf64_dyn: unrecognised GNU dynamic tag".
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

