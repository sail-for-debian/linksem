chapter {* Generated by Lem from archive.lem. *}

theory "Archive" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)
(*open import Show*)
(*open import Assert_extra*)

(*open import Missing_pervasives*)
(*open import Byte_sequence*)
(*open import Error*)

record archive_entry_header =
  
 name      ::" string "
   
 timestamp ::" nat "
   
 uid       ::" nat "
   
 gid       ::" nat "
   
 mode      ::" nat "
   
 size0      ::" nat " (* 1GB should be enough *)
   


type_synonym archive_global_header =" char
  list "

(*val string_of_byte_sequence : byte_sequence -> string*)
fun string_of_byte_sequence0  :: " byte_sequence \<Rightarrow> string "  where 
     " string_of_byte_sequence0 (Sequence bs) = ( (List.map Elf_Types_Local.char_of_unsigned_char bs))" 
declare string_of_byte_sequence0.simps [simp del]


(*val read_archive_entry_header : natural -> byte_sequence -> error (archive_entry_header * natural * byte_sequence)*)
definition read_archive_entry_header  :: " nat \<Rightarrow> byte_sequence \<Rightarrow>(archive_entry_header*nat*byte_sequence)error "  where 
     " read_archive_entry_header seq_length seq = (
  (let magic_bytes = ([(of_nat (( 96 :: nat)) :: byte) (* 0x60 *), (of_nat (( 10 :: nat)) :: byte) (* 0x0a *)]) in
        (let header_length =(( 60 :: nat)) in
        (* let _ = Missing_pervasives.errs (Archive entry header?  ^ (show (take 16 bs)) ^ ? ) in *)
        partition_with_length header_length seq_length seq >>= (\<lambda> (header1, rest) .  
        offset_and_cut(( 58 :: nat))(( 2 :: nat)) header1 >>= (\<lambda> magic .  
        offset_and_cut(( 0 :: nat))(( 16 :: nat)) header1 >>= (\<lambda> name1 .  
        offset_and_cut(( 16 :: nat))(( 12 :: nat)) header1 >>= (\<lambda> timestamp_str .  
        offset_and_cut(( 28 :: nat))(( 6 :: nat))  header1 >>= (\<lambda> uid_str .  
        offset_and_cut(( 34 :: nat))(( 6 :: nat))  header1 >>= (\<lambda> gid_str .  
        offset_and_cut(( 40 :: nat))(( 8 :: nat))  header1 >>= (\<lambda> mode_str .  
        offset_and_cut(( 48 :: nat))(( 10 :: nat)) header1 >>= (\<lambda> size_str .  
        (let size3 = (natural_of_decimal_string (string_of_byte_sequence0 size_str)) in 
                (* let _ = Missing_pervasives.errln (: yes, size  ^ (show size)) in *)
        error_return ((| name = (string_of_byte_sequence0 name1), timestamp = ((( 0 :: nat) :: nat)) (* FIXME *),
          uid =(( 0 :: nat)) (* FIXME *) , gid =(( 0 :: nat)) (* FIXME *) , mode =(( 0 :: nat)) (* FIXME *),
            size0 = ( size3) (* FIXME *) |), (seq_length - header_length), rest)))))))))))))"


(*val read_archive_global_header : byte_sequence -> error (archive_global_header * byte_sequence)*)
fun read_archive_global_header  :: " byte_sequence \<Rightarrow>((char)list*byte_sequence)error "  where 
     " read_archive_global_header (Sequence bs) = (
            (* let _ = Missing_pervasives.errs (Archive?  ^ (show (take 16 bs)) ^ ? )
            in*)
      (let chars = (List.map Elf_Types_Local.char_of_unsigned_char (take(( 8 :: nat)) bs)) in 
        if  chars = ([(CHR ''!''), (CHR ''<''), (CHR ''a''), (CHR ''r''), (CHR ''c''), (CHR ''h''), (CHR ''>''), (Char Nibble0 NibbleA)]) then
          (* let _ = Missing_pervasives.errln : yes in *)
          error_return (chars, Sequence(drop(( 8 :: nat)) bs))
        else
          (* let _ = Missing_pervasives.errln : no in *)
          error_fail (''read_archive_global_header: not an archive'')))" 
declare read_archive_global_header.simps [simp del]


(*val accum_archive_contents : (list (string * byte_sequence)) -> maybe string -> natural -> byte_sequence -> error (list (string * byte_sequence))*)
function (sequential,domintros)  accum_archive_contents  :: "(string*byte_sequence)list \<Rightarrow>(string)option \<Rightarrow> nat \<Rightarrow> byte_sequence \<Rightarrow>((string*byte_sequence)list)error "  where 
     " accum_archive_contents accum extended_filenames whole_seq_length whole_seq = ( 
  (* let _ = Missing_pervasives.errs Can read a header?  in *)
  if \<not> ((Byte_sequence.length0 whole_seq) = whole_seq_length) then
    Lem_assert_extra.fail (* invariant: whole_seq_length always equal to length of whole_seq, so the length is only
      computed one.  This fail needed for Isabelle termination proofs... *)
  else
  (case  (read_archive_entry_header whole_seq_length whole_seq) of
      Fail _ => error_return accum
    | Success (hdr, (seq_length :: nat), seq) =>
    (case  seq of
        Sequence next_bs =>
        (* let _ = Missing_pervasives.errln (yes; next_bs has length  ^ (show (List.length next_bs))) in *)
        (let amount_to_drop =          
(if ((size0   hdr) mod( 2 :: nat)) =( 0 :: nat) then
            ((size0   hdr))
          else
            ((size0   hdr)) +( 1 :: nat))
        in
        if amount_to_drop =( 0 :: nat) then
          error_fail (''accum_archive_contents: amount to drop from byte sequence is 0'')
        else
        (*let _ = Missing_pervasives.errln (amount_to_drop is  ^ (show amount_to_drop)) in*)
        (let chunk = (Sequence(List.take(size0   hdr) next_bs))
        in
        (*let _ = Missing_pervasives.errs (Processing archive header named  ^ hdr.name)
        in*)
        (let (new_accum, (new_extended_filenames ::  string option)) =          
((let name1 = ((name   hdr)) in
            if name1 = [(CHR ''/''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' '')] then
              (* SystemV symbol lookup table; we skip this *) (accum, extended_filenames)
            else
              (case  name1 of
                  x # xs =>
                  if x = (CHR ''/'') then
                    (case  xs of
                        y # ys =>
                        if y = (CHR ''/'') then
                          (accum, Some (string_of_byte_sequence0 chunk))
                        else
                          (let index1 = (natural_of_decimal_string ( xs)) in
                            (case  extended_filenames of 
                                None => failwith (''corrupt archive: reference to non-existent extended filenames'')
                              | Some s => 
                                (let table_suffix = ((case  Elf_Types_Local.string_suffix index1 s of Some x => x | None => ('''') )) in
                                (let index1 = ((case  string_index_of (CHR ''/'') table_suffix of Some x => x | None => ( (List.length table_suffix)) )) in 
                                (let ext_name = ((case  string_prefix index1 table_suffix of Some x => x | None => ('''') )) in
                                  (*let _ = Missing_pervasives.errln (Got ext_name  ^ ext_name) in*)
                                  (((ext_name, chunk) # accum), extended_filenames))))
                           ))
                      | [] =>
                        (let index1 = (natural_of_decimal_string ( xs)) in
                          (case  extended_filenames of 
                              None => failwith (''corrupt archive: reference to non-existent extended filenames'')
                            | Some s => 
                              (let table_suffix = ((case  Elf_Types_Local.string_suffix index1 s of Some x => x | None => ('''') )) in
                              (let index1 = ((case  string_index_of (CHR ''/'') table_suffix of Some x => x | None => ( (List.length table_suffix)) )) in 
                              (let ext_name = ((case  string_prefix index1 table_suffix of Some x => x | None => ('''') )) in
                                (*let _ = Missing_pervasives.errln (Got ext_name  ^ ext_name) in*)
                                (((ext_name, chunk) # accum), extended_filenames))))
                         ))
                    )
                  else
                    ((((name   hdr), chunk) # accum), extended_filenames)
                | [] => ((((name   hdr), chunk) # accum), extended_filenames)
              )))
        in
          (case  (Byte_sequence.dropbytes amount_to_drop seq) of
              Fail _ => error_return accum
            | Success new_seq =>
              accum_archive_contents new_accum new_extended_filenames (seq_length - amount_to_drop) new_seq
          ))))
    )
  ))" 
by pat_completeness auto


(*val read_archive : byte_sequence -> error (list (string * byte_sequence))*)
definition read_archive  :: " byte_sequence \<Rightarrow>((string*byte_sequence)list)error "  where 
     " read_archive bs = ( 
    read_archive_global_header bs >>= (\<lambda> (hdr, seq) .  
    (let result = (accum_archive_contents [] None (Byte_sequence.length0 seq) seq)  in 
    (* let _ = Missing_pervasives.errln Finished reading archive in *)
    (case  result of
        Success r => Success (List.rev r)
        | Fail x => Fail x
    ))))"

end
