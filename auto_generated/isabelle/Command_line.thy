chapter {* Generated by Lem from command_line.lem. *}

theory "Command_line" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string_extra" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set_extra" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Default_printing" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list_extra" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import String_extra*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import List_extra*)
(*import Set*)
(*import Set_extra*)
(*open import Sorting*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)

(*open import Byte_sequence*)
(*open import Default_printing*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(* Here we try to model the command line of GNU ld.bfd.
 * 
 * Some options are global modifiers affecting the link output. 
 * Others have effect only for some subset of input files.
 * Typically some mutually-exclusive possibilities exist
 * whereby each argument selects one such possibility for all subsequent input files, 
 * until a different argument selects another possibility for ensuring inputs.
 *)

datatype input_file_spec = Filename " string "    (* /path/to/file.{o,a,so,...} -- might be script! *)
                     | Libname " string "     (* -llib *)

(*val string_of_input_file_spec : input_file_spec -> string*)
fun string_of_input_file_spec  :: " input_file_spec \<Rightarrow> string "  where 
     " string_of_input_file_spec (Filename(s)) = ( ([(CHR ''f''), (CHR ''i''), (CHR ''l''), (CHR ''e''), (CHR '' ''), (Char Nibble6 Nibble0)]) @ (s @ ([(Char Nibble2 Nibble7)])))"
|" string_of_input_file_spec (Libname(s)) = ( ([(CHR ''l''), (CHR ''i''), (CHR ''b''), (CHR ''r''), (CHR ''a''), (CHR ''r''), (CHR ''y''), (CHR '' ''), (Char Nibble6 Nibble0)]) @ (s @ ([(Char Nibble2 Nibble7)])))" 
declare string_of_input_file_spec.simps [simp del]


definition instance_Show_Show_Command_line_input_file_spec_dict  :: "(input_file_spec)Show_class "  where 
     " instance_Show_Show_Command_line_input_file_spec_dict = ((|

  show_method = string_of_input_file_spec |) )"


record input_file_options = 
 input_fmt ::" string "
                           
 input_libpath ::" string list "
                           
 input_link_sharedlibs ::" bool "      (* -Bstatic *)
                           
 input_check_sections ::" bool "
                           
 input_copy_dt_needed ::" bool "
                           
 input_whole_archive ::" bool "
                           
 input_as_needed ::" bool "
                           

   
(*val null_input_file_options : input_file_options*)
definition null_input_file_options  :: " input_file_options "  where 
     " null_input_file_options = ( 
                      (| input_fmt = ('''')
                       , input_libpath = ([])
                       , input_link_sharedlibs = False
                       , input_check_sections = False
                       , input_copy_dt_needed = False
                       , input_whole_archive = False
                       , input_as_needed = False
                       |) )"


datatype output_kind = Executable
                 | SharedLibrary

datatype link_option = OutputFilename " string "
                 | OutputKind " output_kind "
                 | ForceCommonDefined " bool "        (* -d, -dc, -dp *)
                 | Soname " string "                  (* -soname *)
                 | EntryAddress " nat "
                 | TextSegmentStart " nat "
                 | RodataSegmentStart " nat "
                 | LdataSegmentStart " nat "
                 | BindFunctionsEarly                (* -Bsymbolic-functions *)
                 | BindNonFunctionsEarly              (* the remainder of -Bsymbolic *)
                 (* more here! *) 

(*val tagEqual : link_option -> link_option -> bool*)
definition tagEqual  :: " link_option \<Rightarrow> link_option \<Rightarrow> bool "  where 
     " tagEqual opt1 opt2 = ( (case  (opt1, opt2) of
    (* FIXME: Lem BUG here! says duplicate binding *)
    (OutputFilename(_), OutputFilename(_)) => True
    | (OutputKind(_), OutputKind(_)) => True
    (* | (ForceCommonDefined, ForceCommonDefined) -> true *)
    | (Soname(_), Soname(_)) => True
    (* | (EntryAddress, EntryAddress) -> true *)
    | (TextSegmentStart(_), TextSegmentStart(_)) => True
    | (RodataSegmentStart(_), RodataSegmentStart(_)) => True
    | (LdataSegmentStart(_), LdataSegmentStart(_)) => True
    (* | (BindFunctionsEarly, BindFunctionsEarly) -> true *)
    (* | (BindNonFunctionsEarly, BindNonFunctionsEarly) -> true *)
    | _ => False
))"


type_synonym input_file_and_options =" input_file_spec * input_file_options "
datatype input_unit = File " input_file_and_options "
                | Group " (input_file_and_options) list "   (* NOT recursive *)
                | BuiltinControlScript (* for uniformity when processing script defs *)

(*val string_of_input_unit : input_unit -> string*)
fun string_of_input_unit  :: " input_unit \<Rightarrow> string "  where 
     " string_of_input_unit (File(spec, opts)) = ( 
            (''single '') @ (string_of_input_file_spec spec))"
|" string_of_input_unit (Group(spec_opt_list)) = ( 
            (''group: ['') @ ((string_of_list 
  instance_Show_Show_Command_line_input_file_spec_dict (List.map (\<lambda> (spec, opts) .  spec) spec_opt_list)) @ ('']'')))"
|" string_of_input_unit BuiltinControlScript = ( (''(built-in control script)''))" 
declare string_of_input_unit.simps [simp del]


definition instance_Show_Show_Command_line_input_unit_dict  :: "(input_unit)Show_class "  where 
     " instance_Show_Show_Command_line_input_unit_dict = ((|

  show_method = string_of_input_unit |) )"


(* Reading the command-line: 
 * we encode the meaning of a linker command token 
 * using a reader function interpreting a list of argument definitions.
 * Lookahead is necessary: sometimes the interpretation of an option
 * depends on the next argument (e.g. whether it's a file, directory or another option).
 * The list of argument definitions is from lists of strings to constructor function invocations.
 * We use lists of strings since many options have synonyms.
 * The strings are interpreted as regular expressions and any matched groups are collected together
 * as a second argument list; this is because some arguments are of the form --blah=NUM or similar. *)
 
(* As we read the command line, we keep a current state which is the collection
 * of seen input files, seen whole-link options, and input file options that will
 * apply to any input files we add subsequently. *)
record command_state = 
 input_units           ::" input_unit list "
                      
 link_options          ::"  link_option set "
                      
 current_input_options ::" input_file_options "
                      
 current_group         ::"  ( input_file_and_options list)option "
                      

                      
(* This is the default state when we start reading input options *)
(*val initial_state : list command_state*) (* the stack *)
definition initial_state  :: "(command_state)list "  where 
     " initial_state = ( [(| input_units = ([])
                     , link_options = ({OutputFilename((''a.out'')), OutputKind(Executable)})
                     , current_input_options = ((| input_fmt = (''elf64-x86-64'')   (* FIXME *)
                                                , input_libpath = ([(''/usr/lib'')]) (* FIXME: this probably isn't the right place to supply the default search path *)
                                                , input_link_sharedlibs = True
                                                , input_check_sections = True
                                                , input_copy_dt_needed = False
                                                , input_whole_archive = False
                                                , input_as_needed = True (* FIXME *)
                                                |))
                     , current_group = None
                     |)])"


type_synonym interpreted_command_line =" input_unit list * link_option set "

(*val add_input_file : list command_state -> string -> list command_state*)
fun add_input_file  :: "(command_state)list \<Rightarrow> string \<Rightarrow>(command_state)list "  where 
     " add_input_file (state # more1) s = ( 
    (let chars = ( s) 
    in
    (let spec = ((case  chars of 
        (CHR ''-'') # (CHR ''l'') # more1 => Libname( more1)
        | (CHR ''-'') # more1 => failwith ((''not a valid option or input file: '') @ s)
        | _ => Filename(s)
    ))
    in
    if(current_group   state) = None 
    then
        (| input_units = ((input_units   state) @ [File(spec,(current_input_options   state))])
         , link_options = ((link_options   state))
         , current_input_options = ((current_input_options   state))
         , current_group = ((current_group   state))
         |) # more1
    else 
        (| input_units = ((input_units   state))
         , link_options = ((link_options   state))
         , current_input_options = ((current_input_options   state))
         , current_group = ((let toAppend = ([(spec,(current_input_options   state))]) in 
            (case (current_group   state) of Some l => Some(l @ toAppend) | None => Some(toAppend) 
            )))
         |) # more1)))" 
declare add_input_file.simps [simp del]


(*val start_group : list command_state -> list command_state*)
fun start_group  :: "(command_state)list \<Rightarrow>(command_state)list "  where 
     " start_group (state # more1) = ( (|
           input_units = ((input_units   state))
         , link_options = ((link_options   state))
         , current_input_options = ((current_input_options   state))
         , current_group = ((case (current_group   state) of
                None => Some []
                | _ => failwith (''cannot nest groups'')
            ))
         |) # more1 )" 
declare start_group.simps [simp del]


(*val end_group : list command_state -> list command_state*)
fun end_group  :: "(command_state)list \<Rightarrow>(command_state)list "  where 
     " end_group (state # more1) = ( (|
           input_units = ((input_units   state) @ ((case (current_group   state) of 
                Some l => [Group(l)]
                | None => failwith (''end group without start group'')
            )))
         , link_options = ((link_options   state))
         , current_input_options = ((current_input_options   state))
         , current_group = None
         |) # more1 )" 
declare end_group.simps [simp del]


type_synonym option_token =" string "
type_synonym option_argspecs =" string list * string list "
type_synonym option_argvals =" string list * string list "

(*val set_or_replace_option : link_option -> list command_state -> list command_state*)
fun set_or_replace_option  :: " link_option \<Rightarrow>(command_state)list \<Rightarrow>(command_state)list "  where 
     " set_or_replace_option opt ([]) = ( failwith (''error: no state''))"
|" set_or_replace_option opt (state # more1) = ( 
            (| input_units = ((input_units   state))
             , link_options = (Set.insert opt (set_filter (\<lambda> existing .  ((\<lambda> opt1 .  (\<lambda> opt2 .  \<not> (opt1 = opt2))) existing opt))(link_options   state)))
             , current_input_options = ((current_input_options   state))
             , current_group = ((current_group   state))
             |) # more1 )" 
declare set_or_replace_option.simps [simp del]


(*val find_option_matching_tag : link_option -> set link_option -> maybe link_option*)
fun  find_option_matching_tag  :: " link_option \<Rightarrow>(link_option)set \<Rightarrow>(link_option)option "  where 
     " find_option_matching_tag tag options = ( 
    List.find (tagEqual tag) (list_of_set options))" 
declare find_option_matching_tag.simps [simp del]


(*val extract_hex_addend : char -> maybe natural*)
definition extract_hex_addend  :: " char \<Rightarrow>(nat)option "  where 
     " extract_hex_addend x = (
  if x = (CHR ''0'') then
    Some(( 0 :: nat))
  else if x = (CHR ''1'') then
    Some(( 1 :: nat))
  else if x = (CHR ''2'') then
    Some(( 2 :: nat))
  else if x = (CHR ''3'') then
    Some(( 3 :: nat))
  else if x = (CHR ''4'') then
    Some(( 4 :: nat))
  else if x = (CHR ''5'') then
    Some(( 5 :: nat))
  else if x = (CHR ''6'') then
    Some(( 6 :: nat))
  else if x = (CHR ''7'') then
    Some(( 7 :: nat))
  else if x = (CHR ''8'') then
    Some(( 8 :: nat))
  else if x = (CHR ''9'') then
    Some(( 9 :: nat))
  else if x = (CHR ''a'') then
    Some(( 10 :: nat))
  else if x = (CHR ''b'') then
    Some(( 11 :: nat))
  else if x = (CHR ''c'') then
    Some(( 12 :: nat))
  else if x = (CHR ''d'') then
    Some(( 13 :: nat))
  else if x = (CHR ''e'') then
    Some(( 14 :: nat))
  else if x = (CHR ''f'') then
    Some(( 15 :: nat))
  else
    None )"


(*val accumulate_hex_chars : natural -> list char -> natural*)
function (sequential,domintros)  accumulate_hex_chars  :: " nat \<Rightarrow>(char)list \<Rightarrow> nat "  where 
     " accumulate_hex_chars acc1 ([]) = ( acc1 )"
|" accumulate_hex_chars acc1 (x # xs) = (
      (case  extract_hex_addend x of
          None     => acc1
        | Some addend =>
            accumulate_hex_chars ((acc1 *( 16 :: nat)) + addend) xs
      ))" 
by pat_completeness auto


(*val extract_dec_addend : char -> maybe natural*)
definition extract_dec_addend  :: " char \<Rightarrow>(nat)option "  where 
     " extract_dec_addend x = (
  if x = (CHR ''0'') then
    Some(( 0 :: nat))
  else if x = (CHR ''1'') then
    Some(( 1 :: nat))
  else if x = (CHR ''2'') then
    Some(( 2 :: nat))
  else if x = (CHR ''3'') then
    Some(( 3 :: nat))
  else if x = (CHR ''4'') then
    Some(( 4 :: nat))
  else if x = (CHR ''5'') then
    Some(( 5 :: nat))
  else if x = (CHR ''6'') then
    Some(( 6 :: nat))
  else if x = (CHR ''7'') then
    Some(( 7 :: nat))
  else if x = (CHR ''8'') then
    Some(( 8 :: nat))
  else if x = (CHR ''9'') then
    Some(( 9 :: nat))
  else
    None )"


(*val accumulate_dec_chars : natural -> list char -> natural*)
fun  accumulate_dec_chars  :: " nat \<Rightarrow>(char)list \<Rightarrow> nat "  where 
     " accumulate_dec_chars acc1 ([]) = ( acc1 )"
|" accumulate_dec_chars acc1 (x # xs) = (
      (case  extract_dec_addend x of
          None     => acc1
        | Some addend =>
            accumulate_hex_chars ((acc1 *( 16 :: nat)) + addend) xs
      ))" 
declare accumulate_dec_chars.simps [simp del]


(*val parse_address : string -> natural*)
definition parse_address  :: " string \<Rightarrow> nat "  where 
     " parse_address s = ( (case   s of
    (CHR ''0'') # (CHR ''x'') # more1 => accumulate_hex_chars(( 0 :: nat)) more1
    | chars => accumulate_dec_chars(( 0 :: nat)) chars
))"


type_synonym option_def =" ( option_token list) * option_argspecs * (option_argvals \<Rightarrow> command_state list \<Rightarrow> command_state list) * string "

(* the table is a list of: ... options    and their arg names ... and the option's meaning as a function... and a help string *)
(*val command_line_table : list option_def*)
definition command_line_table  :: "((string)list*((string)list*(string)list)*((string)list*(string)list \<Rightarrow>(command_state)list \<Rightarrow>(command_state)list)*string)list "  where 
     " command_line_table = ( [
  (* per-input options *) 
  ([(''-b''), (''--format'')],                            ([(''TARGET'')], []),    (\<lambda> args .  (\<lambda> state .  state)), (''Specify target for following input files'')),
  ([(''-L''), (''--library-path'')],                      ([(''DIRECTORY'')], []), (\<lambda> args .  (\<lambda> state .  state)), (''Add DIRECTORY to library search path'')),
  ([(''--as-needed'')],                               ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Only set DT_NEEDED for following dynamic libs if used'')),
  ([(''--no-as-needed'')],                            ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Always set DT_NEEDED for dynamic libraries mentioned on the command line'')),
  ([(''-Bdynamic''), (''-dy''), (''-call_shared'')],          ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Link against shared libraries'')),
  ([(''-Bstatic''), (''-dn''), (''-non_shared''), (''-static'')], ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Do not link against shared libraries'')),
  ([(''--check-sections'')],                          ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), ([(CHR ''C''), (CHR ''h''), (CHR ''e''), (CHR ''c''), (CHR ''k''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR '' ''), (CHR ''a''), (CHR ''d''), (CHR ''d''), (CHR ''r''), (CHR ''e''), (CHR ''s''), (CHR ''s''), (CHR ''e''), (CHR ''s''), (CHR '' ''), (CHR ''f''), (CHR ''o''), (CHR ''r''), (CHR '' ''), (CHR ''o''), (CHR ''v''), (CHR ''e''), (CHR ''r''), (CHR ''l''), (CHR ''a''), (CHR ''p''), (CHR ''s''), (CHR '' ''), (CHR ''(''), (CHR ''d''), (CHR ''e''), (CHR ''f''), (CHR ''a''), (CHR ''u''), (CHR ''l''), (CHR ''t''), (CHR '')''), (CHR '' ''), (CHR '' ''), (CHR ''*''), (CHR ''*''), (CHR ''s''), (CHR ''r''), (CHR ''k''), (CHR ''*''), (CHR ''*''), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''s''), (CHR ''u''), (CHR ''r''), (CHR ''e''), (CHR '' ''), (CHR ''i''), (CHR ''t''), (Char Nibble2 Nibble7), (CHR ''s''), (CHR '' ''), (CHR ''p''), (CHR ''e''), (CHR ''r''), (CHR ''-''), (CHR ''i''), (CHR ''n''), (CHR ''p''), (CHR ''u''), (CHR ''t''), (CHR ''!'')])),
  ([(''--no-check-sections'')],                       ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''c''), (CHR ''h''), (CHR ''e''), (CHR ''c''), (CHR ''k''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR '' ''), (CHR ''a''), (CHR ''d''), (CHR ''d''), (CHR ''r''), (CHR ''e''), (CHR ''s''), (CHR ''s''), (CHR ''e''), (CHR ''s''), (CHR '' ''), (CHR ''f''), (CHR ''o''), (CHR ''r''), (CHR '' ''), (CHR ''o''), (CHR ''v''), (CHR ''e''), (CHR ''r''), (CHR ''l''), (CHR ''a''), (CHR ''p''), (CHR ''s''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR ''*''), (CHR ''*''), (CHR ''s''), (CHR ''r''), (CHR ''k''), (CHR ''*''), (CHR ''*''), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''s''), (CHR ''u''), (CHR ''r''), (CHR ''e''), (CHR '' ''), (CHR ''i''), (CHR ''t''), (Char Nibble2 Nibble7), (CHR ''s''), (CHR '' ''), (CHR ''p''), (CHR ''e''), (CHR ''r''), (CHR ''-''), (CHR ''i''), (CHR ''n''), (CHR ''p''), (CHR ''u''), (CHR ''t''), (CHR ''!'')])),
  ([(''--copy-dt-needed-entries'')],                  ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Copy DT_NEEDED links mentioned inside DSOs that follow'')),
  ([(''--no-copy-dt-needed-entries'')],               ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Do not copy DT_NEEDED links mentioned inside DSOs that follow'')),
  ([(''--no-whole-archive'')],                        ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Turn off --whole-archive'')),
  ([(''-rpath-link'')],                               ([(''PATH'')], []),      (\<lambda> _    .  (\<lambda> state .  state)), ([(CHR ''S''), (CHR ''e''), (CHR ''t''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''n''), (CHR ''k''), (CHR '' ''), (CHR ''t''), (CHR ''i''), (CHR ''m''), (CHR ''e''), (CHR '' ''), (CHR ''s''), (CHR ''h''), (CHR ''a''), (CHR ''r''), (CHR ''e''), (CHR ''d''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''b''), (CHR ''r''), (CHR ''a''), (CHR ''r''), (CHR ''y''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''a''), (CHR ''r''), (CHR ''c''), (CHR ''h''), (CHR '' ''), (CHR ''p''), (CHR ''a''), (CHR ''t''), (CHR ''h''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR ''*''), (CHR ''*''), (CHR ''s''), (CHR ''r''), (CHR ''k''), (CHR ''*''), (CHR ''*''), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''s''), (CHR ''u''), (CHR ''r''), (CHR ''e''), (CHR '' ''), (CHR ''i''), (CHR ''t''), (Char Nibble2 Nibble7), (CHR ''s''), (CHR '' ''), (CHR ''p''), (CHR ''e''), (CHR ''r''), (CHR ''-''), (CHR ''i''), (CHR ''n''), (CHR ''p''), (CHR ''u''), (CHR ''t''), (CHR ''!'')])),
  ([(''--whole-archive'')],                           ([], []),            (\<lambda> _    .  (\<lambda> state .  state)), (''Include all objects from following archives'')),
  (* linker plugin control *)
  ([(''-plugin'')],                                   ([(''PLUGIN'')], []),    (\<lambda> _    .  (\<lambda> state .  state)), (''Load named plugin'')),
  ([(''-plugin-opt'')],                               ([(''ARG'')], []),       (\<lambda> _    .  (\<lambda> state .  state)), (''Send arg to last-loaded plugin'')),
  (* output / whole-job options (some may be repeated with different args, but most not): *)
  ([(''-A''), (''--architecture'')],                      ([(''ARCH'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Set architecture'')),
  ([(''-EB'')],                                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Link big-endian objects'')),
  ([(''-EL'')],                                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Link little-endian objects'')),
  ([(''-R''), (''--just-symbols'')],                      ([(''DIR'')], []),       (\<lambda> _ .  (\<lambda> state .  state)), (''**srk** (if directory, same as --rpath)'')),
  ([(''-d''), (''-dc''), (''-dp'')],                          ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Force common symbols to be defined'')),
  ([(''-e''), (''--entry'')],                             ([(''ADDRESS'')], []),   (\<lambda> _ .  (\<lambda> state .  state)), (''Set start address'')),
  ([(''-E''), (''--export-dynamic'')],                    ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Export all dynamic symbols'')),
  ([(''--no-export-dynamic'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Undo the effect of --export-dynamic'')),
  ([(''-f''), (''--auxiliary'')],                         ([(''SHLIB'')], []),     (\<lambda> _ .  (\<lambda> state .  state)), (''Auxiliary filter for shared object symbol table'')),
  ([(''-F''), (''--filter'')],                            ([(''SHLIB'')], []),     (\<lambda> _ .  (\<lambda> state .  state)), (''Filter for shared object symbol table'')),
  ([(''-G''), (''--gpsize'')],                            ([(''SIZE'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Small data size (if no size, same as --shared) **srk NOTE this quirk!**'')),
  ([(''-h''), (''-soname'')],                             ([(''FILENAME'')], []),  (\<lambda> _ .  (\<lambda> state .  state)), (''Set internal name of shared library'')),
  ([(''-I''), (''--dynamic-linker'')],                    ([(''PROGRAM'')], []),   (\<lambda> _ .  (\<lambda> state .  state)), (''Set PROGRAM as the dynamic linker to use'')),
  ([(''--sysroot='')],                                ([], [(''DIRECTORY'')]), (\<lambda> _ .  (\<lambda> state .  state)), (''Override the default sysroot location'')),
  ([(''-m'')],                                        ([(''EMULATION'')], []), (\<lambda> _ .  (\<lambda> state .  state)), (''Set emulation'')),
  ([(''-n''), (''--nmagic'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not page align data'')),
  ([(''-N''), (''--omagic'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not page align data, do not make text readonly'')),
  ([(''--no-omagic'')],                               ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Page align data, make text readonly'')),
  ([(''-o''), (''--output'')],                            ([(''FILE'')], []),      (\<lambda> argvals .  set_or_replace_option (OutputFilename(List.hd (fst argvals)))), (''Set output file name'')),
  ([(''-O'')],                                        ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Optimise output file'')),
  ([(''-q''), (''--emit-relocs'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Generate relocations in final output'')),
  ([(''-r''), (''-i''), (''--relocatable'')],                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Generate relocatable output'')),
  ([(''-s''), (''--strip-all'')],                         ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Strip all symbols'')),
  ([(''-S''), (''--strip-debug'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Strip debugging symbols'')),
  ([(''--strip-discarded'')],                         ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Strip symbols in discarded sections'')),
  ([(''--no-strip-discarded'')],                      ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not strip symbols in discarded sections'')),
  ([(''--default-script''), (''-dT'')],                   ([(''FILE'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Read default linker script'')),
  ([(''--unique='')],                                 ([], [(''SECTION'')]),   (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''m''), (CHR ''e''), (CHR ''r''), (CHR ''g''), (CHR ''e''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR ''p''), (CHR ''u''), (CHR ''t''), (CHR '' ''), (CHR ''[''), (CHR ''S''), (CHR ''E''), (CHR ''C''), (CHR ''T''), (CHR ''I''), (CHR ''O''), (CHR ''N''), (CHR '' ''), (CHR ''|''), (CHR '' ''), (CHR ''o''), (CHR ''r''), (CHR ''p''), (CHR ''h''), (CHR ''a''), (CHR ''n''), (CHR '']''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR ''s'')])),
  ([(''-Ur'')],                                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Build global constructor/destructor tables ( **srk**: like -r, but... )'')),
  ([(''-x''), (''--discard-all'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Discard all local symbols'')),
  ([(''-X''), (''--discard-locals'')],                    ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Discard temporary local symbols (default)'')),
  ([(''--discard-none'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''d''), (CHR ''i''), (CHR ''s''), (CHR ''c''), (CHR ''a''), (CHR ''r''), (CHR ''d''), (CHR '' ''), (CHR ''a''), (CHR ''n''), (CHR ''y''), (CHR '' ''), (CHR ''l''), (CHR ''o''), (CHR ''c''), (CHR ''a''), (CHR ''l''), (CHR '' ''), (CHR ''s''), (CHR ''y''), (CHR ''m''), (CHR ''b''), (CHR ''o''), (CHR ''l''), (CHR ''s'')])),
  ([(''-Bsymbolic'')],                                ([], []),            (\<lambda> argvals .  (\<lambda> state .  set_or_replace_option BindFunctionsEarly (set_or_replace_option BindNonFunctionsEarly state))), (''Bind global references locally'')),
  ([(''-Bsymbolic-functions'')],                      ([], []),            (\<lambda> argvals .  set_or_replace_option (BindFunctionsEarly)), (''Bind global function references locally'')),
  ([(''--force-exe-suffix'')],                        ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Force generation of file with .exe suffix'')),
  ([(''--gc-sections'')],                             ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''**srk: uncertain: can repeat?** Remove unused sections (on some targets)'')),
  ([(''--no-gc-sections'')],                          ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''*''), (CHR ''*''), (CHR ''s''), (CHR ''r''), (CHR ''k''), (CHR '':''), (CHR '' ''), (CHR ''u''), (CHR ''n''), (CHR ''c''), (CHR ''e''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''i''), (CHR ''n''), (CHR '':''), (CHR '' ''), (CHR ''c''), (CHR ''a''), (CHR ''n''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''p''), (CHR ''e''), (CHR ''a''), (CHR ''t''), (CHR ''?''), (CHR ''*''), (CHR ''*''), (CHR '' ''), (CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''m''), (CHR ''o''), (CHR ''v''), (CHR ''e''), (CHR '' ''), (CHR ''u''), (CHR ''n''), (CHR ''u''), (CHR ''s''), (CHR ''e''), (CHR ''d''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR ''s''), (CHR '' ''), (CHR ''(''), (CHR ''d''), (CHR ''e''), (CHR ''f''), (CHR ''a''), (CHR ''u''), (CHR ''l''), (CHR ''t''), (CHR '')'')])),
  ([(''--hash-size='')],                              ([], [(''NUMBER'')]),    (\<lambda> _ .  (\<lambda> state .  state)), (''Set default hash table size close to <NUMBER>'')),
  ([(''--no-define-common'')],                        ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not define Common storage'')),
  ([(''--no-undefined'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not allow unresolved references in object files'')),
  ([(''--allow-shlib-undefined'')],                   ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Allow unresolved references in shared libraries'')),
  ([(''--no-allow-shlib-undefined'')],                ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not allow unresolved references in shared libs'')),
  ([(''--default-symver'')],                          ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Create default symbol version'')),
  ([(''--default-imported-symver'')],                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Create default symbol version for imported symbols'')),
  ([(''-nostdlib'')],                                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Only use library directories specified on the command line'')),
  ([(''--oformat'')],                                 ([(''TARGET'')], []),    (\<lambda> _ .  (\<lambda> state .  state)), (''Specify target of output file'')),
  ([(''--relax'')],                                   ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Reduce code size by using target specific optimisations'')),
  ([(''--no-relax'')],                                ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Do not use relaxation techniques to reduce code size'')),
  ([(''--retain-symbols-file'')],                     ([(''FILE'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Keep only symbols listed in FILE'')),
  ([(''-rpath'')],                                    ([(''PATH'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Set runtime shared library search path'')),
  ([(''-shared''), (''-Bshareable'')],                    ([], []),            (\<lambda> argvals .  set_or_replace_option (OutputKind(SharedLibrary))), (''Create a shared library'')),
  ([(''-pie''), (''--pic-executable'')],                  ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Create a position independent executable'')),
  ([(''--sort-common='')],(* (ascending|descending) *)([], [(''order'')]),     (\<lambda> _ .  (\<lambda> state .  state)), (''Sort common symbols by alignment [in specified order]'')),
  ([(''--sort-section='')],(* (name|alignment) *)     ([], [(''key'')]),       (\<lambda> _ .  (\<lambda> state .  state)), (''Sort sections by name or maximum alignment'')),
  ([(''--spare-dynamic-tags'')],                      ([(''COUNT'')], []),     (\<lambda> _ .  (\<lambda> state .  state)), (''How many tags to reserve in .dynamic section'')),
  ([(''--split-by-file='')],                          ([], [(''SIZE'')]),      (\<lambda> _ .  (\<lambda> state .  state)), (''Split output sections every SIZE octets'')),
  ([(''--split-by-reloc='')],                         ([], [(''COUNT'')]),     (\<lambda> _ .  (\<lambda> state .  state)), (''Split output sections every COUNT relocs'')),
  ([(''--traditional-format'')],                      ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Use same format as native linker'')),
  ([(''--unresolved-symbols='')],                     ([], [(''method'')]),    (\<lambda> _ .  (\<lambda> state .  state)), (''How to handle unresolved symbols.  <method> is: ignore-all, report-all, ignore-in-object-files, ignore-in-shared-libs'')),
  ([(''--dynamic-list-data'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Add data symbols to dynamic list'')),
  ([(''--dynamic-list-cpp-new'')],                    ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Use C++ operator new/delete dynamic list'')),
  ([(''--dynamic-list-cpp-typeinfo '')],              ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Use C++ typeinfo dynamic list'')),
  ([(''--dynamic-list'')],                            ([(''FILE'')], []),      (\<lambda> _ .  (\<lambda> state .  state)), (''Read dynamic list'')),
  ([(''--wrap'')],                                    ([(''SYMBOL'')], []),    (\<lambda> _ .  (\<lambda> state .  state)), (''Use wrapper functions for SYMBOL'')),
  (* the following are specific to ELF emulations *)
  ([(''--audit=(.*)'')],                              ([], [(''AUDITLIB'')]),  (\<lambda> _ .  (\<lambda> state .  state)), (''Specify a library to use for auditing'')),
  ([(''-Bgroup'')],                                   ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Selects group name lookup rules for DSO'')),
  ([(''--build-id='')],                               ([], [(''STYLE'')]),     (\<lambda> _ .  (\<lambda> state .  state)), (''Generate build ID note'')),
  ([(''-P'')],                                        ([(''AUDITLIB'')], []),  (\<lambda> _ .  (\<lambda> state .  state)), (''Specify a library to use for auditing dependencies'')),
  ([(''--depaudit='')],                               ([], [(''AUDITLIB'')]),  (\<lambda> _ .  (\<lambda> state .  state)), (''Specify a library to use for auditing dependencies'')),
  ([(''--disable-new-dtags'')],                       ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Disable new dynamic tags'')),
  ([(''--enable-new-dtags'')],                        ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Enable new dynamic tags'')),
  ([(''--eh-frame-hdr'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Create .eh_frame_hdr section'')),
  ([(''--exclude-libs='')],                           ([], [(''LIBS'')]),      (\<lambda> _ .  (\<lambda> state .  state)), (''Make all symbols in LIBS hidden'')),
  ([(''--hash-style='')],                             ([], [(''STYLE'')]),     (\<lambda> _ .  (\<lambda> state .  state)), (''Set hash style to sysv, gnu or both'')),
  (* NOTE: for these to work, we hack our word-splitter to merge -z options into a single word with a single space in *)
  ([(''-z combreloc'')],                              ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Merge dynamic relocs into one section and sort'')),
  ([(''-z common-page-size='')],                      ([], [(''SIZE'')]),      (\<lambda> _ .  (\<lambda> state .  state)), (''Set common page size to SIZE'')),
  ([(''-z defs'')],                                   ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Report unresolved symbols in object files.'')),
  ([(''-z execstack'')],                              ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark executable as requiring executable stack'')),
  ([(''-z global'')],                                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Make symbols in DSO available for subsequently loaded objects'')),
  ([(''-z initfirst'')],                              ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark DSO to be initialized first at runtime'')),
  ([(''-z interpose'')],                              ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object to interpose all DSOs but executable'')),
  ([(''-z lazy'')],                                   ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object lazy runtime binding (default)'')),
  ([(''-z loadfltr'')],                               ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object requiring immediate process'')),
  ([(''-z max-page-size='')],                         ([], [(''SIZE'')]),      (\<lambda> _ .  (\<lambda> state .  state)), (''Set maximum page size to SIZE'')),
  ([(''-z nocombreloc'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''m''), (CHR ''e''), (CHR ''r''), (CHR ''g''), (CHR ''e''), (CHR '' ''), (CHR ''d''), (CHR ''y''), (CHR ''n''), (CHR ''a''), (CHR ''m''), (CHR ''i''), (CHR ''c''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''l''), (CHR ''o''), (CHR ''c''), (CHR ''s''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR ''t''), (CHR ''o''), (CHR '' ''), (CHR ''o''), (CHR ''n''), (CHR ''e''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n'')])),
  ([(''-z nocopyreloc'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''c''), (CHR ''r''), (CHR ''e''), (CHR ''a''), (CHR ''t''), (CHR ''e''), (CHR '' ''), (CHR ''c''), (CHR ''o''), (CHR ''p''), (CHR ''y''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''l''), (CHR ''o''), (CHR ''c''), (CHR ''s'')])),
  ([(''-z nodefaultlib'')],                           ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object not to use default search paths'')),
  ([(''-z nodelete'')],                               ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark DSO non-deletable at runtime'')),
  ([(''-z nodlopen'')],                               ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark DSO not available to dlopen'')),
  ([(''-z nodump'')],                                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark DSO not available to dldump'')),
  ([(''-z noexecstack'')],                            ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark executable as not requiring executable stack'')),
  ([(''-z norelro'')],                                ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''c''), (CHR ''r''), (CHR ''e''), (CHR ''a''), (CHR ''t''), (CHR ''e''), (CHR '' ''), (CHR ''R''), (CHR ''E''), (CHR ''L''), (CHR ''R''), (CHR ''O''), (CHR '' ''), (CHR ''p''), (CHR ''r''), (CHR ''o''), (CHR ''g''), (CHR ''r''), (CHR ''a''), (CHR ''m''), (CHR '' ''), (CHR ''h''), (CHR ''e''), (CHR ''a''), (CHR ''d''), (CHR ''e''), (CHR ''r'')])),
  ([(''-z now'')],                                    ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object non-lazy runtime binding'')),
  ([(''-z origin'')],                                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Mark object requiring immediate $ORIGIN processing at runtime'')),
  ([(''-z relro'')],                                  ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Create RELRO program header'')),
  ([(''-z stacksize='')],                             ([], [(''SIZE'')]),      (\<lambda> _ .  (\<lambda> state .  state)), (''Set size of stack segment'')),
  ([(''-z bndplt'')],                                 ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Always generate BND prefix in PLT entries'')),
  ([(''--ld-generated-unwind-info'')],                ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Generate exception handling info for PLT.'')),
  ([(''--no-ld-generated-unwind-info'')],             ([], []),            (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''d''), (CHR ''o''), (CHR '' ''), (CHR ''s''), (CHR ''o''), (CHR ''.'')])),
  (* quasi-input options (can be repeated): *)
  ([(''-c''), (''--mri-script'')],                        ([(''FILE'')], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Read MRI format linker script'')),
  ([(''-l''), (''--library'')],                           ([(''LIBNAME'')], []),         (\<lambda> _ .  (\<lambda> state .  state)), (''Search for library LIBNAME'')),
  (* ([-R ,--just-symbols],                   ([FILE], []),            fun _ -> (fun state -> state), Just link symbols), *) (* Handled above! *)
  ([(''-T''), (''--script'')],                            ([(''FILE'')], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Read linker script'')),
  ([(''-u''), (''--undefined'')],                         ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Start with undefined reference to SYMBOL'')),
  ([(''-(''), (''--start-group'')],                       ([], []),                  (\<lambda> _ .  (\<lambda> state .  start_group state)), (''Start a group'')),
  ([(''-)''), (''--end-group'')],                         ([], []),                  (\<lambda> _ .  (\<lambda> state .  end_group state)), (''End a group'')),
  ([(''--defsym'')],                                  ([(''SYMBOL=EXPRESSION'')], []), (\<lambda> _ .  (\<lambda> state .  state)), (''Define a symbol'')),
  ([(''-fini'')],                                     ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Call SYMBOL at unload-time'')),
  ([(''-init'')],                                     ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Call SYMBOL at load-time'')),
  ([(''--section-start'')],                           ([(''SECTION=ADDRESS'')], []), (\<lambda> _ .  (\<lambda> state .  state)), (''Set address of named section'')),
  ([(''-Tbss'')],                                     ([(''ADDRESS'')], []),         (\<lambda> _ .  (\<lambda> state .  state)), (''Set address of .bss section'')),
  ([(''-Tdata'')],                                    ([(''ADDRESS'')], []),         (\<lambda> _ .  (\<lambda> state .  state)), (''Set address of .data section'')),
  ([(''-Ttext'')],                                    ([(''ADDRESS'')], []),         (\<lambda> _ .  (\<lambda> state .  state)), (''Set address of .text section'')),
  ([(''-Ttext-segment'')],                            ([(''ADDRESS'')], []),         (\<lambda> argvals .  set_or_replace_option (TextSegmentStart(parse_address (List.hd (fst argvals))))), (''Set address of text segment'')),
  ([(''-Trodata-segment'')],                          ([(''ADDRESS'')], []),         (\<lambda> argvals .  set_or_replace_option (RodataSegmentStart(parse_address (List.hd (fst argvals))))), (''Set address of rodata segment'')),
  ([(''-Tldata-segment'')],                           ([(''ADDRESS'')], []),         (\<lambda> argvals .  set_or_replace_option (LdataSegmentStart(parse_address (List.hd (fst argvals))))), (''Set address of ldata segment'')),
  ([(''--version-script'')],                          ([(''FILE'')], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Read version information script'')),
  ([(''--version-exports-section'')],                 ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Take export symbols list from .exports, using SYMBOL as the version.'')),
  (* linker internal debugging/diagnostics and performance tuning *)
  ([(''-M''), (''--print-map'')],                         ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print map file on standard output'')),
  ([(''-t''), (''--trace'')],                             ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Trace file opens'')),
  ([(''-v''), (''--version'')],                           ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print version information'')),
  ([(''-V'')],                                        ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print version and emulation information'')),
  ([(''-y''), (''--trace-symbol'')],                      ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Trace mentions of SYMBOL'')),
  ([(''--cref'')],                                    ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Output cross reference table'')),
  ([(''--demangle='')],                               ([], [(''STYLE'')]),             (\<lambda> _ .  (\<lambda> state .  state)), (''Demangle symbol names [using STYLE]'')),
  ([(''--print-gc-sections'')],                       ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''List removed unused sections on stderr'')),
  ([(''--no-print-gc-sections'')],                    ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Do not list removed unused sections'')),
  ([(''-Map'')],                                      ([(''FILE'')], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Write a map file'')),
  ([(''-Map='')],                                     ([], [(''FILE'')]),            (\<lambda> _ .  (\<lambda> state .  state)), (''Write a map file'')),
  ([(''--help'')],                                    ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print option help'')),
  ([(''--no-keep-memory'')],                          ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Use less memory and more disk I/O'')),
  ([(''--no-demangle'')],                             ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Do not demangle symbol names'')),
  ([(''--print-output-format'')],                     ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print default output format'')),
  ([(''--print-sysroot'')],                           ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print current sysroot'')),
  ([(''--reduce-memory-overheads'')],                 ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Reduce memory overheads, possibly taking much longer'')),
  ([(''--stats'')],                                   ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Print memory usage statistics'')),
  ([(''--target-help'')],                             ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Display target specific options'')),
  ([(''--verbose='')],                                ([], [(''NUMBER'')]),          (\<lambda> _ .  (\<lambda> state .  state)), (''Output lots of information during link'')),
  (* unknown *)
  ([(''--embedded-relocs'')],                         ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Generate embedded relocs'')),
  ([(''--task-link'')],                               ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Do task level linking'')),
  (* compatibility *)
  ([(''-a'')],                                        ([(''KEYWORD'')], []),         (\<lambda> _ .  (\<lambda> state .  state)), (''Shared library control for HP/UX compatibility'')),
  ([(''-Y'')],                                        ([(''PATH'')], []),            (\<lambda> _ .  (\<lambda> state .  state)), (''Default search path for Solaris compatibility'')),
  (* permissiveness controls (tightening/loosening) *)
  ([(''--accept-unknown-input-arch'')],               ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Accept input files whose architecture cannot be determined'')),
  ([(''--no-accept-unknown-input-arch'')],            ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Reject input files whose architecture is unknown'')),
  ([(''--fatal-warnings'')],                          ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Treat warnings as errors'')),
  ([(''--no-fatal-warnings'')],                       ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Do not treat warnings as errors (default)'')),
  ([(''--allow-multiple-definition'')],               ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Allow multiple definitions'')),
  ([(''--no-undefined-version'')],                    ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Disallow undefined version'')),
  ([(''--noinhibit-exec'')],                          ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Create an output file even if errors occur'')),
  ([(''--error-unresolved-symbols'')],                ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Report unresolved symbols as errors'')),
  ([(''--ignore-unresolved-symbol'')],                ([(''SYMBOL'')], []),          (\<lambda> _ .  (\<lambda> state .  state)), (''Unresolved SYMBOL will not cause an error or warning'')),
  (* permissiveness, specific to ELF emulation *)
  ([(''-z muldefs'')],                                ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Allow multiple definitions'')),
  (* warnings (enabling/disabling) *)
  ([(''--no-warn-mismatch'')],                        ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''w''), (CHR ''a''), (CHR ''r''), (CHR ''n''), (CHR '' ''), (CHR ''a''), (CHR ''b''), (CHR ''o''), (CHR ''u''), (CHR ''t''), (CHR '' ''), (CHR ''m''), (CHR ''i''), (CHR ''s''), (CHR ''m''), (CHR ''a''), (CHR ''t''), (CHR ''c''), (CHR ''h''), (CHR ''e''), (CHR ''d''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR ''p''), (CHR ''u''), (CHR ''t''), (CHR '' ''), (CHR ''f''), (CHR ''i''), (CHR ''l''), (CHR ''e''), (CHR ''s'')])),
  ([(''--no-warn-search-mismatch'')],                 ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), ([(CHR ''D''), (CHR ''o''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''w''), (CHR ''a''), (CHR ''r''), (CHR ''n''), (CHR '' ''), (CHR ''o''), (CHR ''n''), (CHR '' ''), (CHR ''f''), (CHR ''i''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''n''), (CHR ''g''), (CHR '' ''), (CHR ''a''), (CHR ''n''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR ''c''), (CHR ''o''), (CHR ''m''), (CHR ''p''), (CHR ''a''), (CHR ''t''), (CHR ''i''), (CHR ''b''), (CHR ''l''), (CHR ''e''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''b''), (CHR ''r''), (CHR ''a''), (CHR ''r''), (CHR ''y'')])),
  ([(''--warn-common'')],                             ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn about duplicate common symbols'')),
  ([(''--warn-constructors'')],                       ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn if global constructors/destructors are seen'')),
  ([(''--warn-multiple-gp'')],                        ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn if the multiple GP values are used'')),
  ([(''--warn-once'')],                               ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn only once per undefined symbol'')),
  ([(''--warn-section-align'')],                      ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn if start of section changes due to alignment'')),
  ([(''--warn-shared-textrel'')],                     ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn if shared object has DT_TEXTREL'')),
  ([(''--warn-alternate-em'')],                       ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Warn if an object has alternate ELF machine code'')),
  ([(''--warn-unresolved-symbols'')],                 ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Report unresolved symbols as warnings'')),
  (* meta-options *)
  ([(''--push-state'')],                              ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Push state of flags governing input file handling'')),
  ([(''--pop-state'')],                               ([], []),                  (\<lambda> _ .  (\<lambda> state .  state)), (''Pop state of flags governing input file handling''))
(*([@FILE], [], fun _ -> (fun state -> state), Read options from FILE) *) (* processed during word-splitting phase *) 
])"


(*val delete_trailing_equals: string -> maybe string*)
definition delete_trailing_equals  :: " string \<Rightarrow>(string)option "  where 
     " delete_trailing_equals str = ( 
    (let cs = ( str)
    in
    if [(CHR ''='')] = drop ((List.length cs) -( 1 :: nat)) cs
        then Some (((take ((List.length cs) -( 1 :: nat)) cs)))
        else (* let _ = Missing_pervasives.errln (No trailing equals:  ^ str)
            in *)
            None))"


(*val string_following_equals_at : nat -> string -> maybe string*)
definition string_following_equals_at  :: " nat \<Rightarrow> string \<Rightarrow>(string)option "  where 
     " string_following_equals_at pos str = ( 
    (let (first1, second) = (split_at pos ( str))
    in (case  second of 
        (CHR ''='') # rest => Some ( rest)
        | _ => (* let _ = Missing_pervasives.errln (No trailing equals at  ^ (show pos) ^ :  ^ str)
            in *)
            None
    )))"


(*val equal_modulo_trailing_equals : string -> string -> bool*)
definition equal_modulo_trailing_equals  :: " string \<Rightarrow> string \<Rightarrow> bool "  where 
     " equal_modulo_trailing_equals argstr argdef = ( 
    (* we allow argdef to have a trailing equals; if it does, 
     * we allow the argstring to have the equals (or not) and trailing stuff,
     * which will become an arg  *)
    (let result = ((case  (delete_trailing_equals argdef) of 
        Some matched => 
            (let following_equals = (string_following_equals_at (List.length matched) argstr)
            in
            (case  following_equals of 
                Some following => (* okay; does the pre-equals part match? *)
                    matched = (List.take ((List.length argdef) -( 1 :: nat)) ( argstr))
                | _ => (* the argstr is allowed not to have a trailing equals *) argstr = matched
            ))
        | None => (* no trailing equals *) argdef = argstr
    ))
    in 
    (* let _ = Missing_pervasives.errln (Do ' ^ argstr ^ ' and ' ^ argdef ^ ' match modulo trailing equals?  ^ (show result))
    in *) result))"

    

(*val matching_arg_and_alias : string -> list option_def -> maybe (string * option_def)*)
function (sequential,domintros)  matching_arg_and_alias  :: " string \<Rightarrow>((string)list*((string)list*(string)list)*(option_argvals \<Rightarrow>(command_state)list \<Rightarrow>(command_state)list)*string)list \<Rightarrow>(string*((string)list*((string)list*(string)list)*(option_argvals \<Rightarrow>(command_state)list \<Rightarrow>(command_state)list)*string))option "  where 
     " matching_arg_and_alias arg ([]) = ( None )"
|" matching_arg_and_alias arg ((aliases, argspec, meaning, doc) # more_opts) = ( 
        (case  List.find (\<lambda> alias .  equal_modulo_trailing_equals arg alias) aliases of 
            Some found_alias => Some (found_alias, (aliases, argspec, meaning, doc))
            | None => matching_arg_and_alias arg more_opts
        ))" 
by pat_completeness auto


(* We don't try to convert from strings to other things here; 
 * everything we record is either a bool, meaning option -A was present, for some A,
 * or a string somearg, meaning option -A somearg was present, for some A. *)

(* The above suffices to understand each concrete argument. 
 * Now we define an interpreted command line that includes 
 * some useful structure. *)

(*val read_one_arg : list command_state -> list string -> (list command_state * list string)*)
fun read_one_arg  :: "(command_state)list \<Rightarrow>(string)list \<Rightarrow>(command_state)list*(string)list "  where 
     " read_one_arg state_stack ([]) = ( (state_stack, []))"
|" read_one_arg state_stack (some_arg # more1) = ( (case  (matching_arg_and_alias some_arg command_line_table) of
            (* We need to handle argdefs that have trailing equals. This means 
             * an extra arg might follow the equals. We need some helper functions. *)
                Some (alias, (aliases, (argspec_extras, argspec_regex), meaning, doc)) =>
                    (* Return a new state, by applying the argument's meaning. 
                     * We have to supply the option's argument strings to the meaning function. *)
                    (let argstrings = (List.take (List.length argspec_extras) more1)
                    in 
                    (let regex_matches = ((case  delete_trailing_equals some_arg of
                        Some prefix => 
                            (case  (string_following_equals_at ((List.length alias) -( 1 :: nat)) some_arg) of 
                                Some following_equals => [following_equals]
                                | None => failwith ([(CHR ''i''), (CHR ''m''), (CHR ''p''), (CHR ''o''), (CHR ''s''), (CHR ''s''), (CHR ''i''), (CHR ''b''), (CHR ''l''), (CHR ''e''), (CHR '':''), (CHR '' ''), (Char Nibble2 Nibble7), (CHR ''=''), (Char Nibble2 Nibble7), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''w''), (CHR ''h''), (CHR ''e''), (CHR ''r''), (CHR ''e''), (CHR '' ''), (CHR ''i''), (CHR ''t''), (CHR '' ''), (CHR ''w''), (CHR ''a''), (CHR ''s''), (CHR '' ''), (CHR ''a''), (CHR '' ''), (CHR ''m''), (CHR ''o''), (CHR ''m''), (CHR ''e''), (CHR ''n''), (CHR ''t''), (CHR '' ''), (CHR ''a''), (CHR ''g''), (CHR ''o'')])
                            )
                        | None => []
                    ))
                    in 
                    (let new_state_stack = (meaning (argstrings, regex_matches) state_stack)
                    in
                    (new_state_stack, drop (List.length argspec_extras) more1))))
                | None => 
                    (* If we didn't match any args, we ought to be an input file. *)
                    (add_input_file state_stack some_arg, more1)
            ))" 
declare read_one_arg.simps [simp del]


(* To fold over the command-line arguments we need a fold that passes 
 * suffixes of the list, not individual elements, and gives us back
 * the continuation that we need to fold over: a pair of folded-value, new-list. *)
(*val foldl_suffix : forall 'a 'b. ('a -> list 'b -> ('a * list 'b)) -> 'a -> list 'b -> 'a*) (* originally foldl *)
function (sequential,domintros)  foldl_suffix  :: "('a \<Rightarrow> 'b list \<Rightarrow> 'a*'b list)\<Rightarrow> 'a \<Rightarrow> 'b list \<Rightarrow> 'a "  where 
     " foldl_suffix f a l = ( (case  l of
    []      => a
  | x # xs => 
    (let (new_a, new_list) = (f a l)
    in foldl_suffix f new_a new_list)
))" 
by pat_completeness auto


(* the word-splitting in argv needs a little fixing up. *)
(*val cook_argv : list string -> list string -> list string*)
function (sequential,domintros)  cook_argv  :: "(string)list \<Rightarrow>(string)list \<Rightarrow>(string)list "  where 
     " cook_argv acc1 ([]) = ( acc1 )"
|" cook_argv acc1 (s # l) = ( 
  if(s = (''-z'')) then
    ((case  l of
         [] => failwith (''-z must be followed by another argument'')
       | something # yetmore => cook_argv (acc1 @ [((''-z '') @ something)])
                                  yetmore
     )) else (cook_argv (acc1 @ [s]) l) )" 
by pat_completeness auto


(*val command_line : unit -> interpreted_command_line*)
end
