chapter {* Generated by Lem from elf64_file_of_elf_memory_image.lem. *}

theory "Elf64_file_of_elf_memory_image" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Endianness" 
	 "Elf_types_native_uint" 
	 "Default_printing" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "String_table" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_file" 
	 "Elf_relocation" 
	 "Memory_image" 
	 "Memory_image_orderings" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abis" 
	 "Elf_memory_image" 
	 "Elf_memory_image_of_elf64_file" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*import Set*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)

(*open import Byte_sequence*)
(*open import Default_printing*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)
(*open import Endianness*)

(*open import Elf_header*)
(*open import Elf_file*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_section_header_table*)
(*open import Elf_program_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)
(*open import String_table*)

(*open import Memory_image*)
(*open import Memory_image_orderings*)

(*open import Elf_memory_image*)
(*open import Elf_memory_image_of_elf64_file*)
(*open import Abis*)

(* Things the caller should do first: *)
(* - create segment annotations *)
(* - create .dynamic-equivalent metadata (but not the section) *)
(* - concretise symbolic elements? actually they pass a function to do this. *)

type_synonym make_concrete_fn =" Memory_image.element \<Rightarrow> Memory_image.element "

(* Things we do, at the caller's direction:*)
(* - create SHT *)
(* - create symtabs, strtabs, symbol hash tables (the ABI helps us) *)
(* - create shstrtab (if we're creating a SHT) *)
(* - actually create the dynamic section (and its PHDR) *)
(* - create any other PHDRs (the ABI tells us, mostly) and PT_PHDR (the user tells us) *)

(*val elf64_file_of_elf_memory_image : abi any_abi_feature -> make_concrete_fn -> string -> elf_memory_image -> elf64_file*)
definition elf64_file_of_elf_memory_image  :: "(any_abi_feature)abi \<Rightarrow>(element \<Rightarrow> element)\<Rightarrow> string \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow> elf64_file "  where 
     " elf64_file_of_elf_memory_image a make_concrete fname1 img3 = ( 
    (* Generate an ELF header, (optionally) SHT and (optionally) PHT, 
     * based on metadata in the image.
     * 
     * How do we decide what kind of ELF file to generate?     see whether we have segment annotations?
                        what architecture/osabi to give?       the ABI tells us
                        
     *)
    (let (section_tags, section_ranges) = (elf_memory_image_section_ranges img3)
    in
    (let section_tags_bare = (List.map (\<lambda> tag .  
        (case  tag of 
              FileFeature(ElfSection(idx1, isec1)) => (idx1, isec1)
            | _ => failwith (''not section tag'')
        )) section_tags)
    in
    (let section_tags_bare_noidx = (List.map (\<lambda> (idx1, isec1) .  isec1) section_tags_bare)
    in
    (let basic_shstrtab = (List.foldl (\<lambda> table .  (\<lambda> str .  
        (let (_, t) = (String_table.insert_string str table) in t)
    )) String_table.empty0 [(''.shstrtab''), (''.symtab''), (''.strtab'')])
    in
    (let shstrtab = (List.foldl (\<lambda> table .  \<lambda> (idx1, isec1) .  
        (let (_, t) = (String_table.insert_string(elf64_section_name_as_string   isec1) table) in 
        (* let _ = errln (Adding section name ` ^ isec.elf64_section_name_as_string ^ ' to shstrtab; now has size 
            ^ (show (String_table.size t)))
        in *) t)
    ) basic_shstrtab section_tags_bare)
    in
    (let phoff =(( 64 :: nat))
    in
    (let max_phnum1 = ((max_phnum   (* length phdrs *)a))
    in
        (* what do we generate? 
         * .eh_frame? no, *should* come from the script
         * .got, .got.plt? HMM. These should have been created,
         * as ABI features, by the time we get here.
         * .comment -- maybe
         * .shstrtab -- YES
         * .symtab -- YES
         * .strtab -- YES.
         * 
         * Do we generate them as elements in the image, or just
         * use them to write the ELF file? The latter.
         *)
    (let (symbol_tags, symbol_ranges) = (elf_memory_image_symbol_def_ranges img3)
    in
    (let all_sym_names = (List.map (\<lambda> tag .  
        (case  tag of 
            SymbolDef(sd) =>(def_symname   sd)
            | _ => (''not symbol tag, in symbol tags'')
        )
    ) symbol_tags)
    in
    (*let _ = errln (All symbol names:  ^ (show all_sym_names))
    in*)
    (let strtab = (List.foldl (\<lambda> table .  \<lambda> str .  
        (let (_, t) = (String_table.insert_string str table) in t)
    ) String_table.empty0 all_sym_names)
    in
    (* If the same address starts >1 section, all but one of those sections
     * must have size zero. These need to come *first* to avoid screwing up
     * the offset calculation. So also sort by size, so that the zero-sizers
     * come first. *)
    (let element_section_tag_pairs_sorted_by_address = ( (* List.stable_sort *)Elf_Types_Local.merge_sort
        (\<lambda> (isec1, (el1, range1)) .  (\<lambda> (isec2, (el2, range2)) .  (
            (let (addr1, sz1) = ((case  (elements   img3) el1 of
                Some(e) => 
                    (*let _ = errln (Size of element  ^ el1 ^  is  ^ (show e.length))
                    in*)
                    ((startpos   e),(length1   e))
                | None => failwith (''internal error: element does not exist'')
            ))
            in 
            (let (addr2, sz2) = ((case  (elements   img3) el2 of
                Some(e) => ((startpos   e),(length1   e))
                | None => failwith (''internal error: element does not exist'')
            ))
            in            
(pairCompare (maybeCompare (genericCompare (op<) (op=))) (maybeCompare (genericCompare (op<) (op=))) (addr1, sz1) (addr2, sz2))))
        )))
    (List.zip section_tags_bare_noidx section_ranges))
    in
    (let sorted_sections = (List.map (\<lambda> (isec1, (el, range)) .  isec1)
        element_section_tag_pairs_sorted_by_address)
    in
    (let filesz = (\<lambda> el .  \<lambda> isec1 .  
        (* How can we distinguish progbits from nobits? 
         * A section can be nobits if its representation
         * is all zero or don't-care. But in practice we
         * don't make a section nobits unless its name is .bss. *)
        (let sz = (if (* is_all_zeroes_or_dont_care *) True \<and>            
((elf64_section_name_as_string   isec1) = (''.bss'')) then( 0 :: nat)
            else (case (length1   el) of
                None => failwith (''error: concrete section element has no length'')
                | Some len => len
            ))
        in
        (*let _ = errln (Filesz of  ^ isec.elf64_section_name_as_string ^  is 0x ^ (hex_string_of_natural sz))
        in*)
        sz)
    )
    in
    (let (last_off, section_file_offsets) = (List.foldl (\<lambda> (current_off, offs_so_far) .  (\<lambda> (isec1, (el_name, el_range)) .  
        (* where can we place this in the file?
         * it's the next offset that's congruent to the section addr, 
         * modulo the biggest page size. *)
        (let el = ((case  (elements   img3) el_name of 
            Some e => e
            | None => failwith (''nonexistent element'')
        ))
        in
        (let (start_off :: nat) =  ((case (startpos   el) of
            Some addr => (let this_remainder = (current_off mod(maxpagesize   a))
                in
                (let target_remainder = (addr mod(maxpagesize   a))
                in
                (let bump = (
                    if target_remainder \<ge> this_remainder 
                    then target_remainder - this_remainder
                    else (((maxpagesize   a) + target_remainder) - this_remainder)
                )
                in
                (let _ = (())
                in
                current_off + bump))))
            | None => 
                (* It has no assigned address. That's okay if it's not allocatable. 
                 * If it's not allocatable, it has no alignment. *)
                if flag_is_set shf_alloc(elf64_section_flags   isec1) then (failwith (''allocatable section with no address''))
                else current_off (* FIXME: is alignment important in file-offset-space? *)
        ))
        in
        (let end_off = (start_off + (filesz el isec1))
        in 
        (end_off, (offs_so_far @ [start_off])))))
    )) ((phoff + (max_phnum1 *( 56 :: nat))), []) element_section_tag_pairs_sorted_by_address)
    in
    (let user_sections_sorted_with_offsets = ((let x2 = 
  ([]) in  List.foldr
   (\<lambda>(off, (isec1, (el_name, el_range))) x2 . 
    if True then
      ((let el = ((case   (elements   img3) el_name of
                      Some x => x
                    | None => failwith
                                (''internal error: section not found'')
                  )) in
       (| elf64_section_name = ((elf64_section_name   isec1)) (* ignored *)
       , elf64_section_type = ((elf64_section_type   isec1))
       , elf64_section_flags = ((elf64_section_flags   isec1))
       , elf64_section_addr = ((case (startpos   el) of
                                   Some addr => addr
                                 | None =>( 0 :: nat)
                               )) , elf64_section_offset =
       (*let _ = errln (Assigning offset 0x ^ (hex_string_of_natural off) ^  to section  ^ 
                    isec.elf64_section_name_as_string)
                in*)
       off
       , elf64_section_size = ((case (length1   el) of
                                   Some len => len
                                 | None => List.length (contents   el)
                               ))
       , elf64_section_link = ((elf64_section_link   isec1))
       , elf64_section_info = ((elf64_section_info   isec1))
       , elf64_section_align = ((elf64_section_align   isec1))
       , elf64_section_entsize = ((elf64_section_entsize   isec1))
       , elf64_section_body =
       ((let pad_fn = (
                      if flag_is_set shf_execinstr
                           (elf64_section_flags   isec1) then (pad_data   a)
                      else (pad_code   a)) in
        Sequence
          (concretise_byte_pattern [] (( 0 :: nat))
             (contents   (make_concrete el)) pad_fn)))
       , elf64_section_name_as_string = ((elf64_section_name_as_string   isec1))
       |))) # x2 else x2)
   (List.zip section_file_offsets element_section_tag_pairs_sorted_by_address)
   x2))    
    in
    (let symtab =        
( 
        (* Get all the symbols *)elf64_null_symbol_table_entry # ((let x2 = 
  ([]) in  List.foldr
   (\<lambda>(maybe_range, tag) x2 . 
    if True then
      (case  tag of
          SymbolDef (d) =>
      (let nameidx = ((case  String_table.find_string (def_symname   d)
                               strtab of
                          Some idx1 => (let v = (Elf_Types_Local.uint32_of_nat
                                                   idx1) in
                                       (* let _ = errln (strtab: found ` ^ d.def_symname ^ ' at index  ^ (show v))
                                        in *)
                                       v)
                        | None => failwith
                                    (''impossible: symbol name not in strtab we just created'')
                      )) in
      (let (shndx1, svalue, sz) = (
                                  if(elf64_st_shndx  (def_syment   d)) =
                                      Elf_Types_Local.uint16_of_nat shn_abs
                                  then
                                    ((elf64_st_shndx  (def_syment   d)),(elf64_st_value  (def_syment   d)),(elf64_st_size  (def_syment   d)))
                                  else
                                    (let (el_name, (start, len)) = ((case  maybe_range of
                                                                    Some(el_name, (start, len)) => 
                                                                    (el_name, 
                                                                    (start, len))
                                                                    | None => 
                                                                    failwith
                                                                    (''impossible: non-ABS symbol with no range'')
                                                                    )) in
                                    (Elf_Types_Local.uint16_of_nat
                                       ( (* what's the section index of this element? *)
                                         (let maybe_found = (mapMaybei
                                                               (\<lambda> i .  \<lambda> isec1 . 
                                                                if(elf64_section_name_as_string   isec1)
                                                                    = 
                                                                  el_name then
                                                                  Some i else
                                                                  None)
                                                               sorted_sections)
                                         in
                                         (case  maybe_found of
                                             [i] =>( 1 :: nat) + i
                                           | [] =>(
                                                     (* HMM *) (*let _ = errln (Couldn't compute section index of symbol  ^ d.def_symname)
                                            in*) 0 :: nat)
                                           | _ => failwith
                                                    ((''internal error: multiple sections named '')
                                                       @ el_name)
                                         )) ),
                                    Elf_Types_Local.uint64_of_nat
                                      (start +
                                         (case   (elements   img3) el_name of
                                             Some x => (case (startpos   x) of
                                                           Some addr => 
                                                       addr
                                                         | None => failwith
                                                                    (''internal error: symbol defined in section with no address'')
                                                       )
                                           | None => failwith
                                                       (''internal error: section (of symbol) not found'')
                                         )), of_int (int len) ))) in
      (* CHECK: can we expect these to be these usable, the way we generated them?  *)
      (| elf64_st_name = nameidx
      , elf64_st_info = ((elf64_st_info  (def_syment   d))) (* type, binding, visibility *)
      , elf64_st_other = ((elf64_st_other  (def_syment   d)))
      , elf64_st_shndx = shndx1 , elf64_st_value = svalue
      , elf64_st_size = sz |)))
      (* FIXME: do we ever get symbolrefs? *)
        | _ => failwith (''not a symbol tag, in symbol_tags'')
      ) # x2 else x2) (List.zip symbol_ranges symbol_tags) x2)))
    in
    (*let _ = errln (Building an ELF file from ^ (show (length element_section_tag_pairs_sorted_by_address)) ^  sections)
    in*)
    (* PROBLEM: 
     * sections' offset assignments depend on phnum.
     * BUT
     * phnum depends on sections' offset assignments!
     * How do we break this cycle?
     * We can get an upper bound on the number of phdrs, then 
     * fill them in later.
     *)
    (* How does the GNU BFD output a statically linked executable? 
     * First the ELF header,
     * then program headers,
     * then sections in order of address:
     *      .interp,                 these are all allocatable sections! with addresses!
     * then .note.ABI-tag, 
     * then .note.gnu.build-id,
     * then .gnu.hash,
     * then .dynsym,
     * then .dynstr,
     * then .gnu.version,
     * then .gnu.version_r,
     * then ...
     * 
     * ... and so on ...
     * 
     * then .gnu.debuglink (the only non-allocatable section)
     * then .shstrtab, then SHT. 
     * 
     * So how can we calculate the offset of the SHT?  We have to place
     * all the other sections first. 
     *)
    (let shstrndx =(( 1 :: nat) + List.length section_tags)
    in
    (let shstroff = last_off
    in
    (let shstrsz = (String_table.size1 shstrtab)
    in
    (let symoff = (align_up_to(( 8 :: nat)) (shstroff + shstrsz))
    in
    (let symsz =(( 24 :: nat) * List.length symtab)
    in
    (let stroff = (symoff + symsz)
    in
    (let strsz = (String_table.size1 strtab)
    in
    (let shoff = (align_up_to(( 64 :: nat)) (stroff + strsz))
    in
    (let shnum =(( 4 :: nat) + List.length sorted_sections) (* null, shstrtab, symtab, strtab *)
    in
    (let (entry :: nat) = ((case  Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     instance_Basic_classes_Ord_Abis_any_abi_feature_dict) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      Lem_string_extra.instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (Memory_image_orderings.tagEquiv
    instance_Abi_classes_AbiFeatureTagEquiv_Abis_any_abi_feature_dict) (EntryPoint)(by_tag   img3) of
        [(_, maybe_el_range)] =>
            (case  maybe_el_range of
                Some (el_name, (start, len)) => 
                    address_of_range (el_name, (start, len)) img3
                | None => failwith (''entry point defined without a range'')
            )
       | [] => failwith (''no entry point defined'')
       | _ => failwith (''multiple entry points defined'')
    ))
    in
    (let hdr = ((make_elf_header   a) elf_ft_exec entry shoff phoff max_phnum1 shnum shstrndx)
    in
    (let endian = (if Elf_Types_Local.index(elf64_ident   hdr) elf_ii_data = Some(Elf_Types_Local.unsigned_char_of_nat elf_data_2lsb) then Little else Big)
    in
    (let all_sections_sorted_with_offsets = (user_sections_sorted_with_offsets @ [
          (| elf64_section_name = ((case  String_table.find_string (''.shstrtab'') shstrtab of
                                    Some n => n
                                    | None => failwith ([(CHR ''i''), (CHR ''n''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR ''n''), (CHR ''a''), (CHR ''l''), (CHR '' ''), (CHR ''e''), (CHR ''r''), (CHR ''r''), (CHR ''o''), (CHR ''r''), (CHR '':''), (CHR '' ''), (Char Nibble6 Nibble0), (CHR ''.''), (CHR ''s''), (CHR ''h''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b''), (Char Nibble2 Nibble7), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR '' ''), (CHR ''s''), (CHR ''h''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b'')])
                                ))
           , elf64_section_type = sht_strtab
           , elf64_section_flags =(( 0 :: nat))
           , elf64_section_addr =(( 0 :: nat))
           , elf64_section_offset = shstroff
           , elf64_section_size = shstrsz
           , elf64_section_link =(( 0 :: nat))
           , elf64_section_info =(( 0 :: nat))
           , elf64_section_align =(( 0 :: nat))
           , elf64_section_entsize =(( 0 :: nat))
           , elf64_section_body = (Sequence(List.map Elf_Types_Local.unsigned_char_of_char ((String_table.get_base_string shstrtab))))
           , elf64_section_name_as_string = (''.shstrtab'')
           |),
          (| elf64_section_name      = ((case  String_table.find_string (''.symtab'') shstrtab of
                                    Some n => n
                                    | None => failwith ([(CHR ''i''), (CHR ''n''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR ''n''), (CHR ''a''), (CHR ''l''), (CHR '' ''), (CHR ''e''), (CHR ''r''), (CHR ''r''), (CHR ''o''), (CHR ''r''), (CHR '':''), (CHR '' ''), (Char Nibble6 Nibble0), (CHR ''.''), (CHR ''s''), (CHR ''y''), (CHR ''m''), (CHR ''t''), (CHR ''a''), (CHR ''b''), (Char Nibble2 Nibble7), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR '' ''), (CHR ''s''), (CHR ''h''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b'')])
                                ))
           , elf64_section_type      = sht_symtab
           , elf64_section_flags     =(( 0 :: nat))
           , elf64_section_addr      =(( 0 :: nat))
           , elf64_section_offset    = symoff
           , elf64_section_size      = symsz
           , elf64_section_link      =((( 1 :: nat) + (List.length user_sections_sorted_with_offsets)) +( 2 :: nat))
           , elf64_section_info      =(( 0 :: nat))
           , elf64_section_align =(( 8 :: nat))
           , elf64_section_entsize   =(( 24 :: nat))
           , elf64_section_body = (Byte_sequence.concat_byte_sequence (List.map (bytes_of_elf64_symbol_table_entry endian) symtab))
           , elf64_section_name_as_string = (''.symtab'')
           |), 
          (* strtab *)
          (| elf64_section_name      = ((case  String_table.find_string (''.strtab'') shstrtab of
                                    Some n => n
                                    | None => failwith ([(CHR ''i''), (CHR ''n''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR ''n''), (CHR ''a''), (CHR ''l''), (CHR '' ''), (CHR ''e''), (CHR ''r''), (CHR ''r''), (CHR ''o''), (CHR ''r''), (CHR '':''), (CHR '' ''), (Char Nibble6 Nibble0), (CHR ''.''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b''), (Char Nibble2 Nibble7), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR '' ''), (CHR ''s''), (CHR ''h''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b'')])
                                ))
           , elf64_section_type      = sht_strtab
           , elf64_section_flags     =(( 0 :: nat))
           , elf64_section_addr      =(( 0 :: nat))
           , elf64_section_offset    = stroff
           , elf64_section_size      = strsz
           , elf64_section_link      =(( 0 :: nat))
           , elf64_section_info      =(( 0 :: nat))
           , elf64_section_align =(( 1 :: nat))
           , elf64_section_entsize   =(( 0 :: nat))
           , elf64_section_body = (Sequence(List.map Elf_Types_Local.unsigned_char_of_char ((String_table.get_base_string strtab))))
           , elf64_section_name_as_string = (''.strtab'')
           |)
        ])
    in
    (let phdrs = ((make_phdrs   a)(maxpagesize   a)(commonpagesize   a) elf_ft_exec img3 all_sections_sorted_with_offsets)
    in
    (| elf64_file_header               = ((| (* fix up hdr with the precise phnum *)
         elf64_ident = ((elf64_ident   hdr))
       , elf64_type = ((elf64_type   hdr))
       , elf64_machine = ((elf64_machine   hdr))
       , elf64_version = ((elf64_version   hdr))
       , elf64_entry = ((elf64_entry   hdr))
       , elf64_phoff = ((elf64_phoff   hdr))
       , elf64_shoff = ((elf64_shoff   hdr))
       , elf64_flags = ((elf64_flags   hdr))
       , elf64_ehsize = ((elf64_ehsize   hdr))
       , elf64_phentsize = ((elf64_phentsize   hdr))
       , elf64_phnum = (Elf_Types_Local.uint16_of_nat (List.length phdrs))
       , elf64_shentsize = ((elf64_shentsize   hdr))
       , elf64_shnum = ((elf64_shnum   hdr))
       , elf64_shstrndx = ((elf64_shstrndx   hdr))
        |))
     , elf64_file_program_header_table = phdrs
     , elf64_file_section_header_table = (elf64_null_section_header # ((Lem_list.mapi (\<lambda> i .  \<lambda> isec1 .  
          (| elf64_sh_name      = ((let s = ((elf64_section_name_as_string   isec1)) in
                                (case  String_table.find_string s shstrtab of
                                    Some n => Elf_Types_Local.uint32_of_nat n
                                    | None => failwith (([(CHR ''i''), (CHR ''n''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR ''n''), (CHR ''a''), (CHR ''l''), (CHR '' ''), (CHR ''e''), (CHR ''r''), (CHR ''r''), (CHR ''o''), (CHR ''r''), (CHR '':''), (CHR '' ''), (CHR ''s''), (CHR ''e''), (CHR ''c''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR '' ''), (CHR ''n''), (CHR ''a''), (CHR ''m''), (CHR ''e''), (CHR '' ''), (Char Nibble6 Nibble0)]) @ (s @ ([(Char Nibble2 Nibble7), (CHR '' ''), (CHR ''n''), (CHR ''o''), (CHR ''t''), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR '' ''), (CHR ''s''), (CHR ''h''), (CHR ''s''), (CHR ''t''), (CHR ''r''), (CHR ''t''), (CHR ''a''), (CHR ''b'')])))
                                )))
           , elf64_sh_type      = (Elf_Types_Local.uint32_of_nat(elf64_section_type   isec1))
           , elf64_sh_flags     = (of_int (int(elf64_section_flags   isec1)))
           , elf64_sh_addr      = (Elf_Types_Local.uint64_of_nat(elf64_section_addr   isec1))
           , elf64_sh_offset    = (Elf_Types_Local.uint64_of_nat(elf64_section_offset   isec1))
           , elf64_sh_size      = (of_int (int(elf64_section_size   isec1)))
           , elf64_sh_link      = (Elf_Types_Local.uint32_of_nat(elf64_section_link   isec1))
           , elf64_sh_info      = (Elf_Types_Local.uint32_of_nat(elf64_section_info   isec1))
           , elf64_sh_addralign = (of_int (int(elf64_section_align   isec1)))
           , elf64_sh_entsize   = (of_int (int(elf64_section_entsize   isec1)))
           |)
     )) (* (zip section_tags_bare section_file_offsets) *) all_sections_sorted_with_offsets))
     , elf64_file_interpreted_segments = ([]) (* do we need to build this? I have HACKed elf_file so that we don't; 
               we assume that all the relevant payload is in the section bodies, 
               as it should be. *)
     , elf64_file_interpreted_sections = (null_elf64_interpreted_section # all_sections_sorted_with_offsets)
     , elf64_file_bits_and_bobs        = ([])
     |))))))))))))))))))))))))))))))))"

end
