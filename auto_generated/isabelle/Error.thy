chapter {* Generated by Lem from error.lem. *}

theory "Error" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import Show*)

(** [error] is a type used to represent potentially failing computations. [Success]
  * marks a successful completion of a computation, whilst [Fail err] marks a failure,
  * with [err] as the reason.
  *)
datatype 'a error
	= Success " 'a "
	| Fail " string "

(** [return] is the monadic lifting function for [error], representing a successful
  * computation.
  *)
(*val return : forall 'a. 'a BBB -> error 'a BBB FFF*)
definition error_return  :: " 'a \<Rightarrow> 'a error "  where 
     " error_return r = ( Success r )"


(*val with_success : forall 'a 'b. error 'a BBB FFF -> 'b BBB -> ('a BBB -> 'b BBB) -> 'b BBB*)
fun with_success  :: " 'a error \<Rightarrow> 'b \<Rightarrow>('a \<Rightarrow> 'b)\<Rightarrow> 'b "  where 
     " with_success (Success s) fl suc = ( suc s )"
|" with_success (Fail err) fl suc = ( fl )" 
declare with_success.simps [simp del]


(** [fail err] represents a failing computation, with error message [err].
  *)
(*val fail : forall 'a. string FFF -> error 'a BBB FFF*)
definition error_fail  :: " string \<Rightarrow> 'a error "  where 
     " error_fail err = ( Fail err )"


(** [(>>=)] is the monadic binding function for [error].
  *)
(*val >>= : forall 'a 'b. error 'a BBB FFF -> ('a BBB -> error 'b BBB FFF) -> error 'b BBB FFF*)
fun error_bind :: " 'a error \<Rightarrow>('a \<Rightarrow> 'b error)\<Rightarrow> 'b error " ("_>>=_" [50,50]50) where 
     " error_bind (Success s) f = ( f s )"
|" error_bind (Fail err) f = ( Fail err )" 
declare error_bind.simps [simp del]

	
(** [as_maybe e] drops an [error] value into a [maybe] value, throwing away
  * error information.
  *)

(*val as_maybe : forall 'a. error 'a BBB FFF -> maybe 'a BBB FFF*)
fun as_maybe  :: " 'a error \<Rightarrow> 'a option "  where 
     " as_maybe (Fail err) = ( None )"
|" as_maybe (Success s) = ( Some s )" 
declare as_maybe.simps [simp del]


(** [repeatM count action] fails if [action] is a failing computation, or
  * successfully produces a list [count] elements long, where each element is
  * the value successfully returned by [action].
  *)
(*val repeatM : forall 'a. natural FFF -> error 'a BBB FFF -> error (list 'a BBB FFF)FFF*)
function (sequential,domintros)  repeatM  :: " nat \<Rightarrow> 'a error \<Rightarrow>('a list)error "  where 
     " repeatM count1 action = (
  if count1 =( 0 :: nat) then
    error_return []
  else
    action >>= (\<lambda> head . 
    repeatM (count1 -( 1 :: nat)) action >>= (\<lambda> tail . 
    error_return (head # tail))))" 
by pat_completeness auto


(** [repeatM' count seed action] is a variant of [repeatM] that acts like [repeatM]
  * apart from any successful result returns a tuple whose second component is [seed]
  * and whose first component is the same as would be returned by [repeatM].
  *)
(*val repeatM' : forall 'a 'b. natural FFF -> 'b BBB -> ('b BBB -> error ('a BBB * 'b BBB DDD)FFF) -> error ((list 'a BBB FFF) * 'b BBB DDD)FFF*)
function (sequential,domintros)  repeatM'  :: " nat \<Rightarrow> 'b \<Rightarrow>('b \<Rightarrow>('a *'b)error)\<Rightarrow>('a list*'b)error "  where 
     " repeatM' count1 seed action = (
  if count1 =( 0 :: nat) then
    error_return ([], seed)
  else
    action seed >>= (\<lambda> (head, seed) . 
    repeatM' (count1 -( 1 :: nat)) seed action >>= (\<lambda> (tail, seed) . 
    error_return ((head # tail), seed))))" 
by pat_completeness auto

	
(** [mapM f xs] maps [f] across [xs], failing if [f] fails on any element of [xs].
  *)
(*val mapM : forall 'a 'b. ('a BBB -> error 'b BBB FFF) -> list 'a BBB FFF -> error (list 'b BBB FFF)FFF*)
function (sequential,domintros)  mapM  :: "('a \<Rightarrow> 'b error)\<Rightarrow> 'a list \<Rightarrow>('b list)error "  where 
     " mapM f ([]) = ( error_return [])"
|" mapM f (x # xs) = (
				f x >>= (\<lambda> hd1 . 
				mapM f xs >>= (\<lambda> tl1 . 
				error_return (hd1 # tl1))))" 
by pat_completeness auto


(** [foldM f e xs] performs a monadic right fold of [f] across [xs] using [e]
  * as the base case.  Fails if any application of [f] fails.
  *)
(*val foldM : forall 'a 'b. ('a BBB -> 'b BBB -> error 'a BBB FFF) -> 'a BBB -> list 'b BBB FFF -> error 'a BBB FFF*)
function (sequential,domintros)  foldM  :: "('a \<Rightarrow> 'b \<Rightarrow> 'a error)\<Rightarrow> 'a  \<Rightarrow> 'b list \<Rightarrow> 'a error "  where 
     " foldM f e ([]) = ( error_return e )"
|" foldM f e (x # xs) = ( f e x >>= (\<lambda> res .  foldM f res xs))" 
by pat_completeness auto


(** [string_of_error err] produces a string representation of [err].
  *)
(*val string_of_error : forall 'a. Show 'a => error 'a BBB FFF -> string FFF*)

lemma error_bind_cong [fundef_cong]:
  "(map_error f x = map_error f' x') \<Longrightarrow> error_bind x f = error_bind x' f'"
  by (cases x; cases x') (simp_all add: error_bind.simps)

lemma set_error_fail [simp]:
  shows "set_error (error_fail msg) = {}"
by (simp add: error_fail_def)

lemma set_error_return [simp]:
  shows "set_error (error_return x) = {x}"
by (simp add: error_return_def)

end
