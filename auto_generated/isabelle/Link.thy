chapter {* Generated by Lem from link.lem. *}

theory "Link" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set_extra" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Endianness" 
	 "Elf_types_native_uint" 
	 "Default_printing" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_relocation" 
	 "Memory_image" 
	 "Memory_image_orderings" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_amd64_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abis" 
	 "Elf_memory_image" 
	 "Command_line" 
	 "Input_list" 
	 "Elf_memory_image_of_elf64_file" 
	 "Linkable_list" 
	 "Linker_script" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*open import Set*)
(*import Set_extra*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*import Command_line*)
(*import Input_list*)

(*open import Byte_sequence*)
(*open import Default_printing*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)
(*open import Endianness*)

(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_section_header_table*)
(*open import Elf_program_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)

(*open import Abis*)
(*open import Abi_amd64_relocation*) (* HACK -- remove me *)

(*open import Input_list*)
(*open import Linkable_list*)
(*import Command_line*)

(*open import Memory_image*)
(*open import Memory_image_orderings*)
(*open import Elf_memory_image*)
(*open import Elf_memory_image_of_elf64_file*)
(*open import Linker_script*)

definition all_common_symbols  :: "(any_abi_feature)annotated_memory_image \<Rightarrow>(symbol_definition)list "  where 
     " all_common_symbols img3 = ( List.filter (\<lambda> def1 .  
    unat(elf64_st_shndx  (def_syment   def1)) = shn_common
) (elf_memory_image_defined_symbols img3))"


(* Q. On what does the decision about a reloc depend? definitely on
 * 
 *      -- command-line options applying to the referenc*ed* object;
 *           (CHECK: I'm inferring that -Bsymbolic, like -Bstatic, applies to the 
 *                   *referenced* object, not the referring -- need experimental conf.)
 *            ACTUALLY, it seems to be global: if a definition goes in the library,
 *                   bind to it; doesn't matter where it comes from. So
 * 
 *      -- command-line options applying to the output object / whole link (-Bsymbolic);
 * 
 *      -- command-line options applying to the referencing object?
 * 
 *      What decision can we make?  
 *      Given a reloc, it might be 
 *      - not bound (weak symbols) -- THIS MEANS it *is* bound but to the value 0!
 *      - bound to a definition
 *
 *      ... perhaps our distinction is between firm binding or provisional binding?
 *                                            final binding or overridable binding?
 * 
 *      Can we also hit cases where the binding is final but can't be relocated til load time?
 *      YES, e.g. any final R_*_64_64 reference in a shared library's data segment.
 *      WHAT do we do in these cases? Apply what we can and generate a R_*_RELATIVE?
 *      Yes, that's where R_*_RELATIVE come from, since they don't appear in .o inputs.
 *)

(*val def_is_in_reloc : linkable_item -> bool*)
fun def_is_in_reloc  :: " linkable_object*(string*input_blob*input_origin)*input_options \<Rightarrow> bool "  where 
     " def_is_in_reloc (RelocELF(_), _, _) = ( True )"
|" def_is_in_reloc (ScriptAST(_), _, _) = ( True )"
|" def_is_in_reloc _ = ( False )" 
declare def_is_in_reloc.simps [simp del]


definition retrieve_binding_for_ref  :: " 'b Show_class \<Rightarrow> 'd Show_class \<Rightarrow> 'e Show_class \<Rightarrow> symbol_reference_and_reloc_site \<Rightarrow> 'e \<Rightarrow> 'd \<Rightarrow>((string),(('a*(('e*symbol_reference*'f)*('b*symbol_definition*'c)option))list))Map.map \<Rightarrow>('e*symbol_reference*'f)*('b*symbol_definition*'c)option "  where 
     " retrieve_binding_for_ref dict_Show_Show_b dict_Show_Show_d dict_Show_Show_e r r_linkable_idx item bindings_by_name = ( 
    (let maybe_found_bs = ( bindings_by_name(ref_symname  (ref   r)))
    in 
    (case  maybe_found_bs of
        None => failwith (''impossible: list of bindings does not include symbol reference (map empty)'')
            (* FIXME: could this actually be an undefined symbol link error perhaps? *)
        | Some bis_and_bs => (case  List.filter (\<lambda> (b_idx, ((b_ref_idx, b_ref, b_ref_item), b_maybe_def)) .  
            if (b_ref_idx = r_linkable_idx) \<and> (b_ref =(ref   r)) then 
            (let _ = (())
            in True)
            else False) bis_and_bs of
                  [] => failwith (''impossible: list of bindings does not include symbol reference (filtered list empty)'')
                | [(bi, b)] => b
                | _ =>  failwith (([(CHR ''i''), (CHR ''m''), (CHR ''p''), (CHR ''o''), (CHR ''s''), (CHR ''s''), (CHR ''i''), (CHR ''b''), (CHR ''l''), (CHR ''e''), (CHR '':''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''s''), (CHR ''t''), (CHR '' ''), (CHR ''o''), (CHR ''f''), (CHR '' ''), (CHR ''b''), (CHR ''i''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''n''), (CHR ''g''), (CHR ''s''), (CHR '' ''), (CHR ''b''), (CHR ''i''), (CHR ''n''), (CHR ''d''), (CHR ''s''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''f''), (CHR ''e''), (CHR ''r''), (CHR ''e''), (CHR ''n''), (CHR ''c''), (CHR ''e''), (CHR '' ''), (CHR ''t''), (CHR ''o''), (CHR '' ''), (CHR ''s''), (CHR ''y''), (CHR ''m''), (CHR ''b''), (CHR ''o''), (CHR ''l''), (CHR '' ''), (Char Nibble6 Nibble0)])
                    @ ((ref_symname  (ref   r)) @ ([(Char Nibble2 Nibble7), (CHR '' ''), (CHR ''m''), (CHR ''o''), (CHR ''r''), (CHR ''e''), (CHR '' ''), (CHR ''t''), (CHR ''h''), (CHR ''a''), (CHR ''n''), (CHR '' ''), (CHR ''o''), (CHR ''n''), (CHR ''e''), (CHR '' ''), (CHR ''w''), (CHR ''a''), (CHR ''y''), (CHR '' ''), (CHR ''(''), (CHR ''f''), (CHR ''i''), (CHR ''l''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR ''e''), (CHR ''d''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''s''), (CHR ''t''), (CHR '' ''), (CHR ''h''), (CHR ''a''), (CHR ''s''), (CHR '' ''), (CHR ''>''), (CHR ''1''), (CHR '' ''), (CHR ''e''), (CHR ''l''), (CHR ''e''), (CHR ''m''), (CHR ''e''), (CHR ''n''), (CHR ''t''), (CHR '')'')])))
            )
    )))"


type_synonym reloc_site_resolution =" reloc_site * binding * reloc_decision "


(*val mark_fate_of_relocs : natural -> abi any_abi_feature -> set Command_line.link_option -> 
    binding_map -> linkable_item -> elf_memory_image -> ((list reloc_site_resolution) * elf_memory_image)*)
definition mark_fate_of_relocs  :: " nat \<Rightarrow>(any_abi_feature)abi \<Rightarrow>(Command_line.link_option)set \<Rightarrow>((string),((nat*((nat*symbol_reference*(linkable_object*input_item*input_options))*(nat*symbol_definition*(linkable_object*input_item*input_options))option))list))Map.map \<Rightarrow> linkable_object*input_item*input_options \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow>(reloc_site*((nat*symbol_reference*(linkable_object*input_item*input_options))*(nat*symbol_definition*(linkable_object*input_item*input_options))option)*reloc_decision)list*(any_abi_feature)annotated_memory_image "  where 
     " mark_fate_of_relocs linkable_idx a options bindings_by_name item img3 = ( 
    (* Our image already models relocation sites. For each relocation *record*,
     * we use our bindings to make a decision about whether to apply it or not.
     * 
     * Q1. How do we get the .rela.dyn made? Synthesise a fake reloc section?
     * Or pass them through to the linker script separately?
     * AHA. Note that the script already has an entry for .rela.dyn.
     * And it matches the ordinary rel sections, e.g. .rela.text and so on.
     * So if -q is active, the applied relocs need to be injected back in *after* the script
     * has run.
     * So we need both to materialize some relocs into the script inputs, *and* save some for later. 
     * 
     * Can we just use memory image metadata as the saved for later case? YES, I think so.
     * What do we do with metadata that is now being materialized?
     * I think we should only remove the metadata when we apply the relocation.
     * Q. When do we do that?
     * A. *After* address assignment has happened, i.e. all sections are allocated.
     *)
    (let building_executable = ((op \<in>) (Command_line.OutputKind(Command_line.Executable)) options) in
    (let building_shared_library = ((op \<in>) (Command_line.OutputKind(Command_line.SharedLibrary)) options) in
    (let bind_functions_early = ((op \<in>) Command_line.BindFunctionsEarly options) in
    (let bind_non_functions_early = ((op \<in>) Command_line.BindNonFunctionsEarly options) in
    (let (new_by_tag, rev_decisions) = (List.foldl (\<lambda> (acc_by_tag, rev_acc_decisions) .  (\<lambda> (tag, maybe_range) .  
        (let pass_through = (Set.insert (tag, maybe_range) acc_by_tag, rev_acc_decisions)
        in
        (case  tag of 
            SymbolRef(r) => 
                (case (maybe_reloc   r) of 
                    Some reloc1 => 
                        (* decision: do we want to
                         *  - apply it?   if so, do we need a consequent relocation (e.g. R_*_RELATIVE) in the output?
                         *  - PICify it, but leave it interposable?    
                         *  - is PICified, non-interposable a thing? I don't think so, because non-interposable bindings are 
                                     either intra-object *or* necessarily need load-time relocation to account for load addresses.
                                     In fact ELF can't express non-interposable inter-object bindings because we can't name
                                     specific objects when binding symbols.
                         *  - leave it alone, i.e. relocate at load time?
                         * 
                         * Some useful questions: is the binding final? 
                         * The GNU linker *never* leaves text relocs alone when generating shared libs; 
                         * it always PICifies them.
                         * It can leave them alone when generating executables, though.
                         * This is an approximation; load-time text relocation can make sense for shared libs.
                         *     (but it's dangerous because PC32 relocs might overflow)
                         *)
                        (let (binding_is_final :: Command_line.link_option set \<Rightarrow> binding \<Rightarrow> bool)
                         = (\<lambda> options .  (\<lambda> ((ref_idx, ref1, ref_item), maybe_def) .  
                            (case  maybe_def of 
                                (* Weak bindings to 0 are final (though libcrunch wishes they weren't!). *)
                                None => True
                                | Some (def_idx, def1, def_item) =>                                    
(
                                    (* Bindings to non-global symbols are final. *)get_elf64_symbol_binding(def_syment   def1) = stb_local)
                                    \<or>                                    
(
                                    (* Bindings to hidden- or protected- or internal-visibility globals 
                                     *    are final. *)(op \<in>) (get_symbol_visibility(elf64_st_info  (def_syment   def1))) ({ stv_hidden, stv_protected, stv_internal })
                                    \<or>                                    
(
                                    (* Bindings to global symbols are non-final
                                     *    *unless* 
                                     *      1. the symbol definition is [going to end up] in the executable
                                     *      2. we're -Bsymbolic, outputting a shared object,
                                     *           and the symbol definition is [going to end up] within the same shared object
                                     *      3. we're -Bsymbolic-functions, outputting a shared object,
                                     *           and the symbol definition has STT_FUNC and is [going to end up] within the same shared object
                                     *
                                     * ... where going to end up in an X means we're building an X and def is in a RelocELF rather than a SharedELF.
                                     *)
                                    (* 1. *)(building_executable \<and> def_is_in_reloc def_item) \<or>
                                    (* 2 and 3. *)
                                    (building_shared_library \<and> (def_is_in_reloc def_item \<and> 
                                        (  (((get_elf64_symbol_type(def_syment   def1)) = stt_func)  \<and> bind_functions_early)
                                        \<or> ( \<not> ((get_elf64_symbol_type(def_syment   def1)) = stt_func) \<and> bind_non_functions_early)
                                        ))
                                    )))
                                    (* FIXME: does it matter if the binding is intra-object or inter-object?
                                     * We don't get inter-object bindings much to non-{default global}s. How much? *)
                            )))
                        in
                        (let (reloc_is_absolute :: reloc_site \<Rightarrow> bool) = (\<lambda> rs .  
                            (let kind = (get_elf64_relocation_a_type(ref_relent   rs)) in 
                            (let (is_abs, _) = ((reloc   a) kind) in
                            is_abs)))
                        in
                        (* What's our decision for this reloc? leave, apply, MakePIC? 
                         * In fact we return both a decision and a maybe-function to create
                         * the consequent reloc. 
                         * In what circumstances do we leave the reloc? If we're making an executable
                               and the definition is not in a relocatable input file or archive or script.
                               Or if we're making a shared library and the reference is from data.
                               What does from data mean? I think it means it's a PC-relative reloc. 
                               If we compile our code to do movabs $addr, even from a *local* address,
                               it's not PIC because that address needs load-time fixup.
                               So actually it's is absolute address again.
                         *)
                        (let b = (retrieve_binding_for_ref 
  instance_Show_Show_Num_natural_dict (instance_Show_Show_tup3_dict
   instance_Show_Show_Linkable_list_linkable_object_dict
   (instance_Show_Show_tup3_dict instance_Show_Show_string_dict
      instance_Show_Show_Input_list_input_blob_dict
      (instance_Show_Show_tup2_dict
         Command_line.instance_Show_Show_Command_line_input_unit_dict
         (instance_Show_Show_list_dict
            instance_Show_Show_Input_list_origin_coord_dict)))
   instance_Show_Show_Input_list_input_options_dict) instance_Show_Show_Num_natural_dict r linkable_idx item bindings_by_name)
                        in
                        (let ((ref_idx, _, ref_item), maybe_def) = b
                        in
                        (let defined_in_shared_lib = ((case  maybe_def of
                            Some (def_idx, def1, def_item) => \<not> (def_is_in_reloc def_item)
                            | None => False (* i.e. the definition, 0, can be linked in *)
                        ))
                        in
                        (let decide = (\<lambda> decision .  (                            
((let _ = (())
                            in
                            Set.insert (SymbolRef((|
                                ref           = ((ref   r))
                                , maybe_reloc = ((maybe_reloc   r))
                                , maybe_def_bound_to = (Some (decision, 
                                    (case  maybe_def of
                                        Some(def_idx, def1, def_item) => 
                                                Some (| def_symname = ((def_symname   def1))
                                                      , def_syment  = ((def_syment   def1))
                                                      , def_sym_scn = ((def_sym_scn   def1))
                                                      , def_sym_idx = ((def_sym_idx   def1))
                                                      , def_linkable_idx = def_idx 
                                                      |)
                                        | None => None
                                    )
                                    ))
                                |)
                            ), maybe_range) acc_by_tag)),                            
((reloc1, b, decision) # rev_acc_decisions)))
                        in
                        if (building_executable \<and> defined_in_shared_lib)
                        \<or> (building_shared_library \<and> (reloc_is_absolute reloc1)) 
                        then decide LeaveReloc
                        else
                        (* In what circumstances do we apply the reloc? If it's a final binding. *)
                        if binding_is_final options b then decide ApplyReloc
                        (* In what circumstances do we MakePIC? If it's a non-absolute relocatable field
                         *     and we're building a shared library. 
                         * 
                         * PIC is a kind of consequent relocation, so let's think through it. 
                         * A call site that calls <printf>      will usually be non-final (overridable).
                         * Output needs to call   <printf@plt>. BUT the trick is as follows:
                         *        the reloc is swizzled so that it binds to the PLT slot <printf@plt>;
                         *        the PLT slot is locally generated, so no reloc is needed.
                         * So the point is that
                         *        a *non*-applied reloc
                         *        might still need applying after a fashion (swizzling).
                         * The initial reloc is removed! Since PLT means removing relocs from code
                         * and reproducing their effect using a PLT.
                         * That's why we need this special MakePIC behaviour.
                         * Actually, generalise to a ChangeRelocTo.
                         * 
                         * What about data?
                         * Suppose I have a shared library containing a read-only pointer to <environ>.
                         * The binding is final because <environ> is defined in the executable, say.
                         * PIC doesn't handle this case -- we still need load-time relocation.
                         * It's PIC, not PID: data can't be made position-independent.
                         *
                         * So, at least for simple cases of PIC, we don't need consequent relocation if
                         * we don't apply the reloc. We'll be removing the reloc. But we *do* need to create 
                         * extra stuff later (PLT, GOT).
                         *)
                        else if building_shared_library then decide (* MakePIC *) (ChangeRelocTo(( 0 :: nat),(ref   r), reloc1)) (* FIXME *)
                        (* The above are non-exclusive and non-exhaustive. Often, more than one option is available,
                         * ABIs / practice makes an arbitrary choice. For example, final bindings
                         * within a library could be realised the PIC way, but aren't (it'd create a 
                         * pointless indirection). *)
                        else failwith ([(CHR ''d''), (CHR ''i''), (CHR ''d''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''k''), (CHR ''n''), (CHR ''o''), (CHR ''w''), (CHR '' ''), (CHR ''w''), (CHR ''h''), (CHR ''a''), (CHR ''t''), (CHR '' ''), (CHR ''t''), (CHR ''o''), (CHR '' ''), (CHR ''d''), (CHR ''o''), (CHR '' ''), (CHR ''w''), (CHR ''i''), (CHR ''t''), (CHR ''h''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''l''), (CHR ''o''), (CHR ''c''), (CHR ''a''), (CHR ''t''), (CHR ''i''), (CHR ''o''), (CHR ''n'')])))))))
                    | None => 
                        (* symbol ref with no reloc *)
                        pass_through
                )
        |   _ => pass_through
        ))
    )) ({}, []) (list_of_set(by_tag   img3)))
    in
    (List.rev rev_decisions, (| elements = ((elements   img3))
      , by_range = (by_range_from_by_tag new_by_tag), by_tag = new_by_tag
        
      |))))))))"


(*val strip_metadata_sections : list (reloc_site * binding * reloc_decision) -> abi any_abi_feature -> elf_memory_image -> elf_memory_image*)
definition strip_metadata_sections  :: "(reloc_site*((nat*symbol_reference*linkable_item)*(nat*symbol_definition*linkable_item)option)*reloc_decision)list \<Rightarrow>(any_abi_feature)abi \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow>(any_abi_feature)annotated_memory_image "  where 
     " strip_metadata_sections reloc_decisions a img3 = ( 
    (let (section_tags, section_ranges) = (elf_memory_image_section_ranges img3)
    in
    (let rel_sections = (Lem_list.mapMaybe (\<lambda> (range_tag, (el_name, el_range)) .  
        (case  range_tag of
            FileFeature(ElfSection(idx1, isec1)) => 
                if (op \<in>) ((elf64_section_type   isec1)) ({ sht_rel, sht_rela })
                then Some (idx1, isec1, el_name)
                else None
            | _ => None
        )
    ) (List.zip section_tags section_ranges))
    in
    (let discarded_sections_with_element_name = (Lem_list.mapMaybe (\<lambda> (range_tag, (el_name, el_range)) .  
        (case  range_tag of
            FileFeature(ElfSection(idx1, isec1)) => 
                if(section_is_special   a) isec1 img3 (* discard reloc sections, and we'll re-add them *)
                then Some (el_name, range_tag) else None
        )
    ) (List.zip section_tags section_ranges))
    in
    (let discarded_elements_map = (List.foldl (\<lambda> m .  (\<lambda> (el_name, range_tag) .  
        (let _ = (()) in
        map_update el_name range_tag m)
        )) Map.empty discarded_sections_with_element_name)
    in
    (let filtered_image = (Memory_image.filter_elements (\<lambda> (el_name, el) .  \<not> (el_name \<in> Map.dom discarded_elements_map)) img3)
    in
    (let new_reloc_section_length = (\<lambda> idx1 .  (\<lambda> isec1 .  
        (let retained_relocs_from_this_section = ((let x2 = 
  ([]) in  List.foldr
   (\<lambda>(reloc1, b, decision) x2 . 
    if
    ((ref_rel_scn   (* is it from this section? *) reloc1) = idx1)
      (* are we retaining it? *) \<and> (decision = LeaveReloc) then
      (reloc1, b, decision) # x2 else x2) reloc_decisions x2))
        in (List.length retained_relocs_from_this_section) *(elf64_section_entsize   isec1))
    ))
    in
    (let (new_reloc_elements, new_reloc_tags_and_ranges) = (list_unzip ((let x2 = 
  ([]) in  List.foldr
   (\<lambda>(idx1, isec1, el_name) x2 . 
    if new_reloc_section_length idx1 isec1 > ( 0 :: nat) then
      ((let new_len = (new_reloc_section_length idx1 isec1) in
       (let new_el = ((| startpos = None , length1 = (Some new_len), contents = 
                      ([]) |)) in
       (let new_isec = ((| elf64_section_name = ((elf64_section_name   isec1))
                        , elf64_section_type = ((elf64_section_type   isec1))
                        , elf64_section_flags = ((elf64_section_flags   isec1))
                        , elf64_section_addr =(( 0 :: nat)) (* should be 0 anyway *)
                        , elf64_section_offset =(( 0 :: nat)) (* ignored *)
                        , elf64_section_size = new_len
                        , elf64_section_link = ((elf64_section_link   isec1))
                        , elf64_section_info = ((elf64_section_info   isec1))
                        , elf64_section_align = ((elf64_section_align   isec1))
                        , elf64_section_entsize = ((elf64_section_entsize   isec1))
                        , elf64_section_body = Byte_sequence.empty (* ignored *)
                        , elf64_section_name_as_string = ((elf64_section_name_as_string   isec1))
                        |)) in
       (let new_meta = (FileFeature (ElfSection (idx1, new_isec))) in
       ((el_name, new_el), (new_meta, Some (el_name, (( 0 :: nat), new_len)))))))))
        # x2 else x2) rel_sections x2)))
    in
    (let new_by_tag = (\<Union> {(by_tag   filtered_image), List.set new_reloc_tags_and_ranges })
    in
    (|
        elements = (List.foldr (op++) [(elements   filtered_image), Map.map_of (List.rev new_reloc_elements)] Map.empty)
     ,  by_range = (by_range_from_by_tag new_by_tag),  by_tag   = new_by_tag
      
     |))))))))))"

     

definition expand_sections_for_one_image  :: "(any_abi_feature)abi \<Rightarrow>(Command_line.link_option)set \<Rightarrow>((string),((nat*binding)list))Map.map \<Rightarrow> nat \<Rightarrow> linkable_object*input_item*input_options \<Rightarrow> bool \<Rightarrow>(reloc_site*binding*reloc_decision)list*(any_abi_feature)annotated_memory_image*(input_spec)list "  where 
     " expand_sections_for_one_image a options bindings_by_name linkable_idx item strip_relocs = ( 
    (case  item of
    (RelocELF(img3), (fname1, blob, origin), input_opts) => 
        (*let _ = List.foldl (fun _ -> fun (isec, shndx) ->  
            let _ = errln (For file  ^ fname ^  before stripping, saw section idx  ^ (show shndx) ^ 
                 with name  ^ isec.elf64_section_name_as_string ^ , first 20 bytes:  ^ (show (take 20 (
                    (let maybe_elname = elf_memory_image_element_coextensive_with_section shndx img
                     in
                     match maybe_elname with
                        Nothing -> failwith (impossible: no such section ( ^ (show shndx) ^ ) in image of  ^ fname)
                        | Just idstr -> 
                            match Map.lookup idstr img.elements with
                                Just el -> el.contents
                                | Nothing -> failwith no such element
                            end
                    end
                    )))))
                in
                ()
            ) () (elf_memory_image_sections_with_indices img)
        in*)
        (let ((reloc_decisions :: (reloc_site * binding * reloc_decision) list), marked_img) = (mark_fate_of_relocs linkable_idx a options bindings_by_name item img3)
        in 
        (* Now we have a decision for each reloc: Leave, Apply, MakePIC. Which ones
         * do we materialize? Only the Leave ones, for now. To support -q we'll 
         * have to support tweaking this.
         * 
         * For each relocation that we Leave, we figure out its originating section 
         * and re-create a lookalike in the memory image. 
         * 
         * We also get called for the generated memory image that contains .plt, 
         * .rela.plt and so on. We don't strip these, since they actually contain relocs
         * that need to go directly into the output file. That's what the strip_relocs
         * argument is for. FIXME: refactor this into two functions.
         *)
        (let stripped_img_with_reloc_sections = (if strip_relocs
            then (let _ = (()) in
            strip_metadata_sections reloc_decisions a marked_img) 
            else marked_img)
        in
        (* Now we have a whole new image! It differs from the old one in that 
         * - non-special sections have been stripped
         * - the relocs we want to participate in linking have been materialized.
         *)
        (* The -q option is tricky. It causes all incoming relocs to be retained, but 
         * they *don't* participate in linking -- notice that the default linker script
         * pulls all .rela.* sections into .rela.dyn, whereas these ones *don't* go in there.
         * So FIXME: to support this, we need a way to re-add them, probably when we 
         * generate meta-output like .symtab etc.. *)
        (let inputs1 = 
        (((let x2 = ([]) (* not (a.section_is_special isec img *)in  
  List.foldr
    (\<lambda>(isec1, shndx1) x2 . 
     if True then
       ((let short_name = (short_string_of_linkable_item item) in
        (let _ = (()) in
        InputSection
          ((| idx = linkable_idx , fname = short_name
           , img = stripped_img_with_reloc_sections , shndx = shndx1
           , secname = ((elf64_section_name_as_string   isec1))
           , isec = isec1 |))))) # x2 else x2)
    (elf_memory_image_sections_with_indices stripped_img_with_reloc_sections)
    x2))
        @ (
        (* One item per common symbol. FIXME: what about common symbols that have the same name? 
         * We need to explicitly instantiate common symbols somewhere, probably here. 
         * This means dropping any that are unreferenced (does it?) and merging any multiply-defined.
         * Actually, we deal with section merging at the same time as section concatenation, so during
         * linker script processing. For discarding unused common symbols, I *think* that this has already
         * been done by discarding unreferenced inputs.  *)
        (let common_symbols = (all_common_symbols stripped_img_with_reloc_sections)
        in
        (*let _ = errln (Expanding  ^ (show (length common_symbols)) ^  common symbols)
        in*)
        (let x2 = ([]) in  List.foldr
   (\<lambda>def1 x2 . 
    if (let _ = (()) in True) then
      Common (linkable_idx, fname1, stripped_img_with_reloc_sections, def1) #
        x2 else x2) common_symbols x2))
        ))
        in (reloc_decisions, stripped_img_with_reloc_sections, inputs1))))
    | _ => failwith (''non-reloc linkable not supported yet'')
))"


type_synonym reloc_resolution =" reloc_site * binding * reloc_decision "

(*val default_merge_generated : abi any_abi_feature -> elf_memory_image -> list (list Linker_script.input_spec) -> list (list Linker_script.input_spec)*)
definition default_merge_generated  :: "(any_abi_feature)abi \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow>((input_spec)list)list \<Rightarrow>((input_spec)list)list "  where 
     " default_merge_generated a generated_img input_spec_lists = ( 
    (* We expand the sections in the generated image and hang them off
     * the first linkable item. *) 
    (let _ = (())
    in
    (let dummy_input_item = ((''(no file)''), Input_list.Reloc(Sequence([])), ((Command_line.File(Command_line.Filename((''(no file)'')), Command_line.null_input_file_options)), [InCommandLine(( 0 :: nat))]))
    in 
    (let dummy_linkable_item = (RelocELF(generated_img), dummy_input_item, Input_list.null_input_options)
    in
    (let (_, _, generated_inputs) = (expand_sections_for_one_image a {} Map.empty(( 0 :: nat)) dummy_linkable_item False)
    in
    (let _ = (())
    in
    (* okay, hang them off the first one *)
    (case  input_spec_lists of
        [] => failwith (''link job empty'')
        | first_input_list # more_input_lists => (first_input_list @ generated_inputs) # more_input_lists
    )))))))"

    (* input_spec_lists *)

(*val expand_sections_for_all_inputs : abi any_abi_feature -> set Command_line.link_option -> binding_map ->
    (abi any_abi_feature -> elf_memory_image -> list (list Linker_script.input_spec) -> list (list Linker_script.input_spec)) (* merge_generated *) -> 
    list (natural * Linkable_list.linkable_item) -> 
    list (list reloc_resolution * elf_memory_image * list Linker_script.input_spec)*)
definition expand_sections_for_all_inputs  :: "(any_abi_feature)abi \<Rightarrow>(Command_line.link_option)set \<Rightarrow>((string),((nat*binding)list))Map.map \<Rightarrow>((any_abi_feature)abi \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow>((input_spec)list)list \<Rightarrow>((input_spec)list)list)\<Rightarrow>(nat*(linkable_object*input_item*input_options))list \<Rightarrow>((reloc_site*binding*reloc_decision)list*(any_abi_feature)annotated_memory_image*(input_spec)list)list "  where 
     " expand_sections_for_all_inputs a options bindings_by_name merge_generated idx_and_linkables = ( 
    (let (expanded_reloc_lists, expanded_imgs, linker_script_input_lists) = (unzip3 (List.map (\<lambda> (idx1, linkable) .  
        expand_sections_for_one_image a options bindings_by_name idx1 linkable True) idx_and_linkables))
    in
    (let fnames = (List.map (\<lambda> (idx1, (_, (fname1, _, _), _)) .  fname1) idx_and_linkables)
    in
    (* We pass the collection of linkable images and reloc decision lists 
     * to an ABI tap function. 
     * 
     * This returns us a new *image* containing all the elements. Logically
     * this is another participant in the link, which we could expand separately.
     * A personality function takes care of actually merging it back into the 
     * linker script inputs... in the case of the GNU linker, this means pretending
     * the generated stuff came from the first input object.
     *)
    (let generated_img = ((generate_support   a) (* expanded_relocs *) (List.zip fnames expanded_imgs))
    in
    (* We need to return a 
     * 
     *    list (list reloc_decision * elf_memory_image * list Linker_script.input_spec)
     *
     * i.e. one item for every input image. *)
    (let (final_input_spec_lists :: ( Linker_script.input_spec list) list) = (merge_generated a generated_img linker_script_input_lists)
    in
    zip3 expanded_reloc_lists expanded_imgs final_input_spec_lists)))))"


(*val relocate_output_image : abi any_abi_feature -> map string (list (natural * binding)) -> elf_memory_image -> elf_memory_image*)
definition relocate_output_image  :: "(any_abi_feature)abi \<Rightarrow>((string),((nat*binding)list))Map.map \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow>(any_abi_feature)annotated_memory_image "  where 
     " relocate_output_image a bindings_by_name img3 = ( 
    (let relocs = (Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     instance_Basic_classes_Ord_Abis_any_abi_feature_dict) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      Lem_string_extra.instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (Memory_image_orderings.tagEquiv
    instance_Abi_classes_AbiFeatureTagEquiv_Abis_any_abi_feature_dict) (SymbolRef(null_symbol_reference_and_reloc_site))(by_tag  
        img3))
    in
    
    (*let _ = errln (For __libc_multiple_threads (in relocate_output_image), we have  ^ 
        (let all_bs = match Map.lookup __libc_multiple_threads bindings_by_name with
            Just l -> l
            | Nothing -> []
        end
        in
        ((show (length all_bs)) ^ 
         bindings, of which  ^ 
        (show (length (List.filter (fun (bi, ((ref_idx, ref, ref_item), maybe_def)) -> 
            match maybe_def with
                Just _ -> true
                | _ -> false
            end
        ) all_bs))) ^  have defs)))
    in*)
    (let apply_reloc = (\<lambda> img3 .  \<lambda> (el_name, start, len) .  \<lambda> symref_and_reloc_site .  \<lambda> symaddr .  (
        (let reloc_site = ((case (maybe_reloc   symref_and_reloc_site) of
            None => failwith (''impossible: no reloc site during relocation'')
            | Some r => r
        ))
        in
        (let (field_is_absolute_addr, applyfn) = ((reloc   a) (get_elf64_relocation_a_type(ref_relent   reloc_site)))
        in
        (let element = ((case  (elements   img3) el_name of
            None => failwith (''impossible: reloc site in nonexistent section'')
            | Some e => e
        ))
        in
        (let site_address = ((case (startpos   element) of
            Some addr => addr + start
            | None => failwith (''error: relocation in section with no address'')
        ))
        in
        (let (width, calculate) = (applyfn img3 site_address symref_and_reloc_site)
        in
        (let existing_field = (extract_natural_field width element start)
        in
        (let _ = (())
        in
        (let _ = (())
        in
        (let addend = (sint(elf64_ra_addend  (ref_relent   reloc_site)))
        in
        (let new_field_value = (calculate symaddr addend existing_field)
        in
        (let _ = (())
        in
        (let new_element = (write_natural_field new_field_value width element start)
        in
        (|
            elements = (map_update el_name new_element (map_remove el_name(elements   img3)))
         ,  by_range = ((by_range   img3) - {(Some(el_name, (start, len)), SymbolRef(symref_and_reloc_site))}),  by_tag   = ((by_tag   img3) - {(SymbolRef(symref_and_reloc_site), Some(el_name, (start, len)))})
          
         |)))))))))))))
    ))
    in
    (let relocated_img = (List.foldl (\<lambda> acc_img .  (\<lambda> (tag, maybe_range) . 
        (case  tag of 
            SymbolRef(x) => (case (maybe_reloc   x) of
                Some rs => 
                    (case  maybe_range of
                        None => failwith (''impossible: reloc site with no range'')
                        | Some (el_name, (start, len)) => 
                            (let _ = (())
                            in
                            (let symaddr = ((case (maybe_def_bound_to   x) of
                                Some(ApplyReloc, Some(bound_def)) =>(get_reloc_symaddr  
                                    (* Here we are mapping
                                     * *from* the definition found in an input object during resolution (bound_def)
                                     * *to* the corresponding symbol in the output image, now that we've built it.
                                     *
                                     * Q. What about ABI-specific interventions, e.g.
                                     * redirecting a symbol reference to its GOT or PLT slot?
                                     * A. Indeed, we need to ask the ABI to give us the target
                                     * address. The default implementation is just to look for
                                     * a matching symbol and use its address. But ABIs can do
                                     * wacky things if they like.
                                     *)
                                    a) bound_def img3(maybe_reloc   x)
                                | None => failwith (''no def found for bound-to symbol'')
                                | Some(ApplyReloc, None) => 
                                    (let _ = (())
                                    in
                                    (* CHECK: does the syment say it's weak? *)
                                    if \<not> ((get_elf64_symbol_binding(ref_syment  (ref   x))) = stb_weak) then
                                        (*let _ = errln Actually not weak! bailing
                                        in*)
                                        failwith (''not a weak reference, but no binding'')
                                    else(  
                                    (* Weak symbol. *)0 :: nat))
                                | Some(LeaveReloc, _) => 
                                    (* We shouldn't be seeing this, given that we're applying the reloc Right Now. *)
                                    failwith (''internal error: applying reloc that is not to be applied'')
                            ))
                            in
                            (*let _ = errln (Got symaddr: 0x ^ (hex_string_of_natural symaddr))
                            in*)
                            apply_reloc acc_img (el_name, start, len) x symaddr))
                    )
                | None => (* okay, do nothing *) acc_img
                )
            | _ => failwith (''impossible: not a symbol ref'')
        )
    )) img3 relocs)
    in
    relocated_img))))"


(*val link : address_expr_fn_map allocated_sections_map -> linker_control_script -> abi any_abi_feature -> set Command_line.link_option -> linkable_list -> elf_memory_image*)
definition link  :: "((address_expr_fn_ref),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow>(script_element)list \<Rightarrow>(any_abi_feature)abi \<Rightarrow>(Command_line.link_option)set \<Rightarrow>(linkable_object*(string*input_blob*input_origin)*input_options)list \<Rightarrow>(any_abi_feature)annotated_memory_image "  where 
     " link alloc_map script a options linkables = ( 
    (let initial_included_indices = (mapMaybei (\<lambda> i .  (\<lambda> (obj, inp, (opts :: input_options)) .  
        if(item_force_output   opts) 
        then Some i
        else None
    )) linkables)
    in
    (let linker_script_linkable_idx = (List.length linkables)
    in
    (let defmap =  (all_definitions_by_name linkables)
    in
    (let (accumulated_bindings :: binding list)
     =          
( (* accumulate_bindings_bf a linkables defmap {} initial_included_indices []  *)accumulate_bindings_objectwise_df a linkables defmap [] {} initial_included_indices)
    in
    (* Keep a map whose keys are referenced objects, and whose values are 
     * *some* (diagnostic purposes only) reference to that linkable. *)
    (let referenced_object_indices_and_reasons = (List.foldl (\<lambda> acc_m .  (\<lambda> ((ref_idx, ref_sym, ref_linkable), maybe_def_idx_and_sym_and_linkable) .  
        (case  maybe_def_idx_and_sym_and_linkable of
            None => acc_m
            | Some (def_idx, def_sym, def_linkable) => 
                (* Make sure the map contains this key. *)
                if  acc_m def_idx = None 
                    then map_update def_idx (ref_sym, ref_linkable) acc_m
                    else acc_m
        )
    )) (Map.empty :: (nat, (symbol_reference * linkable_item)) Map.map) accumulated_bindings)
    in
    (* Print something similar to GNU ld's linker map output, about included archive members. *)
    (let _ = (()) in
    (let linkables_not_discarded = (mapMaybei (\<lambda> i .  (\<lambda> (obj, inp, opts) .  
        (let referenced_object_map_entry = ( referenced_object_indices_and_reasons i)
        in
        (let referenced = ( \<not> (referenced_object_map_entry = None))
        in
        (* Print our link map thing *)
        (*let _ = (
            if (not referenced) then () else
                (* Did it come from an archive? *)
                let (name, _, (inp_unit, coordlist)) = inp in
                match coordlist with
                    InArchive(aid, aidx, aname, _) :: _ ->
                        (* yes, from an archive, so print a line *)
                        let (ref_sym, (ref_obj, (ref_name, ref_blob, ref_origin), ref_opts)) = match referenced_object_map_entry with
                            Just(x, y) -> (x, y)
                            | Nothing -> failwith impossible: referenced item has no definition
                        end
                        in
                        let lhs_name = aname ^ ( ^ name ^ )
                        in
                        let lhs_name_len = stringLength lhs_name
                        in
                        let spacing = if lhs_name_len >= 29
                            then (n ^ (makeString 30 #' '))
                            else makeString (30 - lhs_name_len) #' '
                        in
                        Missing_pervasives.outln (
                            lhs_name ^ spacing ^ 
                            (match ref_origin with
                                (_, InArchive(bid, bidx, bname, _) :: _) -> bname ^ ( ^ ref_name ^ )
                                | _ -> ref_name
                            end)
                            ^  ( ^ ref_sym.ref_symname ^ )
                        )
                    | _ (* not from an archive *) -> ()
                end
        )
        in*)
        if referenced \<or>(item_force_output   opts) 
        then Some (i, (obj, inp, opts))
        else None))
    )) linkables)
    in
    (let _ = (())
    in
    (* We have to do a pass over relocations quite early. This is because relocs *do* participate 
     * in linking. For each reloc, we need to decide whether to apply it or not. For those not applied,
     * we include it in a synthesised section that participates in linking. 
     * 
     * Similarly, the GOT needs to participate in linking, so that it gets assigned an address 
     * at the appropriate place (as determined by the script). So we have to generate the GOT 
     * *before* running the linker script. The GNU linker hangs the whole GOT and PLT content 
     * off the first input object (usually crt1.o). In general, expand_sections calls an ABI tap 
     * which synthesises all the necessary things, like (in the GNU case) the .got and .plt sections 
     * hanging off the first input object. *)
    (let (initial_bindings_by_name :: (string, ( (nat * binding)list)) Map.map) =        
 (List.foldl (\<lambda> m .  \<lambda> (b_idx, ((ref_idx, ref1, ref_item), maybe_def)) .  (case   m(ref_symname   ref1) of
            None                  => map_update(ref_symname   ref1) [ (b_idx, ((ref_idx, ref1, ref_item), maybe_def)) ] m
            | Some ((bi, b) # more1) => map_update(ref_symname   ref1)  ((b_idx, ((ref_idx, ref1, ref_item), maybe_def)) # ((bi, b) # more1)) m
            | _ => failwith (''impossible: found empty list in map lacking empties by construction'')
        )) Map.empty (Lem_list.mapi (\<lambda> i .  \<lambda> b .  ( i, b)) accumulated_bindings))
    in
    (let (expanded_triples :: ( reloc_resolution list * elf_memory_image * Linker_script.input_spec list) list)
     = (expand_sections_for_all_inputs a options initial_bindings_by_name default_merge_generated linkables_not_discarded)
    in
    (let (reloc_resolutions, imgs, input_lists) = (unzip3 expanded_triples)
    in
    (let input_sections = (list_concat input_lists)
    in
    (let seen_ordering = (\<lambda> is1 .  (\<lambda> is2 .  (
        (let toNaturalList = (\<lambda> is1 .  (
            (* We're mapping the item to a list of naturals that determine a 
             * lexicographic order. The list has a fixed depth:
             * 
             * [within-commandline, within-group, within-archive, section-or-symbol]
             * 
             * For .o files on the command line, we use the command line order. This
             * is the first level in the hierarchy.
             *  
             * For .a files with --whole-archive, we want to do the same. Do this
             * by using archive position as the second level of the hierarchy, *if*
             * the item is marked as force_output.
             *
             * For other archives, order seen means something different: it's
             * the order in which they were pulled in during input enumeration. Another
             * way to say this is that they're ordered by the first binding that was
             * made to them. We map these to numbers starting from the size of the archive,
             * i.e. so that force_output makes an element appear sooner. In practice
             * we won't get a mixture of force_output and non- in the same archive,
             * so each archive will use only one of the two orderings.
             * 
             * How do sections order relative to common symbols? Again, in practice it
             * doesn't matter because no input query will get a mixture of the two.
             * For symbols, we start the numbering from the number of sections in the file,
             * so symbols always appear later in the sortd order.
             *)
            (let (linkable_idx, section_or_symbol_idx) = ((case  is1 of
                Common(idx1, fname1, img3, def1) => (idx1,                    
 (((let (_, l) = (elf_memory_image_section_ranges img3) in List.length l)) +(def_sym_idx   def1)))
                | InputSection(isrec) => ((idx   isrec),(shndx   isrec))
            ))
            in
            (case  index linkables ( linkable_idx) of
                None => failwith (''impossible: linker input not in linkables list'')
                | Some (obj, (fname1, blob, (inp_unit, coords)), options) => 
                    (let (our_cid, our_gid, our_aid, maybe_archive_size) = ((case  coords of
                      InArchive(aid, aidx, _, asize) # InGroup(gid1, gidx) # [InCommandLine(cid)] => (cid, gid1, aid, Some asize)
                    | InArchive(aid, aidx, _, asize) # [InCommandLine(cid)]                       => (cid,( 0 :: nat), aid,   Some asize)
                    | InGroup(gid1, gidx) # [InCommandLine(cid)]                                   => (cid, gid1,( 0 :: nat),   None)
                    | [InCommandLine(cid)]                                                         => (cid,( 0 :: nat),( 0 :: nat),     None)
                    | _ => failwith (''internal error: impossible coordinates'')
                    ))
                    in
                    (let aid_to_use = (if(item_force_output   options) then our_aid
                    else (* how many elements does the archive have? *)
                        (let archive_size = ((case  maybe_archive_size of
                            None => failwith (''impossible: archive with no size'')
                            | Some a => a
                        ))
                        in archive_size + 
                        (* search the bindings: we want the index of the first binding
                           that refers to this object.
                         *)
                        (case  find_index (\<lambda> ((b_ref_idx, b_ref, b_ref_item), b_maybe_def) .  (case  b_maybe_def of
                            Some (b_def_idx, b_def, b_def_item) => b_def_idx = linkable_idx
                            | _ => False
                        )) accumulated_bindings of
                            Some n =>  n
                            | None => failwith (''impossible: non-force-output object does not contain any bound-to defs'')
                        )))
                    in
                    (* do we care about group idx? probably not. *)
                    [our_cid, aid_to_use, section_or_symbol_idx]))
            ))
        ))
        in        
(lexicographicCompareBy (genericCompare (op<) (op=)) (toNaturalList is1) (toNaturalList is2)))
    )))
    in
    (*
    let get_binding_for_ref = (fun symref -> (fun linkable_idx -> (fun fname -> 
        let name_matches = match Map.lookup symref.ref_symname bindings_by_name with Just x -> x | Nothing -> [] end
        in
        match List.filter (fun (bi, ((r_idx, r, r_item), m_d)) -> r_idx = linkable_idx && r = symref) name_matches with
            [(b_idx, b)] -> (b_idx, b)
            | [] -> failwith no binding found
            | _  -> failwith (ambiguous binding found for symbol ` ^ symref.ref_symname ^ ' in file  ^ fname)
        end
    )))
    in
    *)
    (let (unrelocated_output_image_lacking_abs_symbols, bindings_by_name)
     = (interpret_linker_control_script alloc_map script linkables linker_script_linkable_idx a input_sections seen_ordering default_place_orphans initial_bindings_by_name)
    in
    (* also copy over ABS (range-less) symbols from all included input items *)
    (let all_abs_range_tags_in_included_inputs = (List.concat (
        List.map (\<lambda> (img3, (idx1, linkable)) .  
          (let abslist = (Lem_list.mapMaybe (\<lambda> (tag, maybeRange) . 
            (case  tag of
                SymbolDef(ent) => if (maybeRange = None) \<and> (unat(elf64_st_shndx  (def_syment   ent)) = shn_abs)
                    then Some (maybeRange, ent)
                    else None
                | _ => None
            )
          ) (tagged_ranges_matching_tag 
  instance_Basic_classes_Ord_Abis_any_abi_feature_dict instance_Abi_classes_AbiFeatureTagEquiv_Abis_any_abi_feature_dict (SymbolDef(null_symbol_definition)) img3))
          in
          (let _ = (())
          in
          (let x2 = ([]) in  List.foldr
   (\<lambda>(maybe_range, ent) x2 . 
    if True then
      (maybe_range, SymbolDef
                      ((| def_symname = ((def_symname   ent))
                       , def_syment = ((def_syment   ent))
                       , def_sym_scn = ((def_sym_scn   ent))
                       , def_sym_idx = ((def_sym_idx   ent))
                       , def_linkable_idx = idx1 |))) # x2 else x2) abslist
   x2)))
        ) (List.zip imgs linkables_not_discarded)
    ))
    in
    (let by_range_including_abs_symbols =        
 ((by_range   unrelocated_output_image_lacking_abs_symbols)
        \<union>
        (List.set all_abs_range_tags_in_included_inputs))
    in
    (let unrelocated_output_image = ((|
        elements = ((elements   unrelocated_output_image_lacking_abs_symbols))
    ,   by_range = by_range_including_abs_symbols
    ,   by_tag   = (by_tag_from_by_range by_range_including_abs_symbols)
    |))
    (* This image has 
     * - addresses assigned 
     * - relocations *not* applied
     * - no entry point
     * - some ABI features not generated? GOT, certainly. HMM.
           -- don't consider output features, like symtabs, yet;
           -- other ABI features have to be generated before the linker script runs (dyn relocs, GOT, PLT?)
           -- ... so we might be okay for now.
     *)
    in
    (let remaining_relocs = (Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     instance_Basic_classes_Ord_Abis_any_abi_feature_dict) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      Lem_string_extra.instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (Memory_image_orderings.tagEquiv
    instance_Abi_classes_AbiFeatureTagEquiv_Abis_any_abi_feature_dict) (SymbolRef(null_symbol_reference_and_reloc_site))(by_tag  
        unrelocated_output_image))
    in
    (let _ = (List.foldl (\<lambda> _ .  (\<lambda> (tag, maybe_range) . 
        (let _ = ((case  tag of 
            SymbolRef(x) => (case (maybe_reloc   x) of
                Some rs => 
                    (case  maybe_range of
                        None => failwith (''impossible: reloc site with no range'')
                        | Some (el_name, (start, len)) => 
                            ()  (* errln (After linking, saw a reloc site in element  ^ el_name ^ , offset 0x ^
                                (hex_string_of_natural start) ^ , length 0x ^ (hex_string_of_natural len) ^ 
                                , reloc type  ^ Abi_amd64_relocation.string_of_amd64_relocation_type (get_elf64_relocation_a_type rs.ref_relent)) *)
                    )
                | None => (* okay, do nothing *) () 
                )
            | _ => failwith (''impossible: not a symbol ref'')
        ))
        in
        () )
    )) ()  remaining_relocs)
    in
    (* Before we relocate, we concretise any ABI features that we've linked in. *)
    (let _ = (()) in
    (let unrelocated_concrete_output_image = ((concretise_support   a) unrelocated_output_image)
    in
    (let output_image = (relocate_output_image a bindings_by_name unrelocated_concrete_output_image)
    in
    (let (maybe_entry_point_address ::  nat option) =        
 ((case  Command_line.find_option_matching_tag (Command_line.EntryAddress(( 0 :: nat))) options of
            None =>(guess_entry_point   a) output_image
            | Some(Command_line.EntryAddress(x)) => Some x
        ))
    in
    (case  maybe_entry_point_address of
        Some addr => 
            (case  address_to_element_and_offset addr output_image of
                Some (el_name, el_offset) => 
                    (*let _ = errln (Tagging element  ^ el_name ^  as containing entry point at offset 0x ^ (hex_string_of_natural el_offset))
                    in*)
                    tag_image (EntryPoint) el_name el_offset(( 0 :: nat)) output_image
                | None => 
                    (* HMM. entry point symbol has no address at present. *)
                    failwith ((''error: entry point address 0x'') @ ((hex_string_of_natural addr) @ ('' does not correspond to any element position'')))
            )
        | None => 
            (*let _ = errln Warning: not tagging entry point in output image
            in*) 
            output_image
    )))))))))))))))))))))))))"

end
