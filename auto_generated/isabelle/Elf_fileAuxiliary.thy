chapter {* Generated by Lem from elf_file.lem. *}

theory "Elf_fileAuxiliary" 

imports 
 	 Main "~~/src/HOL/Library/Code_Target_Numeral"
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "String_table" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_file" 

begin 


(****************************************************)
(*                                                  *)
(* Lemmata                                          *)
(*                                                  *)
(****************************************************)

lemma find_first_not_in_range_def_lemma:
" ((\<forall> start. \<forall> ranges.
   (case  List.filter
            (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y))
            ranges of
         [] => start
     | _ => Elf_Types_Local.find_first_not_in_range (start + ( 1 :: nat))
              ranges
   ) = Elf_Types_Local.find_first_not_in_range start ranges)) "
(* Theorem: find_first_not_in_range_def_lemma*)(* try *) by auto

lemma find_first_in_range_def_lemma:
" ((\<forall> start. \<forall> ranges.
   (case  List.filter
            (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y))
            ranges of
         [] => Elf_Types_Local.find_first_in_range (start + ( 1 :: nat))
                 ranges
     | _ => start
   ) = Elf_Types_Local.find_first_in_range start ranges)) "
(* Theorem: find_first_in_range_def_lemma*)(* try *) by auto

lemma compute_differences_def_lemma:
" ((\<forall> start. \<forall> ranges. \<forall> max0.
   (
   if start = max0 then error_return [] else
     if start > max0 then
       error_fail (''compute_differences: passed maximum'') else
       (let first1 = (Elf_Types_Local.find_first_not_in_range start ranges) in
       if first1 \<ge> max0 then error_return [] else
         (let last1 = (Elf_Types_Local.find_first_in_range first1 ranges) in
         if last1 > max0 then error_return [(first1, max0)] else
           Elf_Types_Local.compute_differences last1 max0 ranges >>=
             (\<lambda> tail .  error_return ((first1, last1) # tail))))) =
     Elf_Types_Local.compute_differences start max0 ranges)) "
(* Theorem: compute_differences_def_lemma*)(* try *) by auto



end
