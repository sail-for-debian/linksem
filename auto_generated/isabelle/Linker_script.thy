chapter {* Generated by Lem from linker_script.lem. *}

theory "Linker_script" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Default_printing" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_symbol_table" 
	 "Elf_file" 
	 "Elf_relocation" 
	 "Memory_image" 
	 "Memory_image_orderings" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abis" 
	 "Elf_memory_image" 
	 "Command_line" 
	 "Input_list" 
	 "Elf_memory_image_of_elf64_file" 
	 "Linkable_list" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Set*)
(*import Map*)

(*open import Byte_sequence*)
(*open import Default_printing*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(*open import Elf_header*)
(*open import Elf_file*)
(*open import Elf_interpreted_section*)

(*open import Abis*)
(*open import Command_line*)
(*open import Input_list*)
(*open import Linkable_list*)
(*open import Memory_image*)
(*open import Elf_memory_image*) (* HMM -- ideally we'd be ELF-agnostic in this file. 
     But Abstract_abi is now merged into Elf_memory_image, so never mind. *)
(*open import Elf_memory_image_of_elf64_file*)
(*open import Elf_relocation*)
(*open import Elf_symbol_table*)
(*open import Elf_section_header_table*)
(*open import Elf_types_native_uint*)
(*open import Memory_image_orderings*)

(* We model two kinds of linker script: implicit scripts, which are supplied 
 * on the command line as input objects, and control scripts of which there
 * is exactly one per link job. The abstract syntax of each script comes from the
 * same grammar. 
 * 
 * We define the control script as a bunch of functions, to allow for
 * link jobs where we don't have an AST and the script behaviour is hard-coded. 
 *)

(* Input sections come from individual (relocatable) ELF files. 
 * The name of this file is important! 
 * 
 * Each input section is always an identified section or common symbol 
 * *within* some ELF memory image. *)

record input_section_rec = 
 
    idx   ::" nat "    (* linkable idx *)

   fname ::" string "

   img   ::" elf_memory_image "

   shndx ::" nat "

   secname::" string "

   isec ::" elf64_interpreted_section "



datatype input_spec
 = Common " (nat * string * elf_memory_image * symbol_definition)" (* string is symbol name -- must be a COMMON symbol *)
 | InputSection " input_section_rec "

(* A control script defines
 * - output sections
 * - a mapping from output sections to (ordered) input sections
 * - extra symbols
 * - output format etc. (skip this for now)
 *)

(* We will have to deal with merging etc. at some point, somewhere
 * (maybe here, maybe not); for now we just produce an ordered list 
 * of sections. 
 *)
 
(* We can't model linker scripts as plain Lem functions without writing
 * them to a very different structure than that of scripts. The reason is that
 * certain features of the script language necessitate multiple passes
 * over the script structure. For example, to figure out how big an
 * output section is, hence where to begin the next section, you need to 
 * know which of the input sections are marked for KEEP. For that, you need 
 * a def-use graph over input sections. But for that, you also need to account 
 * for *all* symbol definitions, and the script itself is allowed to add new 
 * ones (right in among its input sections). So we have to do one pass to
 * enumerate the symbol additions, and another pass to eliminate sections
 * that we don't want to KEEP.
 *
 * Other gotchas include:
 * 
 * - symbol provision and address advancement can occur in among the input 
 * section queries, but also outside any output section. 
 * 
 * - semantics of DATA_SEGMENT_ALIGN depend on future script contents
 * 
 * - ONLY_IF_RO and ONLY_IF_RW are tricky: need to evaluate the input section
 * queries
 * 
 * - semantics of empty sections are subtle (. = . will force an empty section
 * to be emitted, but . = . + 0 will not do so).
 * 
 * Our approach is to define an interpreter for (at present) most of the script 
 * language.
 *)

datatype symbol_def_policy = AlwaysDefine
                        | ProvideIfUsed

type_synonym input_selector  =" input_spec list \<Rightarrow> input_spec list "

type_synonym address_expr =" Memory_image.expr "

datatype output_guard = AlwaysOutput
                  | OnlyIfRo
                  | OnlyIfRw
                  
type_synonym symbol_spec =" (nat * Elf_Types_Local.unsigned_char * Elf_Types_Local.unsigned_char)" (* size, info, other *)

datatype retain_policy
  = DefaultKeep
  | KeepEvenWhenGC

type_synonym address_expr_fn_ref    =" nat "
type_synonym 'a address_expr_fn_map =" (address_expr_fn_ref, (nat \<Rightarrow> 'a \<Rightarrow> nat)) Map.map "
(* 'a = allocated_sections_map *)

datatype output_section_composition_element
  = IncludeInputSection " (retain_policy * input_section_rec)"
  | IncludeCommonSymbol " (retain_policy * string (* file *) * nat (* linkable_idx *) * symbol_definition * elf_memory_image)"
  | Hole " address_expr_fn " (* compute the next addr to continue layout at *)
  | ProvideSymbol " (symbol_def_policy * string * symbol_spec)"
and
sort_policy
  = DefaultSort (* Use command line sort option, else seen order *)
  | SeenOrder (* Always use seen order *)
  | ByName
  | ByNameThenAlignment
  | ByAlignment
  | ByAlignmentThenName
  | ByInitPriority
and
(* This mirrors the OutputSection constructor, except that the script elements have become
 * output_section_composition_elements, and we might store the size here. *)
output_section_spec =
  OutputSectionSpec " (output_guard *  nat option * string * ( output_section_composition_element list))"
and
allocated_sections_map =
  AllocatedSectionsMap " (string, (output_section_spec (* OutputSection element idx *) * nat)) Map.map "
and
address_expr_fn
  = AddressExprFn " address_expr_fn_ref "

datatype script_element =
  DefineSymbol " (symbol_def_policy * string * symbol_spec)"
| AdvanceAddress " address_expr_fn "
| MarkAndAlignDataSegment " (nat * nat)" (* maxpagesize, commonpagesize *)
| MarkDataSegmentEnd
| MarkDataSegmentRelroEnd (*of (allocated_sections_map -> (natural * (natural -> natural))) DPM: commented out because of positivity constrains in Isabelle *)
| OutputSection " (output_guard * ( (* address_expr *) address_expr_fn option) * string * script_element list)"
| DiscardInput " input_selector " 
  (* Input queries can only occur within an output section. 
     Output sections may not nest within other output sections. 
     (Ideally we would use something like polymorphic variants to encode this.)
   *)
| InputQuery " (retain_policy * sort_policy * input_selector)"

(* A linker control script is a function from inputs to output elements. 
 * We can define them in syntax (using an interpreter) 
 * or in Lem directly (as functions). *)
type_synonym linker_control_script =" script_element list "
type_synonym labelled_linker_control_script =" (script_element * nat) list "

(*val all_suffixes : list char -> list (list char)*)
function (sequential,domintros)  all_suffixes  :: "(char)list \<Rightarrow>((char)list)list "  where 
     " all_suffixes chars = (
    (case  chars of 
        [] => [[]]
        | c # morecs => chars # (all_suffixes morecs)
    ))" 
by pat_completeness auto


(*val glob_match : list char -> list char -> bool*)
function (sequential,domintros)  glob_match  :: "(char)list \<Rightarrow>(char)list \<Rightarrow> bool "  where 
     " glob_match pat str = ( 
    (case  (pat, str) of
        ([], []) => True
        | ((CHR ''?'') # morepat, _ # morestr) => glob_match morepat morestr
        | ((CHR ''*'') # morepat, _) =>
            (* if any suffix of the remaining string matches
             * the remaining pattern, we've matched the pattern 
             * from '*' onwards. *)
            (let or_suffix_match = (\<lambda> matched .  (\<lambda> newlist . 
                matched \<or> glob_match morepat newlist))
            in 
            List.foldl (or_suffix_match) False (all_suffixes str))
        | (patc # morepat, c # morestr) => (patc = c) \<and> glob_match morepat morestr
        | ([], _) => (* ran out of pattern *) False
        | (_, []) => (* ran out of str *) False
    ))" 
by pat_completeness auto


(*val default_symbol_spec : symbol_spec*)
definition default_symbol_spec  :: " nat*Elf_Types_Local.unsigned_char*Elf_Types_Local.unsigned_char "  where 
     " default_symbol_spec = ( (( 0 :: nat), Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)), Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat))))"

(*val hidden_symbol_spec : symbol_spec*)
definition hidden_symbol_spec  :: " nat*Elf_Types_Local.unsigned_char*Elf_Types_Local.unsigned_char "  where 
     " hidden_symbol_spec = ( (( 0 :: nat), Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)), Elf_Types_Local.unsigned_char_of_nat stv_hidden))"


(* These Lem functions replicate linker script functions or builtin behaviours. *)

(*val only_sections : input_selector*) 
definition only_sections  :: "(input_spec)list \<Rightarrow>(input_spec)list "  where 
     " only_sections inputs1 = ( Lem_list.mapMaybe
    (\<lambda> i .  (case  i of 
        InputSection(_) => Some(i)
      | _ => None
    )) inputs1 )"


(*val filter_and_concat : (input_spec -> bool) -> input_selector*) (* a.k.a. list input_spec -> list input_spec *)
definition filter_and_concat  :: "(input_spec \<Rightarrow> bool)\<Rightarrow>(input_spec)list \<Rightarrow>(input_spec)list "  where 
     " filter_and_concat p inputs1 = ( List.filter p inputs1 )"


(*val name_matches : string -> input_spec -> bool*)
fun name_matches  :: " string \<Rightarrow> input_spec \<Rightarrow> bool "  where 
     " name_matches pat (InputSection(inp)) = ( 
            (*let _ = errln (Does section name ` ^ inp.secname ^ ' match glob pattern ` ^ pat ^ '? ) in
            let result = *)glob_match ( pat) ((secname   inp)))"
|" name_matches pat _ = ( False )" 
declare name_matches.simps [simp del]


(*val file_matches : string -> input_spec -> bool*)
fun file_matches  :: " string \<Rightarrow> input_spec \<Rightarrow> bool "  where 
     " file_matches pat (InputSection(inp)) = ( glob_match ( pat) ((fname   inp)))"
|" file_matches pat _ = ( False )" 
declare file_matches.simps [simp del]


definition compareInputSpecByNameThenAlignment  :: " input_spec \<Rightarrow> input_spec \<Rightarrow> ordering "  where 
     " compareInputSpecByNameThenAlignment i1 i2 = ( 
    (let toPair = (\<lambda> is1 .  ((case  is1 of
         Common(idx1, fname1, img3, def1) => ((''COMMON'') (* FIXME: is this right? *), unat(elf64_st_value  (def_syment   def1)))
         | InputSection(isrec) => ((elf64_section_name_as_string  (isec   isrec)),(elf64_section_align  (isec   isrec)))
    )))
    in (pairCompare (\<lambda> x y. EQ) (genericCompare (op<) (op=)) (toPair i1) (toPair i2))))"


definition compareInputSpecByAlignment  :: " input_spec \<Rightarrow> input_spec \<Rightarrow> ordering "  where 
     " compareInputSpecByAlignment i1 i2 = ( 
    (let toNatural = (\<lambda> is1 .  ((case  is1 of
         Common(idx1, fname1, img3, def1) => unat(elf64_st_value  (def_syment   def1))
         | InputSection(isrec) =>(elf64_section_align  (isec   isrec))
    )))
    in (genericCompare (op<) (op=) (toNatural i1) (toNatural i2))))"


definition compareInputSpecByName  :: " input_spec \<Rightarrow> input_spec \<Rightarrow> ordering "  where 
     " compareInputSpecByName i1 i2 = ( 
    (let toString = (\<lambda> is1 .  ((case  is1 of
         Common(idx1, fname1, img3, def1) => (''COMMON'')
         | InputSection(isrec) =>(elf64_section_name_as_string  (isec   isrec))
    )))
    in EQ))"


definition compareInputSpecByAlignmentThenName  :: " input_spec \<Rightarrow> input_spec \<Rightarrow> ordering "  where 
     " compareInputSpecByAlignmentThenName i1 i2 = (
    (let toPair = (\<lambda> is1 .  ((case  is1 of
         Common(idx1, fname1, img3, def1) => (unat(elf64_st_value  (def_syment   def1)), 
            (''COMMON'') (* FIXME: is this right? *))
         | InputSection(isrec) => ((elf64_section_align  (isec   isrec)),(elf64_section_name_as_string  (isec   isrec)))
    )))
    in (pairCompare (genericCompare (op<) (op=)) (\<lambda> x y. EQ) (toPair i1) (toPair i2))))"


definition compareInputSpecByInitPriority  :: " 'a \<Rightarrow> 'b \<Rightarrow> ordering "  where 
     " compareInputSpecByInitPriority i1 i2 = ( EQ )"
 (* FIXME *)

(* DATA_SEGMENT_ALIGN is defined by two formulae 
 * (over pos and commonpagesize/maxpagesize)
 * ... depending on whether the latter uses fewer COMMONPAGESIZE sized
  pages for the data segment (area between the result of this
  expression and `DATA_SEGMENT_END') than the former or not.  If the
  latter form is used, it means COMMONPAGESIZE bytes of runtime
  memory will be saved at the expense of up to COMMONPAGESIZE wasted
  bytes in the on-disk file.

  So the amount of padding that gets inserted here depends on the location
  of something that comes *later*, namely DATA_SEGMENT_END. 
  So, we can't model it as a function of the current position. 
  Instead, we add MarkDataSegmentEnd and friends 
  to the script_element ADT.
 *)

definition has_writability  :: " 'a \<Rightarrow> input_spec \<Rightarrow> bool "  where 
     " has_writability = ( \<lambda> writable .  (\<lambda> input_sec .  (
    (case  input_sec of
        Common(_, _, _, _)
            => (* all common symbols are potentially writable *) True
        | InputSection(inp)
            => (let (flags :: nat) = ((case  elf_memory_image_section_by_index(shndx   inp)(img   inp) of 
                          Some x =>(elf64_section_flags   x)
                        | None => failwith ((''impossible: no such section'') (*(index  ^ (show inp.shndx) ^ )*))
                     ))
                in 
                flag_is_set shf_write flags)
    )
)))"


(* LARGE_COMMON seems to have been defined in this patch set:
    https://sourceware.org/ml/binutils/2005-07/txt00014.txt
   and at the time was only for x86-64. It seems to be analogous
   to .lbss, i.e. large bss. libbfd defines SHF_X86_64_LARGE.
   The best comment seems to be in llvm's Support/ELF.h:
   
0814   // If an object file section does not have this flag set, then it may not hold
0815   // more than 2GB and can be freely referred to in objects using smaller code
0816   // models. Otherwise, only objects using larger code models can refer to them.
0817   // For example, a medium code model object can refer to data in a section that
0818   // sets this flag besides being able to refer to data in a section that does
0819   // not set it; likewise, a small code model object can refer only to code in a
0820   // section that does not set this flag.
   
 *)

(*val address_zero : natural -> address_expr_fn_map allocated_sections_map ->
  (natural * address_expr_fn_map allocated_sections_map * address_expr_fn)*)
definition address_zero  :: " nat \<Rightarrow>((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow> nat*((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map*address_expr_fn "  where 
     " address_zero fresh alloc_map = (
  (let alloc_map' = (map_update fresh (\<lambda> pos .  (\<lambda> secs . ( 0 :: nat))) alloc_map) in
  (let fresh'     =(( 1 :: nat) + fresh) in
    (fresh', alloc_map', AddressExprFn fresh))))"


(*
val output_sec_composition_size : list output_section_composition_element -> natural
let output_sec_composition_size comp = List.foldl (+) 0 (List.map size_of_output_section_composition_element comp)
*)
(*val do_output_section_layout_starting_at_addr : natural -> allocated_sections_map -> list output_section_composition_element -> (natural * list natural)*)
fun do_output_section_layout_starting_at_addr  :: " nat \<Rightarrow> allocated_sections_map \<Rightarrow>(output_section_composition_element)list \<Rightarrow> nat*(nat)list "  where 
     " do_output_section_layout_starting_at_addr start_addr (AllocatedSectionsMap secs) comps = ( 
    (* map out where we plumb in each section, accounting for their alignment *)
    List.foldl (\<lambda> (next_free_addr, addr_list) .  (\<lambda> comp_el .  (case  comp_el of
          IncludeInputSection(retain_pol, irec (* fname, linkable_idx, shndx, isec, img *)) => 
                (let aligned_next_free = (align_up_to(elf64_section_align  (isec   irec)) next_free_addr)
                in
                (let _ = (())
                in
                ((aligned_next_free +(elf64_section_size  (isec   irec))), (addr_list @ [aligned_next_free]))))
        | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => 
                (let aligned_next_free = (align_up_to (unat(elf64_st_value  (def_syment   def1))) next_free_addr)
                in
                ((aligned_next_free + (unat(elf64_st_size  (def_syment   def1)))), (addr_list @ [aligned_next_free])))
        (*| Hole(AddressExprFn f) -> (f next_free_addr secs, addr_list ++ [next_free_addr])*)
        | ProvideSymbol(pol, name1, spec) => (next_free_addr, (addr_list @ [next_free_addr]))
    )
    )) (start_addr, []) comps )" 
declare do_output_section_layout_starting_at_addr.simps [simp del]


(*val output_sec_composition_size_given_start_addr : natural -> allocated_sections_map -> list output_section_composition_element -> natural*)
definition output_sec_composition_size_given_start_addr  :: " nat \<Rightarrow> allocated_sections_map \<Rightarrow>(output_section_composition_element)list \<Rightarrow> nat "  where 
     " output_sec_composition_size_given_start_addr   start_addr secs comp1 = ( 
    (let (end_addr, comp_addrs) = (do_output_section_layout_starting_at_addr start_addr secs comp1)
    in
    end_addr - start_addr))"


(*val sizeof : string -> allocated_sections_map -> natural*)
fun sizeof  :: " string \<Rightarrow> allocated_sections_map \<Rightarrow> nat "  where 
     " sizeof secname1 (AllocatedSectionsMap secs) = ( 
    (case   secs secname1 of
        Some(OutputSectionSpec (_, maybe_addr, _, comp1), _) => (case  maybe_addr of
            Some addr => output_sec_composition_size_given_start_addr addr (AllocatedSectionsMap secs) comp1
            | None => failwith ((''error: sizeof applied to section without defined start address''))
        )
        | None => failwith ((''error: sizeof applied to non-existent section name '') @ secname1)
    ))" 
declare sizeof.simps [simp del]


(*val alignof_output_section_composition_element : output_section_composition_element -> natural*)
fun alignof_output_section_composition_element  :: " output_section_composition_element \<Rightarrow> nat "  where 
     " alignof_output_section_composition_element (IncludeInputSection(_, irec)) = ((elf64_section_align  (isec   irec)))"
|" alignof_output_section_composition_element (IncludeCommonSymbol(_, _, _, def1, _)) = ( unat(elf64_st_value  (def_syment   def1)))"
|" alignof_output_section_composition_element _ = (( 1 :: nat))" 
declare alignof_output_section_composition_element.simps [simp del]


(*val alignof_output_section : list output_section_composition_element -> natural*)
definition alignof_output_section  :: "(output_section_composition_element)list \<Rightarrow> nat "  where 
     " alignof_output_section comps = ( 
    (let aligns = (List.map alignof_output_section_composition_element comps)
    in
    List.foldl (\<lambda> acc_lcm .  \<lambda> next1 .  GCD.lcm acc_lcm next1)(( 1 :: nat)) aligns))"


(*val default_linker_control_script : natural -> address_expr_fn_map allocated_sections_map ->
  abi any_abi_feature -> maybe natural -> maybe natural -> maybe natural ->
  natural -> (natural * address_expr_fn_map allocated_sections_map * linker_control_script)*)
definition default_linker_control_script  :: " nat \<Rightarrow>((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow>(any_abi_feature)abi \<Rightarrow>(nat)option \<Rightarrow>(nat)option \<Rightarrow>(nat)option \<Rightarrow> nat \<Rightarrow> nat*((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map*(script_element)list "  where 
     " default_linker_control_script fresh alloc_map a user_text_segment_start user_data_segment_start user_rodata_segment_start elf_headers_size = ( 
  (let segment_start = (\<lambda> name1 default1 . 
                        if(name1 = (''ldata-segment'')) then
                          ((case  user_data_segment_start of
                               None => default1
                             | Some addr => (* fun _ -> *) addr
                           )) else
                          (
                          if(name1 = (''text-segment'')) then
                            ((case  user_text_segment_start of
                                 None => default1
                               | Some addr => (* fun _ -> *) addr
                             )) else undefined)) in
  (let is_large_common = (\<lambda> inp .  (* FIXME: treat large commons separately *) False
                          ) in
  (let is_common = (\<lambda> isec1 .  (case  isec1 of
                                           Common (idx1, fname1, img3, def1) => 
                                       (*let _ = errln (Common or large-common symbol:  ^ def.def_symname) in *)
                                       \<not> (is_large_common isec1)
                                         | _ => False
                                       )) in
  (let alloc_fn1 = (\<lambda> _ .  (\<lambda> _ .  (segment_start
                                                      (''text-segment'')
                                                      (( 4 :: nat) *
                                                         ( 1048576 :: nat)))
                                                     + elf_headers_size)) in
  (let alloc_fn1_ref = fresh in
  (let alloc_map = (map_update alloc_fn1_ref alloc_fn1 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn2 = (\<lambda> addr .  (\<lambda> _ . 
                                       (* (align_up_to a.maxpagesize addr) - (natural_land (a.maxpagesize - addr) (a.maxpagesize - 1)) *)
                                       (*
      FIXME: understand the intention of this assignment.
      Evaluating a simple example of this (from true-static-uClibc)

      (ALIGN (0x200000) - ((0x200000 - .) & 0x1fffff))

      starting from 0x00000000004017dc
      means 
      0x600000 - ((0x200000 - 0x4017dc) & 0x1fffff)
      i.e. 
      0x600000 - (((-0x2017dc)) & 0x1fffff)
      i.e.
      0x600000 - (     -0x2017dc   
                      & 0x1fffff )

      which really does come to (according to bash) 0x4017dc
      i.e. we subtract 0x1fe824 from 0x600000
      and end up back where we started.

      What does ANDing a negative number mean?
      It doesn't seem to work for us.
      Well, to take the negation we flip every bit and add one.
      So if we don't want to do a subtraction that might go negative, 
      we can instead add the complement.    
      *)
                                       (align_up_to (maxpagesize   a) addr) -
                                         (natural_land
                                            ((maxpagesize   a) + compl64 addr)
                                            ((maxpagesize   a) - ( 1 :: nat))))) in
  (let (fresh, alloc_map, (address_zero_fn :: address_expr_fn)) = (address_zero
                                                                    fresh
                                                                    alloc_map) in
  (let alloc_fn2_ref = fresh in
  (let alloc_map = (map_update alloc_fn2_ref alloc_fn2 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn3 = (\<lambda> pos .  (\<lambda> secs .  align_up_to
                                                          (
                                                          if pos =
                                                               ( 0 :: nat) then
                                                            (( 64 :: nat) div
                                                               ( 8 :: nat))
                                                          else ( 1 :: nat))
                                                          pos)) in
  (let alloc_fn3_ref = fresh in
  (let alloc_map = (map_update alloc_fn3_ref alloc_fn3 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn4 = (\<lambda> pos .  (\<lambda> secs .  align_up_to
                                                          (( 64 :: nat) div
                                                             ( 8 :: nat)) 
                                                        pos)) in
  (let alloc_fn4_ref = fresh in
  (let alloc_map = (map_update alloc_fn4_ref alloc_fn4 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn5 = (\<lambda> pos .  (\<lambda> secs .  segment_start
                                                          (''ldata-segment'')
                                                          pos)) in
  (let alloc_fn5_ref = fresh in
  (let alloc_map = (map_update alloc_fn5_ref alloc_fn5 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn6 = (\<lambda> pos .  \<lambda> secs .  align_up_to
                                                         ((maxpagesize   a) +
                                                            ((natural_land
                                                                pos
                                                                (maxpagesize   a))
                                                               - ( 1 :: nat)))
                                                         pos) in
  (let alloc_fn6_ref = fresh in
  (let alloc_map = (map_update alloc_fn6_ref alloc_fn6 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn7 = (\<lambda> pos .  (\<lambda> secs .  (
                                                        if \<not>
                                                             (pos =
                                                                (( 0 :: nat))) then
                                                          ( 64 :: nat) div
                                                            ( 8 :: nat) else
                                                          ( 1 :: nat)))) in
  (let alloc_fn7_ref = fresh in
  (let alloc_map = (map_update alloc_fn7_ref alloc_fn7 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (let alloc_fn8 = (\<lambda> pos .  (\<lambda> secs .  align_up_to
                                                          (( 64 :: nat) div
                                                             ( 8 :: nat)) 
                                                        pos)) in
  (let alloc_fn8_ref = fresh in
  (let alloc_map = (map_update alloc_fn8_ref alloc_fn8 alloc_map) in
  (let fresh =(( 1 :: nat) + fresh) in
  (fresh, alloc_map, [
                     (* For now, we base our script on the GNU bfd linker's scripts. 
           Here's the static -z combreloc one.
           
/* Script for -z combreloc: combine and sort reloc sections */
/* Copyright (C) 2014 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT(elf64-x86-64, elf64-x86-64,
              elf64-x86-64)
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR(=/usr/x86_64-linux-gnu/lib64); SEARCH_DIR(=/usr/local/lib/x86_64-linux-gnu); SEARCH_DIR(=/usr/local/lib64); SEARCH_DIR(=/lib/x86_64-linux-gnu); SEARCH_DIR(=/lib64); SEARCH_DIR(=/usr/lib/x86_64-linux-gnu); SEARCH_DIR(=/usr/lib64); SEARCH_DIR(=/usr/x86_64-linux-gnu/lib); SEARCH_DIR(=/usr/local/lib); SEARCH_DIR(=/lib); SEARCH_DIR(=/usr/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START(text-segment, 0x400000)); . = SEGMENT_START(text-segment, 0x400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.* )
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.* )
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.* )
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.* )
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.* )
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.* )
      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.* )
      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.* )
      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.* )
      *(.rela.ifunc)
    }
  .rela.plt       :
    {
      *(.rela.plt)
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  .init           :
  {
    KEEP ( *(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
  .plt.bnd        : { *(.plt.bnd) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.* )
    *(.text.exit .text.exit.* )
    *(.text.startup .text.startup.* )
    *(.text.hot .text.hot.* )
    *(.text .stub .text.* .gnu.linkonce.t.* )
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP ( *(SORT_NONE(.fini)))
  }
   PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.* ) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame       : ONLY_IF_RO { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table
  .gcc_except_table.* ) }
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges
  .exception_ranges* ) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN (CONSTANT (MAXPAGESIZE)) - ((CONSTANT (MAXPAGESIZE) - .) & (CONSTANT (MAXPAGESIZE) - 1)); . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */
  .eh_frame       : ONLY_IF_RW { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.* ) }
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges .exception_ranges* ) }
  /* Thread Local Storage sections  */
  .tdata          : { *(.tdata .tdata.* .gnu.linkonce.td.* ) }
  .tbss           : { *(.tbss .tbss.* .gnu.linkonce.tb.* ) *(.tcommon) }
  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP ( *(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array     :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.init_array.* ) SORT_BY_INIT_PRIORITY(.ctors.* )))
    KEEP ( *(.init_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array     :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.fini_array.* ) SORT_BY_INIT_PRIORITY(.dtors.* )))
    KEEP ( *(.fini_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP ( *crtbegin.o(.ctors))
    KEEP ( *crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .ctors))
    KEEP ( *(SORT(.ctors.* )))
    KEEP ( *(.ctors))
  }
  .dtors          :
  {
    KEEP ( *crtbegin.o(.dtors))
    KEEP ( *crtbegin?.o(.dtors))
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .dtors))
    KEEP ( *(SORT(.dtors.* )))
    KEEP ( *(.dtors))
  }
  .jcr            : { KEEP ( *(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.* ) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.* ) }
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) *(.igot) }
  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);
  .got.plt        : { *(.got.plt)  *(.igot.plt) }
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.* )
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.* )
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we don't
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  .lbss   :
  {
    *(.dynlbss)
    *(.lbss .lbss.* .gnu.linkonce.lb.* )
    *(LARGE_COMMON)
  }
  . = ALIGN(64 / 8);
  . = SEGMENT_START(ldata-segment, .);
  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.lrodata .lrodata.* .gnu.linkonce.lr.* )
  }
  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.ldata .ldata.* .gnu.linkonce.l.* )
    . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  . = ALIGN(64 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.* ) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
  .gnu.attributes 0 : { KEEP ( *(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_* ) }
}
         *)
                     (*  function from 
                  inputs and configuration
             to
                  output sections-with-address-and-policy, output symbols-with-address-and-attributes, 
                      discards, orphans
             BUT
                   1. policy is not a property of output sections, but of *inputs within outputs*
                         i.e. KEEP( *(.init))
         
             what's helpful for writing such functions?
             
             e.g. only_if_ro (input_query) (output ): 
             
             i.e.    ++ only_if_ro OutputSection(AlwaysOutput, Nothing, .eh_frame, [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches .eh_frame))])

                 want to take a bunch of outputs
                         and return a bunch of outputs?
                         
                         if so, need to return a current address
             
          *)
                     (DefineSymbol
                        (ProvideIfUsed, (''__executable_start''), default_symbol_spec))
                     , AdvanceAddress (AddressExprFn alloc_fn1_ref)
                     , OutputSection
                         (AlwaysOutput, None, (''.interp''), [InputQuery
                                                                (DefaultKeep, DefaultSort, 
                                                                filter_and_concat
                                                                  (name_matches
                                                                    (''.interp'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.note.gnu.build-id''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.note.gnu.build-id'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.hash''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.hash'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.gnu.hash''), [InputQuery
                                                                  (DefaultKeep, DefaultSort, 
                                                                  filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.gnu.hash'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.dynsym''), [InputQuery
                                                                (DefaultKeep, DefaultSort, 
                                                                filter_and_concat
                                                                  (name_matches
                                                                    (''.dynsym'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.dynstr''), [InputQuery
                                                                (DefaultKeep, DefaultSort, 
                                                                filter_and_concat
                                                                  (name_matches
                                                                    (''.dynstr'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.gnu.version''), [InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.gnu.version'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.gnu.version_d''), [
                                                                    InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.gnu.version_d'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.gnu.version_r''), [
                                                                    InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.gnu.version_r'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.rela.dyn''), [InputQuery
                                                                  (DefaultKeep, DefaultSort, 
                                                                  filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.rela.init'')))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.text'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.text.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.t.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.rodata'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.rodata.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.r.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.data'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.data.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.d.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.tdata'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.tdata.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.td.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.tbss'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.tbss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.tb.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.rela.ctors'')))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.rela.got'')))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.bss'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.bss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.b.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.ldata'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.ldata.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.l.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.rela.lbss'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.rela.lbss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.rela.gnu.linkonce.lb.*'')
                                                                    s)))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.rela.ifunc'')))
                                                               ])
                     , OutputSection
                         (AlwaysOutput, None, (''.rela.plt''), [
                                                               InputQuery
                                                                 (DefaultKeep, DefaultSort, 
                                                                 filter_and_concat
                                                                   (name_matches
                                                                    (''.rela.plt'')))
                                                               , DefineSymbol
                                                                   (ProvideIfUsed, (''__rela_iplt_start''), 
                                                                   ((
                                                                     0 :: nat), 
                                                                   make_symbol_info
                                                                    stb_local
                                                                    stt_notype (* FIXME *) , 
                                                                   make_symbol_other
                                                                    stv_hidden))
                                                               , InputQuery
                                                                   (DefaultKeep, DefaultSort, 
                                                                   filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.rela.iplt'')))
                                                               , DefineSymbol
                                                                   (ProvideIfUsed, (''__rela_iplt_end''), 
                                                                   ((
                                                                     0 :: nat), 
                                                                   make_symbol_info
                                                                    stb_local
                                                                    stt_notype (* FIXME *) , 
                                                                   make_symbol_other
                                                                    stv_hidden))
                                                               ])
                     , OutputSection
                         (AlwaysOutput, None, (''.init''), [
                                                           InputQuery
                                                             (KeepEvenWhenGC, SeenOrder, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.init'')))
                                                           ])
                     , OutputSection
                         (AlwaysOutput, None, (''.plt''), [InputQuery
                                                             (DefaultKeep, DefaultSort, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.plt'')))
                                                          , InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.iplt'')))
                                                          ])
                     , OutputSection
                         (AlwaysOutput, None, (''.plt.bnd''), [InputQuery
                                                                 (DefaultKeep, DefaultSort, 
                                                                 filter_and_concat
                                                                   (name_matches
                                                                    (''.plt.bnd'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.text''), [
                                                           InputQuery
                                                             (DefaultKeep, DefaultSort, 
                                                             filter_and_concat
                                                               (
                                                               \<lambda> s .  
                                                               name_matches
                                                                 (''.text.unlikely'')
                                                                 s \<or>
                                                                 (name_matches
                                                                    (''.text.*_unlikely'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.text.unlikely.*'')
                                                                    s) ))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.text.exit'')
                                                                   s \<or>
                                                                   name_matches
                                                                    (''.text.exit.*'')
                                                                    s))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.text.startup'')
                                                                   s \<or>
                                                                   name_matches
                                                                    (''.text.startup.*'')
                                                                    s))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.text.hot'')
                                                                   s \<or>
                                                                   name_matches
                                                                    (''.text.hot.*'')
                                                                    s))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.text'')
                                                                   s \<or>
                                                                   (name_matches
                                                                    (''.stub'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.text.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.t.*'')
                                                                    s))))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 (* .gnu.warning sections are handled specially by elf32.em.
          * GAH. That means that what we specify here is not (completely) what 
          * needs to happen with these sections. *)
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.gnu_warning'')
                                                                   s)) ])
                     , OutputSection
                         (AlwaysOutput, None, (''.fini''), [
                                                           InputQuery
                                                             (KeepEvenWhenGC, SeenOrder, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.fini'')))
                                                           ])
                     , DefineSymbol
                         (ProvideIfUsed, (''__etext''), default_symbol_spec)
                     , DefineSymbol
                         (ProvideIfUsed, (''_etext''), default_symbol_spec)
                     , DefineSymbol
                         (ProvideIfUsed, (''etext''), default_symbol_spec)
                     , OutputSection
                         (AlwaysOutput, None, (''.rodata''), [
                                                             InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.rodata'')
                                                                   s \<or>
                                                                   (name_matches
                                                                    (''.rodata.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.r.*'')
                                                                    s) ))])
                     , OutputSection
                         (AlwaysOutput, None, (''.eh_frame_hdr''), [InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.eh_frame_hdr''))) ])
                     , OutputSection
                         (OnlyIfRo, None, (''.eh_frame''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.eh_frame'')))])
                     , OutputSection
                         (OnlyIfRo, None, (''.gcc_except_table''), [InputQuery
                                                                    (DefaultKeep, DefaultSort,
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.gcc_except_table'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gcc_except_table.*'')
                                                                    s))])
                     , OutputSection
                         (OnlyIfRo, None, (''.exception_ranges''), [InputQuery
                                                                    (DefaultKeep, DefaultSort,
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.exception_ranges'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.exception_ranges*'')
                                                                    s))])
                     , AdvanceAddress (AddressExprFn alloc_fn2_ref)
                     , MarkAndAlignDataSegment
                         (((( (* a.maxpagesize *) 2 :: nat) * ( 1024 :: nat))
                             * ( 1024 :: nat)) (* <-- for some reason binutils assumes 2MB max page size,
    even if ABI says smaller *) ,(commonpagesize   a))
                     , OutputSection
                         (OnlyIfRw, None, (''.eh_frame''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.eh_frame'')))])
                     , OutputSection
                         (OnlyIfRw, None, (''.gcc_except_table''), [InputQuery
                                                                    (DefaultKeep, DefaultSort,
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.gcc_except_table'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gcc_except_table.*'')
                                                                    s))])
                     , OutputSection
                         (OnlyIfRw, None, (''.exception_ranges''), [InputQuery
                                                                    (DefaultKeep, DefaultSort,
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.exception_ranges'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.exception_ranges*'')
                                                                    s))])
                     , OutputSection
                         (AlwaysOutput, None, (''.tdata''), [InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (\<lambda> s .  
                                                                  name_matches
                                                                    (''.tdata'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.tdata.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.td.*'')
                                                                    s)))])
                     , OutputSection
                         (AlwaysOutput, None, (''.tbss''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (\<lambda> s .  
                                                                 name_matches
                                                                   (''.tbss'')
                                                                   s \<or>
                                                                   (name_matches
                                                                    (''.tbss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.tb.*'')
                                                                    s)))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (name_matches
                                                                    (''.tcommon'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.preinit_array''), [
                                                                    DefineSymbol
                                                                    (ProvideIfUsed, (''__preinit_array_start''), default_symbol_spec)
                                                                    , 
                                                                    InputQuery
                                                                    (KeepEvenWhenGC, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.preinit_array'')
                                                                    s))
                                                                    , 
                                                                    DefineSymbol
                                                                    (ProvideIfUsed, (''__preinit_array_end''), default_symbol_spec)
                                                                    ])
                     , OutputSection
                         (AlwaysOutput, None, (''.init_array''), [
                                                                 DefineSymbol
                                                                   (ProvideIfUsed, (''__init_array_start''), default_symbol_spec)
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.init_array.*'')
                                                                    s))
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.ctors.*'')
                                                                    s))
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.init_array'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.ctors'')
                                                                    s \<and>
                                                                    \<not>
                                                                    (
                                                                    file_matches
                                                                    (''*crtbegin.o'')
                                                                    s \<or>
                                                                    (
                                                                    file_matches
                                                                    (''*crtbegin?.o'')
                                                                    s \<or>
                                                                    (
                                                                    file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o '')
                                                                    s))))) )
                                                                 , DefineSymbol
                                                                    (ProvideIfUsed, (''__init_array_end''), default_symbol_spec)
                                                                 ])
                     , OutputSection
                         (AlwaysOutput, None, (''.fini_array''), [
                                                                 DefineSymbol
                                                                   (ProvideIfUsed, (''__fini_array_start''), default_symbol_spec)
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.fini_array.*'')
                                                                    s))
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.dtors.*'')
                                                                    s))
                                                                 , InputQuery
                                                                    (KeepEvenWhenGC, ByInitPriority, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.fini_array'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.dtors'')
                                                                    s \<and>
                                                                    \<not>
                                                                    (
                                                                    file_matches
                                                                    (''*crtbegin.o'')
                                                                    s \<or>
                                                                    (
                                                                    file_matches
                                                                    (''*crtbegin?.o'')
                                                                    s \<or>
                                                                    (
                                                                    file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o '')
                                                                    s))))) )
                                                                 , DefineSymbol
                                                                    (ProvideIfUsed, (''__fini_array_end''), default_symbol_spec)
                                                                 ])
                     , OutputSection
                         (AlwaysOutput, None, (''.ctors''), [
                                                            InputQuery
                                                              (KeepEvenWhenGC, DefaultSort, 
                                                              filter_and_concat
                                                                (\<lambda> s .  
                                                                 file_matches
                                                                   (''*crtbegin.o'')
                                                                   s \<and>
                                                                   name_matches
                                                                    (''.ctors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   file_matches
                                                                    (''*crtbegin?.o'')
                                                                    s \<and>
                                                                    name_matches
                                                                    (''.ctors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   \<not>
                                                                    (
                                                                    file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o'')
                                                                    s) \<and>
                                                                    name_matches
                                                                    (''.ctors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, ByName, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   name_matches
                                                                    (''.ctors.*'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   (file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o'')
                                                                    s) \<and>
                                                                    name_matches
                                                                    (''.ctors'')
                                                                    s))
                                                            (* NOTE: this exclusion is implicit in the usual linker script, 
         * because it won't match an input section more than once. We should
         * just replicate this behaviour, since other parts of the script might rely on it
         * less obviously. *)
                                                            ])
                     , OutputSection
                         (AlwaysOutput, None, (''.dtors''), [
                                                            InputQuery
                                                              (KeepEvenWhenGC, DefaultSort, 
                                                              filter_and_concat
                                                                (\<lambda> s .  
                                                                 file_matches
                                                                   (''*crtbegin.o'')
                                                                   s \<and>
                                                                   name_matches
                                                                    (''.dtors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   file_matches
                                                                    (''*crtbegin?.o'')
                                                                    s \<and>
                                                                    name_matches
                                                                    (''.dtors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   \<not>
                                                                    (
                                                                    file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o'')
                                                                    s) \<and>
                                                                    name_matches
                                                                    (''.dtors'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, ByName, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   name_matches
                                                                    (''.dtors.*'')
                                                                    s))
                                                            , InputQuery
                                                                (KeepEvenWhenGC, DefaultSort, 
                                                                filter_and_concat
                                                                  (\<lambda> s .  
                                                                   (file_matches
                                                                    (''*crtend.o'')
                                                                    s \<or>
                                                                    file_matches
                                                                    (''*crtend?.o'')
                                                                    s) \<and>
                                                                    name_matches
                                                                    (''.dtors'')
                                                                    s)) ])
                     , OutputSection
                         (AlwaysOutput, None, (''.jcr''), [InputQuery
                                                             (KeepEvenWhenGC, DefaultSort, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.jcr'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.data.rel.ro''), [
                                                                  InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.data.rel.ro.local*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.d.rel.ro.local.*'')
                                                                    s )),
                                                                  InputQuery
                                                                    (DefaultKeep, DefaultSort, 
                                                                    filter_and_concat
                                                                    (
                                                                    \<lambda> s .  
                                                                    name_matches
                                                                    (''.data.rel.ro'')
                                                                    s \<or>
                                                                    (
                                                                    name_matches
                                                                    (''.data.rel.ro.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.d.rel.ro.*'')
                                                                    s) )) ])
                     , OutputSection
                         (AlwaysOutput, None, (''.dynamic''), [InputQuery
                                                                 (DefaultKeep, DefaultSort, 
                                                                 filter_and_concat
                                                                   (name_matches
                                                                    (''.dynamic'')))])
                     , OutputSection
                         (AlwaysOutput, None, (''.got''), [InputQuery
                                                             (DefaultKeep, DefaultSort, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.got'')))
                                                          , InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.igot'')))
                                                          ])
                     , MarkDataSegmentRelroEnd (*(fun secs -> (if (sizeof .got.plt secs) >= 24 then 24 else 0, (fun pos -> pos)))*)
                     , OutputSection
                         (AlwaysOutput, None, (''.got.plt''), [InputQuery
                                                                 (DefaultKeep, DefaultSort, 
                                                                 filter_and_concat
                                                                   (name_matches
                                                                    (''.got.plt'')))
                                                              , InputQuery
                                                                  (DefaultKeep, DefaultSort, 
                                                                  filter_and_concat
                                                                    (
                                                                    name_matches
                                                                    (''.igot.plt'')))
                                                              ])
                     , OutputSection
                         (AlwaysOutput, None, (''.data''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (
                                                                \<lambda> s .  
                                                                name_matches
                                                                  (''.data'')
                                                                  s \<or>
                                                                  (name_matches
                                                                    (''.data.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.d.*'')
                                                                    s)))
                                                           (* the script also has SORT(CONSTRUCTORS) here, but it has no effect for ELF (I think) *)
                                                           ])
                     , OutputSection
                         (AlwaysOutput, None, (''.data1''), [InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (name_matches
                                                                    (''.data1'')))])
                     , DefineSymbol
                         (AlwaysDefine, (''_edata''), default_symbol_spec)
                     , DefineSymbol
                         (ProvideIfUsed, (''edata''), default_symbol_spec)
                     , (* . = .;    <-- does this do anything? YES! It forces an output section to be emitted. 
         Since it occurs *outside* any output section, 
         it is assumed to start 
       *)
                       DefineSymbol
                         (AlwaysDefine, (''__bss_start''), default_symbol_spec)
                     , OutputSection
                         (AlwaysOutput, None, (''.bss''), [InputQuery
                                                             (DefaultKeep, DefaultSort, 
                                                             filter_and_concat
                                                               (name_matches
                                                                  (''.dynbss'')))
                                                          , InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (
                                                                \<lambda> s .  
                                                                name_matches
                                                                  (''.bss'')
                                                                  s \<or>
                                                                  (name_matches
                                                                    (''.bss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.b.*'')
                                                                    s)))
                                                          , InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              (\<lambda> inputlist . 
                                                               (*let _ = errln Looking for commons in *)
                                                               (let result = 
                                                                    (
                                                                    filter_and_concat
                                                                    is_common
                                                                    inputlist)
                                                               in
                                                               (*let _ = errln (Got  ^ (show (length (result))) ^  commons; sanity check: input list contains  ^
                                    (show (length inputlist)) ^  of which  ^
                                    (show (length (List.filter (fun inp -> match inp with
                                        Common _ -> true
                                        | _ -> false
                                    end) inputlist))) ^  are commons.
                                ) 
                                in*) result))
                                                              ) ])
                     , AdvanceAddress (AddressExprFn alloc_fn3_ref)
                     , OutputSection
                         (AlwaysOutput, None, (''.lbss''), [InputQuery
                                                              (DefaultKeep, DefaultSort, 
                                                              filter_and_concat
                                                                (name_matches
                                                                   (''.dynlbss'')))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (name_matches
                                                                    (''.dynlbss'')))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (
                                                                 \<lambda> s .  
                                                                 name_matches
                                                                   (''.lbss'')
                                                                   s \<or>
                                                                   (name_matches
                                                                    (''.lbss.*'')
                                                                    s \<or>
                                                                    name_matches
                                                                    (''.gnu.linkonce.lb.*'')
                                                                    s) ))
                                                           , InputQuery
                                                               (DefaultKeep, DefaultSort, 
                                                               filter_and_concat
                                                                 (is_large_common))
                                                           ])
                     , AdvanceAddress (AddressExprFn alloc_fn4_ref)
                     , AdvanceAddress (AddressExprFn alloc_fn5_ref)
                     , OutputSection
                         (AlwaysOutput, Some (AddressExprFn alloc_fn6_ref),
                         (''.lrodata''),
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (
                                                         \<lambda> s .  
                                                         name_matches
                                                           (''.lrodata'') 
                                                         s \<or>
                                                           (name_matches
                                                              (''.lrodata.*'')
                                                              s \<or>
                                                              name_matches
                                                                (''.gnu.linkonce.lr.*'')
                                                                s) ))
                         , AdvanceAddress (AddressExprFn alloc_fn7_ref) ])
                     , AdvanceAddress (AddressExprFn alloc_fn8_ref)
                     , DefineSymbol
                         (AlwaysDefine, (''_end''), default_symbol_spec)
                     , DefineSymbol
                         (ProvideIfUsed, (''end''), default_symbol_spec)
                     , MarkDataSegmentEnd
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stab''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stab'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stabstr''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stabstr'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stab.excl''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stab.excl'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stab.exclstr''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stab.exclstr'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stab.index''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stab.index'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.stab.indexstr''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.stab.indexstr'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.comment''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.comment'')))])
                     (* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  *)
                     (* DWARF 1 *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.line''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.line'')))])
                     (* GNU DWARF 1 extensions *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_srcinfo''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_srcinfo'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_sfnames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_sfname'')))])
                     (* DWARF 1.1 and DWARF 2 *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_aranges''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_aranges'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_pubnames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_pubnames'')))])
                     (* DWARF 2 *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_info''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (
                                                         \<lambda> s .  
                                                         name_matches
                                                           (''.debug_info'')
                                                           s \<or>
                                                           name_matches
                                                             (''.gnu.linkonce.wi.*'')
                                                             s))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_abbrev''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_abbrev'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_line''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (
                                                         \<lambda> s .  
                                                         name_matches
                                                           (''.debug_line'')
                                                           s \<or>
                                                           (name_matches
                                                              (''.debug_line.*'')
                                                              s \<or>
                                                              name_matches
                                                                (''.debug_line_end'')
                                                                s)))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_frame''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_frame'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_str''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_str'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_loc''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_loc'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_macinfo''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_macinfo'')))])
                     (* SGI/MIPS DWARF 2 extensions *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_weaknames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_weaknames'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_funcnames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_funcnames'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_typenames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_typenames'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_varnames''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_varnames'')))])
                     (* DWARF 3 *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_pubtypes''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_pubtypes'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_ranges''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_ranges'')))])
                     (* DWARF Extension.  *)
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.debug_macro''), 
                         [InputQuery
                            (DefaultKeep, DefaultSort, filter_and_concat
                                                         (name_matches
                                                            (''.debug_macro'')))])
                     , OutputSection
                         (AlwaysOutput, Some address_zero_fn, (''.gnu.attributes''), 
                         [InputQuery
                            (KeepEvenWhenGC, DefaultSort, filter_and_concat
                                                            (name_matches
                                                               (''.gnu.attributes'')))])
                     , DiscardInput
                         (filter_and_concat
                            (\<lambda> s .  name_matches
                                              (''.note.GNU-stack'') s \<or>
                                              (name_matches
                                                 (''.gnu_debuglink'') 
                                               s \<or>
                                                 name_matches
                                                   (''.gnu.lto_*'') s)))
                     (* NOTE: orphan sections are dealt with in the core linking logic,
       not the script. *)
                     ]))))))))))))))))))))))))))))))))))))) )"


definition interpret_guard  :: " output_guard \<Rightarrow>(output_section_composition_element)list \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " interpret_guard Always comp1 name1 = ( True )"


(* Passes over the script: 
 * 
 * 1. assign input sections to output sections (or discard) and define symbols.
 * 
 * 2. compute def-use and optionally GC, removing unwanted sections and symbols
 * 
 * 3. build image, assigning addresses as we go. 
 * 
 * Some passes require matching/retrieving what a previous pass on the same node did.
 * So we give each script element a natural idx label.
 *)
(*val label_script_aux : natural -> linker_control_script -> labelled_linker_control_script*)
definition label_script_aux  :: " nat \<Rightarrow>(script_element)list \<Rightarrow>(script_element*nat)list "  where 
     " label_script_aux start script = ( 
    mapi (\<lambda> i .  \<lambda> el .  (el, (start +  i))) script )"


(*val label_script : linker_control_script -> labelled_linker_control_script*)
definition label_script  :: "(script_element)list \<Rightarrow>(script_element*nat)list "  where 
     " label_script script = ( label_script_aux(( 0 :: nat)) script )"


type_synonym input_output_assignment =" ( input_spec list * (output_section_spec * nat) list)"

axiomatization
  assign_inputs_to_output_sections  :: "(input_spec)list*(output_section_spec*nat)list \<Rightarrow>(nat*nat)set \<Rightarrow>(nat*nat*nat)set \<Rightarrow>(input_spec)list \<Rightarrow>(output_section_spec*nat)option \<Rightarrow>(input_spec)option \<Rightarrow>(input_spec \<Rightarrow> input_spec \<Rightarrow> ordering)\<Rightarrow>(script_element*nat)list \<Rightarrow>(input_spec)list*(output_section_spec*nat)list"

(*val assign_inputs_to_output_sections : 
    input_output_assignment ->  (* accumulator: list of discards, list of output compositions (these include symbols)  *)
    set (natural * natural) ->  (* used sections *)
    set (natural * natural * natural) -> (* used commons *)
    list input_spec ->            (* remaining inputs *)
    maybe (output_section_spec * natural) ->  (* cur_sec -- the current output section spec and its OutputSection script item idx *)
    maybe input_spec ->           (* last input section to be output -- might not have one *)
    (input_spec -> input_spec -> Basic_classes.ordering) (* seen ordering *) ->
    labelled_linker_control_script -> 
    input_output_assignment*)     (* accumulated result *)

(*function (sequential,domintros)  assign_inputs_to_output_sections  :: "(input_spec)list*(output_section_spec*nat)list \<Rightarrow>(nat*nat)set \<Rightarrow>(nat*nat*nat)set \<Rightarrow>(input_spec)list \<Rightarrow>(output_section_spec*nat)option \<Rightarrow>(input_spec)option \<Rightarrow>(input_spec \<Rightarrow> input_spec \<Rightarrow> ordering)\<Rightarrow>(script_element*nat)list \<Rightarrow>(input_spec)list*(output_section_spec*nat)list "  where 
     " assign_inputs_to_output_sections acc1 used_sections used_commons inputs1 (cur_output_sec ::  (output_section_spec * nat)option) last_input_sec seen_ordering script = ( 
    (let (rev_discards, rev_outputs) = acc1 in 
    (let flush_output_sec 
     = (\<lambda> maybe_output_sec_and_idx .  (case  (maybe_output_sec_and_idx ::  (output_section_spec * nat)option) of
        Some (OutputSectionSpec (guard, addr, name1, comp1), script_idx) => 
            (let _ = (())
            in
            (* evaluate the guard *)
            if interpret_guard guard comp1 name1
            then (* do it     *) (rev_discards, (((OutputSectionSpec (guard, addr, name1, comp1)), script_idx) # rev_outputs))
            else (* ignore it *) acc1)
        | None => (* for convenience, make this a no-op rather than error *)
            (* failwith internal error: flushing output section with no current output section *)
            acc1
    ))
    in
    (case  script of
        [] =>  flush_output_sec cur_output_sec
        | (element, idx1) # more_elements_and_idx =>
            (let do_nothing = (acc1, used_sections, used_commons, cur_output_sec, last_input_sec) 
            in
            (let (new_acc, new_used_sections, new_used_commons, (new_cur_output_sec ::  (output_section_spec * nat)option), new_last_input_sec)
             = ((case  element of
                DefineSymbol(symdefpol, name1, (symsize, syminfo, symother)) =>
                    (* Label the current section in the image 
                     * with a new symbol definition. If there isn't
                     * a current section, use the ABS section (what is that labelling?). *)
                    (acc1,
                     used_sections,
                     used_commons,
                     (case  (cur_output_sec ::  (output_section_spec * nat)option) of
                        None => (let _ = (()) in None)
                        | Some ((OutputSectionSpec (guard, maybe_addr, secname1, comp1)), output_script_idx) =>
                            (let _ = (()) in
                            Some ((OutputSectionSpec (guard, maybe_addr, secname1,                                
 (comp1 @ [ProvideSymbol(symdefpol, name1, (symsize, syminfo, symother))])))
                             , output_script_idx))
                    ),
                    last_input_sec)
                | AdvanceAddress(AddressExprFn advance_fn) =>
                     (* If we're inside a section, insert a hole, 
                      * else just update the logical address *)
                     (let _ = (()) in
                     (case  cur_output_sec of
                        None => do_nothing
                            (* This assignment is setting a new LMA. *)
                            (* (acc,  *)
                        | Some (sec, idx1) => do_nothing
                     ))
                | MarkAndAlignDataSegment(maxpagesize1, commonpagesize1) => 
                     (* The data segment end is a distinguished label, 
                      * so we can encode the whole thing into a conditional. *)
                     (let _ = (()) in
                     do_nothing)
                | MarkDataSegmentEnd => 
                     (let _ = (()) in
                     do_nothing)
                | MarkDataSegmentRelroEnd(*(fun_from_secs_to_something)*) =>
                     (let _ = (()) in
                     do_nothing)
                | OutputSection(outputguard, maybe_expr, name1, sub_elements) => 
                    (* If we have a current output section, finish it and add it to the image.
                     * Q. Where do guards (ONLY_IF_RO etc) get evaluated?
                     * A. Inside flush_output_sec. *)
                    (let _ = (()) in
                    (let acc_with_output_sec = (flush_output_sec cur_output_sec)
                    in
                    (let new_cur_output_sec = (Some((OutputSectionSpec(outputguard, (* maybe_expr pos secs *) None, name1, [])), idx1))
                    in
                    (* Recurse down the list of input queries, assigning them to this output sec
                     * Note that output sections may not nest within other output sections. 
                     * At the end of the list of sub_elements, we will flush the section we built up. 
                     *)
                    (let final_acc
                    = (assign_inputs_to_output_sections acc1 used_sections used_commons inputs1 new_cur_output_sec last_input_sec seen_ordering (label_script sub_elements))
                    in
                    (* NOTE that this sub-accumulation will never add a new output section
                     * because output sections can't nest. *)
                    (final_acc, used_sections, used_commons, (* cur_output_sec *) None, last_input_sec))))) 
                | DiscardInput(selector) => 
                    (let selected = (selector inputs1)
                    in
                    (let (rev_discards, rev_outputs) = acc1 in
                    (let _ = (())
                    in
                    ((((List.rev ((let x2 = 
  ([]) in  List.foldr (\<lambda>i x2 .  if True then i # x2 else x2) selected x2))) @ rev_discards), rev_outputs), used_sections, used_commons, cur_output_sec, last_input_sec))))
                | InputQuery(retainpol, sortpol, selector) => 
                    (* Input queries can only occur within an output section. *)
                    (case  cur_output_sec of
                        None => failwith (''linker script error: input query without output section'')
                        | Some ((OutputSectionSpec (output_guard, output_sec_addr, output_sec_name, output_composition)), output_script_idx) =>
                            (* Add them to the current output spec. We have to be careful about ordering:
                             * according to the GNU ld manual (and observed behaviour), by default
                             * the linker will place files and sections matched by wildcards in the order
                             * in which they are seen during the link. For .o files on the command line,
                             * this means the command line order. But for members of archives, it means
                             * the order in which they were pulled in during input enumeration. We 
                             * actually don't compute this here; it is passed in from our caller in link.lem. *)
                            (let sortfun = ((case  sortpol of
                                DefaultSort => Elf_Types_Local.merge_sort seen_ordering (* FIXME: pay attention to command line *)
                                | SeenOrder => Elf_Types_Local.merge_sort seen_ordering
                                | ByName => Elf_Types_Local.merge_sort compareInputSpecByName
                                | ByNameThenAlignment => Elf_Types_Local.merge_sort compareInputSpecByNameThenAlignment
                                | ByAlignment => Elf_Types_Local.merge_sort compareInputSpecByAlignment
                                | ByAlignmentThenName => Elf_Types_Local.merge_sort compareInputSpecByAlignmentThenName
                                | ByInitPriority => Elf_Types_Local.merge_sort compareInputSpecByInitPriority
                            ))
                            in
                            (let selected = (selector inputs1)
                            in
                            (let selected_deduplicated = (List.filter (\<lambda> inp .  (case  inp of
                                InputSection(irec) => \<not> (((idx   irec),(shndx   irec)) \<in> used_sections)
                                | Common(idx1, fname1, img3, def1) => \<not> ((idx1,(def_sym_scn   def1),(def_sym_idx   def1)) \<in> used_commons)
                            )) selected)
                            in
                            (let _ = (()) in
                            (* Search input memory images for matching sections. *)
                            (let sorted_selected_inputs = (sortfun selected_deduplicated)
                            in
                            (let (sectionMatchList :: input_section_rec list) = (Lem_list.mapMaybe (\<lambda> inp .  
                                (case  inp of
                                    InputSection(x) => 
                                        (*let _ = errln (Matched an input section named  ^ x.isec.elf64_section_name_as_string ^ 
                                             in a file  ^ x.fname ^  with first 20 bytes  ^ (show (take 20 
                                                (let maybe_elname = elf_memory_image_element_coextensive_with_section x.shndx x.img 
                                                 in
                                                 match maybe_elname with
                                                    Nothing -> failwith (impossible: no such element (matching shndx  ^ (show x.shndx) ^ ))
                                                    | Just idstr -> 
                                                        match Map.lookup idstr x.img.elements with
                                                            Just el -> el.contents
                                                            | Nothing -> failwith no such element
                                                        end
                                                end
                                                ))))
                                            in*)
                                            Some x
                                   | _ => None
                                )) sorted_selected_inputs)
                            in
                            (let commonMatchList = (Lem_list.mapMaybe (\<lambda> inp .  
                                (case  inp of
                                     Common(idx1, fname1, img3, def1) => Some(idx1, fname1, img3, def1)
                                   | _ => None
                                )) sorted_selected_inputs)
                            in
                            
                            (acc1,                             
 (used_sections \<union> 
  Set.image (\<lambda> irec .  ((idx   irec),(shndx   irec)))
    (set_filter (\<lambda> irec .  True) (List.set sectionMatchList))),                             
(used_commons  \<union> 
  Set.image
    (\<lambda> (idx1, fname1, img3, def1) .  (idx1,(def_sym_scn   def1),(def_sym_idx   def1)))
    (set_filter (\<lambda> (idx1, fname1, img3, def1) .  True)
       (List.set commonMatchList))),
                             (* new_cur_output_spec *) Some (
                                (OutputSectionSpec(output_guard, output_sec_addr, output_sec_name, 
                                    ((output_composition @                                     
 ((let x2 = ([]) in  List.foldr
   (\<lambda>input_sec x2 . 
    if True then
      IncludeInputSection
        (retainpol, (* input_sec.fname, input_sec.idx, input_sec.shndx, input_sec.isec, input_sec.img *) input_sec)
        # x2 else x2) sectionMatchList x2))) @                                     
 ((let x2 = ([]) in  List.foldr
   (\<lambda>(idx1, fname1, img3, def1) x2 . 
    if True then
      IncludeCommonSymbol (DefaultKeep, fname1, idx1, def1, img3) # x2 else
      x2) commonMatchList x2)))
                                )), output_script_idx), 
                             last_input_sec
                            ))))))))
                    )
            ))
            in
            (let _ = ((case  new_cur_output_sec of
                Some (OutputSectionSpec (guard, addr, name1, comp1), script_idx) => 
                    ()
                | None => () 
            )) in
            assign_inputs_to_output_sections new_acc new_used_sections new_used_commons 
                (inputs1 :: input_spec list)
                (new_cur_output_sec)
                (new_last_input_sec ::  input_spec option)
                seen_ordering
                (more_elements_and_idx :: labelled_linker_control_script))))
    ))))" 
by pat_completeness auto
*)

(* NOTE: this is also responsible for deleting any PROVIDEd symbols that 
 * were not actually referenced. BUT HOW, if we haven't built the image and 
 * hence haven't added the symbols yet? Symbols affect reachability, so 
 * we're going to have to figure this out. Really we want a memory image that
 * does not yet have addresses assigned, but does have the symbols inserted. 
 * BUT even that is not right, because we want to be able to remove some
 * sections (GC them). So the section composition is not yet fixed. So we have 
 * a problem.
 *
 * Note that the only symbols we have to remove are ones that were PROVIDEd 
 * in our output composition. So doing the GC on output compositions seems
 * sane. We can get the graph's edge list by inspecting the constituent memory
 * images from which each output section composition element is drawn.
 * Collecting sections and collecting symbols seems fair. Note that symbols
 * can never be placed mid-section (I don't think?? they can use arbitrary
 * expressions, but not that depend on whether an input section is included
 * or not) so removing a section should never imply the removal of a symbol.
 * 
 * So that implies we need not yet build a memory image.
 *)
(*val compute_def_use_and_gc : allocated_sections_map -> allocated_sections_map*)
definition compute_def_use_and_gc  :: " allocated_sections_map \<Rightarrow> allocated_sections_map "  where 
     " compute_def_use_and_gc outputs_by_name = ( outputs_by_name )"
 (* FIXME: implement GC *)

definition output_section_type  :: "(output_section_composition_element)list \<Rightarrow> nat "  where 
     " output_section_type comp1 = ( 
   (* are we composed entirely of nobits sections and common symbols? *)
        (let all_nobits = (((\<forall> x \<in> (set comp1).  (\<lambda> comp_el .  
            (case  comp_el of 
                IncludeInputSection(retain_pol,(*  fname, linkable_idx, shndx, isec, img *) irec) =>(elf64_section_type  (isec   
                    irec)) = sht_nobits
                | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => True
                | _ => (* padding and symdefs can be nobits *) True
            )) x)))
        in
        if all_nobits then sht_nobits else sht_progbits))"


definition output_section_flags  :: "(output_section_composition_element)list \<Rightarrow> nat "  where 
     " output_section_flags comp1 = ( 
    (let writable = (((\<exists> x \<in> (set comp1).  (\<lambda> comp_el .  
        (case  comp_el of 
            IncludeInputSection(retain_pol, (* fname, linkable_idx, shndx, isec, img *) irec) => 
                flag_is_set shf_write(elf64_section_flags  (isec   irec))
            | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => 
                (* assume common symbols are writable *) True
            | _ => (* padding and symdefs do not make a section writable *) False
        )) x)))
    in
    (let executable = (((\<exists> x \<in> (set comp1).  (\<lambda> comp_el .  
        (case  comp_el of 
            IncludeInputSection(retain_pol,(* fname, linkable_idx, shndx, isec, img *) irec) => 
                flag_is_set shf_execinstr(elf64_section_flags  (isec   irec))
            | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => 
                (* assume common symbols are not executable, since they're zeroed *) False
            | _ => (* padding and symdefs do not make a section executable -- HMM *) False
        )) x)))
    in
    (let alloc = (((\<exists> x \<in> (set comp1).  (\<lambda> comp_el .  
        (case  comp_el of 
            IncludeInputSection(retain_pol, (* fname, linkable_idx, shndx, isec, img *) irec) => 
                flag_is_set shf_alloc(elf64_section_flags  (isec   irec))
            | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => 
                (* common symbols are allocatable *) True
            | ProvideSymbol(pol, name1, spec) => 
                (* symbols make a section allocatable? HMM *) True
            | _ => (* padding does not make a section allocatable *) False
        )) x)))
    in
    (let is_thread_local_yesnomaybe = (\<lambda> comp_el .  
        (case  comp_el of 
            IncludeInputSection(retain_pol, (* fname, linkable_idx, shndx, isec, img *) irec) => 
                Some(flag_is_set shf_tls(elf64_section_flags  (isec   irec)))
            | IncludeCommonSymbol(retain_pol, fname1, linkable_idx, def1, img3) => 
                (* FIXME: support tcommon *) Some(False)
            | ProvideSymbol(pol, name1, spec) => 
                (* linker script symbols shouldn't be defined here, unless they can be declared thread-local (FIXME: can they?) *)
                Some False
            | _ => (* padding does not make a section thread-local, or non-. *) None
        )
    )
    in
    (let thread_local = (
        (* Is any element positively thread-local? *)
        (let v = (List.foldl (\<lambda> acc_ynm .  \<lambda> comp_el .  
            (let new_ynm = (is_thread_local_yesnomaybe comp_el)
            in  (case  (acc_ynm, new_ynm) of
     (None, None) => None
   | (None, Some x) => Some x
   | (Some x, None) => Some x
   | (Some True, Some False) => Some True
   | (Some True, Some True) => Some True
   | (Some False, Some False) => Some False
 ))) None comp1)
        in
        if (v = Some(True)) \<and> \<not> (Some(True) = (* are *all* either don't-care or positively thread-local? *)
            (List.foldl (\<lambda> acc_ynm .  \<lambda> comp_el .  
            (let new_ynm = (is_thread_local_yesnomaybe comp_el)
            in  (case  (acc_ynm, new_ynm) of
     (None, None) => None
   | (None, Some x) => Some x
   | (Some x, None) => Some x
   | (Some True, Some False) => Some False
   | (Some True, Some True) => Some True
   | (Some False, Some False) => Some False
 ))) None comp1)) then failwith (''error: section mixes thread-local and non-thread-local inputs'')
        else (case  v of
            None => False
            | Some x => x
        ))
    )
    in
    natural_lor
        (if thread_local then shf_tls else( 0 :: nat))
        (natural_lor
            (if executable then shf_execinstr else( 0 :: nat))
            (natural_lor 
                (if writable then shf_write else( 0 :: nat))
                (if alloc then    shf_alloc else( 0 :: nat))
            )
        )))))))"


definition symbol_def_for_provide_symbol  :: " string \<Rightarrow> nat \<Rightarrow> Elf_Types_Local.unsigned_char \<Rightarrow> Elf_Types_Local.unsigned_char \<Rightarrow> nat \<Rightarrow> symbol_definition "  where 
     " symbol_def_for_provide_symbol name1 size3 info other control_script_linkable_idx = ( 
    (|
        def_symname = (*let _ = errln (Linker script is defining symbol called ` ^ name ^ ') in*) name1
        , def_syment = ((|
             elf64_st_name  = (Elf_Types_Local.uint32_of_nat(( 0 :: nat))) (* ignored *)
           , elf64_st_info  = info
           , elf64_st_other = other
           , elf64_st_shndx = (Elf_Types_Local.uint16_of_nat(( 0 :: nat)))
           , elf64_st_value = (Elf_Types_Local.uint64_of_nat(( 0 :: nat))) (* ignored *)
           , elf64_st_size  = (of_int (int size3))
           |))
        , def_sym_scn =(( 0 :: nat))
        , def_sym_idx =(( 0 :: nat))
        , def_linkable_idx = control_script_linkable_idx
    |) )"


(*val assign_dot_to_itself : natural -> address_expr_fn_map allocated_sections_map -> (natural * address_expr_fn_map allocated_sections_map * address_expr_fn)*)
definition assign_dot_to_itself  :: " nat \<Rightarrow>((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow> nat*((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map*address_expr_fn "  where 
     " assign_dot_to_itself fresh alloc_map = (
  (let fn = (\<lambda> dot .  \<lambda> _ .  dot) in
  (let alloc_map' = (map_update fresh fn alloc_map) in
  (let fresh' =(( 1 :: nat) + fresh) in
    (fresh', alloc_map', AddressExprFn fresh)))))"


(*val build_image :
    address_expr_fn_map allocated_sections_map -> (* global dictionary of address_expr_fn_ref -> address_expr_fn *)
    elf_memory_image ->          (* accumulator *)
    natural ->                   (* location counter *)
    allocated_sections_map ->  (* outputs constructed earlier *)
    (Map.map string (list (natural * binding))) -> (* bindings_by_name *)
    labelled_linker_control_script -> 
    natural -> (* control_script_linkable_idx *)
    (Map.map string (list symbol_definition)) -> (* linker_defs_by_name *)
    (elf_memory_image * allocated_sections_map)*)            (* accumulated result *)
function (sequential,domintros)  build_image  :: "((nat),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow>(any_abi_feature)annotated_memory_image \<Rightarrow> nat \<Rightarrow> allocated_sections_map \<Rightarrow>((string),((nat*((nat*symbol_reference*(linkable_object*input_item*input_options))*(nat*symbol_definition*linkable_item)option))list))Map.map \<Rightarrow>(script_element*nat)list \<Rightarrow> nat \<Rightarrow>((string),((symbol_definition)list))Map.map \<Rightarrow>(any_abi_feature)annotated_memory_image*allocated_sections_map "  where 
     " build_image alloc_map acc1 pos (AllocatedSectionsMap outputs_by_name) bindings_by_name script control_script_linkable_idx linker_defs_by_name = ( 
     (let (add_output_section :: (nat * elf_memory_image) \<Rightarrow> output_section_spec \<Rightarrow> (nat * elf_memory_image * nat * output_section_spec))
     = (\<lambda> ((*scn_idx, *)pos, acc_img) . 
        (\<lambda>o1 .  
  (case  (o1 ) of
      ( (OutputSectionSpec (guard, addr, secname1, comp1)) ) =>
  (let _ = (()) in
  (let unaligned_start_addr = ((case  addr of
                                   Some a => failwith
                                               ((''internal error: section '')
                                                  @
                                                  (secname1 @
                                                     ('': did not expect address to be assigned yet'')))
                                 | None => pos
                               )) in
  (let align = (alignof_output_section comp1) in
  (let _ = (()) in
  (let output_section_start_addr = (align_up_to align unaligned_start_addr)
  in
  (let (end_addr, comp_addrs) = (do_output_section_layout_starting_at_addr
                                   output_section_start_addr
                                   (AllocatedSectionsMap outputs_by_name)
                                   comp1) in
  (let size3 = (end_addr - output_section_start_addr) in
  (let _ = (()) in
  (let (concatenated_content, final_addr, new_range_tag_pairs) = (List.foldl
                                                                    (
                                                                    \<lambda> (accum_pat, accum_current_addr, accum_meta) .  
                                                                    (
                                                                    \<lambda> (comp_el, comp_addr) . 
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    make_line = 
                                                                    (
                                                                    \<lambda> namestr .  
                                                                    (
                                                                    \<lambda> addrstr .  
                                                                    (
                                                                    \<lambda> szstr .  
                                                                    (
                                                                    \<lambda> rhs .  
                                                                    (
                                                                    (
                                                                    space_padded_and_maybe_newline
                                                                    (
                                                                    (
                                                                     16 :: nat))
                                                                    (
                                                                    ('' '') @
                                                                    namestr))
                                                                    @
                                                                    (
                                                                    (
                                                                    (''0x'')
                                                                    @
                                                                    (
                                                                    left_zero_padded_to
                                                                    (
                                                                    (
                                                                     16 :: nat))
                                                                    addrstr))
                                                                    @
                                                                    (
                                                                    ('' '') @
                                                                    (
                                                                    (
                                                                    left_space_padded_to
                                                                    (
                                                                    (
                                                                     10 :: nat))
                                                                    (
                                                                    (''0x'')
                                                                    @ 
                                                                    szstr)) @
                                                                    (
                                                                    ('' '') @
                                                                    rhs)))) )))))
                                                                    in
                                                                    (let 
                                                                    (sz, comp_el_pat, this_el_meta) = 
                                                                    (
                                                                    (case  comp_el of
                                                                      IncludeInputSection (retainpolicy, (* fname, linkable_idx, shndx, isec, img *) irec) =>
                                                                    (* We want to get the input section as a byte pattern *)
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    maybe_secname = 
                                                                    (
                                                                    elf_memory_image_element_coextensive_with_section
                                                                    (shndx   irec)
                                                                    (img   irec))
                                                                    in
                                                                    (case  maybe_secname of
                                                                    None => 
                                                                    failwith
                                                                    (
                                                                    (''impossible: no such section'') (*(matching irec.shndx  ^ (show irec.shndx) ^ )*) )
                                                                    | Some idstr =>
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (case  
                                                                    
                                                                    (elements  (img   irec))
                                                                    idstr of
                                                                    Some el =>
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    section_el_name = 
                                                                    (
                                                                    get_unique_name_for_section_from_index
                                                                    (shndx   irec)
                                                                    (isec   irec)
                                                                    (img   irec))
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    range_or_sym_is_in_this_sec = 
                                                                    (
                                                                    \<lambda> maybe_range .  
                                                                    (
                                                                    \<lambda> tag . 
                                                                    (* is it within the section we're outputting? 
                                         * first we needs its element name. *)
                                                                    (* filter out ones that don't overlap *)
                                                                    (case  maybe_range of
                                                                    Some(el_name, (start, len)) =>
                                                                    (* img and shndx came as a unit, so they're definitely 
                                                 * talking about the same file *)
                                                                    (* shndx = sym_shndx *)
                                                                    section_el_name
                                                                    = 
                                                                    el_name
                                                                    | None =>
                                                                    (* ABS symbols have this property *)
                                                                    (case  tag of
                                                                    SymbolDef (def1) =>
                                                                    (* don't match section symbols, or we'll be inundated *)
                                                                    (let 
                                                                    sym_shndx = 
                                                                    (
                                                                    unat
                                                                    (elf64_st_shndx  (def_syment   def1)))
                                                                    in
                                                                    if 
                                                                    \<not>
                                                                    (
                                                                    sym_shndx
                                                                    = 
                                                                    shn_abs)
                                                                    \<or>
                                                                    ( 
                                                                    \<not>
                                                                    (
                                                                    (
                                                                    get_elf64_symbol_type
                                                                    (def_syment   def1))
                                                                    =
                                                                    stt_section)) then
                                                                    False
                                                                    else
                                                                    (
                                                                    (let 
                                                                    abs_address = 
                                                                    (
                                                                    unat
                                                                    (elf64_st_value  (def_syment   def1)))
                                                                    in
                                                                    (* check it against our section *)
                                                                    (let 
                                                                    section_end_addr = 
                                                                    (
                                                                    accum_current_addr
                                                                    +
                                                                    (elf64_section_size  (isec   irec)))
                                                                    in
                                                                    (
                                                                    (
                                                                    abs_address
                                                                    \<ge>
                                                                    accum_current_addr)
                                                                    \<and>
                                                                    (
                                                                    abs_address
                                                                    <
                                                                    section_end_addr))
                                                                    (* FIXME: argument that this should be <=, i.e. can mark end addr *)
                                                                    (* PROBLEM: this is all very well, but there's no reason why
                                                                 * ABS symbols need to point at an address within some output
                                                                 * section. They can just be arbitrary values. This is a bit of an
                                                                 * abuse if we do it within the C language (to get the value, you 
                                                                 * have to do (int) &sym, i.e. create a meaningless pointer 
                                                                 * intermediate) but arguably is okay in an impl-def way.
                                                                 * 
                                                                 * WHAT to do? well, just always output the ABS symbols, for now.
                                                                 * 
                                                                 * The example that provoked this is in glibc's 
                                                                 * locale/lc-address.c, which compiles down to create
                                                                 * the following ABS symbol:
                                                                 * 
                                                                 * 0000000000000001 g       *ABS*	0000000000000000 _nl_current_LC_ADDRESS_used
                                                                 * 
                                                                 * ... i.e. the _nl_current_LC_ADDRESS_used appears to be just a flag.
                                                                 *
                                                                 * Where can we handle this? We don't see ABS symbols since they
                                                                 * aren't associated with sections. We simply need to copy over
                                                                 * all the ABS symbols appearing in included input objects.
                                                                 * That means there's no point doing anything with them here
                                                                 * while we're fiddling with sections. Do it later in a whole-
                                                                 * -image pass.
                                                                 *)
                                                                    \<and>
                                                                    False)) (* ... at least until we see a better way *)
                                                                    ))
                                                                    | _ => 
                                                                    False
                                                                    )
                                                                    ) )) in
                                                                    (let 
                                                                    ranges_and_tags = 
                                                                    (
                                                                    (let 
                                                                    x2 = 
                                                                    ([]) in
                                                                    List.foldr
                                                                    (
                                                                    \<lambda>(maybe_range, tag) x2 . 
                                                                    if
                                                                    range_or_sym_is_in_this_sec
                                                                    maybe_range
                                                                    tag then
                                                                    (maybe_range, tag)
                                                                    # 
                                                                    x2 else
                                                                    x2)
                                                                    (
                                                                    list_of_set
                                                                    (by_range  (img   irec)))
                                                                    x2)) in
                                                                    (let 
                                                                    included_defs = 
                                                                    (
                                                                    (let 
                                                                    x2 = 
                                                                    ([]) in
                                                                    List.foldr
                                                                    (
                                                                    \<lambda>(maybe_range, def1) x2 . 
                                                                    if 
                                                                    range_or_sym_is_in_this_sec
                                                                    maybe_range
                                                                    (
                                                                    SymbolDef
                                                                    (def1)) then
                                                                    def1 # x2
                                                                    else 
                                                                    x2)
                                                                    (
                                                                    elf_memory_image_defined_symbols_and_ranges
                                                                    (img   irec))
                                                                    x2)) in
                                                                    (let 
                                                                    included_global_defs = 
                                                                    (
                                                                    (let 
                                                                    x2 = 
                                                                    ([]) in
                                                                    List.foldr
                                                                    (
                                                                    \<lambda>def1 x2 . 
                                                                    if 
                                                                    \<not>
                                                                    (
                                                                    (
                                                                    (* filter out locals *) get_elf64_symbol_binding
                                                                    (def_syment   def1))
                                                                    =
                                                                    stb_local) then
                                                                    def1 # x2
                                                                    else 
                                                                    x2)
                                                                    included_defs
                                                                    x2)) in
                                                                    (* What symbol defs are being included? *)
                                                                    (* For each global symbol defined in the section, output a line. *)
                                                                    (*let _ = Missing_pervasives.outs (List.foldl (^)  (
                                        List.map (fun def -> (make_line 
                                                (hex_string_of_natural (comp_addr + (natural_of_elf64_addr def.def_syment.elf64_st_value)))
                                                (hex_string_of_natural (natural_of_elf64_xword def.def_syment.elf64_st_size))
                                                (     ^ def.def_symname)) ^ n
                                        ) included_global_defs
                                    ))
                                    in*)
                                                                    (let 
                                                                    (new_ranges_and_tags :: (( element_range option) * ( any_abi_feature range_tag)) set)
                                                                    = 
                                                                    (
                                                                    Lem_set.setMapMaybe
                                                                    (
                                                                    \<lambda> (maybe_range, tag) . 
                                                                    (* How do we update existing metadata? In general,
                                         * we get a new range. *)
                                                                    (let 
                                                                    new_range = 
                                                                    (
                                                                    (case  maybe_range of
                                                                    None => 
                                                                    None
                                                                    | Some(el_name, (start, len)) =>
                                                                    Some
                                                                    (secname1,
                                                                    ( 
                                                                    (* FIXME: pass this through a section-to-element gensym. 
                                                                We can just (for now) define output element names
                                                                to equal the section names, since we have no unnamed
                                                                output sections and no output common symbols. *) (let 
                                                                    new_start_off = 
                                                                    (
                                                                    start +
                                                                    (
                                                                    comp_addr
                                                                    -
                                                                    output_section_start_addr))
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (new_start_off,
                                                                    len)))))
                                                                    )) in
                                                                    (case  tag of
                                                                    (* If it's a section, we discard it.
                                             * We will add a new section record at the end. (FIXME)  *)
                                                                      FileFeature (ElfSection (idx1, isec1)) => 
                                                                    None
                                                                    (* If it's a symbol def, we propagate it.
                                             * We record its linkable idx, so we can
                                             * match it later with the bindings we formed
                                             * earlier.
                                             * FIXME: this is a bit nasty. Perhaps we 
                                             * should replace syment with a minimal structure
                                             * that avoids duplication. Same for isecs. *)
                                                                    | SymbolDef (def1) =>
                                                                    (* if get_elf64_symbol_type def.def_syment = stt_section
                                                then Nothing FIXME: also re-create the section symbol when we create the ElfSection
                                                else *) (* This doesn't work -- some refs might be bound to this symbol. 
                                                           Instead, strip the symbol when we generate the output symtab (FIXME). *)
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    Some
                                                                    (new_range, 
                                                                    SymbolDef
                                                                    (
                                                                    (|
                                                                    def_symname = 
                                                                    (
                                                                    (def_symname   def1))
                                                                    , def_syment = 
                                                                    (
                                                                    (def_syment   def1))
                                                                    , def_sym_scn = 
                                                                    (
                                                                    (def_sym_scn   def1))
                                                                    , def_sym_idx = 
                                                                    (
                                                                    (def_sym_idx   def1))
                                                                    , def_linkable_idx = 
                                                                    (
                                                                    (idx   irec))
                                                                    |))))
                                                                    | AbiFeature (x) => 
                                                                    Some
                                                                    (new_range, 
                                                                    AbiFeature
                                                                    (x))
                                                                    (* If it's a symbol ref with no reloc site, we discard it? *)
                                                                    | SymbolRef (r) =>
                                                                    (let 
                                                                    _ = 
                                                                    (
                                                                    if
                                                                    (ref_symname  (ref   r))
                                                                    =
                                                                    (''_start'') then
                                                                    () else
                                                                    () ) in
                                                                    (let 
                                                                    get_binding_for_ref = 
                                                                    (
                                                                    \<lambda> symref .  
                                                                    (
                                                                    \<lambda> linkable_idx .  
                                                                    (
                                                                    \<lambda> fname1 . 
                                                                    (let 
                                                                    name_matches1 = 
                                                                    (
                                                                    (case  
                                                                    
                                                                    bindings_by_name
                                                                    (ref_symname   symref) of
                                                                    Some x => 
                                                                    x
                                                                    | None => 
                                                                    []
                                                                    )) in
                                                                    (case  
                                                                    List.filter
                                                                    (
                                                                    \<lambda> (bi, ((r_idx, r, r_item), m_d)) .  
                                                                    (
                                                                    r_idx =
                                                                    linkable_idx)
                                                                    \<and>
                                                                    (
                                                                    r =
                                                                    symref))
                                                                    name_matches1 of
                                                                    [(b_idx, b)] => 
                                                                    (b_idx, b)
                                                                    | [] => 
                                                                    failwith
                                                                    (''no binding found'')
                                                                    | _ => 
                                                                    failwith
                                                                    (
                                                                    ([(CHR ''a''), (CHR ''m''), (CHR ''b''), (CHR ''i''), (CHR ''g''), (CHR ''u''), (CHR ''o''), (CHR ''u''), (CHR ''s''), (CHR '' ''), (CHR ''b''), (CHR ''i''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''n''), (CHR ''g''), (CHR '' ''), (CHR ''f''), (CHR ''o''), (CHR ''u''), (CHR ''n''), (CHR ''d''), (CHR '' ''), (CHR ''f''), (CHR ''o''), (CHR ''r''), (CHR '' ''), (CHR ''s''), (CHR ''y''), (CHR ''m''), (CHR ''b''), (CHR ''o''), (CHR ''l''), (CHR '' ''), (Char Nibble6 Nibble0)])
                                                                    @
                                                                    (
                                                                    (ref_symname   symref)
                                                                    @
                                                                    (
                                                                    ([(Char Nibble2 Nibble7), (CHR '' ''), (CHR ''i''), (CHR ''n''), (CHR '' ''), (CHR ''f''), (CHR ''i''), (CHR ''l''), (CHR ''e''), (CHR '' '')])
                                                                    @ 
                                                                    fname1)))
                                                                    )) ))) in
                                                                    (let 
                                                                    (bi, b) = 
                                                                    (
                                                                    get_binding_for_ref
                                                                    (ref   r)
                                                                    (idx   irec)
                                                                    (fname   irec))
                                                                    in
                                                                    (let 
                                                                    ((ref_idx, ref1, ref_linkable), maybe_def) = b
                                                                    in
                                                                    (case (maybe_reloc   r) of
                                                                    None => 
                                                                    None
                                                                    (* If it's a reloc site, we need to somehow point it
                                                     * at the *definition* that it was bound to. YES. 
                                                     * reloc_sites are 
                                                     
                                                     type reloc_site = <|
                                                      ref_relent  : elf64_relocation_a 
                                                    ; ref_rel_scn : natural  --the relocation section idx
                                                    ; ref_rel_idx : natural  --the index of the relocation rec
                                                    ; ref_src_scn : natural  --the section *from which* the reference logically comes
                                                    |>
                                                    
                                                    type elfNN_relocation_a =
                                                      <| elfNN_ra_offset : elf32_addr  --Address at which to relocate
                                                       ; elfNN_ra_info   : elf32_word  --Symbol table index/type of relocation to apply
                                                       ; elfNN_ra_addend : elf32_sword --Addend used to compute value to be stored
                                                       |>
                                                    
                                                     * ... of which ref_src_scn, ref_rel_idx, 
                                                     * ref_rel_scn and elfNN_ra_offset can be ignored.
                                                     * 
                                                     * What *is* important is that we somehow point at
                                                     * the symbol definition (or perhaps *un*definition,
                                                     * if we're generating a shared library) that it
                                                     * refers to. 
                                                     *
                                                     * For that, we update ra_info use the 1 + binding_idx,
                                                     * i.e. consider that there is a fresh symbol table
                                                     * and that it has a distinct entry for each binding.
                                                     * 
                                                     * FIXME: we also need to account for 
                                                     * reloc decisions -- MakePIC etc.
                                                     *)
                                                                    | Some(rs) => 
                                                                    Some
                                                                    (new_range, 
                                                                    SymbolRef
                                                                    (
                                                                    (| ref = 
                                                                    (
                                                                    (|
                                                                    (* This is not the place to be fixing up 
                                                         * symbol references. We can't yet patch the element content,
                                                         * because we haven't yet decided on the address of everything.
                                                         *
                                                         * That said, we *do* need to represent the old ref in the new 
                                                         * linked-image context. That's *all* we should be doing, right now.
                                                         * 
                                                         *)
                                                                    ref_symname = 
                                                                    (
                                                                    (ref_symname   ref1))
                                                                    , ref_syment =
                                                                    (
                                                                    (| elf64_st_name = 
                                                                    (
                                                                    Elf_Types_Local.uint32_of_nat
                                                                    (
                                                                    (
                                                                     0 :: nat))) (* unused *)
                                                                    , elf64_st_info = 
                                                                    (
                                                                    (elf64_st_info  (ref_syment   ref1)))
                                                                    , elf64_st_other = 
                                                                    (
                                                                    (elf64_st_other  (ref_syment   ref1)))
                                                                    , elf64_st_shndx = 
                                                                    (
                                                                    Elf_Types_Local.uint16_of_nat
                                                                    (
                                                                    (
                                                                    
                                                                    (* shn_abs *) 0 :: nat)))
                                                                    , elf64_st_value = 
                                                                    (
                                                                    Elf_Types_Local.uint64_of_nat
                                                                    (
                                                                    (
                                                                     0 :: nat)))
                                                                    , elf64_st_size = 
                                                                    (
                                                                    of_int
                                                                    (
                                                                    int
                                                                    (
                                                                    (
                                                                     0 :: nat))))
                                                                    |))
                                                                    , ref_sym_scn =
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    , ref_sym_idx =
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    (* match maybe_def with Just _ -> 1+bi | Nothing -> 0 end *)
                                                                    |))
                                                                    , maybe_reloc = 
                                                                    (
                                                                    Some
                                                                    (|
                                                                    ref_relent = 
                                                                    (
                                                                    (|
                                                                    elf64_ra_offset = 
                                                                    (
                                                                    Elf_Types_Local.uint64_of_nat
                                                                    (
                                                                    (
                                                                     0 :: nat))) (* ignored *)
                                                                    , elf64_ra_info = 
                                                                    (
                                                                    Elf_Types_Local.uint64_lor
                                                                    (* HACK: use bi as the symbol index. *)
                                                                    (
                                                                    of_int
                                                                    (
                                                                    int
                                                                    (
                                                                    get_elf64_relocation_a_type
                                                                    (ref_relent   rs))))
                                                                    (
                                                                    Elf_Types_Local.uint64_lshift
                                                                    (* ... actually, don't, now we have maybe_def_bound_to *)
                                                                    (
                                                                    of_int
                                                                    (
                                                                    int
                                                                    (
                                                                    (
                                                                    
                                                                    (* (1+bi) *) 0 :: nat))))
                                                                    (
                                                                    (
                                                                     32 :: nat))
                                                                    ) )
                                                                    , elf64_ra_addend = 
                                                                    (
                                                                    (elf64_ra_addend  (ref_relent   rs)))
                                                                    |))
                                                                    , ref_rel_scn =
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    , ref_rel_idx =
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    , ref_src_scn =
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    |))
                                                                    , maybe_def_bound_to =
                                                                    (
                                                                    (* Re-search the bindings list for a match, because we might have
                                                             * re-bound this symbol since we created the image. FIXME: since
                                                             * we do this, is there anything gained from populating this field
                                                             * earlier? Probably best not to. *) (let 
                                                                    (possible_bindings :: ( nat * binding) list)
                                                                    = 
                                                                    (
                                                                    (case  
                                                                    
                                                                    bindings_by_name
                                                                    (ref_symname   ref1) of
                                                                    Some l =>
                                                                    if
                                                                    (ref_symname   ref1)
                                                                    =
                                                                    (''__fini_array_end'') then
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    l) else 
                                                                    l
                                                                    | None => 
                                                                    []
                                                                    )) in
                                                                    (* what's the actual binding? *)
                                                                    (case (maybe_def_bound_to   r) of
                                                                    None => 
                                                                    failwith
                                                                    (
                                                                    ([(CHR ''a''), (CHR ''t''), (CHR '' ''), (CHR ''t''), (CHR ''h''), (CHR ''i''), (CHR ''s''), (CHR '' ''), (CHR ''s''), (CHR ''t''), (CHR ''a''), (CHR ''g''), (CHR ''e''), (CHR '',''), (CHR '' ''), (CHR ''a''), (CHR ''l''), (CHR ''l''), (CHR '' ''), (CHR ''r''), (CHR ''e''), (CHR ''f''), (CHR ''e''), (CHR ''r''), (CHR ''e''), (CHR ''n''), (CHR ''c''), (CHR ''e''), (CHR ''s''), (CHR '' ''), (CHR ''m''), (CHR ''u''), (CHR ''s''), (CHR ''t''), (CHR '' ''), (CHR ''h''), (CHR ''a''), (CHR ''v''), (CHR ''e''), (CHR '' ''), (CHR ''a''), (CHR '' ''), (CHR ''d''), (CHR ''e''), (CHR ''c''), (CHR ''i''), (CHR ''s''), (CHR ''i''), (CHR ''o''), (CHR ''n''), (CHR '':''), (CHR '' ''), (Char Nibble6 Nibble0)])
                                                                    @
                                                                    (
                                                                    (ref_symname   ref1)
                                                                    @
                                                                    ([(Char Nibble2 Nibble7)])))
                                                                    | Some(decision, _) =>
                                                                    (* Search the list of bindings for a possibly-updated 
                                                                     * binding for this reference. *)
                                                                    (let 
                                                                    matching_possibles = 
                                                                    (
                                                                    List.filter
                                                                    (
                                                                    \<lambda> (bi, ((ref_idx, ref1, ref_item), maybe_d)) . 
                                                                    (case  maybe_d of
                                                                    None => 
                                                                    False
                                                                    | Some (def_idx, def1, def_item) =>
                                                                    (
                                                                    (idx  
                                                                    (* match the *reference*, whose linkable we're processing now *) irec)
                                                                    = 
                                                                    ref_idx)
                                                                    \<and>
                                                                    (
                                                                    (
                                                                    (ref_sym_scn  (ref   r))
                                                                    =
                                                                    (ref_sym_scn   ref1))
                                                                    \<and>
                                                                    (
                                                                    (ref_sym_idx  (ref   r))
                                                                    =
                                                                    (ref_sym_idx   ref1)))
                                                                    (* 
                                                                                     def.def_syment  = sd.def_syment
                                                                                  && def.def_sym_scn = sd.def_sym_scn
                                                                                  && def.def_sym_idx = sd.def_sym_idx
                                                                                  && def_idx         = sd.def_linkable_idx *)
                                                                    ) )
                                                                    possible_bindings)
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    new_bound_to = 
                                                                    (
                                                                    (case  matching_possibles of
                                                                    [] => 
                                                                    Some
                                                                    (ApplyReloc, None)
                                                                    | [(bi, ((rl, r, ri), maybe_d))] =>
                                                                    Some
                                                                    (decision,
                                                                    (case  maybe_d of
                                                                    Some (def_idx, def1, def_item) => 
                                                                    Some
                                                                    (|
                                                                    def_symname = 
                                                                    (
                                                                    (def_symname   def1))
                                                                    , def_syment = 
                                                                    (
                                                                    (def_syment   def1))
                                                                    , def_sym_scn = 
                                                                    (
                                                                    (def_sym_scn   def1))
                                                                    , def_sym_idx = 
                                                                    (
                                                                    (def_sym_idx   def1))
                                                                    , def_linkable_idx = def_idx
                                                                    |)
                                                                    | None => 
                                                                    None
                                                                    ))
                                                                    | _ => 
                                                                    failwith
                                                                    (
                                                                    ([(CHR ''A''), (CHR ''f''), (CHR ''t''), (CHR ''e''), (CHR ''r''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''n''), (CHR ''k''), (CHR ''e''), (CHR ''r''), (CHR '' ''), (CHR ''s''), (CHR ''c''), (CHR ''r''), (CHR ''i''), (CHR ''p''), (CHR ''t''), (CHR '',''), (CHR '' ''), (CHR ''a''), (CHR ''m''), (CHR ''b''), (CHR ''i''), (CHR ''g''), (CHR ''u''), (CHR ''o''), (CHR ''u''), (CHR ''s''), (CHR '' ''), (CHR ''b''), (CHR ''i''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''n''), (CHR ''g''), (CHR ''s''), (CHR '' ''), (CHR ''f''), (CHR ''o''), (CHR ''r''), (CHR '' ''), (Char Nibble6 Nibble0)])
                                                                    @
                                                                    (
                                                                    (ref_symname   ref1)
                                                                    @
                                                                    ([(Char Nibble2 Nibble7)])))
                                                                    )) in
                                                                    if 
                                                                    \<not>
                                                                    (
                                                                    new_bound_to
                                                                    =
                                                                    (maybe_def_bound_to   r)) then
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    new_bound_to)
                                                                    else
                                                                    if 
                                                                    new_bound_to
                                                                    = 
                                                                    None then
                                                                    failwith
                                                                    (''really need a decision by now'')
                                                                    else
                                                                    new_bound_to)))
                                                                    )))
                                                                    (* if irec.fname = libc.a(__uClibc_main.os)
                                                                && irec.isec.elf64_section_name_as_string = .data.rel.local
                                                                then
                                                                let _ = errln (Saw the bugger:  ^ (match r.maybe_def_bound_to with
                                                                    Just(decision, Just(sd)) -> show sd.def_syment
                                                                    | _ -> (not complete)
                                                                end))
                                                                in r.maybe_def_bound_to
                                                            else r.maybe_def_bound_to
                                                            *)
                                                                    |) ))
                                                                    ))))) (* match maybe_reloc *)
                                                                    )) (* match tag *)
                                                                    )
                                                                    (
                                                                    List.set
                                                                    ranges_and_tags)) (* end mapMaybe fn *)
                                                                    in
                                                                    (let 
                                                                    isec_sz = 
                                                                    (
                                                                    (elf64_section_size  (isec   irec))) in
                                                                    (let 
                                                                    maybe_el_sz = 
                                                                    (
                                                                    (length1   el)) in
                                                                    (let 
                                                                    contents_sz = 
                                                                    (
                                                                    List.length
                                                                    (contents   el)) in
                                                                    (let 
                                                                    (actual_sz, padded_contents) =
                                                                    (
                                                                    (case  maybe_el_sz of
                                                                    Some el_sz =>
                                                                    (let 
                                                                    diff = 
                                                                    (
                                                                    el_sz -
                                                                    contents_sz) in
                                                                    if 
                                                                    diff <
                                                                    (
                                                                     0 :: nat) then
                                                                    (* contents greater than what the el says, so chop the end off *)
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (el_sz, 
                                                                    take
                                                                    el_sz
                                                                    (contents   el)))
                                                                    else
                                                                    (el_sz, 
                                                                    (
                                                                    (contents   el)
                                                                    @
                                                                    List.replicate
                                                                    diff 
                                                                    None)))
                                                                    | None =>
                                                                    if 
                                                                    \<not>
                                                                    (
                                                                    (
                                                                    List.length
                                                                    (contents   el))
                                                                    = 
                                                                    isec_sz)
                                                                    then
                                                                    failwith
                                                                    (''input section size not equal to its content pattern length'')
                                                                    else
                                                                    (isec_sz,(contents   el))
                                                                    )) in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (actual_sz, padded_contents, new_ranges_and_tags))))))))))))))
                                                                    | _ => 
                                                                    failwith
                                                                    (''impossible: no such element'')
                                                                    )) (* match Map.lookup idstr img.elements *)
                                                                    ))) (* match maybe_secname *)
                                                                    | IncludeCommonSymbol (retain_pol, fname1, linkable_idx, def1, img3) =>
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (* We want to get the common symbol as a byte pattern *)
                                                                    (let 
                                                                    sz = 
                                                                    (
                                                                    unat
                                                                    (elf64_st_size  (def_syment   def1)))
                                                                    in
                                                                    (let 
                                                                    content = 
                                                                    (
                                                                    List.replicate
                                                                    sz
                                                                    (
                                                                    Some
                                                                    (
                                                                    (
                                                                    of_nat
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    :: 
                                                                    byte))))
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (sz, content, 
                                                                    {
                                                                    (
                                                                    Some
                                                                    (secname1, 
                                                                    (
                                                                    (
                                                                    comp_addr
                                                                    -
                                                                    output_section_start_addr), sz)), 
                                                                    SymbolDef
                                                                    (
                                                                    (|
                                                                    def_symname = 
                                                                    (
                                                                    (def_symname   def1))
                                                                    , def_syment = 
                                                                    (
                                                                    (def_syment   def1))
                                                                    , def_sym_scn = 
                                                                    (
                                                                    (def_sym_scn   def1))
                                                                    , def_sym_idx = 
                                                                    (
                                                                    (def_sym_idx   def1))
                                                                    , def_linkable_idx = linkable_idx
                                                                    |)))})))))
                                                                    (*                    | Hole(AddressExprFn f) -> 
                        let next_addr = f addr (AllocatedSectionsMap outputs_by_name)
                        in
                        let n = next_addr - addr
                        in
                        let content = Missing_pervasives.replicate n Nothing
                        in 
                        let _ = Missing_pervasives.outln (make_line *fill* (hex_string_of_natural comp_addr)
                             (hex_string_of_natural n)
                             )
                        in
                        (next_addr - addr, content, {}) *)
                                                                    | ProvideSymbol (pol, name1, (size3, info, other)) =>
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    symaddr = accum_current_addr (* FIXME: support others *)
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (
                                                                    (
                                                                    
                                                                    (* sz *) 0 :: nat), 
                                                                    (* comp_el_pat *) [], 
                                                                    (* this_el_meta *) {
                                                                    (
                                                                    Some
                                                                    (secname1, 
                                                                    (
                                                                    (
                                                                    symaddr -
                                                                    output_section_start_addr),
                                                                    (
                                                                     0 :: nat))),
                                                                    SymbolDef
                                                                    (
                                                                    symbol_def_for_provide_symbol
                                                                    name1
                                                                    size3
                                                                    info
                                                                    other
                                                                    control_script_linkable_idx)
                                                                    )} ))))
                                                                    )) (* match comp_el_pat *)
                                                                    in
                                                                    (let 
                                                                    _ = 
                                                                    (()) in
                                                                    (let 
                                                                    new_content = 
                                                                    (
                                                                    append_to_byte_pattern_at_offset
                                                                    (
                                                                    comp_addr
                                                                    -
                                                                    output_section_start_addr)
                                                                    accum_pat
                                                                    comp_el_pat)
                                                                    in
                                                                    (let 
                                                                    new_addr = 
                                                                    (
                                                                    comp_addr
                                                                    + 
                                                                    sz) in
                                                                    (let 
                                                                    new_meta = 
                                                                    (
                                                                    accum_meta
                                                                    \<union>
                                                                    this_el_meta)
                                                                    in
                                                                    (new_content, new_addr, new_meta))))))))
                                                                    ))
                                                                    (
                                                                    [], output_section_start_addr, 
                                                                    {})
                                                                    (
                                                                    List.zip
                                                                    comp1
                                                                    comp_addrs))
  in
  (let concat_sec_el = ((|
                        Memory_image.element.startpos = (Some
                                                   (output_section_start_addr))
                        , Memory_image.element.length1 = (Some (size3))
                        , Memory_image.element.contents = concatenated_content |)) in
  (let _ = (()) in
  (* Make a new element in the image, also transferring metadata from input elements 
             * as appropriate. *)
  (let new_by_range_list =
       ((Some (secname1, (( 0 :: nat), size3)), FileFeature
                                                  (ElfSection
                                                     ((
                                                         (* We don't yet konw where this'll come in the output file, so ...  *) (* scn_idx *) 0 :: nat),
                                                     (| elf64_section_name =
                                                     (( 0 :: nat)) (* ignored *)
                                                     , elf64_section_type = 
                                                     (output_section_type
                                                        comp1)
                                                     , elf64_section_flags = 
                                                     (output_section_flags
                                                        comp1)
                                                     , elf64_section_addr =
                                                     (( 0 :: nat)) (* ignored -- covered by element *)
                                                     , elf64_section_offset =
                                                     (( 0 :: nat)) (* ignored -- will be replaced when file offsets are assigned *)
                                                     , elf64_section_size =
                                                     (( 0 :: nat)) (* ignored *)
                                                     , elf64_section_link =
                                                     (( 0 :: nat)) (* HMM *)
                                                     , elf64_section_info =
                                                     (( 0 :: nat)) (* HMM *)
                                                     , elf64_section_align = 
                                                     (alignof_output_section
                                                        comp1)
                                                     , elf64_section_entsize =
                                                     (( 0 :: nat)) (* HMM *)
                                                     , elf64_section_body = Byte_sequence.empty (* ignored *)
                                                     , elf64_section_name_as_string = secname1 (* can't rely on this being ignored *)
                                                     |) ))) #
          list_of_set new_range_tag_pairs) in
  (let _ = (()) in
  (let new_by_range = (List.foldl
                         (\<lambda> m .  \<lambda> (maybe_range, tag) . 
                          (let new_s = (Set.insert (maybe_range, tag) m) in
                          (* let _ = errln (Inserting an element into by_range; before:  ^ (show (Set.size m)) ^ ; after:  ^ (show (Set.size new_s)))
                in *)
                          new_s) ) (by_range   acc_img) new_by_range_list) in
  (let new_by_tag = (by_tag_from_by_range new_by_range) in
  (let _ =
       ((let section_tags_bare = (List.filter
                                    (\<lambda> (maybe_range, tag) . 
                                     (case  tag of
                                           FileFeature (ElfSection (idx1, isec1)) => 
                                     True
                                       | _ => False
                                     )) (list_of_set new_by_range)) in
        (* errln (Total metadata now includes  ^ (show (length section_tags_bare)) ^  sections; are by_range and 
                    ^ by_tag consistent?  ^ (show (new_by_tag = by_tag_from_by_range new_by_range))) *) () ))
  in
  (* this expression is the return value of add_output_section *)
  ( ( (* new_pos *) output_section_start_addr + size3), (* new_acc *) (|
  elements = (map_update secname1 concat_sec_el (elements   acc_img))
  (* tag it as a section, and transfer any tags *)
  , by_range = (* let _ = errln (Returning from add_output_section a by_range with  ^ 
                                (show (Set.size new_by_range))) in *) new_by_range
  , by_tag = new_by_tag |), (* sec_sz *) size3,
  (* replacement_output_sec *) (OutputSectionSpec
                                  (guard, Some (output_section_start_addr), secname1, comp1))
  )))))))))))))))))
  )
        )) (* end add_output_section *)
    in
    (case  script of
        [] => (acc1, (AllocatedSectionsMap outputs_by_name))
        | (element, el_idx) # more_elements_and_idx =>
             (let do_nothing = (acc1, pos, (AllocatedSectionsMap outputs_by_name)) in 
             (let (new_acc, new_pos, new_outputs_by_name) =             
 ((case  element of
                DefineSymbol(symdefpol, name1, (symsize, syminfo, symother)) => 
                    (* We've already added this to the output composition. *)
                    do_nothing
                | AdvanceAddress(AddressExprFn advance_fn_ref) => 
                    (let advance_fn =                      
((case   alloc_map advance_fn_ref of
                          Some m  => m
                        | None => failwith (''alloc_map invariant failure'')
                      ))
                    in
                    (let new_pos = (advance_fn pos (AllocatedSectionsMap outputs_by_name))
                    in
                    (acc1, new_pos, (AllocatedSectionsMap outputs_by_name))))
                    (* FIXME: the allocated sections map is the subset of the outputs_by_name map 
                     * that has been allocated -- meaning *both* sized *and* placed. 
                     * Since we're a multi-pass interpreter, we've sized everything already, but 
                     * only a subset has been placed. So we need to weed out all elements from
                     * outputs_by_name that don't correspond to a section in the accumulated image.
                     * We should probably include the section's range_tag in the allocated_sections_map,
                     * which would force us to do this, but at the moment neither of these is done. *)
                | MarkAndAlignDataSegment(maxpagesize1, commonpagesize1) => 
                    (* GNU linker manual says:
                    
                    DATA_SEGMENT_ALIGN(MAXPAGESIZE, COMMONPAGESIZE)
                            is equivalent to either
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - 1)))
                      or
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - COMMONPAGESIZE)))
                      depending on whether the latter uses fewer COMMONPAGESIZE sized
                      pages for the data segment (area between the result of this
                      expression and `DATA_SEGMENT_END') than the former or not.  If the
                      latter form is used, it means COMMONPAGESIZE bytes of runtime
                      memory will be saved at the expense of up to COMMONPAGESIZE wasted
                      bytes in the on-disk file.
                      
                        In other words, we're marking the beginning of the data segment
                        by aligning our position upwards by an amount that 
                        
                        - guarantees we're on a new page...
                        
                        - ... but (option 1) at an address that's congruent, modulo the max page size
                                  (e.g. for 64kB maxpage, 4kB commonpage, we AND with 0xffff)
                        
                        - ... (option 2) at an offset that's at the commonpagesize boundary
                                  immediately preceding the lowest congruent address
                                  (e.g. for 64kB maxpage, 4kB commonpage, we AND with 0xf000,
                                  so if we're at pos 0x1234, we bump up to 0x11000).
                                  
                                  FIXME:
                                  
                                  The GNU linker seems to bump up to 0x12000 here, not 0x11000.
                                  Specifically, 
                                  
                                    DATA_SEGMENT_ALIGN (0x200000, 0x1000)
                                    
                                    bumps 0x4017dc up to 0x602000.
                                    
                                  This is indeed better, because it allows the next section
                                  to be output without a big gap in the file.
                                  
                                  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                                                 0x00000000000017dc 0x00000000000017dc  R E    200000
                                  LOAD           0x0000000000002000 0x0000000000602000 0x0000000000602000
                                                 0x0000000000000120 0x0000000000000ce8  RW     200000
                                  
                                  ... whereas if the second LOAD began at address 0x601000,
                                  the file offset of its first section would have to be 0x11000.
                                  
                                  So what *should* the formula be?
                                  It needs to calculate the next address which
                                  
                                  - is a commonpagesize boundary;
                                  
                                  - is minimally >= the current address, modulo the commonpagesize
                                  
                                  - is minimally >= the current address, modulo the maxpagesize.
                                  
                                  The AND operation gives us something that is minimally *below*
                                  the commonpagesize boundary. I think we need to add COMMONPAGESIZE.
                                  
                                  The code does this (in ldexp.c around line 478 as of binutils 2.25):
                                  
                                        expld.result.value = align_n (expld.dot, maxpage);
                                        /* omit relro phase */
                                        if (expld.dataseg.phase == exp_dataseg_adjust)
                                        {
                                          if (commonpage < maxpage)
                                            expld.result.value += ((expld.dot + commonpage - 1)
                                                                   & (maxpage - commonpage));
                                        }
                                        else 
                                        {
                                          expld.result.value += expld.dot & (maxpage - 1);
                                        
                                  Which amounts to:
                                       
                                       1. first, align up to maxpage. So for our example, we're now 0x10000.
                                          or for our real example, we're now 0x600000
                                       
                                          THEN since the first phase (expld_dataseg_none) 
                                          hits the final else case,
                                          we immediately restore the modulus of the address,
                                          giving 0x60188c.
                                           or 0x6019ac  the second time around (FIXME: why two?)
                                       
                                       2. next, on the relevant phase (pass) of the script interpreter,
                                          i.e. OPTION 2
                                          if commonpage < maxpage,
                                          bump up the *non-maxpage-aligned non-modulo-restored* address
                                          by 
                                              (. + commonpage - 1)  &  (maxpage - commonpage)
                                            
                                          i.e. for our example earlier
                                              (0x01234 + 0x1000 - 1) &  (0xf000)
                                              = 
                                               0x02233               &   0xf000
                                              =
                                               0x02000
                                               
                                         i.e. for our real example
                                              (0x4019ac + 0x1000 - 1) &  (0x1ff000)
                                              = 
                                               0x4019ac + 0x1000 - 1) &   0x1ff000
                                              =
                                               0x002000
                                               
                                        3. OPTION 1 is implemented by the trailing else {
                                           -- it restores the modulus.
                                           
                                  So the problem with our original logic (below) was that 
                                  it did what the manual says, not what the code does.
                                  Specifically, the code for option 2 does
                                  
                                    (. + commonpagesize - 1) & (maxpagesize - commonpagesize)
                                    
                                    and NOT simply
                                    
                                    . & (maxpagesize - commonpagesize).
                                    
                                  FIXME: report this bug.
                                  
                        
                        Note that intervening commands can do arbitrary things to the location
                        counter, so we can't do any short-cut arithmetic based on section sizes;
                        we actually have to run the layout procedure til we hit the end of the 
                        data segment, and then see how we do. 
                        
                        We run this function *forward* with the first option on a subset
                        of the script ending with the end of the data segment.
                        We then see what comes back. 
                    
                     *)
                    (* let num_pages_used *)
                    (let _ = (())
                    in
                    (let option1 = (align_up_to maxpagesize1 pos + (natural_land pos (maxpagesize1 -( 1 :: nat))))
                    in
                    (let _ = (())
                    in
                    (let option2 = (align_up_to maxpagesize1 pos + (natural_land ((pos + commonpagesize1) -( 1 :: nat)) (maxpagesize1 - commonpagesize1)))
                    in
                    (let _ = (())
                    in
                    (let data_segment_endpos = (\<lambda> startpos1 .  
                        (* run forward from here until MarkDataSegmentEnd, 
                         * accumulating the actually-made outputs by name and their sizes *)
                        (let (endpos, _) = (List.foldl (\<lambda> (curpos, seen_end) .  \<lambda> (new_script_item, new_script_item_idx) .  
                            (let _ = (())
                            in
                            if seen_end 
                            then (curpos, True)
                            else (let (newpos, new_seen) = ((case  new_script_item of 
                                  MarkDataSegmentEnd => 
                                    (let _ = (())
                                    in
                                    (* break the loop early here *)
                                    (curpos, True))
                                | OutputSection(outputguard, maybe_expr, name1, sub_elements) => 
                                    (let _ = (())
                                    in
                                    (let maybe_found = ( outputs_by_name name1)
                                    in  
  (case  (case  maybe_found of
             Some (f, seen_script_el_idx) => (f, seen_script_el_idx)
           | None => failwith (''internal error: output section not found'')
         ) of
      (OutputSectionSpec (guard, addr, secname1, comp1), seen_script_el_idx) =>
  (* Sometimes a given output section name, say .eh_frame, can come from multiple 
                                     * script elements with disjoint guard conditions (only_if_ro and only_if_rw, say). 
                                     * Only one of them will actually be selected when the guard is being evaluated.
                                     * So when we replay the sections' output here, we want to skip the ones whose
                                     * guards were false. The way we implement this is to store the originating script
                                     * element idx in the allocated_output_sections map. We can test that against our 
                                     * current script element_idx here *)
  (let replay_output = (seen_script_el_idx = el_idx) in
  if replay_output then
    (
    (let unaligned_start_addr = curpos in
    (let start_addr = (align_up_to (alignof_output_section comp1)
                         unaligned_start_addr) in
    (let (end_addr, comp_addrs) = (do_output_section_layout_starting_at_addr
                                     start_addr
                                     (AllocatedSectionsMap outputs_by_name)
                                     comp1) in
    (let size3 = (end_addr - start_addr) in (end_addr, (* seen_end *) False)))))
    ) else (curpos, (* seen_end *) False))
  )))
                                | AdvanceAddress(AddressExprFn advance_fn_ref) => 
                                    (let _ = (())
                                    in
                                    (let advance_fn =                                      
((case   alloc_map advance_fn_ref of
                                          Some m  => m
                                        | None => failwith (''alloc_map invariant failed'')
                                      ))
                                    in
                                    (let new_pos = (advance_fn curpos (AllocatedSectionsMap outputs_by_name))
                                    in
                                    (new_pos, False))))
                                | _ => (curpos, seen_end)
                            ))
                            in
                            if newpos < curpos then failwith (''went backwards'') else (newpos, new_seen)))
                        ) (startpos1, False) more_elements_and_idx)
                        in endpos)
                    )
                    in
                    (let endpos_option1 = (data_segment_endpos option1)
                    in
                    (let endpos_option2 = (data_segment_endpos option2)
                    in
                    (let _ = (())
                    in
                    (let _ = (())
                    in
                    (let npages = (\<lambda> startpos1 .  (\<lambda> endpos . 
                        ((align_up_to  commonpagesize1 endpos) - 
                        (round_down_to commonpagesize1 startpos1)) div commonpagesize1
                    ))
                    in
                    (let npages_option1 = (npages option1 endpos_option1)
                    in
                    (let npages_option2 = (npages option2 endpos_option1)
                    in
                    (let _ = (())
                    in
                    (let _ = (())
                    in
                    if npages_option1 < npages_option2 
                    then (let _ = (()) in (acc1, option1, (AllocatedSectionsMap outputs_by_name)))
                    else (let _ = (()) in (acc1, option2, (AllocatedSectionsMap outputs_by_name))))))))))))))))))
                | MarkDataSegmentEnd => do_nothing
                | MarkDataSegmentRelroEnd(*(fun_from_secs_to_something)*) => do_nothing
                | OutputSection(outputguard, maybe_expr, name1, sub_elements) => 
                    (* Get the composition we computed earlier, and actually put it in
                     * the image, assigning an address to it. *)
                    (let maybe_found = ( outputs_by_name name1)
                    in
                    (let (found, seen_script_el_idx) = ((case  maybe_found of
                        Some (f, saved_idx) => (f, saved_idx)
                        | None => failwith (''internal error: output section not found'')
                    ))
                    in  
  (case  found of
      (OutputSectionSpec (guard, addr, secname1, comp1)) =>
  (* let next_free_section_idx = 1 + naturalFromNat (Map.size outputs_by_name)
                    in *)
  (let count_sections_in_image = (\<lambda> img3 .  (
                                                    (let (section_tags, section_ranges) = 
                                                         (elf_memory_image_section_ranges
                                                            img3) in
                                                    (let section_tags_bare = 
                                                         (List.map
                                                            (\<lambda> tag . 
                                                             (case  tag of
                                                                   FileFeature (ElfSection (idx1, isec1)) => 
                                                             True
                                                               | _ => 
                                                             False
                                                             )) section_tags)
                                                    in
                                                    List.length
                                                      section_tags_bare)) ))
  in
  (* Do we actually want to add an output section? Skip empty sections. 
                     * CARE: we actually want to heed the proper ld semantics for empty sections 
                     * (e.g. . = . will force output). From the GNU ld manual:
                     
                        The linker will not normally create output sections with no contents.
                        This is for convenience when referring to input sections that may or
                        may not be present in any of the input files.  For example:
                             .foo : { *(.foo) }
                           will only create a `.foo' section in the output file if there is a
                        `.foo' section in at least one input file, and if the input sections
                        are not all empty.  Other link script directives that allocate space in
                        an output section will also create the output section.  So too will
                        assignments to dot even if the assignment does not create space, except
                        for `. = 0', `. = . + 0', `. = sym', `. = . + sym' and `. = ALIGN (. !=
                        0, expr, 1)' when `sym' is an absolute symbol of value 0 defined in the
                        script.  This allows you to force output of an empty section with `. =
                        .'.

                           The linker will ignore address assignments ( *note Output Section
                        Address::) on discarded output sections, except when the linker script
                        defines symbols in the output section.  In that case the linker will
                        obey the address assignments, possibly advancing dot even though the
                        section is discarded.
                     
                     * It follows that we might discard the output section,
                     * but *retain* the symbol definitions within it,
                     * and keep the dot-advancements that 
                     * In other words, we care about two things:
                     * 
                     * -- whether there are any non-empty input sections, *or* 
                     *       non-excluded assignments to dot, inside the composition:
                     *       this controls whether the section is output
                     
                     * -- whether the script defines symbols in the section; if so
                     *       then *even if the section is discarded*
                     *       we must honour the address assignments,
                     *       which means using the ending address of do_output_section_layout_starting_at_addr,
                     *       *and*
                     *       we must retain the symbol definitions (which now could
                     *       end up going in some other section? HMM...)
                     *)
  (let comp_element_allocates_space = (\<lambda> comp_el .  (case  comp_el of
                                                                IncludeInputSection (_, irec) =>
                                                            (let _ = (()) in
                                                            (elf64_section_size  (isec  
                                                            irec)) >
                                                              ( 0 :: nat))
                                                              | IncludeCommonSymbol (retain_pol, fname1, idx1, def1, img3) =>
                                                            unat
                                                              (elf64_st_size  (def_syment   def1))
                                                              > ( 0 :: nat)
                                                              | ProvideSymbol (pol, name1, spec) => 
                                                            True (* HACK: what else makes sense here? *)
                                                              | Hole (AddressExprFn (address_fn_ref)) =>
                                                            (let address_fn =
                                                                 ((case  
                                                                   alloc_map
                                                                    address_fn_ref of
                                                                      Some m => 
                                                                  m
                                                                    | None => 
                                                                  failwith
                                                                    (''alloc_map invariant failed'')
                                                                  )) in
                                                            (let assignment_is_excluded = 
                                                                 (\<lambda> f . 
                                                                  (* really makes you wish you were programming in Lisp *)
                                                                  (let 
                                                                  always_gives_0 =
                                                                  ((f
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    (
                                                                    AllocatedSectionsMap
                                                                    outputs_by_name)
                                                                    =
                                                                    (
                                                                     0 :: nat))
                                                                    \<and>
                                                                    (
                                                                    f
                                                                    (
                                                                    (
                                                                     42 :: nat))
                                                                    (
                                                                    AllocatedSectionsMap
                                                                    outputs_by_name)
                                                                    =
                                                                    (
                                                                     0 :: nat))) (* FIXME: this is wrong *)
                                                                  in
                                                                  (let 
                                                                  always_gives_dot =
                                                                  ((f
                                                                    (
                                                                    (
                                                                     0 :: nat))
                                                                    (
                                                                    AllocatedSectionsMap
                                                                    outputs_by_name)
                                                                    =
                                                                    (
                                                                     0 :: nat))
                                                                    \<and>
                                                                    (
                                                                    f
                                                                    (
                                                                    (
                                                                     42 :: nat))
                                                                    (
                                                                    AllocatedSectionsMap
                                                                    outputs_by_name)
                                                                    =
                                                                    (
                                                                     42 :: nat))) (* FIXME: this is wrong *)
                                                                  in
                                                                  (* FIXME: what are the semantics of function equality in Lem? *)
                                                                  always_gives_0
                                                                    \<or>
                                                                    (
                                                                    always_gives_dot (*&& (AddressExprFn(f)) <> assign_dot_to_itself*) (* FIXME DPM: almost certainly not what is meant... *) ))))
                                                            in
                                                            \<not>
                                                              (assignment_is_excluded
                                                                 address_fn)))
                                                            )) in
  (let section_contains_non_empty_inputs =
       (((\<exists> x \<in> (set comp1). comp_element_allocates_space x))) in
  (* See note in MarkDataSegmentEnd case about script element idx. Short version:
                     * multiple output section stanzas, for a given section name, may be in the script,
                     * but only one was activated by the section composition pass. Ignore the others. *)
  (let do_output = ((seen_script_el_idx = el_idx) \<and>
                      section_contains_non_empty_inputs) in
  if \<not> do_output then
    (let _ = (()) in (acc1, pos, (AllocatedSectionsMap outputs_by_name)))
  else
    (
    (* let _ = errln (Before adding output section, we have  ^ (show (count_sections_in_image acc))
                            ^  sections.)
                        in *)
    (let (new_pos, new_acc, sec_sz, replacement_output_sec)
         = (add_output_section ((* next_free_section_idx, *) pos, acc1) found)
    in
    (let _ = (()) in
    (* let _ = errln (Received from add_output_section a by_range with  ^ (show (Set.size new_acc.by_range))
                            ^  metadata records of which  ^ (show (Set.size {
                                (r, t)
                                | forall ((r, t) IN new_acc.by_range)
                                | match t with FileFeature(ElfSection(x)) -> true | _ -> false end
                            }
                            )) ^  are ELF sections; one more time:  ^ (show (Set.size {
                                (t, r)
                                | forall ((t, r) IN new_acc.by_tag)
                                | match t with FileFeature(ElfSection(x)) -> true | _ -> false end
                            }
                            )) ^ ; count_sections_in_image says  ^ (show (
                                length (Multimap.lookupBy Memory_image_orderings.tagEquiv (FileFeature(ElfSection(0, null_elf64_interpreted_section))) new_acc.by_tag)
                                )) 
                            )
                        in *)
    (* let _ = errln (After adding output section, we have  ^ (show (count_sections_in_image new_acc))
                            ^  sections.)
                        in *)
    (new_acc, new_pos, (AllocatedSectionsMap
                          (map_update name1 (replacement_output_sec, el_idx)
                             (map_remove name1 outputs_by_name)))))) )))))
  )))
                | DiscardInput(selector) => do_nothing
                | InputQuery(retainpol, sortpol, selector) => do_nothing
            ))
            in
            (* recurse *)
            build_image alloc_map new_acc new_pos new_outputs_by_name bindings_by_name more_elements_and_idx control_script_linkable_idx linker_defs_by_name))
    )))" 
by pat_completeness auto


(*
let rec consecutive_commons rev_acc l = 
    match l with
    [] -> reverse rev_acc
    | IncludeCommonSymbol(pol, fname, def, img) :: rest -> 
        consecutive_commons ((pol, fname, def, img) :: rev_acc) rest
    | _ -> reverse rev_acc
end
*)

(*val default_place_orphans : input_output_assignment -> list input_spec -> input_output_assignment*)
fun default_place_orphans  :: "(input_spec)list*(output_section_spec*nat)list \<Rightarrow>(input_spec)list \<Rightarrow>(input_spec)list*(output_section_spec*nat)list "  where 
     " default_place_orphans (discards, outputs1) inputs1 = ( 
    (* Try to emulate the GNU linker.
     * Its docs say:
     
     It attempts to place orphan sections after
     non-orphan sections of the same attribute, such as code vs data,
     loadable vs non-loadable, etc.  If there is not enough room to do this
     then it places at the end of the file.


     For ELF targets, the attribute of the section includes section type 
     as well as section flag.
 
     * It places the .tm_clone_table orphan 

          [ 9] .tm_clone_table   PROGBITS         0000000000000000  00000160
               0000000000000000  0000000000000000  WA       0     0     8
     
     as
     
             .data          0x0000000000602120        0x0 crtend.o
             .data          0x0000000000602120        0x0 crtn.o

            .tm_clone_table
                            0x0000000000602120        0x0
             .tm_clone_table
                            0x0000000000602120        0x0 crtbeginT.o
             .tm_clone_table
                            0x0000000000602120        0x0 crtend.o

            .data1
             *(.data1)
                            0x0000000000602120                _edata = .

     i.e. between .data and .data1. In the script: 

          .got.plt        : { *(.got.plt)  *(.igot.plt) }
          .data           :
          {
            *(.data .data.* .gnu.linkonce.d.* )
            SORT(CONSTRUCTORS)
          }
          .data1          : { *(.data1) }
          _edata = .; PROVIDE (edata = .);
          . = .;
          __bss_start = .;
     
     i.e. no clear reason for why between .data and .data1. In the code:
     
         (see elf32em.c line 1787 in binutils 2.25)
         
         ... the key bit of code is as follows.
         
  place = NULL;
  if ((s->flags & (SEC_ALLOC | SEC_DEBUGGING)) == 0)
    place = &hold[orphan_nonalloc];
  else if ((s->flags & SEC_ALLOC) == 0)
    ;
  else if ((s->flags & SEC_LOAD) != 0
           && ((iself && sh_type == SHT_NOTE)
               || (!iself && CONST_STRNEQ (secname, .note))))
    place = &hold[orphan_interp];
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)
    place = &hold[orphan_bss];
  else if ((s->flags & SEC_SMALL_DATA) != 0)
    place = &hold[orphan_sdata];
  else if ((s->flags & SEC_THREAD_LOCAL) != 0)
    place = &hold[orphan_tdata];
  else if ((s->flags & SEC_READONLY) == 0)
    place = &hold[orphan_data];
  else if (((iself && (sh_type == SHT_RELA || sh_type == SHT_REL))
            || (!iself && CONST_STRNEQ (secname, .rel)))
           && (s->flags & SEC_LOAD) != 0)
    place = &hold[orphan_rel];
  else if ((s->flags & SEC_CODE) == 0)
    place = &hold[orphan_rodata];
  else
    place = &hold[orphan_text];


        .. we replicate it here.
     *)
     (let output_irecs = (List.foldl (\<lambda> acc1 .  \<lambda> outp .  (
  (case  outp of
      (OutputSectionSpec (guard, maybe_addr, name1, comp1), script_el_idx) =>
  (let all_irecs = (List.foldl
                      (\<lambda> inner_acc .  \<lambda> comp_el .  (case  comp_el of
                                                                    IncludeInputSection (_, irec) => 
                                                                   Set.insert
                                                                    irec
                                                                    inner_acc
                                                                    | _ => 
                                                                   inner_acc
                                                                   )) 
                    {} comp1) in all_irecs \<union> acc1)
  ))) {} outputs1)
     in
     (let (orphans :: input_spec list) = (List.filter (\<lambda> inp .  (case  inp of 
             InputSection(irec) => (let v = (\<not> (irec \<in> output_irecs))
                                   in (let _ = (if v then () else () )
                                   in v))
             | _ => False
     )) inputs1)
     in
     (let place_one_orphan = (\<lambda> acc1 .  \<lambda> input .  (
         (let irec = ((case  input of
             InputSection(irec) => irec
             | _ => failwith (''impossible: orphan section is not a section'')
         ))
         in
         (let (discards, outputs1) = acc1 in
         (let find_output = (\<lambda> maybe_name .  \<lambda> maybe_type .  \<lambda> flags_must_have .  \<lambda> flags_must_not_have .  (
            Missing_pervasives.find_index (\<lambda>p .  
  (case  (p ) of
      ( (OutputSectionSpec (guard, maybe_addr, name1, comp1), script_el_idx) ) =>
  (let flags = (output_section_flags comp1) in
  (case  maybe_name of Some n => n = name1 | None => True ) \<and>
    ((case  maybe_type of
         Some t => output_section_type comp1 = t
       | None => True
     ) \<and>
       (Set.Ball flags_must_have (\<lambda> x .  flag_is_set x flags) \<and>
          Set.Ball flags_must_not_have
            (\<lambda> x .  \<not> (flag_is_set x flags)))))
  )
             ) outputs1
         ))
         in
         (let place_after_nonalloc = (find_output None None {} { shf_alloc }) in
         (let place_after_interp =  (find_output (Some((''.interp''))) (Some(sht_progbits)) { shf_alloc } {}) in
         (let place_after_bss = (find_output (Some((''.bss''))) (Some(sht_nobits)) { shf_alloc, shf_write} {}) in
         (let place_after_rodata = (find_output (Some((''.rodata''))) (Some(sht_progbits)) { shf_alloc } { shf_write }) in
         (let place_after_rel = (find_output (Some((''.rela.dyn''))) (Some(sht_rela)) {} {}) in
         (let place_after_data = (find_output (Some((''.data''))) (Some(sht_progbits)) { shf_alloc, shf_write } {}) in
         (let place_after_text = (find_output (Some((''.text''))) (Some(sht_progbits)) { shf_alloc, shf_execinstr } {}) in
         (let (place_after ::  nat option) = ((case  input of 
            InputSection(irec) => 
                (* HACK: simulates GNU linker, but this logic ought to go elsewhere *)
                if(elf64_section_name_as_string  (isec   irec)) = (''.note.GNU-stack'') then None
                else
                if \<not> (flag_is_set shf_alloc(elf64_section_flags  (isec   irec)))
                 \<and> (* not flag_is_set shf_alloc irec.isec.elf64_section_flags *) (* no debugging, for now *) True
                    then place_after_nonalloc
                else (* FIXME: reinstate alloc-debugging case *)
                    if ((elf64_section_type  (isec   irec)) = sht_note) (* FIXME: replicate iself logic *)
                    \<or> ((elf64_section_name_as_string  (isec   irec)) = (''.note''))
                    then place_after_interp
                else if(elf64_section_type  (isec   irec)) = sht_nobits
                    then place_after_bss
                else (* FIXME: implement thread-local case *)
                    if \<not> (flag_is_set shf_write(elf64_section_flags  (isec   irec)))
                     \<and> \<not> (flag_is_set shf_execinstr(elf64_section_flags  (isec   irec)))
                        then place_after_rodata
                else if flag_is_set shf_write(elf64_section_flags  (isec   irec))
                     \<and> \<not> (flag_is_set shf_execinstr(elf64_section_flags  (isec   irec)))
                        then place_after_data
                else place_after_text
        )) 
        in
        (let (discards, outputs1) = acc1 in
        (case  place_after of
            Some idx1 => (* The section exists and has the flags we expected, and is at output idx *)
                (discards, mapi (\<lambda> i .  \<lambda> output1 .  
  (* FIXME: also fix up flags, alignment etc. *)
  (case  output1 of
      (OutputSectionSpec (guard, maybe_addr, name1, comp1), script_el_idx) =>
  if  i = idx1 then
    (OutputSectionSpec
       (guard, maybe_addr, name1, (comp1 @
                                     [IncludeInputSection (DefaultKeep, irec)])), script_el_idx)
  else output1
  )
                    ) outputs1
                )
            | None => 
                    (let _ = (())
                    in
                    ((discards @ [input]), outputs1))
         )))))))))))))
     ))
     in
     List.foldl place_one_orphan (discards, outputs1) orphans))))" 
declare default_place_orphans.simps [simp del]
 

(*val interpret_linker_control_script :
    address_expr_fn_map allocated_sections_map ->
    linker_control_script
    -> linkable_list
    -> natural (* control_script_linkable_idx *)
    -> abi any_abi_feature
    -> list input_spec
    -> (input_spec -> input_spec -> ordering)                       (* seen ordering *)
    -> (input_output_assignment -> list input_spec -> input_output_assignment)     (* place orphans *)
    -> (Map.map string (list (natural * binding))) (* initial_bindings_by_name *)
    -> (elf_memory_image * Map.map string (list (natural * binding)))*)
definition interpret_linker_control_script  :: "((address_expr_fn_ref),(nat \<Rightarrow> allocated_sections_map \<Rightarrow> nat))Map.map \<Rightarrow>(script_element)list \<Rightarrow>(linkable_object*input_item*input_options)list \<Rightarrow> nat \<Rightarrow>(any_abi_feature)abi \<Rightarrow>(input_spec)list \<Rightarrow>(input_spec \<Rightarrow> input_spec \<Rightarrow> ordering)\<Rightarrow>((input_spec)list*(output_section_spec*nat)list \<Rightarrow>(input_spec)list \<Rightarrow>(input_spec)list*(output_section_spec*nat)list)\<Rightarrow>((string),((nat*((nat*symbol_reference*(linkable_object*input_item*input_options))*(nat*symbol_definition*(linkable_object*input_item*input_options))option))list))Map.map \<Rightarrow>(any_abi_feature)annotated_memory_image*((string),((nat*binding)list))Map.map "  where 
     " interpret_linker_control_script alloc_map script linkables control_script_linkable_idx a inputs1 seen_ordering place_orphans initial_bindings_by_name = (
    (let labelled_script = (label_script script)
    in
    (let _ = (Lem_list.mapi (\<lambda> i .  \<lambda> input .  
        ()
    ) inputs1)
    in
    (let (discards_before_orphans, outputs_before_orphans)
     = (assign_inputs_to_output_sections ([], []) {} {} inputs1 None None seen_ordering labelled_script)
    in
    (* place orphans *)
    (let (discards, outputs1) = (place_orphans (discards_before_orphans, outputs_before_orphans) inputs1)
    in
    (* In assigning inputs to outputs, we may also have defined some symbols. These affect the 
     * bindings that are formed. So, we rewrite the bindings here. Note that we have to do so here,
     * not in the caller, because these extra bindings can affect the reachability calculation 
     * during GC. *)
    (let (linker_defs_by_name, (bindings_by_name :: ( (string, ( (nat * binding)list))Map.map))) = (
        (let (script_defs_by_name :: (string, ( (symbol_definition * symbol_def_policy)list)) Map.map)
         = (List.foldl (\<lambda> acc1 .  (\<lambda>p .  
  (case  (p ) of
      ( ((OutputSectionSpec (guard, maybe_addr, secname1, comp1)), script_el_idx) ) =>
  List.foldl
    (\<lambda> inner_acc .  \<lambda> comp_el .  (
                                                 (case  comp_el of
                                                     ProvideSymbol (pol, name1, (size3, info, other)) =>
                                                 (let _ = (()) in
                                                 (let def1 = (symbol_def_for_provide_symbol
                                                                name1 
                                                              size3 info
                                                                other
                                                                control_script_linkable_idx)
                                                 in
                                                 (let v = ((case   inner_acc
                                                                    name1 of
                                                               None => 
                                                           [(def1, pol)]
                                                             | Some l => 
                                                           (def1, pol) # 
                                                           l
                                                           )) in
                                                 map_update name1 v inner_acc)))
                                                   | _ => inner_acc
                                                 ) ))
    (acc1 :: ( string, ( ( symbol_definition * symbol_def_policy) list)) Map.map)
    comp1
  )
        )) Map.empty outputs1)
        in
        (* Now that we've made these definitions, what bindings are affected? 
         * We also use this opportunity to bind references to linker-generated symbols,
         * such as _GLOBAL_OFFSET_TABLE_, since any definitions of these should now be merged
         * into our inputs. *)
        (* bit of a HACK: reconstruct the linkable img and idx from the input items *)
        (let idx_to_img = (List.foldl (\<lambda> acc_m .  \<lambda> item .  
                            (case  item of 
                                Common(idx1, _, img3, symdef) => map_update idx1 img3 (map_remove idx1 acc_m)
                                | InputSection(irec) => map_update(idx   irec)(img   irec) (map_remove(idx   irec) acc_m)
                            )
                        ) Map.empty inputs1)
        in
        (let (lowest_idx :: nat) = ((case  Elf_Types_Local.find_min_element (Map.dom idx_to_img)
            of Some x => x
            | None => failwith (''internal error: no linkable items'')
        ))
        in
        (let first_linkable_item = ((case  linkables of x # more1 => x | _ => failwith (''internal error: no linkables'') ))
        in
        (let (control_script_input_item :: input_item) = (
            (''(built-in control script)''), 
            ControlScript, 
            (BuiltinControlScript, [Builtin])
        )
        in
        (let (control_script_linkable_item :: linkable_item) = (
            ControlScriptDefs, control_script_input_item, 
                  (| item_fmt = ('''')
                   , item_check_sections = False
                   , item_copy_dt_needed = False
                   , item_force_output = True 
                   |)
        )
        in
        (let updated_bindings_and_new_defs = (map_image (\<lambda> b_list_initial .  
            List.map (\<lambda> (b_idx, b_initial) . 
                (let ((iref_idx, iref, iref_item), maybe_idef) = b_initial
                in
                (let _ = (())
                in
                (let possible_script_defs = ((case   script_defs_by_name(ref_symname   iref) of
                    Some l => l
                    | None => []
                ))
                in
                (let (possible_linker_generated_def ::  symbol_definition option) =                    
 (if(symbol_is_generated_by_linker   a)(ref_symname   iref)
                        then (* can we find a definition by this name? *)
                            ((case   idx_to_img lowest_idx of
                                None => failwith (''no lowest idx found'')
                                | Some img3 => 
                                    (case  List.filter (\<lambda> def1 . (def_symname   def1) =(ref_symname   iref)) (defined_symbols 
  instance_Basic_classes_Ord_Abis_any_abi_feature_dict instance_Abi_classes_AbiFeatureTagEquiv_Abis_any_abi_feature_dict img3) of
                                        [] => None
                                        | [def1] => Some(def1)
                                        | _ => failwith (([(CHR ''f''), (CHR ''i''), (CHR ''r''), (CHR ''s''), (CHR ''t''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''n''), (CHR ''k''), (CHR ''a''), (CHR ''b''), (CHR ''l''), (CHR ''e''), (CHR '' ''), (CHR ''h''), (CHR ''a''), (CHR ''s''), (CHR '' ''), (CHR ''m''), (CHR ''u''), (CHR ''l''), (CHR ''t''), (CHR ''i''), (CHR ''p''), (CHR ''l''), (CHR ''e''), (CHR '' ''), (CHR ''d''), (CHR ''e''), (CHR ''f''), (CHR ''s''), (CHR '' ''), (CHR ''o''), (CHR ''f''), (CHR '' ''), (CHR ''n''), (CHR ''a''), (CHR ''m''), (CHR ''e''), (CHR '' ''), (Char Nibble6 Nibble0)]) @ ((ref_symname   iref) @ ([(Char Nibble2 Nibble7)])))
                                    )
                            ))
                    else None)
                in
                (* If the binding has no def, we always use the def we have. 
                 * If the binding has a def, we use our def only if the policy is AlwaysDefine. *)
                (let _ = (())
                in
                (* FIXME: check real semantics of defining symbols like '_GLOBAL_OFFSET_TABLE_' in linker script or input objects. 
                 * This is really just a guess. *)
                (let new_b_and_maybe_new_def = ((case  (maybe_idef, possible_script_defs, possible_linker_generated_def) of
                      (_, [], None) => (let _ = (()) in 
                        (((iref_idx, iref, iref_item), maybe_idef), None))
                    | (None, [], Some(def1)) => (let _ = (()) in 
                        (((iref_idx, iref, iref_item), Some(lowest_idx, def1, first_linkable_item)), Some(def1)))
                    | (_, [(def1, AlwaysDefine)], _) => (let _ = (()) in
                        (((iref_idx, iref, iref_item), Some (control_script_linkable_idx, def1, control_script_linkable_item)), Some(def1)))
                    | (Some existing_def, ([(def1, ProvideIfUsed)]), _) => (let _ = (()) in
                        (((iref_idx, iref, iref_item), Some existing_def), None))
                    | (None, [(def1, ProvideIfUsed)], _) => (let _ = (()) in
                        (((iref_idx, iref, iref_item), Some (control_script_linkable_idx, def1, control_script_linkable_item)), Some(def1)))
                    | (_, pair1 # pair2 # more1, _) => (let _ = (()) in
                        failwith (''ambiguous symbol binding in linker control script''))
                ))
                in
                (b_idx, new_b_and_maybe_new_def)))))))
            ) b_list_initial
        ) initial_bindings_by_name)
        in
        (let (new_symbol_defs_map :: (string, ( ( symbol_definition option)list)) Map.map)
         = (map_image (\<lambda> b_pair_list .  List.map (\<lambda> (b_idx, (new_b, maybe_new_def)) .  maybe_new_def) b_pair_list) updated_bindings_and_new_defs)
        in
        (let (new_symbol_defs_by_name :: (string, ( symbol_definition list)) Map.map) = (map_image
            (\<lambda> v .  Lem_list.mapMaybe id0 v) new_symbol_defs_map)
        in
        (*    { List.mapMaybe id maybe_def_list | forall ((_, maybe_def_list) IN (Map.toSet new_symbol_defs_map)) | true }
        in*)
        (*let new_symbol_defs = List.concat (Set_extra.toList new_symbol_def_list_set)
        in*)
        (let updated_bindings = (map_image (\<lambda> b_pair_list .  List.map (\<lambda> (b_idx, (new_b, maybe_new_def)) .  (b_idx, new_b)) b_pair_list) updated_bindings_and_new_defs)
        in
        (new_symbol_defs_by_name, updated_bindings)))))))))))
    )
    in
    (*let _ = errln (For __fini_array_end, we have  ^ 
        (let all_bs = match Map.lookup __fini_array_end bindings_by_name with
            Just l -> l
            | Nothing -> []
        end
        in
        ((show (length all_bs)) ^ 
         bindings, of which  ^ 
        (show (length (List.filter (fun (bi, ((ref_idx, ref, ref_item), maybe_def)) -> 
            match maybe_def with
                Just _ -> true
                | _ -> false
            end
        ) all_bs))) ^  have defs)))
    in*)
    (let outputs_by_name = 
        ((let insert_fun = (\<lambda> m .  (\<lambda>p .  
  (case  (p ) of
      ( (OutputSectionSpec (guard, maybe_addr, name1, compos), script_idx) ) => 
  map_update name1
    ((OutputSectionSpec (guard, maybe_addr, name1, compos)), script_idx) 
  m
  )))
        in
        List.foldl insert_fun Map.empty outputs1))
    in
    (* Print the link map's discarded input sections output. *)
    (let _ = (())
    in
    (let discard_line = (\<lambda> i .  ((case  i of
        InputSection(s) => 
            (let lpadded_secname = (('' '') @(secname   s))
            in
            lpadded_secname @ ((space_padding_and_maybe_newline(( 16 :: nat)) lpadded_secname) @ ((''0x0000000000000000'') (* FIXME *)
            @ ((''        0x'') @ ((hex_string_of_natural(elf64_section_size  (isec   s))) @ (('' '')
            @ ((fname   s) @ ([(Char Nibble0 NibbleA)]))))))))
        | Common(idx1, fname1, img3, def1) => ('''') (* don't print discard lines for discarded commons *)
    )))
    in
    (*let _ = Missing_pervasives.outs (List.foldl (fun str -> (fun input -> (str ^ (discard_line input))))  (reverse discards))
    in*)
    (let outputs_by_name_after_gc = (compute_def_use_and_gc (AllocatedSectionsMap outputs_by_name))
    in
    (let _ = (())
    in
    (let _ = (())
    in
    (* FIXME: print LOAD and START_GROUP trace *)
    (let (img3, outputs_by_name_with_position)
     = (build_image alloc_map empty_elf_memory_image(( 0 :: nat)) outputs_by_name_after_gc bindings_by_name labelled_script control_script_linkable_idx linker_defs_by_name)
    in
    (*let _ = errln (Final image has  ^ (show (Map.size img.elements)) ^  elements and  
        ^ (show (Set.size img.by_tag)) ^  metadata tags, of which  ^ (
            let (section_tags, section_ranges) = elf_memory_image_section_ranges img
            in
            let section_tags_bare = List.map (fun tag -> 
                match tag with 
                    | FileFeature(ElfSection(idx, isec)) -> (idx, isec)
                    | _ -> failwith not section tag
                end) section_tags
            in
            show (length section_tags_bare)
        ) ^  are sections.)
    in*)
    (* The link map output for the section/address assignment basically mirrors our notion of 
     * output section composition.  In the following:
     
                0x0000000000400000                PROVIDE (__executable_start, 0x400000)
                0x0000000000400190                . = (0x400000 + SIZEOF_HEADERS)

.interp
 *(.interp)

.note.ABI-tag   0x0000000000400190       0x20
 .note.ABI-tag  0x0000000000400190       0x20 crt1.o

.note.gnu.build-id
                0x00000000004001b0       0x24
 *(.note.gnu.build-id)
 .note.gnu.build-id
                0x00000000004001b0       0x24 crt1.o

.hash
 *(.hash)

.gnu.hash
 *(.gnu.hash)

... we can see that 

        - symbol provision, holes and output sections all get lines
        
        - each output section appears with its name left-aligned, and its address,
             if any, appearing afterwards; if so, the section's total size also follows.
        
        - each input query is printed verbatim, e.g. *(.note.gnu.build-id)
        
        - underneath this, a line is printed for each input section that was included,
             with its address and size. This can spill onto a second line in the usual way.
        
        - holes are shown as *fill*
        
        - provided symbols are shown as in the linker script source.
        
    PROBLEM: we don't have the script in source form, so we can't print the queries verbatim.
    I should really annotate each query with its source form; when the script is parsed from source,
    this can be inserted automatically. For the moment, what to do? I could annotate each script
    element manually. For the moment, for diffing purposes, filter out lines with asterisks.
     
     *)
    (img3, bindings_by_name))))))))))))))"

end
