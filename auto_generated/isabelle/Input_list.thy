chapter {* Generated by Lem from input_list.lem. *}

theory "Input_list" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string_extra" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Default_printing" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "Elf_file" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list_extra" 
	 "Archive" 
	 "Command_line" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import String_extra*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import List_extra*)
(*open import Sorting*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)

(*open import Byte_sequence*)
(*open import Default_printing*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(*open import Archive*)
(*open import Command_line*)
(*open import Elf_types_native_uint*)
(*open import Elf_file*)
(*open import Elf_header*)

(* Here we elaborate away various properties of the command line: 
 * archives, groups, library paths, -l, --as-needed, --whole-archive,
 * and which inputs can be used to resolve symbols undefined in which other inputs.
 * 
 * What we get out is a list of input files and the options applying to them.
 * Input files are either relocatable files, shared objects or linker scripts.
 *)

datatype input_blob =  Reloc " byte_sequence "
                 | Shared " byte_sequence "
                 | Script " byte_sequence "
                 | ControlScript

(* We remember where the input item came from on the command line,
 * using coordinates identifying the index in the higher-up list
 * followed by the index within that item. *)
datatype origin_coord = InArchive " (nat * nat * string * nat)" (* archive-id, pos-within-archive, archive-name, archive-member-count *)
                  | InGroup " (nat * nat)"   (* group-id, pos-within-group *)
                  | InCommandLine " nat "
                  | Builtin

(*val string_of_origin_coord : origin_coord -> string*)
fun string_of_origin_coord  :: " origin_coord \<Rightarrow> string "  where 
     " string_of_origin_coord (InArchive(aid, aidx, aname, _)) = ( (''at position '') @ ((stringFromNatural aidx) @ (('' within archive '') @ (aname @ (('' (at position '') @ ((stringFromNatural aid) @ ('')'')))))))"
|" string_of_origin_coord (InGroup(gid1, gidx)) = ( (''at position '') @ ((stringFromNatural gidx) @ (('' within group at position '') @ (stringFromNatural gid1))))"
|" string_of_origin_coord (InCommandLine(cid)) = ( (''(command line)''))"
|" string_of_origin_coord Builtin = ( (''(built-in)''))" 
declare string_of_origin_coord.simps [simp del]


definition instance_Show_Show_Input_list_origin_coord_dict  :: "(origin_coord)Show_class "  where 
     " instance_Show_Show_Input_list_origin_coord_dict = ((|

  show_method = string_of_origin_coord |) )"


type_synonym input_origin =" input_unit * origin_coord list "

type_synonym input_item =" string * input_blob * input_origin "

(*val string_of_input_blob : input_blob -> string*)
fun string_of_input_blob  :: " input_blob \<Rightarrow> string "  where 
     " string_of_input_blob (Reloc(seq)) = ( (''relocatable file ('') @ ((stringFromNatural (Byte_sequence.length0 seq)) @ ('' bytes)'')))"
|" string_of_input_blob (Shared(seq)) = ( (''shared object ('') @ ((stringFromNatural (Byte_sequence.length0 seq)) @ ('' bytes)'')))"
|" string_of_input_blob (Script(seq)) = ( (''script ('') @ ((stringFromNatural (Byte_sequence.length0 seq)) @ ('' bytes)'')))"
|" string_of_input_blob ControlScript = ( (''the linker control script''))" 
declare string_of_input_blob.simps [simp del]


definition instance_Show_Show_Input_list_input_blob_dict  :: "(input_blob)Show_class "  where 
     " instance_Show_Show_Input_list_input_blob_dict = ((|

  show_method = string_of_input_blob |) )"


(*val short_string_of_input_item : input_item -> string*)
definition short_string_of_input_item  :: " string*input_blob*(input_unit*(origin_coord)list)\<Rightarrow> string "  where 
     " short_string_of_input_item item = ( 
    (let (fname1, blob, (u, origin)) = item
    in
    (case  origin of
        InArchive(aid, aidx, aname, _) # _ => aname @ ((''('') @ (fname1 @ ('')'')))
        | _ => fname1
    )))"


(* About symbol resolution and suppliers.
 * 
 * Groups change this.
 * 
 * When we expand a .a file into a list of .o files, what is the supplier
 * relation among them? I *THINK* that within the archive, each can supply any other,
 * but outside the archive, each can only supply leftmore.
 *)

type_synonym can_supply_function =" input_item list \<Rightarrow> nat \<Rightarrow> bool list "

record input_options =  
 item_fmt ::" string "
                       
 item_check_sections ::" bool "
                       
 item_copy_dt_needed ::" bool "
                       
 item_force_output ::" bool "  (* true for .o, false for .a unless --whole-archive, 
                                                 true for .so with --no-as-needed, 
                                                 false for .so with --as-needed *)
                       


(*val null_input_options : input_options*)
definition null_input_options  :: " input_options "  where 
     " null_input_options = ( 
                      (| item_fmt = ('''')
                       , item_check_sections = False
                       , item_copy_dt_needed = False
                       , item_force_output = True
                       |) )"


(*val string_of_input_options : input_options -> string*)
definition string_of_input_options  :: " input_options \<Rightarrow> string "  where 
     " string_of_input_options opts = ( (''(some options)''))"


definition instance_Show_Show_Input_list_input_options_dict  :: "(input_options)Show_class "  where 
     " instance_Show_Show_Input_list_input_options_dict = ((|

  show_method = string_of_input_options |) )"


type_synonym input_list =" (input_item * input_options) list "

(*val toplevel_dot_o_can_supply : list input_item -> nat -> list bool*)
definition toplevel_dot_o_can_supply  :: "(string*input_blob*input_origin)list \<Rightarrow> nat \<Rightarrow>(bool)list "  
 where 
     " toplevel_dot_o_can_supply inputs1 pos 
 = ( genlist (\<lambda> _ .  True) (List.length inputs1))"


(*val toplevel_shared_can_supply : list input_item -> nat -> list bool*)
definition toplevel_shared_can_supply  :: "(string*input_blob*input_origin)list \<Rightarrow> nat \<Rightarrow>(bool)list "  
 where 
     " toplevel_shared_can_supply inputs1 pos 
 = ( genlist (\<lambda> ndx .  ndx \<le> pos) (List.length inputs1))"

 
(*val toplevel_archive_can_supply : list input_item -> nat -> list bool*)
definition toplevel_archive_can_supply  :: "(string*input_blob*input_origin)list \<Rightarrow> nat \<Rightarrow>(bool)list "  
 where 
     " toplevel_archive_can_supply inputs1 pos 
 = ( genlist (\<lambda> ndx .  ndx \<le> pos) (List.length inputs1))"


(*val lib_filename_from_spec : string -> string -> string*)
definition lib_filename_from_spec  :: " string \<Rightarrow> string \<Rightarrow> string "  where 
     " lib_filename_from_spec spec ext = (
    (case  ( spec) of
        (CHR '':'') # more1 => ( more1)
        | _ => (''lib'') @ (spec @ ((''.'') @ ext))
    ))"


(*val find_library_in : string -> list string -> list string -> maybe string*)

(*val find_one_library_filename : input_file_options -> string -> string*)

(*val is_elf64_with_type : elf64_half -> byte_sequence -> bool*)
definition is_elf64_with_type  :: " uint16 \<Rightarrow> byte_sequence \<Rightarrow> bool "  where 
     " is_elf64_with_type typ1 seq = ( 
    (*let _ = Missing_pervasives.errs (elf64?  ^ 
        (match seq with Sequence(bs) -> show (List.take 16 bs) end))
    in*)
    (case  Elf_file.read_elf64_file seq of
    Success(e) => (* let _ = Missing_pervasives.errln : yes in *) ((elf64_type  (elf64_file_header   e)) = typ1)
    | Fail _ => (* let _ = Missing_pervasives.errln : no in *) False
    ))"


(*val is_archive : byte_sequence -> bool*)
definition is_archive  :: " byte_sequence \<Rightarrow> bool "  where 
     " is_archive seq = (
    (case  read_archive_global_header seq of
        Success _ => True
        | Fail _ => False
    ))"


(*val open_file_and_expand : string -> input_unit -> natural -> list input_item*)

(*val make_input_items_and_options : list input_item -> Command_line.input_file_options -> list origin_coord -> list (input_item * input_options)*)
definition make_input_items_and_options  :: "(string*input_blob*(input_unit*(origin_coord)list))list \<Rightarrow> input_file_options \<Rightarrow>(origin_coord)list \<Rightarrow>((string*input_blob*(input_unit*(origin_coord)list))*input_options)list "  where 
     " make_input_items_and_options file_list cmdopts coords_to_append = ( 
  (case  file_list of
      [] => failwith (''impossible: empty list of files'')
    | [(fname1, Reloc (seq), (u, coords))] =>
  [((fname1, Reloc (seq), (u, (coords @ coords_to_append))),
   (| item_fmt = ((input_fmt   cmdopts))
   , item_check_sections = ((input_check_sections   cmdopts))
   , item_copy_dt_needed = ((input_copy_dt_needed   cmdopts))
   , item_force_output = True |))]
    | [(fname1, Shared (seq), (u, coords))] =>
  [((fname1, Shared (seq), (u, (coords @ coords_to_append))),
   (| item_fmt = ((input_fmt   cmdopts))
   , item_check_sections = ((input_check_sections   cmdopts))
   , item_copy_dt_needed = ((input_copy_dt_needed   cmdopts))
   , item_force_output = (if(input_as_needed   cmdopts) then False else True)
   |))]
    | [(fname1, Script (seq), (u, coords))] =>
  [((fname1, Script (seq), (u, (coords @ coords_to_append))),
   (| item_fmt = ((input_fmt   cmdopts))
   , item_check_sections = ((input_check_sections   cmdopts))
   , item_copy_dt_needed = ((input_copy_dt_needed   cmdopts))
   , item_force_output = True |))]
    | _ => (* guaranteed to be all relocs, from one archive *)
           (let (items_and_options :: ( input_item * input_options) list) =
                (mapMaybei
                   (\<lambda> i .  (\<lambda> (fname1, reloc1, (u, coords)) . 
                                    (let (item :: input_item) = (fname1, reloc1, 
                                                                (u, (
                                                                    coords @
                                                                    coords_to_append)))
                                    in
                                    (let (options :: input_options) =
                                         ((| item_fmt = ((input_fmt   cmdopts))
                                          , item_check_sections = ((input_check_sections   cmdopts))
                                          , item_copy_dt_needed = ((input_copy_dt_needed   cmdopts))
                                          , item_force_output = (
                                                                if(input_whole_archive   cmdopts) then
                                                                  True else
                                                                  False) |))
                                    in Some (item, options))) )) file_list)
           in items_and_options)
  ) )"


(*val elaborate_input_helper : natural -> list Command_line.input_unit -> input_list -> input_list*)
    
(*val elaborate_input : list Command_line.input_unit -> input_list*)
end
