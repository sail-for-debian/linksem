chapter {* Generated by Lem from elf_header.lem. *}

theory "Elf_header" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Endianness" 
	 "Elf_types_native_uint" 
	 "Default_printing" 

begin 

(** [elf_header] includes types, functions and other definitions for working with
  * ELF headers.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*import Set*)

(*open import Assert_extra*)

(*open import Default_printing*)
(*open import Endianness*)

(*open import Elf_types_native_uint*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** Special section header table indices *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  * Present here instead of in elf_section_header_table.lem because a calculation
  * below requires this constant (i.e. forward reference in the ELF spec).
  *)
definition shn_undef  :: " nat "  where 
     " shn_undef = (( 0 :: nat))"


(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears). Present here instead
  * of in elf_section_header_table.lem because a calculation below requires this
  * constant (i.e. forward reference in the ELF spec).
  *)
definition shn_xindex  :: " nat "  where 
     " shn_xindex = (( 65535 :: nat))"
 (* 0xffff *)

(** ELF object file types.  Enumerates the ELF object file types specified in the
 *  System V ABI.  Values between [elf_ft_lo_os] and [elf_ft_hi_os] inclusive are
 *  reserved for operating system specific values typically defined in an
 *  addendum to the System V ABI for that operating system.  Values between
 *  [elf_ft_lo_proc] and [elf_ft_hi_proc] inclusive are processor specific and
 *  are typically defined in an addendum to the System V ABI for that processor
 *  series.
 *)

(** No file type *)
definition elf_ft_none  :: " nat "  where 
     " elf_ft_none = (( 0 :: nat))"

(** Relocatable file *)
definition elf_ft_rel  :: " nat "  where 
     " elf_ft_rel = (( 1 :: nat))"

(** Executable file *)
definition elf_ft_exec  :: " nat "  where 
     " elf_ft_exec = (( 2 :: nat))"

(** Shared object file *)
definition elf_ft_dyn  :: " nat "  where 
     " elf_ft_dyn = (( 3 :: nat))"

(** Core file *)
definition elf_ft_core  :: " nat "  where 
     " elf_ft_core = (( 4 :: nat))"

(** Operating-system specific *)
definition elf_ft_lo_os  :: " nat "  where 
     " elf_ft_lo_os = (( 65024 :: nat))"
 (* 0xfe00 *)
(** Operating-system specific *)
definition elf_ft_hi_os  :: " nat "  where 
     " elf_ft_hi_os = (( 65279 :: nat))"
 (* 0xfeff *)
(** Processor specific *)
definition elf_ft_lo_proc  :: " nat "  where 
     " elf_ft_lo_proc = (( 65280 :: nat))"
 (* 0xff00 *)
(** Processor specific *)
definition elf_ft_hi_proc  :: " nat "  where 
     " elf_ft_hi_proc = (( 65535 :: nat))"
 (* 0xffff *)

(** [string_of_elf_file_type os proc m] produces a string representation of the
  * numeric encoding [m] of the ELF file type.  For values reserved for OS or
  * processor specific values, the higher-order functions [os] and [proc] are
  * used for printing, respectively.
  *)
(*val string_of_elf_file_type : (natural -> string) -> (natural -> string) -> natural -> string*)
definition string_of_elf_file_type  :: "(nat \<Rightarrow> string)\<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow> nat \<Rightarrow> string "  where 
     " string_of_elf_file_type os_specific proc_specific m = (
	if m = elf_ft_none then
		(''No file type'')
	else if m = elf_ft_rel then
		(''REL (Relocatable file)'')
	else if m = elf_ft_exec then
		(''EXEC (Executable file)'')
	else if m = elf_ft_dyn then
		(''DYN (Shared object file)'')
	else if m = elf_ft_core then
		(''CORE (Core file)'')
	else if (m \<ge> elf_ft_lo_os) \<and> (m \<le> elf_ft_hi_os) then
		os_specific m
	else if (m \<ge> elf_ft_lo_proc) \<and> (m \<le> elf_ft_hi_proc) then
		proc_specific m
	else
		(''Invalid file type''))"


(** [is_operating_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for operating system-specific purposes.
  *)
(*val is_operating_system_specific_object_file_type_value : natural -> bool*)
definition is_operating_system_specific_object_file_type_value  :: " nat \<Rightarrow> bool "  where 
     " is_operating_system_specific_object_file_type_value v = (  
(v \<ge>( 65024 :: nat)) \<and> (v \<le>( 65279 :: nat)))"


(** [is_processor_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for processor-specific purposes.
  *)
(*val is_processor_specific_object_file_type_value : natural -> bool*)
definition is_processor_specific_object_file_type_value  :: " nat \<Rightarrow> bool "  where 
     " is_processor_specific_object_file_type_value v = (  
(v \<ge>( 65280 :: nat)) \<and> (v \<le>( 65535 :: nat)))"


(** ELF machine architectures *)

(** RISC-V *)
definition elf_ma_riscv  :: " nat "  where 
     " elf_ma_riscv = (( 243 :: nat))"

(** AMD GPU architecture *)
definition elf_ma_amdgpu  :: " nat "  where 
     " elf_ma_amdgpu = (( 224 :: nat))"

(** Moxie processor family *)
definition elf_ma_moxie  :: " nat "  where 
     " elf_ma_moxie = (( 223 :: nat))"

(** FTDI Chip FT32 high performance 32-bit RISC architecture *)
definition elf_ma_ft32  :: " nat "  where 
     " elf_ma_ft32 = (( 222 :: nat))"

(** Controls and Data Services VISIUMcore processor *)
definition elf_ma_visium  :: " nat "  where 
     " elf_ma_visium = (( 221 :: nat))"

(** Zilog Z80 *)
definition elf_ma_z80  :: " nat "  where 
     " elf_ma_z80 = (( 220 :: nat))"

(** CSR Kalimba architecture family *)
definition elf_ma_kalimba  :: " nat "  where 
     " elf_ma_kalimba = (( 219 :: nat))"

(** Nanoradio optimised RISC *)
definition elf_ma_norc  :: " nat "  where 
     " elf_ma_norc = (( 218 :: nat))"

(** iCelero CoolEngine *)
definition elf_ma_cool  :: " nat "  where 
     " elf_ma_cool = (( 217 :: nat))"

(** Cognitive Smart Memory Processor *)
definition elf_ma_coge  :: " nat "  where 
     " elf_ma_coge = (( 216 :: nat))"

(** Paneve CDP architecture family *)
definition elf_ma_cdp  :: " nat "  where 
     " elf_ma_cdp = (( 215 :: nat))"

(** KM211 KVARC processor *)
definition elf_ma_kvarc  :: " nat "  where 
     " elf_ma_kvarc = (( 214 :: nat))"

(** KM211 KMX8 8-bit processor *)
definition elf_ma_kmx8  :: " nat "  where 
     " elf_ma_kmx8 = (( 213 :: nat))"

(** KM211 KMX16 16-bit processor *)
definition elf_ma_kmx16  :: " nat "  where 
     " elf_ma_kmx16 = (( 212 :: nat))"

(** KM211 KMX32 32-bit processor *)
definition elf_ma_kmx32  :: " nat "  where 
     " elf_ma_kmx32 = (( 211 :: nat))"

(** KM211 KM32 32-bit processor *)
definition elf_ma_km32  :: " nat "  where 
     " elf_ma_km32 = (( 210 :: nat))"

(** Microchip 8-bit PIC(r) family *)
definition elf_ma_mchp_pic  :: " nat "  where 
     " elf_ma_mchp_pic = (( 204 :: nat))"

(** XMOS xCORE processor family *)
definition elf_ma_xcore  :: " nat "  where 
     " elf_ma_xcore = (( 203 :: nat))"

(** Beyond BA2 CPU architecture *)
definition elf_ma_ba2  :: " nat "  where 
     " elf_ma_ba2 = (( 202 :: nat))"

(** Beyond BA1 CPU architecture *)  
definition elf_ma_ba1  :: " nat "  where 
     " elf_ma_ba1 = (( 201 :: nat))"

(** Freescale 56800EX Digital Signal Controller (DSC) *)
definition elf_ma_5600ex  :: " nat "  where 
     " elf_ma_5600ex = (( 200 :: nat))"

(** 199 Renesas 78KOR family *)
definition elf_ma_78kor  :: " nat "  where 
     " elf_ma_78kor = (( 199 :: nat))"

(** Broadcom VideoCore V processor *)
definition elf_ma_videocore5  :: " nat "  where 
     " elf_ma_videocore5 = (( 198 :: nat))"

(** Renesas RL78 family *)
definition elf_ma_rl78  :: " nat "  where 
     " elf_ma_rl78 = (( 197 :: nat))"

(** Open8 8-bit RISC soft processing core *)
definition elf_ma_open8  :: " nat "  where 
     " elf_ma_open8 = (( 196 :: nat))"

(** Synopsys ARCompact V2 *)
definition elf_ma_arc_compact2  :: " nat "  where 
     " elf_ma_arc_compact2 = (( 195 :: nat))"

(** KIPO_KAIST Core-A 2nd generation processor family *)
definition elf_ma_corea_2nd  :: " nat "  where 
     " elf_ma_corea_2nd = (( 194 :: nat))"

(** KIPO_KAIST Core-A 1st generation processor family *)
definition elf_ma_corea_1st  :: " nat "  where 
     " elf_ma_corea_1st = (( 193 :: nat))"

(** CloudShield architecture family *)
definition elf_ma_cloudshield  :: " nat "  where 
     " elf_ma_cloudshield = (( 192 :: nat))"

(** Infineon Technologies SLE9X core *)
definition elf_ma_sle9x  :: " nat "  where 
     " elf_ma_sle9x = (( 179 :: nat))"

(** Intel L10M *)
definition elf_ma_l10m  :: " nat "  where 
     " elf_ma_l10m = (( 180 :: nat))"

(** Intel K10M *)
definition elf_ma_k10m  :: " nat "  where 
     " elf_ma_k10m = (( 181 :: nat))"

(** ARM 64-bit architecture (AARCH64) *)
definition elf_ma_aarch64  :: " nat "  where 
     " elf_ma_aarch64 = (( 183 :: nat))"

(** Atmel Corporation 32-bit microprocessor family *)
definition elf_ma_avr32  :: " nat "  where 
     " elf_ma_avr32 = (( 185 :: nat))"

(** STMicroelectronics STM8 8-bit microcontroller *)
definition elf_ma_stm8  :: " nat "  where 
     " elf_ma_stm8 = (( 186 :: nat))"

(** Tilera TILE64 multicore architecture family *)
definition elf_ma_tile64  :: " nat "  where 
     " elf_ma_tile64 = (( 187 :: nat))"

(** Tilera TILEPro multicore architecture family *)
definition elf_ma_tilepro  :: " nat "  where 
     " elf_ma_tilepro = (( 188 :: nat))"

(** Xilinix MicroBlaze 32-bit RISC soft processor core *)
definition elf_ma_microblaze  :: " nat "  where 
     " elf_ma_microblaze = (( 189 :: nat))"

(** NVIDIA CUDA architecture *)
definition elf_ma_cuda  :: " nat "  where 
     " elf_ma_cuda = (( 190 :: nat))"

(** Tilera TILE-Gx multicore architecture family *)
definition elf_ma_tilegx  :: " nat "  where 
     " elf_ma_tilegx = (( 191 :: nat))"

(** Cypress M8C microprocessor *)
definition elf_ma_cypress  :: " nat "  where 
     " elf_ma_cypress = (( 161 :: nat))"

(** Renesas R32C series microprocessors *)
definition elf_ma_r32c  :: " nat "  where 
     " elf_ma_r32c = (( 162 :: nat))"

(** NXP Semiconductors TriMedia architecture family *)
definition elf_ma_trimedia  :: " nat "  where 
     " elf_ma_trimedia = (( 163 :: nat))"

(** QUALCOMM DSP6 processor *)
definition elf_ma_qdsp6  :: " nat "  where 
     " elf_ma_qdsp6 = (( 164 :: nat))"

(** Intel 8051 and variants *)
definition elf_ma_8051  :: " nat "  where 
     " elf_ma_8051 = (( 165 :: nat))"

(** STMicroelectronics STxP7x family of configurable and extensible RISC processors *)
definition elf_ma_stxp7x  :: " nat "  where 
     " elf_ma_stxp7x = (( 166 :: nat))"

(** Andes Technology compact code size embedded RISC processor family *)
definition elf_ma_nds32  :: " nat "  where 
     " elf_ma_nds32 = (( 167 :: nat))"

(** Cyan Technology eCOG1X family *)
definition elf_ma_ecog1x  :: " nat "  where 
     " elf_ma_ecog1x = (( 168 :: nat))"

(** Dallas Semiconductor MAXQ30 Core Micro-controllers *)
definition elf_ma_maxq30  :: " nat "  where 
     " elf_ma_maxq30 = (( 169 :: nat))"

(** New Japan Radio (NJR) 16-bit DSP Processor *)
definition elf_ma_ximo16  :: " nat "  where 
     " elf_ma_ximo16 = (( 170 :: nat))"

(** M2000 Reconfigurable RISC Microprocessor *)
definition elf_ma_manik  :: " nat "  where 
     " elf_ma_manik = (( 171 :: nat))"

(** Cray Inc. NV2 vector architecture *)
definition elf_ma_craynv2  :: " nat "  where 
     " elf_ma_craynv2 = (( 172 :: nat))"

(** Renesas RX family *)
definition elf_ma_rx  :: " nat "  where 
     " elf_ma_rx = (( 173 :: nat))"

(** Imagination Technologies META processor architecture *)
definition elf_ma_metag  :: " nat "  where 
     " elf_ma_metag = (( 174 :: nat))"

(** MCST Elbrus general purpose hardware architecture *)
definition elf_ma_mcst_elbrus  :: " nat "  where 
     " elf_ma_mcst_elbrus = (( 175 :: nat))"

(** Cyan Technology eCOG16 family *)
definition elf_ma_ecog16  :: " nat "  where 
     " elf_ma_ecog16 = (( 176 :: nat))"

(** National Semiconductor CompactRISC CR16 16-bit microprocessor *)
definition elf_ma_cr16  :: " nat "  where 
     " elf_ma_cr16 = (( 177 :: nat))"

(** Freescale Extended Time Processing Unit *)
definition elf_ma_etpu  :: " nat "  where 
     " elf_ma_etpu = (( 178 :: nat))"

(** Altium TSK3000 core *)
definition elf_ma_tsk3000  :: " nat "  where 
     " elf_ma_tsk3000 = (( 131 :: nat))"

(** Freescale RS08 embedded processor *)
definition elf_ma_rs08  :: " nat "  where 
     " elf_ma_rs08 = (( 132 :: nat))"

(** Analog Devices SHARC family of 32-bit DSP processors *)
definition elf_ma_sharc  :: " nat "  where 
     " elf_ma_sharc = (( 133 :: nat))"

(** Cyan Technology eCOG2 microprocessor *)
definition elf_ma_ecog2  :: " nat "  where 
     " elf_ma_ecog2 = (( 134 :: nat))"

(** Sunplus S+core7 RISC processor *)
definition elf_ma_ccore7  :: " nat "  where 
     " elf_ma_ccore7 = (( 135 :: nat))"

(** New Japan Radio (NJR) 24-bit DSP Processor *)
definition elf_ma_dsp24  :: " nat "  where 
     " elf_ma_dsp24 = (( 136 :: nat))"

(** Broadcom VideoCore III processor *)
definition elf_ma_videocore3  :: " nat "  where 
     " elf_ma_videocore3 = (( 137 :: nat))"

(** RISC processor for Lattice FPGA architecture *)
definition elf_ma_latticemico32  :: " nat "  where 
     " elf_ma_latticemico32 = (( 138 :: nat))"

(** Seiko Epson C17 family *)
definition elf_ma_c17  :: " nat "  where 
     " elf_ma_c17 = (( 139 :: nat))"

(** The Texas Instruments TMS320C6000 DSP family *)
definition elf_ma_c6000  :: " nat "  where 
     " elf_ma_c6000 = (( 140 :: nat))"

(** The Texas Instruments TMS320C2000 DSP family *)
definition elf_ma_c2000  :: " nat "  where 
     " elf_ma_c2000 = (( 141 :: nat))"

(** The Texas Instruments TMS320C55x DSP family *)
definition elf_ma_c5500  :: " nat "  where 
     " elf_ma_c5500 = (( 142 :: nat))"

(** STMicroelectronics 64bit VLIW Data Signal Processor *)
definition elf_ma_mmdsp_plus  :: " nat "  where 
     " elf_ma_mmdsp_plus = (( 160 :: nat))"

(** LSI Logic 16-bit DSP Processor *)
definition elf_ma_zsp  :: " nat "  where 
     " elf_ma_zsp = (( 79 :: nat))"

(** Donald Knuth's educational 64-bit processor *)
definition elf_ma_mmix  :: " nat "  where 
     " elf_ma_mmix = (( 80 :: nat))"

(** Harvard University machine-independent object files *)
definition elf_ma_huany  :: " nat "  where 
     " elf_ma_huany = (( 81 :: nat))"

(** SiTera Prism *)
definition elf_ma_prism  :: " nat "  where 
     " elf_ma_prism = (( 82 :: nat))"

(** Atmel AVR 8-bit microcontroller *)
definition elf_ma_avr  :: " nat "  where 
     " elf_ma_avr = (( 83 :: nat))"

(** Fujitsu FR30 *)
definition elf_ma_fr30  :: " nat "  where 
     " elf_ma_fr30 = (( 84 :: nat))"

(** Mitsubishi D10V *)
definition elf_ma_d10v  :: " nat "  where 
     " elf_ma_d10v = (( 85 :: nat))"

(** Mitsubishi D30V *)
definition elf_ma_d30v  :: " nat "  where 
     " elf_ma_d30v = (( 86 :: nat))"

(** NEC v850 *)
definition elf_ma_v850  :: " nat "  where 
     " elf_ma_v850 = (( 87 :: nat))"

(** Mitsubishi M32R *)
definition elf_ma_m32r  :: " nat "  where 
     " elf_ma_m32r = (( 88 :: nat))"

(** Matsushita MN10300 *)
definition elf_ma_mn10300  :: " nat "  where 
     " elf_ma_mn10300 = (( 89 :: nat))"

(** Matsushita MN10200 *)
definition elf_ma_mn10200  :: " nat "  where 
     " elf_ma_mn10200 = (( 90 :: nat))"

(** picoJava *)
definition elf_ma_pj  :: " nat "  where 
     " elf_ma_pj = (( 91 :: nat))"

(** OpenRISC 32-bit embedded processor *)
definition elf_ma_openrisc  :: " nat "  where 
     " elf_ma_openrisc = (( 92 :: nat))"

(** ARC International ARCompact processor (old spelling/synonym: ELF_MA_ARC_A5) *)
definition elf_ma_arc_compact  :: " nat "  where 
     " elf_ma_arc_compact = (( 93 :: nat))"

(** Tensilica Xtensa Architecture *)
definition elf_ma_xtensa  :: " nat "  where 
     " elf_ma_xtensa = (( 94 :: nat))"

(** Alphamosaic VideoCore processor *)
definition elf_ma_videocore  :: " nat "  where 
     " elf_ma_videocore = (( 95 :: nat))"

(** Thompson Multimedia General Purpose Processor *)
definition elf_ma_tmm_gpp  :: " nat "  where 
     " elf_ma_tmm_gpp = (( 96 :: nat))"

(** National Semiconductor 32000 series *)
definition elf_ma_ns32k  :: " nat "  where 
     " elf_ma_ns32k = (( 97 :: nat))"

(** Tenor Network TPC processor *)
definition elf_ma_tpc  :: " nat "  where 
     " elf_ma_tpc = (( 98 :: nat))"

(** Trebia SNP 1000 processor *)
definition elf_ma_snp1k  :: " nat "  where 
     " elf_ma_snp1k = (( 99 :: nat))"

(** STMicroelectronics ST200 microcontroller *)
definition elf_ma_st200  :: " nat "  where 
     " elf_ma_st200 = (( 100 :: nat))"

(** Ubicom IP2xxx microcontroller family *)
definition elf_ma_ip2k  :: " nat "  where 
     " elf_ma_ip2k = (( 101 :: nat))"

(** MAX Processor *)
definition elf_ma_max  :: " nat "  where 
     " elf_ma_max = (( 102 :: nat))"

(** National Semiconductor CompactRISC microprocessor *)
definition elf_ma_cr  :: " nat "  where 
     " elf_ma_cr = (( 103 :: nat))"

(** Fujitsu F2MC16 *)
definition elf_ma_f2mc16  :: " nat "  where 
     " elf_ma_f2mc16 = (( 104 :: nat))"

(** Texas Instruments embedded microcontroller msp430 *)
definition elf_ma_msp430  :: " nat "  where 
     " elf_ma_msp430 = (( 105 :: nat))"

(** Analog Devices Blackfin (DSP) processor *)
definition elf_ma_blackfin  :: " nat "  where 
     " elf_ma_blackfin = (( 106 :: nat))"

(** S1C33 Family of Seiko Epson processors *)
definition elf_ma_se_c33  :: " nat "  where 
     " elf_ma_se_c33 = (( 107 :: nat))"

(** Sharp embedded microprocessor *)
definition elf_ma_sep  :: " nat "  where 
     " elf_ma_sep = (( 108 :: nat))"

(** Arca RISC Microprocessor *)
definition elf_ma_arca  :: " nat "  where 
     " elf_ma_arca = (( 109 :: nat))"

(** Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University *)
definition elf_ma_unicore  :: " nat "  where 
     " elf_ma_unicore = (( 110 :: nat))"

(** eXcess: 16/32/64-bit configurable embedded CPU *)
definition elf_ma_excess  :: " nat "  where 
     " elf_ma_excess = (( 111 :: nat))"

(** Icera Semiconductor Inc. Deep Execution Processor *)
definition elf_ma_dxp  :: " nat "  where 
     " elf_ma_dxp = (( 112 :: nat))"

(** Altera Nios II soft-core processor *)
definition elf_ma_altera_nios2  :: " nat "  where 
     " elf_ma_altera_nios2 = (( 113 :: nat))"

(** National Semiconductor CompactRISC CRX microprocessor *)
definition elf_ma_crx  :: " nat "  where 
     " elf_ma_crx = (( 114 :: nat))"

(** Motorola XGATE embedded processor *)
definition elf_ma_xgate  :: " nat "  where 
     " elf_ma_xgate = (( 115 :: nat))"

(** Infineon C16x/XC16x processor *)
definition elf_ma_c166  :: " nat "  where 
     " elf_ma_c166 = (( 116 :: nat))"

(** Renesas M16C series microprocessors *)
definition elf_ma_m16c  :: " nat "  where 
     " elf_ma_m16c = (( 117 :: nat))"

(** Microchip Technology dsPIC30F Digital Signal Controller *)
definition elf_ma_dspic30f  :: " nat "  where 
     " elf_ma_dspic30f = (( 118 :: nat))"

(** Freescale Communication Engine RISC core *)
definition elf_ma_ce  :: " nat "  where 
     " elf_ma_ce = (( 119 :: nat))"

(** Renesas M32C series microprocessors *)
definition elf_ma_m32c  :: " nat "  where 
     " elf_ma_m32c = (( 120 :: nat))"

(** No machine *)
definition elf_ma_none  :: " nat "  where 
     " elf_ma_none = (( 0 :: nat))"

(** AT&T WE 32100 *)
definition elf_ma_m32  :: " nat "  where 
     " elf_ma_m32 = (( 1 :: nat))"

(** SPARC *)
definition elf_ma_sparc  :: " nat "  where 
     " elf_ma_sparc = (( 2 :: nat))"

(** Intel 80386 *)
definition elf_ma_386  :: " nat "  where 
     " elf_ma_386 = (( 3 :: nat))"

(** Motorola 68000 *)
definition elf_ma_68k  :: " nat "  where 
     " elf_ma_68k = (( 4 :: nat))"

(** Motorola 88000 *)
definition elf_ma_88k  :: " nat "  where 
     " elf_ma_88k = (( 5 :: nat))"

(** Intel 80860 *)
definition elf_ma_860  :: " nat "  where 
     " elf_ma_860 = (( 7 :: nat))"

(** MIPS I Architecture *)
definition elf_ma_mips  :: " nat "  where 
     " elf_ma_mips = (( 8 :: nat))"

(** IBM System/370 Processor *)
definition elf_ma_s370  :: " nat "  where 
     " elf_ma_s370 = (( 9 :: nat))"

(** MIPS RS3000 Little-endian *)
definition elf_ma_mips_rs3_le  :: " nat "  where 
     " elf_ma_mips_rs3_le = (( 10 :: nat))"

(** Hewlett-Packard PA-RISC *)
definition elf_ma_parisc  :: " nat "  where 
     " elf_ma_parisc = (( 15 :: nat))"

(** Fujitsu VPP500 *)
definition elf_ma_vpp500  :: " nat "  where 
     " elf_ma_vpp500 = (( 17 :: nat))"

(** Enhanced instruction set SPARC *)
definition elf_ma_sparc32plus  :: " nat "  where 
     " elf_ma_sparc32plus = (( 18 :: nat))"

(** Intel 80960 *)
definition elf_ma_960  :: " nat "  where 
     " elf_ma_960 = (( 19 :: nat))"

(** PowerPC *)
definition elf_ma_ppc  :: " nat "  where 
     " elf_ma_ppc = (( 20 :: nat))"

(** 64-bit PowerPC *)
definition elf_ma_ppc64  :: " nat "  where 
     " elf_ma_ppc64 = (( 21 :: nat))"

(** IBM System/390 Processor *)
definition elf_ma_s390  :: " nat "  where 
     " elf_ma_s390 = (( 22 :: nat))"

(** IBM SPU/SPC *)
definition elf_ma_spu  :: " nat "  where 
     " elf_ma_spu = (( 23 :: nat))"

(** NEC V800 *)
definition elf_ma_v800  :: " nat "  where 
     " elf_ma_v800 = (( 36 :: nat))"

(** Fujitsu FR20 *)
definition elf_ma_fr20  :: " nat "  where 
     " elf_ma_fr20 = (( 37 :: nat))"

(** TRW RH-32 *)
definition elf_ma_rh32  :: " nat "  where 
     " elf_ma_rh32 = (( 38 :: nat))"

(** Motorola RCE *)
definition elf_ma_rce  :: " nat "  where 
     " elf_ma_rce = (( 39 :: nat))"

(** ARM 32-bit architecture (AARCH32) *)
definition elf_ma_arm  :: " nat "  where 
     " elf_ma_arm = (( 40 :: nat))"

(** Digital Alpha *)
definition elf_ma_alpha  :: " nat "  where 
     " elf_ma_alpha = (( 41 :: nat))"

(** Hitachi SH *)
definition elf_ma_sh  :: " nat "  where 
     " elf_ma_sh = (( 42 :: nat))"

(** SPARC Version 9 *)
definition elf_ma_sparcv9  :: " nat "  where 
     " elf_ma_sparcv9 = (( 43 :: nat))"

(** Siemens TriCore embedded processor *)
definition elf_ma_tricore  :: " nat "  where 
     " elf_ma_tricore = (( 44 :: nat))"

(** Argonaut RISC Core, Argonaut Technologies Inc. *)
definition elf_ma_arc  :: " nat "  where 
     " elf_ma_arc = (( 45 :: nat))"

(** Hitachi H8/300 *)
definition elf_ma_h8_300  :: " nat "  where 
     " elf_ma_h8_300 = (( 46 :: nat))"

(** Hitachi H8/300H *)
definition elf_ma_h8_300h  :: " nat "  where 
     " elf_ma_h8_300h = (( 47 :: nat))"

(** Hitachi H8S *)
definition elf_ma_h8s  :: " nat "  where 
     " elf_ma_h8s = (( 48 :: nat))"

(** Hitachi H8/500 *)
definition elf_ma_h8_500  :: " nat "  where 
     " elf_ma_h8_500 = (( 49 :: nat))"

(** Intel IA-64 processor architecture *)
definition elf_ma_ia_64  :: " nat "  where 
     " elf_ma_ia_64 = (( 50 :: nat))"

(** Stanford MIPS-X *)
definition elf_ma_mips_x  :: " nat "  where 
     " elf_ma_mips_x = (( 51 :: nat))"

(** Motorola ColdFire *)
definition elf_ma_coldfire  :: " nat "  where 
     " elf_ma_coldfire = (( 52 :: nat))"

(** Motorola M68HC12 *)
definition elf_ma_68hc12  :: " nat "  where 
     " elf_ma_68hc12 = (( 53 :: nat))"

(** Fujitsu MMA Multimedia Accelerator *)
definition elf_ma_mma  :: " nat "  where 
     " elf_ma_mma = (( 54 :: nat))"

(** Siemens PCP *)
definition elf_ma_pcp  :: " nat "  where 
     " elf_ma_pcp = (( 55 :: nat))"

(** Sony nCPU embedded RISC processor *)
definition elf_ma_ncpu  :: " nat "  where 
     " elf_ma_ncpu = (( 56 :: nat))"

(** Denso NDR1 microprocessor *)
definition elf_ma_ndr1  :: " nat "  where 
     " elf_ma_ndr1 = (( 57 :: nat))"

(** Motorola Star*Core processor *)
definition elf_ma_starcore  :: " nat "  where 
     " elf_ma_starcore = (( 58 :: nat))"

(** Toyota ME16 processor *)
definition elf_ma_me16  :: " nat "  where 
     " elf_ma_me16 = (( 59 :: nat))"

(** STMicroelectronics ST100 processor *)
definition elf_ma_st100  :: " nat "  where 
     " elf_ma_st100 = (( 60 :: nat))"

(** Advanced Logic Corp. TinyJ embedded processor family *)
definition elf_ma_tinyj  :: " nat "  where 
     " elf_ma_tinyj = (( 61 :: nat))"

(** AMD x86-64 architecture *)
definition elf_ma_x86_64  :: " nat "  where 
     " elf_ma_x86_64 = (( 62 :: nat))"

(** Sony DSP Processor *)
definition elf_ma_pdsp  :: " nat "  where 
     " elf_ma_pdsp = (( 63 :: nat))"

(** Digital Equipment Corp. PDP-10 *)
definition elf_ma_pdp10  :: " nat "  where 
     " elf_ma_pdp10 = (( 64 :: nat))"

(** Digital Equipment Corp. PDP-11 *)
definition elf_ma_pdp11  :: " nat "  where 
     " elf_ma_pdp11 = (( 65 :: nat))"

(** Siemens FX66 microcontroller *)
definition elf_ma_fx66  :: " nat "  where 
     " elf_ma_fx66 = (( 66 :: nat))"

(** STMicroelectronics ST9+ 8/16 bit microcontroller *)
definition elf_ma_st9plus  :: " nat "  where 
     " elf_ma_st9plus = (( 67 :: nat))"

(** STMicroelectronics ST7 8-bit microcontroller *)
definition elf_ma_st7  :: " nat "  where 
     " elf_ma_st7 = (( 68 :: nat))"

(** Motorola MC68HC16 Microcontroller *)
definition elf_ma_68hc16  :: " nat "  where 
     " elf_ma_68hc16 = (( 69 :: nat))"

(** Motorola MC68HC11 Microcontroller *)
definition elf_ma_68hc11  :: " nat "  where 
     " elf_ma_68hc11 = (( 70 :: nat))"

(** Motorola MC68HC08 Microcontroller *)
definition elf_ma_68hc08  :: " nat "  where 
     " elf_ma_68hc08 = (( 71 :: nat))"

(** Motorola MC68HC05 Microcontroller *)
definition elf_ma_68hc05  :: " nat "  where 
     " elf_ma_68hc05 = (( 72 :: nat))"

(** Silicon Graphics SVx *)
definition elf_ma_svx  :: " nat "  where 
     " elf_ma_svx = (( 73 :: nat))"

(** STMicroelectronics ST19 8-bit microcontroller *)
definition elf_ma_st19  :: " nat "  where 
     " elf_ma_st19 = (( 74 :: nat))"

(** Digital VAX *)
definition elf_ma_vax  :: " nat "  where 
     " elf_ma_vax = (( 75 :: nat))"

(** Axis Communications 32-bit embedded processor *)
definition elf_ma_cris  :: " nat "  where 
     " elf_ma_cris = (( 76 :: nat))"

(** Infineon Technologies 32-bit embedded processor *)
definition elf_ma_javelin  :: " nat "  where 
     " elf_ma_javelin = (( 77 :: nat))"

(** Element 14 64-bit DSP Processor *)
definition elf_ma_firepath  :: " nat "  where 
     " elf_ma_firepath = (( 78 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel209  :: " nat "  where 
     " elf_ma_intel209 = (( 209 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel208  :: " nat "  where 
     " elf_ma_intel208 = (( 208 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel207  :: " nat "  where 
     " elf_ma_intel207 = (( 207 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel206  :: " nat "  where 
     " elf_ma_intel206 = (( 206 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel205  :: " nat "  where 
     " elf_ma_intel205 = (( 205 :: nat))"

(** Reserved by Intel *)
definition elf_ma_intel182  :: " nat "  where 
     " elf_ma_intel182 = (( 182 :: nat))"

(** Reserved by ARM *)
definition elf_ma_arm184  :: " nat "  where 
     " elf_ma_arm184 = (( 184 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved6  :: " nat "  where 
     " elf_ma_reserved6 = (( 6 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved11  :: " nat "  where 
     " elf_ma_reserved11 = (( 11 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved12  :: " nat "  where 
     " elf_ma_reserved12 = (( 12 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved13  :: " nat "  where 
     " elf_ma_reserved13 = (( 13 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved14  :: " nat "  where 
     " elf_ma_reserved14 = (( 14 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved16  :: " nat "  where 
     " elf_ma_reserved16 = (( 16 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved24  :: " nat "  where 
     " elf_ma_reserved24 = (( 24 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved25  :: " nat "  where 
     " elf_ma_reserved25 = (( 25 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved26  :: " nat "  where 
     " elf_ma_reserved26 = (( 26 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved27  :: " nat "  where 
     " elf_ma_reserved27 = (( 27 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved28  :: " nat "  where 
     " elf_ma_reserved28 = (( 28 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved29  :: " nat "  where 
     " elf_ma_reserved29 = (( 29 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved30  :: " nat "  where 
     " elf_ma_reserved30 = (( 30 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved31  :: " nat "  where 
     " elf_ma_reserved31 = (( 31 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved32  :: " nat "  where 
     " elf_ma_reserved32 = (( 32 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved33  :: " nat "  where 
     " elf_ma_reserved33 = (( 33 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved34  :: " nat "  where 
     " elf_ma_reserved34 = (( 34 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved35  :: " nat "  where 
     " elf_ma_reserved35 = (( 35 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved121  :: " nat "  where 
     " elf_ma_reserved121 = (( 121 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved122  :: " nat "  where 
     " elf_ma_reserved122 = (( 122 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved123  :: " nat "  where 
     " elf_ma_reserved123 = (( 123 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved124  :: " nat "  where 
     " elf_ma_reserved124 = (( 124 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved125  :: " nat "  where 
     " elf_ma_reserved125 = (( 125 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved126  :: " nat "  where 
     " elf_ma_reserved126 = (( 126 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved127  :: " nat "  where 
     " elf_ma_reserved127 = (( 127 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved128  :: " nat "  where 
     " elf_ma_reserved128 = (( 128 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved129  :: " nat "  where 
     " elf_ma_reserved129 = (( 129 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved130  :: " nat "  where 
     " elf_ma_reserved130 = (( 130 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved143  :: " nat "  where 
     " elf_ma_reserved143 = (( 143 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved144  :: " nat "  where 
     " elf_ma_reserved144 = (( 144 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved145  :: " nat "  where 
     " elf_ma_reserved145 = (( 145 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved146  :: " nat "  where 
     " elf_ma_reserved146 = (( 146 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved147  :: " nat "  where 
     " elf_ma_reserved147 = (( 147 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved148  :: " nat "  where 
     " elf_ma_reserved148 = (( 148 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved149  :: " nat "  where 
     " elf_ma_reserved149 = (( 149 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved150  :: " nat "  where 
     " elf_ma_reserved150 = (( 150 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved151  :: " nat "  where 
     " elf_ma_reserved151 = (( 151 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved152  :: " nat "  where 
     " elf_ma_reserved152 = (( 152 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved153  :: " nat "  where 
     " elf_ma_reserved153 = (( 153 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved154  :: " nat "  where 
     " elf_ma_reserved154 = (( 154 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved155  :: " nat "  where 
     " elf_ma_reserved155 = (( 155 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved156  :: " nat "  where 
     " elf_ma_reserved156 = (( 156 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved157  :: " nat "  where 
     " elf_ma_reserved157 = (( 157 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved158  :: " nat "  where 
     " elf_ma_reserved158 = (( 158 :: nat))"

(** Reserved for future use *)
definition elf_ma_reserved159  :: " nat "  where 
     " elf_ma_reserved159 = (( 159 :: nat))"


(** [string_of_elf_machine_architecture m] produces a string representation of
  * the numeric encoding [m] of the ELF machine architecture.
  * TODO: finish this .
  *)
(*val string_of_elf_machine_architecture : natural -> string*)
definition string_of_elf_machine_architecture  :: " nat \<Rightarrow> string "  where 
     " string_of_elf_machine_architecture m = (
	if m = elf_ma_386 then
		(''Intel 80386'')
  else if m = elf_ma_ppc then
    (''PowerPC'')
  else if m = elf_ma_ppc64 then
    (''PowerPC64'')
  else if m = elf_ma_arm then
    (''AArch'')
  else if m = elf_ma_x86_64 then
    (''Advanced Micro Devices X86-64'')
  else if m = elf_ma_aarch64 then
    (''AArch64'')
	else
		(''Other architecture''))"


(** ELF version numbers.  Denotes the ELF version number of an ELF file.  Current is
  * defined to have a value of 1 with the present specification.  Extensions
  * may create versions of ELF with higher version numbers.
  *)

(** Invalid version *)
definition elf_ev_none  :: " nat "  where 
     " elf_ev_none = (( 0 :: nat))"

(** Current version *)
definition elf_ev_current  :: " nat "  where 
     " elf_ev_current = (( 1 :: nat))"


(** [string_of_elf_version_number m] produces a string representation of the
  * numeric encoding [m] of the ELF version number.
  *)
(*val string_of_elf_version_number : natural -> string*)
definition string_of_elf_version_number  :: " nat \<Rightarrow> string "  where 
     " string_of_elf_version_number m = (
	if m = elf_ev_none then
		(''Invalid ELF version'')
	else if m = elf_ev_current then
		(''1 (current)'')
	else
		(''Extended ELF version''))"


(** Check that an extended version number is correct (i.e. greater than 1). *)
definition is_valid_extended_version_number  :: " nat \<Rightarrow> bool "  where 
     " is_valid_extended_version_number (n :: nat) = ( n >( 1 :: nat))"


(** Identification indices.  The initial bytes of an ELF header (and an object
  * file) correspond to the e_ident member.
  *)

(** File identification *)
definition elf_ii_mag0  :: " nat "  where 
     " elf_ii_mag0 = (( 0 :: nat))"

(** File identification *)
definition elf_ii_mag1  :: " nat "  where 
     " elf_ii_mag1 = (( 1 :: nat))"

(** File identification *)
definition elf_ii_mag2  :: " nat "  where 
     " elf_ii_mag2 = (( 2 :: nat))"

(** File identification *)
definition elf_ii_mag3  :: " nat "  where 
     " elf_ii_mag3 = (( 3 :: nat))"

(** File class *)
definition elf_ii_class  :: " nat "  where 
     " elf_ii_class = (( 4 :: nat))"

(** Data encoding *)
definition elf_ii_data  :: " nat "  where 
     " elf_ii_data = (( 5 :: nat))"

(** File version *)
definition elf_ii_version  :: " nat "  where 
     " elf_ii_version = (( 6 :: nat))"

(** Operating system/ABI identification *)
definition elf_ii_osabi  :: " nat "  where 
     " elf_ii_osabi = (( 7 :: nat))"

(** ABI version *)
definition elf_ii_abiversion  :: " nat "  where 
     " elf_ii_abiversion = (( 8 :: nat))"

(** Start of padding bytes *)
definition elf_ii_pad  :: " nat "  where 
     " elf_ii_pad = (( 9 :: nat))"

(** Size of e*_ident[] *)
definition elf_ii_nident  :: " nat "  where 
     " elf_ii_nident = (( 16 :: nat))"


(** Magic number indices.  A file's first 4 bytes hold a ``magic number,''
  * identifying the file as an ELF object file.
  *)

(** Position: e*_ident[elf_ii_mag0], 0x7f magic number *)
definition elf_mn_mag0  :: " Elf_Types_Local.unsigned_char "  where 
     " elf_mn_mag0 = ( Elf_Types_Local.unsigned_char_of_nat(( 127 :: nat)))"

(** Position: e*_ident[elf_ii_mag1], 'E' format identifier *)
definition elf_mn_mag1  :: " Elf_Types_Local.unsigned_char "  where 
     " elf_mn_mag1 = ( Elf_Types_Local.unsigned_char_of_nat(( 69 :: nat)))"

(** Position: e*_ident[elf_ii_mag2], 'L' format identifier *)
definition elf_mn_mag2  :: " Elf_Types_Local.unsigned_char "  where 
     " elf_mn_mag2 = ( Elf_Types_Local.unsigned_char_of_nat(( 76 :: nat)))"

(** Position: e*_ident[elf_ii_mag3], 'F' format identifier *)
definition elf_mn_mag3  :: " Elf_Types_Local.unsigned_char "  where 
     " elf_mn_mag3 = ( Elf_Types_Local.unsigned_char_of_nat(( 70 :: nat)))"


(** ELf file classes.  The file format is designed to be portable among machines
  * of various sizes, without imposing the sizes of the largest machine on the
  * smallest. The class of the file defines the basic types used by the data
  * structures of the object file container itself.
  *)

(** Invalid class *)
definition elf_class_none  :: " nat "  where 
     " elf_class_none = (( 0 :: nat))"

(** 32 bit objects *)
definition elf_class_32  :: " nat "  where 
     " elf_class_32 = (( 1 :: nat))"

(** 64 bit objects *)
definition elf_class_64  :: " nat "  where 
     " elf_class_64 = (( 2 :: nat))"


(** [string_of_elf_file_class m] produces a string representation of the numeric
  * encoding [m] of the ELF file class.
  *)
(*val string_of_elf_file_class : natural -> string*)
definition string_of_elf_file_class  :: " nat \<Rightarrow> string "  where 
     " string_of_elf_file_class m = (
	if m = elf_class_none then
		(''Invalid ELF file class'')
	else if m = elf_class_32 then
		(''ELF32'')
	else if m = elf_class_64 then
		(''ELF64'')
	else
		(''Invalid ELF file class''))"


(** ELF data encodings.  Byte e_ident[elf_ei_data] specifies the encoding of both the
  * data structures used by object file container and data contained in object
  * file sections.
  *)

(** Invalid data encoding *)
definition elf_data_none  :: " nat "  where 
     " elf_data_none = (( 0 :: nat))"

(** Two's complement values, least significant byte occupying lowest address *)
definition elf_data_2lsb  :: " nat "  where 
     " elf_data_2lsb = (( 1 :: nat))"

(** Two's complement values, most significant byte occupying lowest address *)
definition elf_data_2msb  :: " nat "  where 
     " elf_data_2msb = (( 2 :: nat))"


(** [string_of_elf_data_encoding m] produces a string representation of the
  * numeric encoding [m] of the ELF data encoding.
  *)
(*val string_of_elf_data_encoding : natural -> string*)
definition string_of_elf_data_encoding  :: " nat \<Rightarrow> string "  where 
     " string_of_elf_data_encoding m = (
	if m = elf_data_none then
		(''Invalid data encoding'')
	else if m = elf_data_2lsb then
		([(CHR ''2''), (Char Nibble2 Nibble7), (CHR ''s''), (CHR '' ''), (CHR ''c''), (CHR ''o''), (CHR ''m''), (CHR ''p''), (CHR ''l''), (CHR ''e''), (CHR ''m''), (CHR ''e''), (CHR ''n''), (CHR ''t''), (CHR '',''), (CHR '' ''), (CHR ''l''), (CHR ''i''), (CHR ''t''), (CHR ''t''), (CHR ''l''), (CHR ''e''), (CHR '' ''), (CHR ''e''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''a''), (CHR ''n'')])
	else if m = elf_data_2msb then
		([(CHR ''2''), (Char Nibble2 Nibble7), (CHR ''s''), (CHR '' ''), (CHR ''c''), (CHR ''o''), (CHR ''m''), (CHR ''p''), (CHR ''l''), (CHR ''e''), (CHR ''m''), (CHR ''e''), (CHR ''n''), (CHR ''t''), (CHR '',''), (CHR '' ''), (CHR ''b''), (CHR ''i''), (CHR ''g''), (CHR '' ''), (CHR ''e''), (CHR ''n''), (CHR ''d''), (CHR ''i''), (CHR ''a''), (CHR ''n'')])
	else
		(''Invalid data encoding''))"


(** OS and ABI versions.  Byte e_ident[elf_ei_osabi] identifies the OS- or
  * ABI-specific ELF extensions used by this file. Some fields in other ELF
  * structures have flags and values that have operating system and/or ABI
  * specific meanings; the interpretation of those fields is determined by the
  * value of this byte.
  *)

(** No extensions or unspecified *)
definition elf_osabi_none  :: " nat "  where 
     " elf_osabi_none = (( 0 :: nat))"

(** Hewlett-Packard HP-UX *)
definition elf_osabi_hpux  :: " nat "  where 
     " elf_osabi_hpux = (( 1 :: nat))"

(** NetBSD *)
definition elf_osabi_netbsd  :: " nat "  where 
     " elf_osabi_netbsd = (( 2 :: nat))"

(** GNU *)
definition elf_osabi_gnu  :: " nat "  where 
     " elf_osabi_gnu = (( 3 :: nat))"

(** Linux, historical alias for GNU *)
definition elf_osabi_linux  :: " nat "  where 
     " elf_osabi_linux = (( 3 :: nat))"

(** Sun Solaris *)
definition elf_osabi_solaris  :: " nat "  where 
     " elf_osabi_solaris = (( 6 :: nat))"

(** AIX *)
definition elf_osabi_aix  :: " nat "  where 
     " elf_osabi_aix = (( 7 :: nat))"

(** IRIX *)
definition elf_osabi_irix  :: " nat "  where 
     " elf_osabi_irix = (( 8 :: nat))"

(** FreeBSD *)
definition elf_osabi_freebsd  :: " nat "  where 
     " elf_osabi_freebsd = (( 9 :: nat))"

(** Compaq Tru64 Unix *)
definition elf_osabi_tru64  :: " nat "  where 
     " elf_osabi_tru64 = (( 10 :: nat))"

(** Novell Modesto *)
definition elf_osabi_modesto  :: " nat "  where 
     " elf_osabi_modesto = (( 11 :: nat))"

(** OpenBSD *)
definition elf_osabi_openbsd  :: " nat "  where 
     " elf_osabi_openbsd = (( 12 :: nat))"

(** OpenVMS *)
definition elf_osabi_openvms  :: " nat "  where 
     " elf_osabi_openvms = (( 13 :: nat))"

(** Hewlett-Packard Non-stop Kernel *)
definition elf_osabi_nsk  :: " nat "  where 
     " elf_osabi_nsk = (( 14 :: nat))"

(** Amiga Research OS *)
definition elf_osabi_aros  :: " nat "  where 
     " elf_osabi_aros = (( 15 :: nat))"

(** FenixOS highly-scalable multi-core OS *)
definition elf_osabi_fenixos  :: " nat "  where 
     " elf_osabi_fenixos = (( 16 :: nat))"

(** Nuxi CloudABI *)
definition elf_osabi_cloudabi  :: " nat "  where 
     " elf_osabi_cloudabi = (( 17 :: nat))"

(** Stratus technologies OpenVOS *)
definition elf_osabi_openvos  :: " nat "  where 
     " elf_osabi_openvos = (( 18 :: nat))"


(** Checks an architecture defined OSABI version is correct, i.e. in the range
  * 64 to 255 inclusive.
  *)
definition is_valid_architecture_defined_osabi_version  :: " nat \<Rightarrow> bool "  where 
     " is_valid_architecture_defined_osabi_version (n :: nat) = (  
(n \<ge>( 64 :: nat)) \<and> (n \<le>( 255 :: nat)))"


(** [string_of_elf_osabi_version m] produces a string representation of the
  * numeric encoding [m] of the ELF OSABI version.
  *)
(*val string_of_elf_osabi_version : (natural -> string) -> natural -> string*)
definition string_of_elf_osabi_version  :: "(nat \<Rightarrow> string)\<Rightarrow> nat \<Rightarrow> string "  where 
     " string_of_elf_osabi_version arch m = (
	if m = elf_osabi_none then
		(''UNIX - System V'')
	else if m = elf_osabi_netbsd then
		(''Hewlett-Packard HP-UX'')
	else if m = elf_osabi_netbsd then
		(''NetBSD'')
	else if m = elf_osabi_gnu then
		(''UNIX - GNU'')
	else if m = elf_osabi_linux then
		(''Linux'')
	else if m = elf_osabi_solaris then
		(''Sun Solaris'')
	else if m = elf_osabi_aix then
		(''AIX'')
	else if m = elf_osabi_irix then
		(''IRIX'')
	else if m = elf_osabi_freebsd then
		(''FreeBSD'')
	else if m = elf_osabi_tru64 then
		(''Compaq Tru64 Unix'')
	else if m = elf_osabi_modesto then
		(''Novell Modesto'')
	else if m = elf_osabi_openbsd then
		(''OpenBSD'')
	else if m = elf_osabi_openvms then
		(''OpenVMS'')
	else if m = elf_osabi_nsk then
		(''Hewlett-Packard Non-stop Kernel'')
	else if m = elf_osabi_aros then
		(''Amiga Research OS'')
	else if m = elf_osabi_fenixos then
		(''FenixOS highly-scalable multi-core OS'')
  else if m = elf_osabi_cloudabi then
    (''Nuxi CloudABI'')
  else if m = elf_osabi_openvos then
    (''Stratus technologies OpenVOS'')
	else if is_valid_architecture_defined_osabi_version m then
	  arch m
	else
		(''Invalid OSABI version''))"


(** ELF Header type *)

(** [ei_nident] is the fixed length of the identification field in the
  * [elf32_ehdr] type.
  *)
(*val ei_nident : natural*)
definition ei_nident  :: " nat "  where 
     " ei_nident = (( 16 :: nat))"


(** [elf32_header] is the type of headers for 32-bit ELF files.
  *)
record elf32_header =
  
 elf32_ident    ::" Elf_Types_Local.unsigned_char list " (** Identification field *)
   
 elf32_type     ::" uint16 "         (** The object file type *)
   
 elf32_machine  ::" uint16 "         (** Required machine architecture *)
   
 elf32_version  ::" uint32 "         (** Object file version *)
   
 elf32_entry    ::" uint32 "         (** Virtual address for transfer of control *)
   
 elf32_phoff    ::" uint32 "          (** Program header table offset in bytes *)
   
 elf32_shoff    ::" uint32 "          (** Section header table offset in bytes *)
   
 elf32_flags    ::" uint32 "         (** Processor-specific flags *)
   
 elf32_ehsize   ::" uint16 "         (** ELF header size in bytes *)
   
 elf32_phentsize::" uint16 "         (** Program header table entry size in bytes *)
   
 elf32_phnum    ::" uint16 "         (** Number of entries in program header table *)
   
 elf32_shentsize::" uint16 "         (** Section header table entry size in bytes *)
   
 elf32_shnum    ::" uint16 "         (** Number of entries in section header table *)
   
 elf32_shstrndx ::" uint16 "         (** Section header table entry for section name string table *)
   

   
(** [elf64_header] is the type of headers for 64-bit ELF files.
  *)
record elf64_header =
  
 elf64_ident    ::" Elf_Types_Local.unsigned_char list " (** Identification field *)
   
 elf64_type     ::" uint16 "         (** The object file type *)
   
 elf64_machine  ::" uint16 "         (** Required machine architecture *)
   
 elf64_version  ::" uint32 "         (** Object file version *)
   
 elf64_entry    ::" Elf_Types_Local.uint64 "         (** Virtual address for transfer of control *)
   
 elf64_phoff    ::" uint64 "          (** Program header table offset in bytes *)
   
 elf64_shoff    ::" uint64 "          (** Section header table offset in bytes *)
   
 elf64_flags    ::" uint32 "         (** Processor-specific flags *)
   
 elf64_ehsize   ::" uint16 "         (** ELF header size in bytes *)
   
 elf64_phentsize::" uint16 "         (** Program header table entry size in bytes *)
   
 elf64_phnum    ::" uint16 "         (** Number of entries in program header table *)
   
 elf64_shentsize::" uint16 "         (** Section header table entry size in bytes *)
   
 elf64_shnum    ::" uint16 "         (** Number of entries in section header table *)
   
 elf64_shstrndx ::" uint16 "         (** Section header table entry for section name string table *)
   

   
(** [is_valid_elf32_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
(*val is_valid_elf32_header : elf32_header -> bool*)
definition is_valid_elf32_header  :: " elf32_header \<Rightarrow> bool "  where 
     " is_valid_elf32_header hdr = (
  List.take(( 4 :: nat))(elf32_ident   hdr) = [elf_mn_mag0, elf_mn_mag1, elf_mn_mag2, elf_mn_mag3])"

  
(** [is_valid_elf64_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
(*val is_valid_elf64_header : elf64_header -> bool*)
definition is_valid_elf64_header  :: " elf64_header \<Rightarrow> bool "  where 
     " is_valid_elf64_header hdr = (
  List.take(( 4 :: nat))(elf64_ident   hdr) = [elf_mn_mag0, elf_mn_mag1, elf_mn_mag2, elf_mn_mag3])"


(** [elf32_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
(*val elf32_header_compare : elf32_header -> elf32_header -> Basic_classes.ordering*)
definition elf32_header_compare  :: " elf32_header \<Rightarrow> elf32_header \<Rightarrow> ordering "  where 
     " elf32_header_compare h1 h2 = (    
 (pairCompare (lexicographicCompareBy (genericCompare (op<) (op=))) (lexicographicCompareBy (genericCompare (op<) (op=))) (List.map unat(elf32_ident   h1), [unat(elf32_type   h1), 
            unat(elf32_machine   h1) , unat(elf32_version   h1) , 
            unat(elf32_entry   h1) , unat(elf32_phoff   h1) , unat(elf32_shoff   h1) , 
            unat(elf32_flags   h1) , unat(elf32_ehsize   h1) , 
            unat(elf32_phentsize   h1), unat(elf32_phnum   h1) , 
            unat(elf32_shentsize   h1), unat(elf32_shnum   h1) , 
            unat(elf32_shstrndx   h1)])
     (List.map unat(elf32_ident   h2), [unat(elf32_type   h2), 
            unat(elf32_machine   h2) , unat(elf32_version   h2) , 
            unat(elf32_entry   h2) , unat(elf32_phoff   h2) , unat(elf32_shoff   h2) , 
            unat(elf32_flags   h2) , unat(elf32_ehsize   h2) , 
            unat(elf32_phentsize   h2), unat(elf32_phnum   h2) , 
            unat(elf32_shentsize   h2), unat(elf32_shnum   h2) , 
            unat(elf32_shstrndx   h2)])))"


definition instance_Basic_classes_Ord_Elf_header_elf32_header_dict  :: "(elf32_header)Ord_class "  where 
     " instance_Basic_classes_Ord_Elf_header_elf32_header_dict = ((|

  compare_method = elf32_header_compare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (elf32_header_compare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elf32_header_compare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (elf32_header_compare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elf32_header_compare f1 f2) ({GT, EQ})))|) )"


(** [elf64_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
(*val elf64_header_compare : elf64_header -> elf64_header -> Basic_classes.ordering*)
definition elf64_header_compare  :: " elf64_header \<Rightarrow> elf64_header \<Rightarrow> ordering "  where 
     " elf64_header_compare h1 h2 = (    
 (pairCompare (lexicographicCompareBy (genericCompare (op<) (op=))) (lexicographicCompareBy (genericCompare (op<) (op=))) (List.map unat(elf64_ident   h1), [unat(elf64_type   h1), 
            unat(elf64_machine   h1) , unat(elf64_version   h1) , 
            unat(elf64_entry   h1) , unat(elf64_phoff   h1) , unat(elf64_shoff   h1) , 
            unat(elf64_flags   h1) , unat(elf64_ehsize   h1) , 
            unat(elf64_phentsize   h1), unat(elf64_phnum   h1) , 
            unat(elf64_shentsize   h1), unat(elf64_shnum   h1) , 
            unat(elf64_shstrndx   h1)])
     (List.map unat(elf64_ident   h2), [unat(elf64_type   h2), 
            unat(elf64_machine   h2) , unat(elf64_version   h2) , 
            unat(elf64_entry   h2) , unat(elf64_phoff   h2) , unat(elf64_shoff   h2) , 
            unat(elf64_flags   h2) , unat(elf64_ehsize   h2) , 
            unat(elf64_phentsize   h2), unat(elf64_phnum   h2) , 
            unat(elf64_shentsize   h2), unat(elf64_shnum   h2) , 
            unat(elf64_shstrndx   h2)])))"


definition instance_Basic_classes_Ord_Elf_header_elf64_header_dict  :: "(elf64_header)Ord_class "  where 
     " instance_Basic_classes_Ord_Elf_header_elf64_header_dict = ((|

  compare_method = elf64_header_compare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (elf64_header_compare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elf64_header_compare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (elf64_header_compare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elf64_header_compare f1 f2) ({GT, EQ})))|) )"


(** [is_elf32_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
(*val is_elf32_executable_file : elf32_header -> bool*)
definition is_elf32_executable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_executable_file hdr = (
  unat(elf32_type   hdr) = elf_ft_exec )"


(** [is_elf64_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
(*val is_elf64_executable_file : elf64_header -> bool*)
definition is_elf64_executable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_executable_file hdr = (
  unat(elf64_type   hdr) = elf_ft_exec )"


(** [is_elf32_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
(*val is_elf32_shared_object_file : elf32_header -> bool*)
definition is_elf32_shared_object_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_shared_object_file hdr = (
  unat(elf32_type   hdr) = elf_ft_dyn )"


(** [is_elf64_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
(*val is_elf64_shared_object_file : elf64_header -> bool*)
definition is_elf64_shared_object_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_shared_object_file hdr = (
  unat(elf64_type   hdr) = elf_ft_dyn )"


(** [is_elf32_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
(*val is_elf32_relocatable_file : elf32_header -> bool*)
definition is_elf32_relocatable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_relocatable_file hdr = (
  unat(elf32_type   hdr) = elf_ft_rel )"


(** [is_elf64_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
(*val is_elf64_relocatable_file : elf64_header -> bool*)
definition is_elf64_relocatable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_relocatable_file hdr = (
  unat(elf64_type   hdr) = elf_ft_rel )"


(** [is_elf32_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
(*val is_elf32_linkable_file : elf32_header -> bool*)
definition is_elf32_linkable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_linkable_file hdr = (
  is_elf32_shared_object_file hdr \<or> is_elf32_relocatable_file hdr )"


(** [is_elf64_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
(*val is_elf64_linkable_file : elf64_header -> bool*)
definition is_elf64_linkable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_linkable_file hdr = (
  is_elf64_shared_object_file hdr \<or> is_elf64_relocatable_file hdr )"


(** [get_elf32_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf32_machine_architecture : elf32_header -> natural*)
definition get_elf32_machine_architecture  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_machine_architecture hdr = (
  unat(elf32_machine   hdr))"


(** [get_elf64_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf64_machine_architecture : elf64_header -> natural*)
definition get_elf64_machine_architecture  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_machine_architecture hdr = (
  unat(elf64_machine   hdr))"


(** [get_elf32_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf32_osabi : elf32_header -> natural*)
definition get_elf32_osabi  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_osabi hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_osabi) of
      Some osabi => unat osabi
    | None    => failwith (''get_elf32_osabi: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf64_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf64_osabi : elf64_header -> natural*)
definition get_elf64_osabi  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_osabi hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_osabi) of
      Some osabi => unat osabi
    | None    => failwith (''get_elf64_osabi: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)
  
(** [get_elf32_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
(*val get_elf32_data_encoding : elf32_header -> natural*)
definition get_elf32_data_encoding  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_data_encoding hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_data) of
      Some data => unat data
    | None    => failwith (''get_elf32_data_encoding: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf64_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
(*val get_elf64_data_encoding : elf64_header -> natural*)
definition get_elf64_data_encoding  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_data_encoding hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_data) of
      Some data => unat data
    | None    => failwith (''get_elf64_data_encoding: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)
  
(** [get_elf32_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
(*val get_elf32_file_class : elf32_header -> natural*)
definition get_elf32_file_class  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_file_class hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_class) of
      Some cls => unat cls
    | None    => failwith (''get_elf32_file_class: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf64_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
(*val get_elf64_file_class : elf64_header -> natural*)
definition get_elf64_file_class  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_file_class hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_class) of
      Some cls => unat cls
    | None    => failwith (''get_elf64_file_class: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf32_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf32_version_number : elf32_header -> natural*)
definition get_elf32_version_number  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_version_number hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_version) of
      Some ver => unat ver
    | None    => failwith (''get_elf32_version_number: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf64_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf64_version_number : elf64_header -> natural*)
definition get_elf64_version_number  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_version_number hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_version) of
      Some ver => unat ver
    | None    => failwith (''get_elf64_version_number: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)
  
(** [is_valid_elf32_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf32_header] to create a single
  * correctness check.
  *)
(*val is_valid_elf32_version_number : elf32_header -> bool*)
definition is_valid_elf32_version_numer  :: " elf32_header \<Rightarrow> bool "  where 
     " is_valid_elf32_version_numer hdr = (
  get_elf32_version_number hdr = elf_ev_current )"


(** [is_valid_elf64_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf64_header] to create a single
  * correctness check.
  *)
(*val is_valid_elf64_version_number : elf64_header -> bool*)
definition is_valid_elf64_version_numer  :: " elf64_header \<Rightarrow> bool "  where 
     " is_valid_elf64_version_numer hdr = (
  get_elf64_version_number hdr = elf_ev_current )"

  
(** [get_elf32_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf32_abi_version : elf32_header -> natural*)
definition get_elf32_abi_version  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_abi_version hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_abiversion) of
      Some ver => unat ver
    | None    => failwith (''get_elf32_abi_version: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)

(** [get_elf64_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf64_abi_version : elf64_header -> natural*)
definition get_elf64_abi_version  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_abi_version hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_abiversion) of
      Some ver => unat ver
    | None    => failwith (''get_elf64_abi_version: lookup in ident failed'')
  ))"
 (* Partial: should never return Nothing *)
  
(** [deduce_endianness uc] deduces the endianness of an ELF file based on the ELF
  * header's magic number [uc].
  *)
(*val deduce_endianness : list unsigned_char -> endianness*)
definition deduce_endianness  :: "(Elf_Types_Local.unsigned_char)list \<Rightarrow> endianness "  where 
     " deduce_endianness id2 = (
  (case  index id2(( 5 :: nat)) of
      None => failwith (''deduce_endianness: read of magic number has failed'')
    | Some v  =>
      if unat v = elf_data_2lsb then
        Little
      else if unat v = elf_data_2msb then
        Big
      else
        failwith (''deduce_endianness: value is not valid'')
  ))"


(** [get_elf32_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
(*val get_elf32_header_endianness : elf32_header -> endianness*)
definition get_elf32_header_endianness  :: " elf32_header \<Rightarrow> endianness "  where 
     " get_elf32_header_endianness hdr = (
  deduce_endianness ((elf32_ident   hdr)))"


(** [get_elf64_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
(*val get_elf64_header_endianness : elf64_header -> endianness*)
definition get_elf64_header_endianness  :: " elf64_header \<Rightarrow> endianness "  where 
     " get_elf64_header_endianness hdr = (
  deduce_endianness ((elf64_ident   hdr)))"

  
(** [has_elf32_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
(*val has_elf32_header_associated_entry_point : elf32_header -> bool*)
definition has_elf32_header_associated_entry_point  :: " elf32_header \<Rightarrow> bool "  where 
     " has_elf32_header_associated_entry_point hdr = ( \<not> ((unat(elf32_entry   hdr)) =(( 0 :: nat))))"


(** [has_elf64_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
(*val has_elf64_header_associated_entry_point : elf64_header -> bool*)
definition has_elf64_header_associated_entry_point  :: " elf64_header \<Rightarrow> bool "  where 
     " has_elf64_header_associated_entry_point hdr = ( \<not> ((unat(elf64_entry   hdr)) =(( 0 :: nat))))"

  
(** [has_elf32_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
(*val has_elf32_header_string_table : elf32_header -> bool*)
definition has_elf32_header_string_table  :: " elf32_header \<Rightarrow> bool "  where 
     " has_elf32_header_string_table hdr = ( \<not> ((unat(elf32_shstrndx   hdr)) = shn_undef))"

  
(** [has_elf64_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
(*val has_elf64_header_string_table : elf64_header -> bool*)
definition has_elf64_header_string_table  :: " elf64_header \<Rightarrow> bool "  where 
     " has_elf64_header_string_table hdr = ( \<not> ((unat(elf64_shstrndx   hdr)) = shn_undef))"

  
(** [is_elf32_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
(*val is_elf32_header_section_size_in_section_header_table : elf32_header -> bool*)
definition is_elf32_header_section_size_in_section_header_table  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_section_size_in_section_header_table hdr = (
  unat(elf32_shnum   hdr) =( 0 :: nat))"

  
(** [is_elf64_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
(*val is_elf64_header_section_size_in_section_header_table : elf64_header -> bool*)
definition is_elf64_header_section_size_in_section_header_table  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_section_size_in_section_header_table hdr = (
  unat(elf64_shnum   hdr) =( 0 :: nat))"

  
(** [is_elf32_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
(*val is_elf32_header_string_table_index_in_link : elf32_header -> bool*)
definition is_elf32_header_string_table_index_in_link  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_string_table_index_in_link hdr = (
  unat(elf32_shstrndx   hdr) = shn_xindex )"

  
(** [is_elf64_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
(*val is_elf64_header_string_table_index_in_link : elf64_header -> bool*)
definition is_elf64_header_string_table_index_in_link  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_string_table_index_in_link hdr = (
  unat(elf64_shstrndx   hdr) = shn_xindex )"


(** The [hdr_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
type_synonym hdr_print_bundle =" (nat \<Rightarrow> string) * (nat \<Rightarrow> string)"

(** [string_of_elf32_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
(*val string_of_elf32_header : hdr_print_bundle -> elf32_header -> string*)
fun string_of_elf32_header  :: "(nat \<Rightarrow> string)*(nat \<Rightarrow> string)\<Rightarrow> elf32_header \<Rightarrow> string "  where 
     " string_of_elf32_header (os, proc) hdr = (
	unlines [	  
(([(Char Nibble0 Nibble9)]) @ ((''Magic number: '') @ string_of_list 
  instance_Show_Show_Elf_types_native_uint_unsigned_char_dict(elf32_ident   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Endianness: '') @ string_of_endianness (deduce_endianness(elf32_ident   hdr))))
	, (([(Char Nibble0 Nibble9)]) @ ((''Type: '') @ string_of_elf_file_type os proc (unat(elf32_type   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Version: '') @ string_of_elf_version_number (unat(elf32_version   hdr))))
	, (([(Char Nibble0 Nibble9)]) @ ((''Machine: '') @ string_of_elf_machine_architecture (unat(elf32_machine   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entry point: '') @ Elf_Types_Local.string_of_uint32(elf32_entry   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Flags: '') @ Elf_Types_Local.string_of_uint32(elf32_flags   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entries in program header table: '') @ Elf_Types_Local.string_of_uint16(elf32_phnum   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entries in section header table: '') @ Elf_Types_Local.string_of_uint16(elf32_shnum   hdr)))
	])" 
declare string_of_elf32_header.simps [simp del]


(** [string_of_elf64_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
(*val string_of_elf64_header : hdr_print_bundle -> elf64_header -> string*)
fun string_of_elf64_header  :: "(nat \<Rightarrow> string)*(nat \<Rightarrow> string)\<Rightarrow> elf64_header \<Rightarrow> string "  where 
     " string_of_elf64_header (os, proc) hdr = (
  unlines [    
(([(Char Nibble0 Nibble9)]) @ ((''Magic number: '') @ string_of_list 
  instance_Show_Show_Elf_types_native_uint_unsigned_char_dict(elf64_ident   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Endianness: '') @ string_of_endianness (deduce_endianness(elf64_ident   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Type: '') @ string_of_elf_file_type os proc (unat(elf64_type   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Version: '') @ string_of_elf_version_number (unat(elf64_version   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Machine: '') @ string_of_elf_machine_architecture (unat(elf64_machine   hdr))))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entry point: '') @ Elf_Types_Local.string_of_uint64(elf64_entry   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Flags: '') @ Elf_Types_Local.string_of_uint32(elf64_flags   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entries in program header table: '') @ Elf_Types_Local.string_of_uint16(elf64_phnum   hdr)))
  , (([(Char Nibble0 Nibble9)]) @ ((''Entries in section header table: '') @ Elf_Types_Local.string_of_uint16(elf64_shnum   hdr)))
  ])" 
declare string_of_elf64_header.simps [simp del]


(** The following are thin wrappers around the pretty-printing functions above
  * using a default print bundle for the header.
  *)
  
(*val string_of_elf32_header_default : elf32_header -> string*)
definition string_of_elf32_header_default  :: " elf32_header \<Rightarrow> string "  where 
     " string_of_elf32_header_default = (
	string_of_elf32_header
    (default_os_specific_print,
      default_proc_specific_print))"


(*val string_of_elf64_header_default : elf64_header -> string*)
definition string_of_elf64_header_default  :: " elf64_header \<Rightarrow> string "  where 
     " string_of_elf64_header_default = (
  string_of_elf64_header
    (default_os_specific_print,
      default_proc_specific_print))"

	
definition instance_Show_Show_Elf_header_elf32_header_dict  :: "(elf32_header)Show_class "  where 
     " instance_Show_Show_Elf_header_elf32_header_dict = ((|

  show_method = string_of_elf32_header_default |) )"


definition instance_Show_Show_Elf_header_elf64_header_dict  :: "(elf64_header)Show_class "  where 
     " instance_Show_Show_Elf_header_elf64_header_dict = ((|

  show_method = string_of_elf64_header_default |) )"


(** [read_elf_ident bs0] reads the initial bytes of an ELF file from byte sequence
  * [bs0], returning the remainder of the byte sequence too.
  * Fails if transcription fails.
  *)
(*val read_elf_ident : byte_sequence -> error (list unsigned_char * byte_sequence)*)
definition read_elf_ident  :: " byte_sequence \<Rightarrow>((Elf_Types_Local.unsigned_char)list*byte_sequence)error " 
 where 
     " read_elf_ident bs
 = ( repeatM' ei_nident bs (read_unsigned_char default_endianness))"


(** [bytes_of_elf32_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
(*val bytes_of_elf32_header : elf32_header -> byte_sequence*)
definition bytes_of_elf32_header  :: " elf32_header \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf32_header hdr = (
  (let endian = (deduce_endianness(elf32_ident   hdr)) in
    Byte_sequence.from_byte_lists [
      List.map id(elf32_ident   hdr)
    , bytes_of_elf32_half endian(elf32_type   hdr)
    , bytes_of_elf32_half endian(elf32_machine   hdr)
    , bytes_of_elf32_word endian(elf32_version   hdr)
    , bytes_of_elf32_addr endian(elf32_entry   hdr)
    , bytes_of_elf32_off  endian(elf32_phoff   hdr)
    , bytes_of_elf32_off  endian(elf32_shoff   hdr)
    , bytes_of_elf32_word endian(elf32_flags   hdr)
    , bytes_of_elf32_half endian(elf32_ehsize   hdr)
    , bytes_of_elf32_half endian(elf32_phentsize   hdr)
    , bytes_of_elf32_half endian(elf32_phnum   hdr)
    , bytes_of_elf32_half endian(elf32_shentsize   hdr)
    , bytes_of_elf32_half endian(elf32_shnum   hdr)
    , bytes_of_elf32_half endian(elf32_shstrndx   hdr)
    ]))"

    
(** [bytes_of_elf64_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
(*val bytes_of_elf64_header : elf64_header -> byte_sequence*)
definition bytes_of_elf64_header  :: " elf64_header \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf64_header hdr = (
  (let endian = (deduce_endianness(elf64_ident   hdr)) in
    Byte_sequence.from_byte_lists [
      List.map id(elf64_ident   hdr)
    , bytes_of_elf64_half endian(elf64_type   hdr)
    , bytes_of_elf64_half endian(elf64_machine   hdr)
    , bytes_of_elf64_word endian(elf64_version   hdr)
    , bytes_of_elf64_addr endian(elf64_entry   hdr)
    , bytes_of_elf64_off  endian(elf64_phoff   hdr)
    , bytes_of_elf64_off  endian(elf64_shoff   hdr)
    , bytes_of_elf64_word endian(elf64_flags   hdr)
    , bytes_of_elf64_half endian(elf64_ehsize   hdr)
    , bytes_of_elf64_half endian(elf64_phentsize   hdr)
    , bytes_of_elf64_half endian(elf64_phnum   hdr)
    , bytes_of_elf64_half endian(elf64_shentsize   hdr)
    , bytes_of_elf64_half endian(elf64_shnum   hdr)
    , bytes_of_elf64_half endian(elf64_shstrndx   hdr)
    ]))"

    
(*val is_elf32_header_padding_correct : elf32_header -> bool*)
definition is_elf32_header_padding_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_padding_correct ehdr = (  
(index(elf32_ident   ehdr)(( 9 :: nat))  = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 10 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 11 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 12 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 13 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 14 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>  
(index(elf32_ident   ehdr)(( 15 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat))))))))))"


(*val is_magic_number_correct : list unsigned_char -> bool*)
definition is_magic_number_correct  :: "(Elf_Types_Local.unsigned_char)list \<Rightarrow> bool "  where 
     " is_magic_number_correct ident = (  
(index ident(( 0 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 127 :: nat)))) \<and>
  ((index ident(( 1 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 69 :: nat))))  \<and>
  ((index ident(( 2 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 76 :: nat))))  \<and>  
(index ident(( 3 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 70 :: nat)))))))"


(** [read_elf32_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
(*val read_elf32_header : byte_sequence -> error (elf32_header * byte_sequence)*)
definition read_elf32_header  :: " byte_sequence \<Rightarrow>(elf32_header*byte_sequence)error "  where 
     " read_elf32_header bs = (
	read_elf_ident bs >>= (\<lambda> (ident, bs) . 
	if \<not> (is_magic_number_correct ident) then
	  error_fail (''read_elf32_header: magic number incorrect'')
	else
    (let endian = (deduce_endianness ident) in
	  read_elf32_half endian bs >>= (\<lambda> (typ1, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (machine, bs) . 
	  read_elf32_word endian bs >>= (\<lambda> (version, bs) . 
	  read_elf32_addr endian bs >>= (\<lambda> (entry, bs) . 
	  read_elf32_off  endian bs >>= (\<lambda> (phoff, bs) . 
	  read_elf32_off  endian bs >>= (\<lambda> (shoff, bs) . 
	  read_elf32_word endian bs >>= (\<lambda> (flags, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (ehsize, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (phentsize, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (phnum, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (shentsize, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (shnum, bs) . 
	  read_elf32_half endian bs >>= (\<lambda> (shstrndx, bs) . 
    (case  index ident(( 4 :: nat)) of
        None => error_fail (''read_elf32_header: transcription of ELF identifier failed'')
      | Some c  =>
        if unat c = elf_class_32 then
		      error_return ((| elf32_ident = ident, elf32_type  = typ1,
                      elf32_machine = machine, elf32_version = version,
                      elf32_entry = entry, elf32_phoff = phoff,
                      elf32_shoff = shoff, elf32_flags = flags,
                      elf32_ehsize = ehsize, elf32_phentsize = phentsize,
                      elf32_phnum = phnum, elf32_shentsize = shentsize,
                      elf32_shnum = shnum, elf32_shstrndx = shstrndx |), bs)
        else
          error_fail (''read_elf32_header: not a 32-bit ELF file'')
    )))))))))))))))))"


(** [read_elf64_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
(*val read_elf64_header : byte_sequence -> error (elf64_header * byte_sequence)*)
definition read_elf64_header  :: " byte_sequence \<Rightarrow>(elf64_header*byte_sequence)error "  where 
     " read_elf64_header bs = (
  read_elf_ident bs >>= (\<lambda> (ident, bs) . 
  if \<not> (is_magic_number_correct ident) then
    error_fail (''read_elf64_header: magic number incorrect'')
  else
    (let endian = (deduce_endianness ident) in
    read_elf64_half endian bs >>= (\<lambda> (typ1, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (machine, bs) . 
    read_elf64_word endian bs >>= (\<lambda> (version, bs) . 
    read_elf64_addr endian bs >>= (\<lambda> (entry, bs) . 
    read_elf64_off  endian bs >>= (\<lambda> (phoff, bs) . 
    read_elf64_off  endian bs >>= (\<lambda> (shoff, bs) . 
    read_elf64_word endian bs >>= (\<lambda> (flags, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (ehsize, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (phentsize, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (phnum, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (shentsize, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (shnum, bs) . 
    read_elf64_half endian bs >>= (\<lambda> (shstrndx, bs) . 
    (case  index ident(( 4 :: nat)) of
        None => error_fail (''read_elf64_header: transcription of ELF identifier failed'')
      | Some c  =>
        if unat c = elf_class_64 then
          error_return ((| elf64_ident = ident, elf64_type  = typ1,
                     elf64_machine = machine, elf64_version = version,
                     elf64_entry = entry, elf64_phoff = phoff,
                     elf64_shoff = shoff, elf64_flags = flags,
                     elf64_ehsize = ehsize, elf64_phentsize = phentsize,
                     elf64_phnum = phnum, elf64_shentsize = shentsize,
                     elf64_shnum = shnum, elf64_shstrndx = shstrndx |), bs)
        else
          error_fail (''read_elf64_header: not a 64-bit ELF file'')
    )))))))))))))))))"


(** [is_elf32_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
(*val is_elf32_header_class_correct : elf32_header -> bool*)
definition is_elf32_header_class_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_class_correct ehdr = (
  index(elf32_ident   ehdr)(( 4 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"

  
(** [is_elf64_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
(*val is_elf64_header_class_correct : elf64_header -> bool*)
definition is_elf64_header_class_correct  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_class_correct ehdr = (
  index(elf64_ident   ehdr)(( 4 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"


(** [is_elf32_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
(*val is_elf32_header_version_correct : elf32_header -> bool*)
definition is_elf32_header_version_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_version_correct ehdr = (
  index(elf32_ident   ehdr)(( 6 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"

  
(** [is_elf64_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
(*val is_elf64_header_version_correct : elf64_header -> bool*)
definition is_elf64_header_version_correct  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_version_correct ehdr = (
  index(elf64_ident   ehdr)(( 6 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"


(** [is_elf32_header_valid] checks whether an [elf32_header] value is a valid 32-bit
  * ELF file header (i.e. [elf32_ident] is [ei_nident] entries long, and other
  * constraints on headers).
  *)
(*val is_elf32_header_valid : elf32_header -> bool*)
definition is_elf32_header_valid  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_valid ehdr = (  
( (List.length(elf32_ident   ehdr)) = ei_nident) \<and>  
(is_magic_number_correct(elf32_ident   ehdr) \<and>  
(is_elf32_header_padding_correct ehdr \<and>  
(is_elf32_header_class_correct ehdr \<and>
  is_elf32_header_version_correct ehdr))))"


(** [get_elf32_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_program_table_size : elf32_header -> natural*)
definition get_elf32_header_program_table_size  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_header_program_table_size ehdr = (
  (let phentsize = (unat(elf32_phentsize   ehdr)) in
  (let phnum     = (unat(elf32_phnum   ehdr)) in
    phentsize * phnum)))"


(** [get_elf64_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_program_table_size : elf64_header -> natural*)
definition get_elf64_header_program_table_size  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_header_program_table_size ehdr = (
  (let phentsize = (unat(elf64_phentsize   ehdr)) in
  (let phnum     = (unat(elf64_phnum   ehdr)) in
    phentsize * phnum)))"


(** [is_elf32_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf32_header_section_table_present : elf32_header -> bool*)
definition is_elf32_header_section_table_present  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_section_table_present ehdr = (
  \<not> (unat(elf32_shoff   ehdr) =( 0 :: nat)))"


(** [is_elf64_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf64_header_section_table_present : elf64_header -> bool*)
definition is_elf64_header_section_table_present  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_section_table_present ehdr = (
  \<not> (unat(elf64_shoff   ehdr) =( 0 :: nat)))"


(** [get_elf32_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_section_table_size : elf32_header -> natural*)
definition get_elf32_header_section_table_size  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_header_section_table_size ehdr = (
  (let shentsize = (unat(elf32_shentsize   ehdr)) in
  (let shnum     = (unat(elf32_shnum   ehdr)) in
    shentsize * shnum)))"


(** [get_elf64_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_section_table_size : elf64_header -> natural*)
definition get_elf64_header_section_table_size  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_header_section_table_size ehdr = (
  (let shentsize = (unat(elf64_shentsize   ehdr)) in
  (let shnum     = (unat(elf64_shnum   ehdr)) in
    shentsize * shnum)))"

end
