chapter {* Generated by Lem from memory_image.lem. *}

theory "Memory_image" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set_extra" 
	 "Missing_pervasives" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_file" 
	 "Elf_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map_extra" 
	 "Multimap" 
	 "GCD" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*import Map_extra*)
(*open import Set*)
(*open import Set_extra*)
(*open import Multimap*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Show*)

(*open import Byte_sequence*)
(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)

(*open import Missing_pervasives*)

(*open import {isabelle} `GCD`*)

(* Now we can define memory images *)

type_synonym byte_pattern_element ="  Elf_Types_Local.byte option "
type_synonym byte_pattern =" byte_pattern_element list "

(* An element might have an address/offset, and it has some contents. *)
record element = 
 startpos ::"  nat option " 
                
 length1   ::"  nat option "
                
 contents ::" byte_pattern "
                


(* HMM -- ideally I want to fold these into the memory image notion
 * and the startpos thingy. *)
type_synonym allocated_symbols_map =" (string, (nat * nat)) Map.map " (* start, length *)

(* Instead of modelling address calculations (in linker scripts) like so:

type address_expr = natural -> allocated_symbols_map -> natural
                  ( pos     -> environment           -> result address )
                  
   ... we model it as expressions in terms of CursorPosition. HMM.
*) 

datatype expr_operand = Var " string "
                   | CursorPosition          (* only valid in certain expressions... HMM *)
                   | Constant " nat "
                   | UnOp " (expr_unary_operation * expr_operand)"
                   | BinOp " (expr_binary_operation * expr_operand * expr_operand)"
and
expr_unary_operation = Neg " expr_operand "
                           | BitwiseInverse " expr_operand "
and 
expr_binary_operation = Add " (expr_operand * expr_operand)"
                           | Sub " (expr_operand * expr_operand)"
                           | BitwiseAnd " (expr_operand * expr_operand)"
                           | BitwiseOr " (expr_operand * expr_operand)"

datatype expr_binary_relation = 
    Lt
    | Lte
    | Gt
    | Gte
    | Eq
    | Neq

datatype expr = 
    False0
    | True0
    | Not " expr "
    | And " (expr * expr)"
    | Or " (expr * expr)"
    | BinRel " (expr_binary_relation * expr_operand)"  (* LH operand is the expr's value *)

(*
val cond_expr : expr -> expr -> expr -> expr
let cond_expr expr1 expr2 expr3 = (Or((And(expr1, expr2)), (And((Not(expr1)), expr3))))
*)

(* Memory image elements all have identities. For convenience
 * we make the identities strings. The string contents are arbitrary,
 * and only their equality is relevant, but choosing friendly names
 * like ELF header is good practice.*)
type_synonym memory_image =" (string, element) Map.map "

type_synonym range =" nat * nat " (* start, length *)

type_synonym element_range =" string * range "

(* An element of an ELF image, in the linking phase, is either a section,
 * the ELF header, the section header table or the program header table.
 * 
 * PROBLEM: We'd like to use section names as the identifiers
 * for those elements that are sections.
 * but we can't, because they are not guaranteed to be unique. 
 * 
 * SOLUTION: Names that are unique in the file are used as keys. 
 * If not unique, the sections are treated as anonymous and given
 * gensym'd string ids (FIXME: implement this).
 *)

(* Currently, our elements have unique names, which are strings.
 * We *don't* want to encode any meaning onto these strings.
 * All meaning should be encoded into labelled ranges.
 * We want to be able to look up 
 *
 * - elements
 * - ranges within elements
 * 
 * ... by their *labels* -- or sometimes just *part* of their labels.
 *)

(* ELF file features with which we can label ranges of the memory image. *)
datatype elf_file_feature = 
    ElfHeader " elf64_header "
    | ElfSectionHeaderTable " elf64_section_header_table " (* do we want to expand these? *)
    | ElfProgramHeaderTable " elf64_program_header_table "
    | ElfSection " (nat * elf64_interpreted_section)" (* SHT idx *)
    | ElfSegment " (nat * elf64_interpreted_segment)" (* PHT idx *)

record symbol_definition
 = 
 def_symname ::" string "
    
 def_syment ::" elf64_symbol_table_entry " (* definition's symtab entry *)
    
 def_sym_scn ::" nat "                 (* symtab section index, to disamiguate dynsym *)
    
 def_sym_idx ::" nat "                 (* index of symbol into the symtab *)
    
 def_linkable_idx ::" nat "            (* used to propagate origin linkable information to linked image *)
    


definition symDefCompare  :: " symbol_definition \<Rightarrow> symbol_definition \<Rightarrow> ordering "  where 
     " symDefCompare x1 x2 = (        
(quintupleCompare (\<lambda> x y. EQ) elf64_symbol_table_entry_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((def_symname   x1),(def_syment   x1),(def_sym_scn   x1),(def_sym_idx   x1),(def_linkable_idx   x1))
                ((def_symname   x2),(def_syment   x2),(def_sym_scn   x2),(def_sym_idx   x2),(def_linkable_idx   x2))))"


definition instance_Basic_classes_Ord_Memory_image_symbol_definition_dict  :: "(symbol_definition)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_definition_dict = ((|

  compare_method = symDefCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symDefCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symDefCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symDefCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symDefCompare f1 f2) ({GT, EQ})))|) )"


record symbol_reference
 = 
 ref_symname ::" string "                  (* symbol name *)
    
 ref_syment ::" elf64_symbol_table_entry " (* likely-undefined (referencing) symbol *)
    
 ref_sym_scn ::" nat "                 (* symtab section idx *) 
    
 ref_sym_idx ::" nat "                 (* index into symbol table *)
    


definition symRefCompare  :: " symbol_reference \<Rightarrow> symbol_reference \<Rightarrow> ordering "  where 
     " symRefCompare x1 x2 = (        
(quadrupleCompare (\<lambda> x y. EQ) elf64_symbol_table_entry_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((ref_symname   x1),(ref_syment   x1),(ref_sym_scn   x1),(ref_sym_idx   x1))
                ((ref_symname   x2),(ref_syment   x2),(ref_sym_scn   x2),(ref_sym_idx   x2))))"

                
definition instance_Basic_classes_Ord_Memory_image_symbol_reference_dict  :: "(symbol_reference)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_reference_dict = ((|

  compare_method = symRefCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefCompare f1 f2) ({GT, EQ})))|) )"


record reloc_site = 

      ref_relent  ::" elf64_relocation_a " 
    
 ref_rel_scn ::" nat "  (* the relocation section idx *)
    
 ref_rel_idx ::" nat "  (* the index of the relocation rec *)
    
 ref_src_scn ::" nat "  (* the section *from which* the reference logically comes *)



definition relocSiteCompare  :: " reloc_site \<Rightarrow> reloc_site \<Rightarrow> ordering "  where 
     " relocSiteCompare x1 x2 = (        
(quadrupleCompare elf64_relocation_a_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((ref_relent   x1),(ref_rel_scn   x1),(ref_rel_idx   x1),(ref_src_scn   x1))
                ((ref_relent   x2),(ref_rel_scn   x2),(ref_rel_idx   x2),(ref_src_scn   x2))))"

                
definition instance_Basic_classes_Ord_Memory_image_reloc_site_dict  :: "(reloc_site)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_reloc_site_dict = ((|

  compare_method = relocSiteCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocSiteCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocSiteCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocSiteCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocSiteCompare f1 f2) ({GT, EQ})))|) )"

    
datatype reloc_decision = LeaveReloc
                    | ApplyReloc
                    | ChangeRelocTo " (nat * symbol_reference * reloc_site)"
                    (* | MakePIC    -- is now a kind of ChangeRelocTo *)

fun relocDecisionCompare  :: " reloc_decision \<Rightarrow> reloc_decision \<Rightarrow> ordering "  where 
     " relocDecisionCompare LeaveReloc LeaveReloc = ( EQ )"
|" relocDecisionCompare LeaveReloc _ = ( LT )"
|" relocDecisionCompare ApplyReloc ApplyReloc = ( EQ )"
|" relocDecisionCompare ApplyReloc (ChangeRelocTo _) = ( LT )"
|" relocDecisionCompare ApplyReloc LeaveReloc = ( GT )"
|" relocDecisionCompare (ChangeRelocTo t1) (ChangeRelocTo t2) = ( (tripleCompare (genericCompare (op<) (op=)) symRefCompare relocSiteCompare t1 t2))"
|" relocDecisionCompare (ChangeRelocTo _) _ = ( GT )" 
declare relocDecisionCompare.simps [simp del]


definition instance_Basic_classes_Ord_Memory_image_reloc_decision_dict  :: "(reloc_decision)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_reloc_decision_dict = ((|

  compare_method = relocDecisionCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocDecisionCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocDecisionCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocDecisionCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocDecisionCompare f1 f2) ({GT, EQ})))|) )"


record symbol_reference_and_reloc_site = 

      ref         ::" symbol_reference "
    
 maybe_reloc ::"  reloc_site option "
    
 maybe_def_bound_to ::"  (reloc_decision *  symbol_definition option)option "
    


definition symRefAndRelocSiteCompare  :: " symbol_reference_and_reloc_site \<Rightarrow> symbol_reference_and_reloc_site \<Rightarrow> ordering "  where 
     " symRefAndRelocSiteCompare x1 x2 = (        
(tripleCompare symRefCompare (maybeCompare relocSiteCompare) (maybeCompare (pairCompare relocDecisionCompare (maybeCompare symDefCompare))) ((ref   x1),(maybe_reloc   x1),(maybe_def_bound_to   x1))
                ((ref   x2),(maybe_reloc   x2),(maybe_def_bound_to   x2))))"


definition instance_Basic_classes_Ord_Memory_image_symbol_reference_and_reloc_site_dict  :: "(symbol_reference_and_reloc_site)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_reference_and_reloc_site_dict = ((|

  compare_method = symRefAndRelocSiteCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefAndRelocSiteCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefAndRelocSiteCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefAndRelocSiteCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefAndRelocSiteCompare f1 f2) ({GT, EQ})))|) )"


(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella ELF type to the relevant types in each case? *)
datatype 'abifeature range_tag = (*  forall 'abifeature . *)
                 ImageBase
               | EntryPoint
               | SymbolDef " symbol_definition "
               | SymbolRef " symbol_reference_and_reloc_site "
               | FileFeature " elf_file_feature " (* file feature other than symdef and reloc *)
               | AbiFeature " 'abifeature "

record 'abifeature annotated_memory_image = 

      elements         ::" memory_image " 
    
 by_range         ::" (( element_range option) * ( 'abifeature range_tag)) set "
    
 by_tag           ::" (( 'abifeature range_tag), ( element_range option)) multimap "



(*val get_empty_memory_image : forall 'abifeature. unit -> annotated_memory_image 'abifeature*)
definition get_empty_memory_image  :: " unit \<Rightarrow> 'abifeature annotated_memory_image "  where 
     " get_empty_memory_image = ( \<lambda> _ .  (| 
      elements = Map.empty
    , by_range = {}
    , by_tag   = {}
|) )"


(* Basic ELFy and ABI-y things. *)
(* Special sections are those that necessarily require special treatment by the 
 * linker. Examples include symbol tables and relocation tables. There are some
 * grey areas, such as .eh_frame, debug info, and string tables. For us, the rule
 * is that if we have special code to create them, i.e. that we don't rely on
 * ordinary section concatenation during the linker script interpretation, they
 * should be special -- it means strip_metadata_sections will remove them from
 * the image, they won't be seen by the linker script, and that it's *our* job
 * to reinstate them afterwards (as we do with symtab and strtab, for example). *)
(* FIXME: this shouldn't really be here, but needs to be in some low-lying module;
 * keeping it out of elf_* for now to avoid duplication into elf64_, elf32_. *)
definition elf_section_is_special  :: " elf64_interpreted_section \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " elf_section_is_special s f = ( \<not> ((elf64_section_type   s) = sht_progbits)
                     \<and> (\<not> ((elf64_section_type   s) = sht_nobits)
                     \<and> (\<not> ((elf64_section_type   s) = sht_fini_array)
                     \<and> \<not> ((elf64_section_type   s) = sht_init_array))))"


(* This record collects things that ABIs may or must define. 
 * 
 * Since we want to put all ABIs in a list and select one at run time, 
 * we can't maintain a type-level distinction between ABIs; we have to
 * use elf_memory_image any_abi_feature. To avoid a reference cycle,
 * stay polymorphic in the ABI feature type until we define specific ABIs.
 * In practice we'll use only any_abi_feature, because we need to pull
 * the ABI out of a list at run time.
 *)
type_synonym null_abi_feature =" unit "

(* The reloc calculation is complicated, so we split up the big function
 * type into smaller ones. *)

(* Q. Do we want existing, or is it a kind of addend? 
 * A. We do want it -- modelling both separately is necessary, 
 * because we model relocations bytewise, but some arches
 * do bitfield relocations (think ARM). *)
type_synonym reloc_calculate_fn    =" nat \<Rightarrow> int \<Rightarrow> nat \<Rightarrow> nat " (* symaddr -> addend -> existing -> relocated *)

type_synonym 'abifeature reloc_apply_fn =" 'abifeature 
                                (* elf memory image: the context in which the relocation is being applied *)
                                annotated_memory_image \<Rightarrow>
                               (* the site address *)
                                nat \<Rightarrow>
                                (* Typically there are two symbol table entries involved in a relocation.
                                 * One is the reference, and is usually undefined.
                                 * The other is the definition, and is defined (else absent, when we use 0).
                                 * However, sometimes the reference is itself a defined symbol.
                                 * Almost always, if so, *that* symbol *is* the definition.
                                 * However, copy relocs are an exception.
                                 * 
                                 * In the case of copy relocations being fixed up by the dynamic
                                 * linker, the dynamic linker must figure out which definition to
                                 * copy from. This can't be as simple as the first definition in
                                 * link order, because *our* copy of that symbol is a definition
                                 * (typically in bss). It could be as simple as the first *after us*
                                 * in link order. FIXME: find the glibc code that does this.
                                 * 
                                 * Can we dig this stuff out of the memory image? If we pass the address
                                 * being relocated, we can find the tags. But I don't want to pass
                                 * the symbol address until the very end. It seems better to pass the symbol
                                 * name, since that's the key that the dynamic linker uses to look for
                                 * other definitions.
                                 * 
                                 * Do we want to pass a whole symbol_reference? This has not only the
                                 * symbol name but also syment, scn and idx. The syment is usually UND, 
                                 * but *could* be defined (and is for copy relocs). The scn and idx are
                                 * not relevant, but it seems cleaner to pass the whole thing anyway.
                                 *)
                                symbol_reference_and_reloc_site \<Rightarrow> 
                                (* Should we pass a symbol_definition too? Implicitly, we pass part of it
                                 * by passing the symaddr argument (below). I'd prefer not to depend on
                                 * others -- relocation calculations should look like mostly address 
                                 * arithmetic, i.e. only the weird ones do something else. *)
                                 (* How wide, in bytes, is the relocated field? this may depend on img 
                                 * and on the wider image (copy relocs), so it's returned *by* the reloc function. *)
                                (nat (* width *) * reloc_calculate_fn)"

(* Some kinds of relocation necessarily give us back a R_*_RELATIVE reloc.
 * We don't record this explicitly. Instead, the bool is a flag recording whether
 * the field represents an absolute address.
 * Similarly, some relocations can fail according to their ABI manuals.
 * This just means that the result can't be represented in the field width.
 * We detect this when actually applying the reloc in the memory image content
 * (done elsewhere). *)
type_synonym 'abifeature reloc_fn =" nat \<Rightarrow> (bool * 'abifeature reloc_apply_fn)"

(*val noop_reloc_calculate : natural -> integer -> natural -> natural*)
definition noop_reloc_calculate  :: " nat \<Rightarrow> int \<Rightarrow> nat \<Rightarrow> nat "  where 
     " noop_reloc_calculate symaddr addend existing = ( existing )"


(*val noop_reloc_apply : forall 'abifeature. reloc_apply_fn 'abifeature*)
definition noop_reloc_apply  :: " 'abifeature annotated_memory_image \<Rightarrow> nat \<Rightarrow> symbol_reference_and_reloc_site \<Rightarrow> nat*(nat \<Rightarrow> int \<Rightarrow> nat \<Rightarrow> nat)"  where 
     " noop_reloc_apply img3 site_addr ref1 = ( (( 0 :: nat), noop_reloc_calculate))"


(*val noop_reloc : forall 'abifeature. natural -> (bool (* result is absolute addr *) * reloc_apply_fn 'abifeature)*)
definition noop_reloc  :: " nat \<Rightarrow> bool*('abifeature annotated_memory_image \<Rightarrow> nat \<Rightarrow> symbol_reference_and_reloc_site \<Rightarrow> nat*reloc_calculate_fn)"  where 
     " noop_reloc k = ( (False, noop_reloc_apply))"


record 'abifeature abi = (* forall 'abifeature. *)
   
 is_valid_elf_header ::" elf64_header \<Rightarrow> bool " (* doesn't this generalise outrageously? is_valid_elf_file? *)
    
 make_elf_header    ::" nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> elf64_header "
                           (* t entry shoff phoff phnum shnum shstrndx *)
    
 reloc              ::" 'abifeature reloc_fn "
    
 section_is_special ::" elf64_interpreted_section \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> bool "
    
 section_is_large   ::" elf64_interpreted_section \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> bool "
    
 maxpagesize        ::" nat "
    
 minpagesize        ::" nat "
    
 commonpagesize     ::" nat "
    
 symbol_is_generated_by_linker ::" string \<Rightarrow> bool "
    (*; link_inputs_tap    : 
    ; link_output_sections_tap   : 
    ; link_output_image_tap      : *)
    
 make_phdrs         ::" nat \<Rightarrow> nat \<Rightarrow> nat (* file type *) \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> elf64_interpreted_section list \<Rightarrow> elf64_program_header_table_entry list "
    
 max_phnum          ::" nat "
    
 guess_entry_point  ::" 'abifeature annotated_memory_image \<Rightarrow>  nat option "
    
 pad_data           ::" nat \<Rightarrow> Elf_Types_Local.byte list "
    
 pad_code           ::" nat \<Rightarrow> Elf_Types_Local.byte list "
    
 generate_support   ::" (string * 'abifeature annotated_memory_image) (* list (list reloc_site_resolution) ->  *)list \<Rightarrow> 'abifeature annotated_memory_image "
    
 concretise_support ::" 'abifeature annotated_memory_image \<Rightarrow> 'abifeature annotated_memory_image "
    
 get_reloc_symaddr  ::" symbol_definition \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>  reloc_site option \<Rightarrow> nat "
    


(*val align_up_to : natural -> natural -> natural*)
definition align_up_to  :: " nat \<Rightarrow> nat \<Rightarrow> nat "  where 
     " align_up_to align addr = ( 
    (let quot = (addr div align)
    in
    if (quot * align) = addr then addr else (quot +( 1 :: nat)) * align))"


(*val round_down_to : natural -> natural -> natural*)
definition round_down_to  :: " nat \<Rightarrow> nat \<Rightarrow> nat "  where 
     " round_down_to align addr = ( 
    (let quot = (addr div align)
    in
    quot * align))"


(*val uint32_max : natural*)
definition uint32_max  :: " nat "  where 
     " uint32_max = ( (( 2 :: nat) ^( 32 :: nat)) -( 1 :: nat))"


(*val uint64_max : natural*)
definition uint64_max  :: " nat "  where 
     " uint64_max = (
    ((
    (* HACK around Lem's inability to parse 18446744073709551615: 
     * the square of uint32_max is 
     *       (2**32 - 1) (2**32 - 1)
     * i.e.   2**64 - 2**32 - 2**32 + 1
     * So
     * 2**64 - 1 =  uint32_max * uint32_max  + 2**32 + 2**32 - 2
     *)uint32_max * uint32_max) -( 2 :: nat)) + (( 2 :: nat)^( 33 :: nat)))"

    (* 18446744073709551615 *) (* i.e. 0x ffff ffff ffff ffff *)
    (* HMM. This still overflows int64 *)

(* The 2's complement of a value, at 64-bit width *)
(*val compl64 : natural -> natural*)
definition compl64  :: " nat \<Rightarrow> nat "  where 
     " compl64 v = (( 1 :: nat) + (natural_lxor v uint64_max))"


(*val gcd : natural -> natural -> natural*)
(*let rec gcd a b=  
    if (Instance_Basic_classes_Eq_Num_natural.=) b 0 then a else gcd b ((Instance_Num_NumRemainder_Num_natural.mod) a b)*)

(*val lcm : natural -> natural -> natural*)
(*let lcm a b=  
    (* let _ = errln (lcm of  ^ (show a) ^  and  ^ (show b) ^ ?)
    in *)
    (Instance_Num_NumDivision_Num_natural./) (( Instance_Num_NumMult_Num_natural.* ) a b) (gcd a b)*)

(*val address_of_range : forall 'abifeature. element_range -> annotated_memory_image 'abifeature -> natural*)
definition address_of_range  :: " string*(nat*nat)\<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> nat "  where 
     " address_of_range el_range img3 = ( 
    (let (el_name, (start, len)) = el_range
    in
    (case  (elements   img3) el_name of
        Some el =>
            (case (startpos   el) of
                Some addr => addr + start
                | None => failwith (''address_of_range called for element with no address'')
            )
        | None => failwith (''address_of_range called on nonexistent element'')
    )))"


(*val range_contains : (natural * natural) -> (natural * natural) -> bool*)
fun range_contains  :: " nat*nat \<Rightarrow> nat*nat \<Rightarrow> bool "  where 
     " range_contains (r1begin, r1len) (r2begin, r2len) = (    
( 
    (* r1 is at least as big as r2 *)r2begin \<ge> r1begin) \<and> ((r2begin + r2len) \<le> (r1begin + r1len)))" 
declare range_contains.simps [simp del]


(*val range_overlaps : (natural * natural) -> (natural * natural) -> bool*)
fun range_overlaps  :: " nat*nat \<Rightarrow> nat*nat \<Rightarrow> bool "  where 
     " range_overlaps (r1begin, r1len) (r2begin, r2len) = (
    ((r1begin < (r2begin + r2len)) \<and> ((r1begin + r1len) > r2begin))
     \<or> ((r2begin < (r1begin + r1len)) \<and> ((r2begin + r2len) > r1begin)))" 
declare range_overlaps.simps [simp del]

    
(*val is_partition : list (natural * natural) -> list (natural * natural) -> bool*)
definition is_partition  :: "(nat*nat)list \<Rightarrow>(nat*nat)list \<Rightarrow> bool "  where 
     " is_partition rs ranges = ( 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    (let r_is_contained_by_some_range
     = (\<lambda> r .  List.foldl (op \<or>) False (List.map (\<lambda> range .  range_contains range r) ranges))
    in
    ((\<forall> x \<in> (set rs).  (\<lambda> r .  r_is_contained_by_some_range r) x))
    \<and>
    (* 2. elements of the first list do not overlap *)
    ((\<forall> x \<in> (set rs).  (\<lambda> r .  ((\<forall> x \<in> (set rs).  (\<lambda> r2 .  (r = (* should be ==? *) r2) \<or> (\<not> (range_overlaps r r2))) x))) x))))"


(*val     nat_range : natural -> natural -> list natural*)
function (sequential,domintros)  nat_range  :: " nat \<Rightarrow> nat \<Rightarrow>(nat)list "  where 
     " nat_range base len = (
    (case  len of 
        0 => []
    |   _ => base # (nat_range (base +( 1 :: nat)) (len -( 1 :: nat)))
    ))" 
by pat_completeness auto


(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
(*val expand_sorted_ranges : list (natural * natural) -> natural -> list bool -> list bool*)
function (sequential,domintros)  expand_sorted_ranges  :: "(nat*nat)list \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " expand_sorted_ranges ([]) min_length accum = ( accum @ (
            (let pad_length = (max(( 0 :: nat)) (min_length - (List.length accum)))
            in
            (* let _ = Missing_pervasives.errln (
                padding ranges cares list with  ^ (show pad_length) ^ 
                 cares (accumulated  ^ (show (Missing_pervasives.length accum)) ^ 
                , min length  ^ (show min_length) ^ ))
            in *)
            List.replicate pad_length True)))"
|" expand_sorted_ranges ((base, len) # more1) min_length accum = ( 
            (* pad the accum so that it reaches up to base *)
            (let up_to_base = (List.replicate (base - (List.length accum)) True)
            in
            (let up_to_end_of_range = (up_to_base @ (List.replicate len False))
            in
            expand_sorted_ranges more1 min_length (accum @ up_to_end_of_range))))" 
by pat_completeness auto


(*val expand_unsorted_ranges : list (natural * natural) -> natural -> list bool -> list bool*)
fun  expand_unsorted_ranges  :: "(nat*nat)list \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " expand_unsorted_ranges unsorted_ranges min_length accum = (
    expand_sorted_ranges (sort_by (\<lambda> (base1, len1) .  (\<lambda> (base2, len2) .  base1 < base2)) unsorted_ranges) min_length accum )" 
declare expand_unsorted_ranges.simps [simp del]


(*val make_byte_pattern_revacc : list (maybe byte) -> list byte -> list bool -> list (maybe byte)*)
function (sequential,domintros)  make_byte_pattern_revacc  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " make_byte_pattern_revacc revacc ([]) cares = ( List.rev revacc )"
|" make_byte_pattern_revacc revacc (b # bs) cares = ( (case  cares of 
                care # more1 => make_byte_pattern_revacc ((if \<not> care then None else Some b) # revacc) bs more1
              | _ => failwith (''make_byte_pattern: unequal length'')
              ))" 
by pat_completeness auto


(*val make_byte_pattern : list byte -> list bool -> list (maybe byte)*)
fun  make_byte_pattern  :: "(Elf_Types_Local.byte)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " make_byte_pattern bytes cares = ( 
    make_byte_pattern_revacc [] bytes cares )" 
declare make_byte_pattern.simps [simp del]


(*val relax_byte_pattern_revacc : list (maybe byte) -> list (maybe byte) -> list bool -> list (maybe byte)*)
function (sequential,domintros)  relax_byte_pattern_revacc  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " relax_byte_pattern_revacc revacc ([]) cares = ( List.rev revacc )"
|" relax_byte_pattern_revacc revacc (b # bs) cares = ( (case  cares of 
                care # more1 => relax_byte_pattern_revacc ((if \<not> care then None else b) # revacc) bs more1
              | _ => failwith ((''relax_byte_pattern: unequal length''))
              ))" 
by pat_completeness auto

    
(*val relax_byte_pattern : list (maybe byte) -> list bool -> list (maybe byte)*)
fun  relax_byte_pattern  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " relax_byte_pattern bytes cares = ( 
    relax_byte_pattern_revacc [] bytes cares )" 
declare relax_byte_pattern.simps [simp del]


type_synonym pad_fn =" nat \<Rightarrow> Elf_Types_Local.byte list "

(*val concretise_byte_pattern : list byte -> natural -> list (maybe byte) -> pad_fn -> list byte*)
function (sequential,domintros)  concretise_byte_pattern  :: "(Elf_Types_Local.byte)list \<Rightarrow> nat \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>(nat \<Rightarrow>(Elf_Types_Local.byte)list)\<Rightarrow>(Elf_Types_Local.byte)list "  where 
     " concretise_byte_pattern rev_acc acc_pad ([]) pad = ( 
            (let padding_bytes = (if acc_pad >( 0 :: nat) then pad acc_pad else [])
            in List.rev ((List.rev padding_bytes) @ rev_acc)))"
|" concretise_byte_pattern rev_acc acc_pad (Some(b) # more1) pad = ( 
            (* flush accumulated padding *)
            (let padding_bytes = (if acc_pad >( 0 :: nat) then pad acc_pad else [])
            in
            concretise_byte_pattern (b # ((List.rev padding_bytes) @ rev_acc))(( 0 :: nat)) more1 pad))"
|" concretise_byte_pattern rev_acc acc_pad (None # more1) pad = ( 
            concretise_byte_pattern rev_acc (acc_pad+( 1 :: nat)) more1 pad )" 
by pat_completeness auto


(*val byte_option_matches_byte : maybe byte -> byte -> bool*)
fun byte_option_matches_byte  :: "(Elf_Types_Local.byte)option \<Rightarrow> Elf_Types_Local.byte \<Rightarrow> bool "  where 
     " byte_option_matches_byte None b = ( True )"
|" byte_option_matches_byte (Some some) b = ( some = b )" 
declare byte_option_matches_byte.simps [simp del]


(*val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool*)
function (sequential,domintros)  byte_list_matches_pattern  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> bool "  where 
     " byte_list_matches_pattern ([]) bytes = ( True )"
|" byte_list_matches_pattern (optbyte # more1) bytes = ( (case  bytes of 
                [] => False
                | abyte # morebytes => 
                    byte_option_matches_byte optbyte abyte 
                 \<and> byte_list_matches_pattern more1 morebytes
            ))" 
by pat_completeness auto


(*val append_to_byte_pattern_at_offset : natural -> list (maybe byte) -> list (maybe byte) -> list (maybe byte)*)
definition append_to_byte_pattern_at_offset  :: " nat \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " append_to_byte_pattern_at_offset offset pat1 pat2 = (
    (let pad_length = (offset - List.length pat1)
    in
    if pad_length <( 0 :: nat) then failwith ([(CHR ''c''), (CHR ''a''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''a''), (CHR ''p''), (CHR ''p''), (CHR ''e''), (CHR ''n''), (CHR ''d''), (CHR '' ''), (CHR ''a''), (CHR ''t''), (CHR '' ''), (CHR ''o''), (CHR ''f''), (CHR ''f''), (CHR ''s''), (CHR ''e''), (CHR ''t''), (CHR '' ''), (CHR ''a''), (CHR ''l''), (CHR ''r''), (CHR ''e''), (CHR ''a''), (CHR ''d''), (CHR ''y''), (CHR '' ''), (CHR ''u''), (CHR ''s''), (CHR ''e''), (CHR ''d'')])
    else (pat1 @ (List.replicate ( pad_length) None)) @ pat2))"


(*val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural*)
function (sequential,domintros)  accum_pattern_possible_starts_in_one_byte_sequence  :: "((Elf_Types_Local.byte)option)list \<Rightarrow> nat \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>(nat)list \<Rightarrow>(nat)list "  where 
     " accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum = (
    (* let _ = Missing_pervasives.errs (At offset  ^ (show offset) ^ ... )
    in *)
    (case  pattern of
        [] => (* let _ = Missing_pervasives.errs (terminating with hit (empty pattern)n) in *)
            offset # accum
        | bpe # more_bpes => (* nonempty, so check for nonempty seq *)
            (case  seq of 
                [] => (*let _ = Missing_pervasives.errs (terminating with miss (empty pattern)n) 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte # more_bytes => (let matched_this_byte =                            
 (byte_option_matches_byte bpe byte)
                       in
                       (* let _ = Missing_pervasives.errs (Byte  ^ (show byte) ^  matched  ^ (show byte_pattern) ^ ?  ^ (show matched_this_byte) ^ ; ) 
                       in *)
                       (let sequence_long_enough = (seq_len \<ge> pattern_len) 
                       in
                       (* let _ = Missing_pervasives.errs (enough bytes remaining ( ^ (show seq_len) ^ ) to match rest of pattern ( ^ (show pattern_len) ^ )?  ^ (show sequence_long_enough) ^ ; ) 
                       in *)
                       (let matched_here = (matched_this_byte \<and> (sequence_long_enough \<and>
                        byte_list_matches_pattern more_bpes more_bytes))
                       in
                       (* let _ = Missing_pervasives.errs (matched pattern anchored here?  ^ (show matched_this_byte) ^ n) 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len -( 1 :: nat)) 
                           (offset +( 1 :: nat)) 
                           (if matched_here then offset # accum else accum))))
            )
    ))" 
by pat_completeness auto


definition swap_pairs  :: "('b*'a)set \<Rightarrow>('a*'b)set "  where 
     " swap_pairs s = (
  Set.image (\<lambda> (k, v) .  (v, k))
    (set_filter (\<lambda> (k, v) .  True) s) )"


definition by_range_from_by_tag  :: "('a*'b)set \<Rightarrow>('b*'a)set "  where 
     " by_range_from_by_tag = ( swap_pairs )"


definition by_tag_from_by_range  :: "('a*'b)set \<Rightarrow>('b*'a)set "  where 
     " by_tag_from_by_range = ( swap_pairs )"


(*val filter_elements : forall 'abifeature. ((string * element) -> bool) -> 
    annotated_memory_image 'abifeature -> annotated_memory_image 'abifeature*)
definition filter_elements  :: "(string*element \<Rightarrow> bool)\<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> 'abifeature annotated_memory_image "  where 
     " filter_elements pred img3 = ( 
    (let new_elements = (Map.map_of (List.rev ((let x2 = 
  ([]) in  List.foldr
   (\<lambda>(n, r) x2 . 
    if
    (let result = (pred (n, r)) in
    if \<not> result then
      (*let _ = Missing_pervasives.outln (Discarding element named  ^ n) in*) result
    else result) then (n, r) # x2 else x2)
   (list_of_set (map_to_set (elements   img3))) x2))))
    in
    (let new_by_range =  (set_filter (\<lambda> (maybe_range, tag) .  (case  maybe_range of
            None => True
            | Some (el_name, el_range) => el_name \<in> Map.dom new_elements
        ))(by_range   img3))
    in
    (let new_by_tag =
  (Set.image (\<lambda> (k, v) .  (v, k))
     (set_filter (\<lambda> (k, v) .  True) new_by_range))
    in
    (| elements = new_elements
     , by_range = new_by_range
     , by_tag   = new_by_tag
     |)))))"


(*val tag_image : forall 'abifeature. range_tag 'abifeature -> string -> natural -> natural -> annotated_memory_image 'abifeature
    ->  annotated_memory_image 'abifeature*)
definition tag_image  :: " 'abifeature range_tag \<Rightarrow> string \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> 'abifeature annotated_memory_image "  where 
     " tag_image t el_name el_offset tag_len img3 = ( 
    (let (k, v) = (Some (el_name, (el_offset, tag_len)), t)
    in
    (let new_by_range = (Set.insert (k, v)(by_range   img3))
    in
    (let new_by_tag = (Set.insert (v, k)(by_tag   img3))
    in
    (| elements = ((elements   img3))
     , by_range = new_by_range
     , by_tag   = new_by_tag
     |)))))"


(*val address_to_element_and_offset : forall 'abifeature. natural -> annotated_memory_image 'abifeature -> maybe (string * natural)*)
definition address_to_element_and_offset  :: " nat \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>(string*nat)option "  where 
     " address_to_element_and_offset query_addr img3 = ( 
    (* Find the element with the highest address <= addr.
     * What about zero-length elements?
     * Break ties on the bigger size. *)
    (let (maybe_highest_le ::  (nat * string * element)option)
     = (List.foldl (\<lambda> maybe_current_max_le .  (\<lambda> (el_name, el_rec) . 
        (let _ = (())
        in
        (case  (maybe_current_max_le,(startpos   el_rec)) of
              (None,                                    None) => None
            | (None,                                    Some this_element_pos) => if this_element_pos \<le> query_addr 
                                                                                     then Some (this_element_pos, el_name, el_rec) 
                                                                                     else None
            | (Some (cur_max_le, cur_el_name, cur_el_rec), None) =>               maybe_current_max_le
            | (Some (cur_max_le, cur_el_name, cur_el_rec), Some this_element_pos) => if (this_element_pos \<le> query_addr) 
                                                                                        \<and> ((this_element_pos > cur_max_le) 
                                                                                         \<or> ((this_element_pos = cur_max_le)
                                                                                             \<and> ((length1   cur_el_rec) = Some(( 0 :: nat)))))
                                                                                        then Some (this_element_pos, el_name, el_rec) 
                                                                                        else maybe_current_max_le
        ))
    )) None (list_of_set (LemExtraDefs.map_to_set (elements img3))))
    in
    (case  maybe_highest_le of
        Some (el_def_startpos, el_name, el_rec) =>
            (* final sanity check: is the length definite, and if so, does the
             * element span far enough? *)
            (case (length1   el_rec) of
                Some l => if (el_def_startpos + l) \<ge> query_addr 
                    then Some (el_name, (query_addr - el_def_startpos)) 
                    else 
                        (let _ = (()) in None)
                | None => (let _ = (()) in None)
            )
        | None => 
            (* no elements with a low enough assigned address, so nothing *)
            (let _ = (()) in None)
    )))"

    
(*val element_and_offset_to_address : forall 'abifeature. (string * natural) -> annotated_memory_image 'abifeature -> maybe natural*)
fun element_and_offset_to_address  :: " string*nat \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>(nat)option "  where 
     " element_and_offset_to_address (el_name, el_off) img3 = ( 
    (case  (elements   img3) el_name of
        Some el => (case (startpos   el) of
                        Some addr => Some (addr + el_off)
                        | None => None
                   )
        | None => failwith ((''error: nonexistent element: '') @ el_name)
    ))" 
declare element_and_offset_to_address.simps [simp del]


definition null_symbol_reference  :: " symbol_reference "  where 
     " null_symbol_reference = ( (|
    ref_symname = ('''')
    , ref_syment = elf64_null_symbol_table_entry
    , ref_sym_scn =(( 0 :: nat))
    , ref_sym_idx =(( 0 :: nat))
|) )"


definition null_elf_relocation_a  :: " elf64_relocation_a "  where 
     " null_elf_relocation_a = (
  (| elf64_ra_offset = (Elf_Types_Local.uint64_of_nat(( 0 :: nat)))  
   , elf64_ra_info   = (of_int (int (( 0 :: nat)))) 
   , elf64_ra_addend = (of_int(( 0 :: int)))
   |) )"



definition null_symbol_reference_and_reloc_site  :: " symbol_reference_and_reloc_site "  where 
     " null_symbol_reference_and_reloc_site = ( (|
      ref = null_symbol_reference
    , maybe_reloc =        
 (Some   (| ref_relent = null_elf_relocation_a
                , ref_rel_scn =(( 0 :: nat))
                , ref_rel_idx =(( 0 :: nat))
                , ref_src_scn =(( 0 :: nat))
                |))
    , maybe_def_bound_to = None
    |) )"


definition null_symbol_definition  :: " symbol_definition "  where 
     " null_symbol_definition = ( (|
    def_symname = ('''')
    , def_syment = elf64_null_symbol_table_entry
    , def_sym_scn =(( 0 :: nat))
    , def_sym_idx =(( 0 :: nat))
    , def_linkable_idx =(( 0 :: nat))
|) )"

    
(*val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural*)
definition pattern_possible_starts_in_one_byte_sequence  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> nat \<Rightarrow>(nat)list "  where 
     " pattern_possible_starts_in_one_byte_sequence pattern seq offset = (
    (* let _ = Missing_pervasives.errs (Looking for matches of  ^
        (show (List.length pattern)) ^ -byte pattern in  ^ (show (List.length seq)) ^ -byte regionn)
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset [])"


(*val byte_pattern_of_byte_sequence : byte_sequence -> list (maybe byte)*)
fun byte_pattern_of_byte_sequence  :: " byte_sequence \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " byte_pattern_of_byte_sequence (Sequence(bs)) = ( List.map (\<lambda> b .  Some b) bs )" 
declare byte_pattern_of_byte_sequence.simps [simp del]


(*val compute_virtual_address_adjustment : natural -> natural -> natural -> natural*)
definition compute_virtual_address_adjustment  :: " nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat "  where 
     " compute_virtual_address_adjustment max_page_size offset vaddr = (
  (vaddr - offset) mod max_page_size )"


(*val extract_natural_field : natural -> element -> natural -> natural*)
definition extract_natural_field  :: " nat \<Rightarrow> element \<Rightarrow> nat \<Rightarrow> nat "  where 
     " extract_natural_field width element offset = ( 
    (* Read n bytes from the contents *)
    (let maybe_bytes = (take width (drop offset(contents   element)))
    in
    (let bytes = (List.map (\<lambda> mb .  (case  mb of None => (of_nat (( 0 :: nat)) :: byte) | Some mb => mb )) maybe_bytes)
    in
    (* FIXME: do we want little- or big-endian? *)
    List.foldl (\<lambda> acc1 .  \<lambda> next_byte .         
(acc1 *( 256 :: nat)) + (unat next_byte)
    ) (( 0 :: nat) :: nat) bytes)))"


(*val natural_to_le_byte_list : natural -> list byte*)
function (sequential,domintros)  natural_to_le_byte_list  :: " nat \<Rightarrow>(Elf_Types_Local.byte)list "  where 
     " natural_to_le_byte_list n = ( 
    ((of_nat (n mod( 256 :: nat)) :: byte)) # ((let d = (n div( 256 :: nat)) in if d =( 0 :: nat) then [] else natural_to_le_byte_list (n div( 256 :: nat)))))" 
by pat_completeness auto


(*val natural_to_le_byte_list_padded_to : natural -> natural -> list byte*)
fun  natural_to_le_byte_list_padded_to  :: " nat \<Rightarrow> nat \<Rightarrow>(Elf_Types_Local.byte)list "  where 
     " natural_to_le_byte_list_padded_to width n = ( 
    (let bytes = (natural_to_le_byte_list n)
    in 
    bytes @ (List.replicate (width - List.length bytes) ((of_nat (( 0 :: nat)) :: byte)))))" 
declare natural_to_le_byte_list_padded_to.simps [simp del]


(*val n2i : natural -> integer*)
definition n2i  :: " nat \<Rightarrow> int "  where 
     " n2i = ( int )"


(*val i2n: integer -> natural*)
definition i2n  :: " int \<Rightarrow> nat "  where 
     " i2n = ( (\<lambda> i. nat (abs i)))"


(*val i2n_signed : nat -> integer -> natural*)
definition i2n_signed  :: " nat \<Rightarrow> int \<Rightarrow> nat "  where 
     " i2n_signed width i = ( 
    if i \<ge>( 0 :: int) then 
        if i \<ge>(( 2 :: int) ^ (width-( 1 :: nat))) then failwith (''overflow'')
        else nat (abs i)
    else 
        (* We manually encode the 2's complement of the negated value *)
        (let negated = (nat (abs (( 0 :: int) - i))) in 
        (let (xormask :: nat) = ((( 2 :: nat) ^ width) -( 1 :: nat)) in
        (let compl =(( 1 :: nat) + natural_lxor negated xormask)
        in
        (*let _ = errln (Signed value  ^ (show i) ^  is 2's-compl'd to 0x ^ (hex_string_of_natural compl))
        in*) compl))))"


(*val to_le_signed_bytes : natural -> integer -> list byte*)
definition to_le_signed_bytes  :: " nat \<Rightarrow> int \<Rightarrow>(Elf_Types_Local.byte)list "  where 
     " to_le_signed_bytes bytewidth i = ( 
    natural_to_le_byte_list_padded_to bytewidth (i2n_signed ( (( 8 :: nat)*bytewidth)) i))"


(*val to_le_unsigned_bytes : natural -> integer -> list byte*)
definition to_le_unsigned_bytes  :: " nat \<Rightarrow> int \<Rightarrow>(Elf_Types_Local.byte)list "  where 
     " to_le_unsigned_bytes bytewidth i = ( 
    natural_to_le_byte_list_padded_to bytewidth (nat (abs i)))"


(*val write_natural_field : natural -> natural -> element -> natural -> element*)
definition write_natural_field  :: " nat \<Rightarrow> nat \<Rightarrow> element \<Rightarrow> nat \<Rightarrow> element "  where 
     " write_natural_field new_field_value width element offset = ( 
    (let pre_bytes = (take offset(contents   element))
    in
    (let post_bytes = (drop (offset + width)(contents   element))
    in
    (* FIXME: avoid hard-coding little-endian *)
    (let field_bytes = (natural_to_le_byte_list new_field_value)
    in
    if List.length field_bytes > width then failwith (''internal error: relocation output unrepresentable'')
    else  (| startpos = ((startpos   element)) , length1 = ((length1   element)),
 contents = (((pre_bytes @
                 ((let x2 = ([]) in
                  List.foldr
                    (\<lambda>b x2 .  if True then Some b # x2 else x2)
                    field_bytes x2))) @
                (List.replicate (width - (List.length field_bytes))
                   (Some ((of_nat (( 0 :: nat)) :: byte))))) @ post_bytes)  
 |)))))"

end
