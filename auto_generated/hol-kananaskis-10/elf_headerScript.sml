(*Generated by Lem from elf_header.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_setTheory lem_functionTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory missing_pervasivesTheory errorTheory byte_sequenceTheory endiannessTheory elf_types_native_uintTheory default_printingTheory;

val _ = numLib.prefer_num();



val _ = new_theory "elf_header"

(** [elf_header] includes types, functions and other definitions for working with
  * ELF headers.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*import Set*)

(*open import Assert_extra*)

(*open import Default_printing*)
(*open import Endianness*)

(*open import Elf_types_native_uint*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** Special section header table indices *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  * Present here instead of in elf_section_header_table.lem because a calculation
  * below requires this constant (i.e. forward reference in the ELF spec).
  *)
val _ = Define `
 (shn_undef : num= (( 0:num)))`;


(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears). Present here instead
  * of in elf_section_header_table.lem because a calculation below requires this
  * constant (i.e. forward reference in the ELF spec).
  *)
val _ = Define `
 (shn_xindex : num= (( 65535:num)))`;
 (* 0xffff *)

(** ELF object file types.  Enumerates the ELF object file types specified in the
 *  System V ABI.  Values between [elf_ft_lo_os] and [elf_ft_hi_os] inclusive are
 *  reserved for operating system specific values typically defined in an
 *  addendum to the System V ABI for that operating system.  Values between
 *  [elf_ft_lo_proc] and [elf_ft_hi_proc] inclusive are processor specific and
 *  are typically defined in an addendum to the System V ABI for that processor
 *  series.
 *)

(** No file type *)
val _ = Define `
 (elf_ft_none : num= (( 0:num)))`;

(** Relocatable file *)
val _ = Define `
 (elf_ft_rel : num= (( 1:num)))`;

(** Executable file *)
val _ = Define `
 (elf_ft_exec : num= (( 2:num)))`;

(** Shared object file *)
val _ = Define `
 (elf_ft_dyn : num= (( 3:num)))`;

(** Core file *)
val _ = Define `
 (elf_ft_core : num= (( 4:num)))`;

(** Operating-system specific *)
val _ = Define `
 (elf_ft_lo_os : num= (( 65024:num)))`;
 (* 0xfe00 *)
(** Operating-system specific *)
val _ = Define `
 (elf_ft_hi_os : num= (( 65279:num)))`;
 (* 0xfeff *)
(** Processor specific *)
val _ = Define `
 (elf_ft_lo_proc : num= (( 65280:num)))`;
 (* 0xff00 *)
(** Processor specific *)
val _ = Define `
 (elf_ft_hi_proc : num= (( 65535:num)))`;
 (* 0xffff *)

(** [string_of_elf_file_type os proc m] produces a string representation of the
  * numeric encoding [m] of the ELF file type.  For values reserved for OS or
  * processor specific values, the higher-order functions [os] and [proc] are
  * used for printing, respectively.
  *)
(*val string_of_elf_file_type : (natural -> string) -> (natural -> string) -> natural -> string*)
val _ = Define `
 (string_of_elf_file_type os_specific proc_specific m=	
 (if m = elf_ft_none then
		"No file type"
	else if m = elf_ft_rel then
		"REL (Relocatable file)"
	else if m = elf_ft_exec then
		"EXEC (Executable file)"
	else if m = elf_ft_dyn then
		"DYN (Shared object file)"
	else if m = elf_ft_core then
		"CORE (Core file)"
	else if (m >= elf_ft_lo_os) /\ (m <= elf_ft_hi_os) then
		os_specific m
	else if (m >= elf_ft_lo_proc) /\ (m <= elf_ft_hi_proc) then
		proc_specific m
	else
		"Invalid file type"))`;


(** [is_operating_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for operating system-specific purposes.
  *)
(*val is_operating_system_specific_object_file_type_value : natural -> bool*)
val _ = Define `
 (is_operating_system_specific_object_file_type_value v=
   ((v >=( 65024:num)) /\ (v <=( 65279:num))))`;


(** [is_processor_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for processor-specific purposes.
  *)
(*val is_processor_specific_object_file_type_value : natural -> bool*)
val _ = Define `
 (is_processor_specific_object_file_type_value v=
   ((v >=( 65280:num)) /\ (v <=( 65535:num))))`;


(** ELF machine architectures *)

(** RISC-V *)
val _ = Define `
 (elf_ma_riscv : num= (( 243:num)))`;

(** AMD GPU architecture *)
val _ = Define `
 (elf_ma_amdgpu : num= (( 224:num)))`;

(** Moxie processor family *)
val _ = Define `
 (elf_ma_moxie : num= (( 223:num)))`;

(** FTDI Chip FT32 high performance 32-bit RISC architecture *)
val _ = Define `
 (elf_ma_ft32 : num= (( 222:num)))`;

(** Controls and Data Services VISIUMcore processor *)
val _ = Define `
 (elf_ma_visium : num= (( 221:num)))`;

(** Zilog Z80 *)
val _ = Define `
 (elf_ma_z80 : num= (( 220:num)))`;

(** CSR Kalimba architecture family *)
val _ = Define `
 (elf_ma_kalimba : num= (( 219:num)))`;

(** Nanoradio optimised RISC *)
val _ = Define `
 (elf_ma_norc : num= (( 218:num)))`;

(** iCelero CoolEngine *)
val _ = Define `
 (elf_ma_cool : num= (( 217:num)))`;

(** Cognitive Smart Memory Processor *)
val _ = Define `
 (elf_ma_coge : num= (( 216:num)))`;

(** Paneve CDP architecture family *)
val _ = Define `
 (elf_ma_cdp : num= (( 215:num)))`;

(** KM211 KVARC processor *)
val _ = Define `
 (elf_ma_kvarc : num= (( 214:num)))`;

(** KM211 KMX8 8-bit processor *)
val _ = Define `
 (elf_ma_kmx8 : num= (( 213:num)))`;

(** KM211 KMX16 16-bit processor *)
val _ = Define `
 (elf_ma_kmx16 : num= (( 212:num)))`;

(** KM211 KMX32 32-bit processor *)
val _ = Define `
 (elf_ma_kmx32 : num= (( 211:num)))`;

(** KM211 KM32 32-bit processor *)
val _ = Define `
 (elf_ma_km32 : num= (( 210:num)))`;

(** Microchip 8-bit PIC(r) family *)
val _ = Define `
 (elf_ma_mchp_pic : num= (( 204:num)))`;

(** XMOS xCORE processor family *)
val _ = Define `
 (elf_ma_xcore : num= (( 203:num)))`;

(** Beyond BA2 CPU architecture *)
val _ = Define `
 (elf_ma_ba2 : num= (( 202:num)))`;

(** Beyond BA1 CPU architecture *)  
val _ = Define `
 (elf_ma_ba1 : num= (( 201:num)))`;

(** Freescale 56800EX Digital Signal Controller (DSC) *)
val _ = Define `
 (elf_ma_5600ex : num= (( 200:num)))`;

(** 199 Renesas 78KOR family *)
val _ = Define `
 (elf_ma_78kor : num= (( 199:num)))`;

(** Broadcom VideoCore V processor *)
val _ = Define `
 (elf_ma_videocore5 : num= (( 198:num)))`;

(** Renesas RL78 family *)
val _ = Define `
 (elf_ma_rl78 : num= (( 197:num)))`;

(** Open8 8-bit RISC soft processing core *)
val _ = Define `
 (elf_ma_open8 : num= (( 196:num)))`;

(** Synopsys ARCompact V2 *)
val _ = Define `
 (elf_ma_arc_compact2 : num= (( 195:num)))`;

(** KIPO_KAIST Core-A 2nd generation processor family *)
val _ = Define `
 (elf_ma_corea_2nd : num= (( 194:num)))`;

(** KIPO_KAIST Core-A 1st generation processor family *)
val _ = Define `
 (elf_ma_corea_1st : num= (( 193:num)))`;

(** CloudShield architecture family *)
val _ = Define `
 (elf_ma_cloudshield : num= (( 192:num)))`;

(** Infineon Technologies SLE9X core *)
val _ = Define `
 (elf_ma_sle9x : num= (( 179:num)))`;

(** Intel L10M *)
val _ = Define `
 (elf_ma_l10m : num= (( 180:num)))`;

(** Intel K10M *)
val _ = Define `
 (elf_ma_k10m : num= (( 181:num)))`;

(** ARM 64-bit architecture (AARCH64) *)
val _ = Define `
 (elf_ma_aarch64 : num= (( 183:num)))`;

(** Atmel Corporation 32-bit microprocessor family *)
val _ = Define `
 (elf_ma_avr32 : num= (( 185:num)))`;

(** STMicroelectronics STM8 8-bit microcontroller *)
val _ = Define `
 (elf_ma_stm8 : num= (( 186:num)))`;

(** Tilera TILE64 multicore architecture family *)
val _ = Define `
 (elf_ma_tile64 : num= (( 187:num)))`;

(** Tilera TILEPro multicore architecture family *)
val _ = Define `
 (elf_ma_tilepro : num= (( 188:num)))`;

(** Xilinix MicroBlaze 32-bit RISC soft processor core *)
val _ = Define `
 (elf_ma_microblaze : num= (( 189:num)))`;

(** NVIDIA CUDA architecture *)
val _ = Define `
 (elf_ma_cuda : num= (( 190:num)))`;

(** Tilera TILE-Gx multicore architecture family *)
val _ = Define `
 (elf_ma_tilegx : num= (( 191:num)))`;

(** Cypress M8C microprocessor *)
val _ = Define `
 (elf_ma_cypress : num= (( 161:num)))`;

(** Renesas R32C series microprocessors *)
val _ = Define `
 (elf_ma_r32c : num= (( 162:num)))`;

(** NXP Semiconductors TriMedia architecture family *)
val _ = Define `
 (elf_ma_trimedia : num= (( 163:num)))`;

(** QUALCOMM DSP6 processor *)
val _ = Define `
 (elf_ma_qdsp6 : num= (( 164:num)))`;

(** Intel 8051 and variants *)
val _ = Define `
 (elf_ma_8051 : num= (( 165:num)))`;

(** STMicroelectronics STxP7x family of configurable and extensible RISC processors *)
val _ = Define `
 (elf_ma_stxp7x : num= (( 166:num)))`;

(** Andes Technology compact code size embedded RISC processor family *)
val _ = Define `
 (elf_ma_nds32 : num= (( 167:num)))`;

(** Cyan Technology eCOG1X family *)
val _ = Define `
 (elf_ma_ecog1x : num= (( 168:num)))`;

(** Dallas Semiconductor MAXQ30 Core Micro-controllers *)
val _ = Define `
 (elf_ma_maxq30 : num= (( 169:num)))`;

(** New Japan Radio (NJR) 16-bit DSP Processor *)
val _ = Define `
 (elf_ma_ximo16 : num= (( 170:num)))`;

(** M2000 Reconfigurable RISC Microprocessor *)
val _ = Define `
 (elf_ma_manik : num= (( 171:num)))`;

(** Cray Inc. NV2 vector architecture *)
val _ = Define `
 (elf_ma_craynv2 : num= (( 172:num)))`;

(** Renesas RX family *)
val _ = Define `
 (elf_ma_rx : num= (( 173:num)))`;

(** Imagination Technologies META processor architecture *)
val _ = Define `
 (elf_ma_metag : num= (( 174:num)))`;

(** MCST Elbrus general purpose hardware architecture *)
val _ = Define `
 (elf_ma_mcst_elbrus : num= (( 175:num)))`;

(** Cyan Technology eCOG16 family *)
val _ = Define `
 (elf_ma_ecog16 : num= (( 176:num)))`;

(** National Semiconductor CompactRISC CR16 16-bit microprocessor *)
val _ = Define `
 (elf_ma_cr16 : num= (( 177:num)))`;

(** Freescale Extended Time Processing Unit *)
val _ = Define `
 (elf_ma_etpu : num= (( 178:num)))`;

(** Altium TSK3000 core *)
val _ = Define `
 (elf_ma_tsk3000 : num= (( 131:num)))`;

(** Freescale RS08 embedded processor *)
val _ = Define `
 (elf_ma_rs08 : num= (( 132:num)))`;

(** Analog Devices SHARC family of 32-bit DSP processors *)
val _ = Define `
 (elf_ma_sharc : num= (( 133:num)))`;

(** Cyan Technology eCOG2 microprocessor *)
val _ = Define `
 (elf_ma_ecog2 : num= (( 134:num)))`;

(** Sunplus S+core7 RISC processor *)
val _ = Define `
 (elf_ma_ccore7 : num= (( 135:num)))`;

(** New Japan Radio (NJR) 24-bit DSP Processor *)
val _ = Define `
 (elf_ma_dsp24 : num= (( 136:num)))`;

(** Broadcom VideoCore III processor *)
val _ = Define `
 (elf_ma_videocore3 : num= (( 137:num)))`;

(** RISC processor for Lattice FPGA architecture *)
val _ = Define `
 (elf_ma_latticemico32 : num= (( 138:num)))`;

(** Seiko Epson C17 family *)
val _ = Define `
 (elf_ma_c17 : num= (( 139:num)))`;

(** The Texas Instruments TMS320C6000 DSP family *)
val _ = Define `
 (elf_ma_c6000 : num= (( 140:num)))`;

(** The Texas Instruments TMS320C2000 DSP family *)
val _ = Define `
 (elf_ma_c2000 : num= (( 141:num)))`;

(** The Texas Instruments TMS320C55x DSP family *)
val _ = Define `
 (elf_ma_c5500 : num= (( 142:num)))`;

(** STMicroelectronics 64bit VLIW Data Signal Processor *)
val _ = Define `
 (elf_ma_mmdsp_plus : num= (( 160:num)))`;

(** LSI Logic 16-bit DSP Processor *)
val _ = Define `
 (elf_ma_zsp : num= (( 79:num)))`;

(** Donald Knuth's educational 64-bit processor *)
val _ = Define `
 (elf_ma_mmix : num= (( 80:num)))`;

(** Harvard University machine-independent object files *)
val _ = Define `
 (elf_ma_huany : num= (( 81:num)))`;

(** SiTera Prism *)
val _ = Define `
 (elf_ma_prism : num= (( 82:num)))`;

(** Atmel AVR 8-bit microcontroller *)
val _ = Define `
 (elf_ma_avr : num= (( 83:num)))`;

(** Fujitsu FR30 *)
val _ = Define `
 (elf_ma_fr30 : num= (( 84:num)))`;

(** Mitsubishi D10V *)
val _ = Define `
 (elf_ma_d10v : num= (( 85:num)))`;

(** Mitsubishi D30V *)
val _ = Define `
 (elf_ma_d30v : num= (( 86:num)))`;

(** NEC v850 *)
val _ = Define `
 (elf_ma_v850 : num= (( 87:num)))`;

(** Mitsubishi M32R *)
val _ = Define `
 (elf_ma_m32r : num= (( 88:num)))`;

(** Matsushita MN10300 *)
val _ = Define `
 (elf_ma_mn10300 : num= (( 89:num)))`;

(** Matsushita MN10200 *)
val _ = Define `
 (elf_ma_mn10200 : num= (( 90:num)))`;

(** picoJava *)
val _ = Define `
 (elf_ma_pj : num= (( 91:num)))`;

(** OpenRISC 32-bit embedded processor *)
val _ = Define `
 (elf_ma_openrisc : num= (( 92:num)))`;

(** ARC International ARCompact processor (old spelling/synonym: ELF_MA_ARC_A5) *)
val _ = Define `
 (elf_ma_arc_compact : num= (( 93:num)))`;

(** Tensilica Xtensa Architecture *)
val _ = Define `
 (elf_ma_xtensa : num= (( 94:num)))`;

(** Alphamosaic VideoCore processor *)
val _ = Define `
 (elf_ma_videocore : num= (( 95:num)))`;

(** Thompson Multimedia General Purpose Processor *)
val _ = Define `
 (elf_ma_tmm_gpp : num= (( 96:num)))`;

(** National Semiconductor 32000 series *)
val _ = Define `
 (elf_ma_ns32k : num= (( 97:num)))`;

(** Tenor Network TPC processor *)
val _ = Define `
 (elf_ma_tpc : num= (( 98:num)))`;

(** Trebia SNP 1000 processor *)
val _ = Define `
 (elf_ma_snp1k : num= (( 99:num)))`;

(** STMicroelectronics ST200 microcontroller *)
val _ = Define `
 (elf_ma_st200 : num= (( 100:num)))`;

(** Ubicom IP2xxx microcontroller family *)
val _ = Define `
 (elf_ma_ip2k : num= (( 101:num)))`;

(** MAX Processor *)
val _ = Define `
 (elf_ma_max : num= (( 102:num)))`;

(** National Semiconductor CompactRISC microprocessor *)
val _ = Define `
 (elf_ma_cr : num= (( 103:num)))`;

(** Fujitsu F2MC16 *)
val _ = Define `
 (elf_ma_f2mc16 : num= (( 104:num)))`;

(** Texas Instruments embedded microcontroller msp430 *)
val _ = Define `
 (elf_ma_msp430 : num= (( 105:num)))`;

(** Analog Devices Blackfin (DSP) processor *)
val _ = Define `
 (elf_ma_blackfin : num= (( 106:num)))`;

(** S1C33 Family of Seiko Epson processors *)
val _ = Define `
 (elf_ma_se_c33 : num= (( 107:num)))`;

(** Sharp embedded microprocessor *)
val _ = Define `
 (elf_ma_sep : num= (( 108:num)))`;

(** Arca RISC Microprocessor *)
val _ = Define `
 (elf_ma_arca : num= (( 109:num)))`;

(** Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University *)
val _ = Define `
 (elf_ma_unicore : num= (( 110:num)))`;

(** eXcess: 16/32/64-bit configurable embedded CPU *)
val _ = Define `
 (elf_ma_excess : num= (( 111:num)))`;

(** Icera Semiconductor Inc. Deep Execution Processor *)
val _ = Define `
 (elf_ma_dxp : num= (( 112:num)))`;

(** Altera Nios II soft-core processor *)
val _ = Define `
 (elf_ma_altera_nios2 : num= (( 113:num)))`;

(** National Semiconductor CompactRISC CRX microprocessor *)
val _ = Define `
 (elf_ma_crx : num= (( 114:num)))`;

(** Motorola XGATE embedded processor *)
val _ = Define `
 (elf_ma_xgate : num= (( 115:num)))`;

(** Infineon C16x/XC16x processor *)
val _ = Define `
 (elf_ma_c166 : num= (( 116:num)))`;

(** Renesas M16C series microprocessors *)
val _ = Define `
 (elf_ma_m16c : num= (( 117:num)))`;

(** Microchip Technology dsPIC30F Digital Signal Controller *)
val _ = Define `
 (elf_ma_dspic30f : num= (( 118:num)))`;

(** Freescale Communication Engine RISC core *)
val _ = Define `
 (elf_ma_ce : num= (( 119:num)))`;

(** Renesas M32C series microprocessors *)
val _ = Define `
 (elf_ma_m32c : num= (( 120:num)))`;

(** No machine *)
val _ = Define `
 (elf_ma_none : num= (( 0:num)))`;

(** AT&T WE 32100 *)
val _ = Define `
 (elf_ma_m32 : num= (( 1:num)))`;

(** SPARC *)
val _ = Define `
 (elf_ma_sparc : num= (( 2:num)))`;

(** Intel 80386 *)
val _ = Define `
 (elf_ma_386 : num= (( 3:num)))`;

(** Motorola 68000 *)
val _ = Define `
 (elf_ma_68k : num= (( 4:num)))`;

(** Motorola 88000 *)
val _ = Define `
 (elf_ma_88k : num= (( 5:num)))`;

(** Intel 80860 *)
val _ = Define `
 (elf_ma_860 : num= (( 7:num)))`;

(** MIPS I Architecture *)
val _ = Define `
 (elf_ma_mips : num= (( 8:num)))`;

(** IBM System/370 Processor *)
val _ = Define `
 (elf_ma_s370 : num= (( 9:num)))`;

(** MIPS RS3000 Little-endian *)
val _ = Define `
 (elf_ma_mips_rs3_le : num= (( 10:num)))`;

(** Hewlett-Packard PA-RISC *)
val _ = Define `
 (elf_ma_parisc : num= (( 15:num)))`;

(** Fujitsu VPP500 *)
val _ = Define `
 (elf_ma_vpp500 : num= (( 17:num)))`;

(** Enhanced instruction set SPARC *)
val _ = Define `
 (elf_ma_sparc32plus : num= (( 18:num)))`;

(** Intel 80960 *)
val _ = Define `
 (elf_ma_960 : num= (( 19:num)))`;

(** PowerPC *)
val _ = Define `
 (elf_ma_ppc : num= (( 20:num)))`;

(** 64-bit PowerPC *)
val _ = Define `
 (elf_ma_ppc64 : num= (( 21:num)))`;

(** IBM System/390 Processor *)
val _ = Define `
 (elf_ma_s390 : num= (( 22:num)))`;

(** IBM SPU/SPC *)
val _ = Define `
 (elf_ma_spu : num= (( 23:num)))`;

(** NEC V800 *)
val _ = Define `
 (elf_ma_v800 : num= (( 36:num)))`;

(** Fujitsu FR20 *)
val _ = Define `
 (elf_ma_fr20 : num= (( 37:num)))`;

(** TRW RH-32 *)
val _ = Define `
 (elf_ma_rh32 : num= (( 38:num)))`;

(** Motorola RCE *)
val _ = Define `
 (elf_ma_rce : num= (( 39:num)))`;

(** ARM 32-bit architecture (AARCH32) *)
val _ = Define `
 (elf_ma_arm : num= (( 40:num)))`;

(** Digital Alpha *)
val _ = Define `
 (elf_ma_alpha : num= (( 41:num)))`;

(** Hitachi SH *)
val _ = Define `
 (elf_ma_sh : num= (( 42:num)))`;

(** SPARC Version 9 *)
val _ = Define `
 (elf_ma_sparcv9 : num= (( 43:num)))`;

(** Siemens TriCore embedded processor *)
val _ = Define `
 (elf_ma_tricore : num= (( 44:num)))`;

(** Argonaut RISC Core, Argonaut Technologies Inc. *)
val _ = Define `
 (elf_ma_arc : num= (( 45:num)))`;

(** Hitachi H8/300 *)
val _ = Define `
 (elf_ma_h8_300 : num= (( 46:num)))`;

(** Hitachi H8/300H *)
val _ = Define `
 (elf_ma_h8_300h : num= (( 47:num)))`;

(** Hitachi H8S *)
val _ = Define `
 (elf_ma_h8s : num= (( 48:num)))`;

(** Hitachi H8/500 *)
val _ = Define `
 (elf_ma_h8_500 : num= (( 49:num)))`;

(** Intel IA-64 processor architecture *)
val _ = Define `
 (elf_ma_ia_64 : num= (( 50:num)))`;

(** Stanford MIPS-X *)
val _ = Define `
 (elf_ma_mips_x : num= (( 51:num)))`;

(** Motorola ColdFire *)
val _ = Define `
 (elf_ma_coldfire : num= (( 52:num)))`;

(** Motorola M68HC12 *)
val _ = Define `
 (elf_ma_68hc12 : num= (( 53:num)))`;

(** Fujitsu MMA Multimedia Accelerator *)
val _ = Define `
 (elf_ma_mma : num= (( 54:num)))`;

(** Siemens PCP *)
val _ = Define `
 (elf_ma_pcp : num= (( 55:num)))`;

(** Sony nCPU embedded RISC processor *)
val _ = Define `
 (elf_ma_ncpu : num= (( 56:num)))`;

(** Denso NDR1 microprocessor *)
val _ = Define `
 (elf_ma_ndr1 : num= (( 57:num)))`;

(** Motorola Star*Core processor *)
val _ = Define `
 (elf_ma_starcore : num= (( 58:num)))`;

(** Toyota ME16 processor *)
val _ = Define `
 (elf_ma_me16 : num= (( 59:num)))`;

(** STMicroelectronics ST100 processor *)
val _ = Define `
 (elf_ma_st100 : num= (( 60:num)))`;

(** Advanced Logic Corp. TinyJ embedded processor family *)
val _ = Define `
 (elf_ma_tinyj : num= (( 61:num)))`;

(** AMD x86-64 architecture *)
val _ = Define `
 (elf_ma_x86_64 : num= (( 62:num)))`;

(** Sony DSP Processor *)
val _ = Define `
 (elf_ma_pdsp : num= (( 63:num)))`;

(** Digital Equipment Corp. PDP-10 *)
val _ = Define `
 (elf_ma_pdp10 : num= (( 64:num)))`;

(** Digital Equipment Corp. PDP-11 *)
val _ = Define `
 (elf_ma_pdp11 : num= (( 65:num)))`;

(** Siemens FX66 microcontroller *)
val _ = Define `
 (elf_ma_fx66 : num= (( 66:num)))`;

(** STMicroelectronics ST9+ 8/16 bit microcontroller *)
val _ = Define `
 (elf_ma_st9plus : num= (( 67:num)))`;

(** STMicroelectronics ST7 8-bit microcontroller *)
val _ = Define `
 (elf_ma_st7 : num= (( 68:num)))`;

(** Motorola MC68HC16 Microcontroller *)
val _ = Define `
 (elf_ma_68hc16 : num= (( 69:num)))`;

(** Motorola MC68HC11 Microcontroller *)
val _ = Define `
 (elf_ma_68hc11 : num= (( 70:num)))`;

(** Motorola MC68HC08 Microcontroller *)
val _ = Define `
 (elf_ma_68hc08 : num= (( 71:num)))`;

(** Motorola MC68HC05 Microcontroller *)
val _ = Define `
 (elf_ma_68hc05 : num= (( 72:num)))`;

(** Silicon Graphics SVx *)
val _ = Define `
 (elf_ma_svx : num= (( 73:num)))`;

(** STMicroelectronics ST19 8-bit microcontroller *)
val _ = Define `
 (elf_ma_st19 : num= (( 74:num)))`;

(** Digital VAX *)
val _ = Define `
 (elf_ma_vax : num= (( 75:num)))`;

(** Axis Communications 32-bit embedded processor *)
val _ = Define `
 (elf_ma_cris : num= (( 76:num)))`;

(** Infineon Technologies 32-bit embedded processor *)
val _ = Define `
 (elf_ma_javelin : num= (( 77:num)))`;

(** Element 14 64-bit DSP Processor *)
val _ = Define `
 (elf_ma_firepath : num= (( 78:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel209 : num= (( 209:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel208 : num= (( 208:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel207 : num= (( 207:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel206 : num= (( 206:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel205 : num= (( 205:num)))`;

(** Reserved by Intel *)
val _ = Define `
 (elf_ma_intel182 : num= (( 182:num)))`;

(** Reserved by ARM *)
val _ = Define `
 (elf_ma_arm184 : num= (( 184:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved6 : num= (( 6:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved11 : num= (( 11:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved12 : num= (( 12:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved13 : num= (( 13:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved14 : num= (( 14:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved16 : num= (( 16:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved24 : num= (( 24:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved25 : num= (( 25:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved26 : num= (( 26:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved27 : num= (( 27:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved28 : num= (( 28:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved29 : num= (( 29:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved30 : num= (( 30:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved31 : num= (( 31:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved32 : num= (( 32:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved33 : num= (( 33:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved34 : num= (( 34:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved35 : num= (( 35:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved121 : num= (( 121:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved122 : num= (( 122:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved123 : num= (( 123:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved124 : num= (( 124:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved125 : num= (( 125:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved126 : num= (( 126:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved127 : num= (( 127:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved128 : num= (( 128:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved129 : num= (( 129:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved130 : num= (( 130:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved143 : num= (( 143:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved144 : num= (( 144:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved145 : num= (( 145:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved146 : num= (( 146:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved147 : num= (( 147:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved148 : num= (( 148:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved149 : num= (( 149:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved150 : num= (( 150:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved151 : num= (( 151:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved152 : num= (( 152:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved153 : num= (( 153:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved154 : num= (( 154:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved155 : num= (( 155:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved156 : num= (( 156:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved157 : num= (( 157:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved158 : num= (( 158:num)))`;

(** Reserved for future use *)
val _ = Define `
 (elf_ma_reserved159 : num= (( 159:num)))`;


(** [string_of_elf_machine_architecture m] produces a string representation of
  * the numeric encoding [m] of the ELF machine architecture.
  * TODO: finish this .
  *)
(*val string_of_elf_machine_architecture : natural -> string*)
val _ = Define `
 (string_of_elf_machine_architecture m=	
 (if m = elf_ma_386 then
		"Intel 80386"
  else if m = elf_ma_ppc then
    "PowerPC"
  else if m = elf_ma_ppc64 then
    "PowerPC64"
  else if m = elf_ma_arm then
    "AArch"
  else if m = elf_ma_x86_64 then
    "Advanced Micro Devices X86-64"
  else if m = elf_ma_aarch64 then
    "AArch64"
	else
		"Other architecture"))`;


(** ELF version numbers.  Denotes the ELF version number of an ELF file.  Current is
  * defined to have a value of 1 with the present specification.  Extensions
  * may create versions of ELF with higher version numbers.
  *)

(** Invalid version *)
val _ = Define `
 (elf_ev_none : num= (( 0:num)))`;

(** Current version *)
val _ = Define `
 (elf_ev_current : num= (( 1:num)))`;


(** [string_of_elf_version_number m] produces a string representation of the
  * numeric encoding [m] of the ELF version number.
  *)
(*val string_of_elf_version_number : natural -> string*)
val _ = Define `
 (string_of_elf_version_number m=	
 (if m = elf_ev_none then
		"Invalid ELF version"
	else if m = elf_ev_current then
		"1 (current)"
	else
		"Extended ELF version"))`;


(** Check that an extended version number is correct (i.e. greater than 1). *)
val _ = Define `
 (is_valid_extended_version_number (n : num)=  (n >( 1:num)))`;


(** Identification indices.  The initial bytes of an ELF header (and an object
  * file) correspond to the e_ident member.
  *)

(** File identification *)
val _ = Define `
 (elf_ii_mag0 : num= (( 0:num)))`;

(** File identification *)
val _ = Define `
 (elf_ii_mag1 : num= (( 1:num)))`;

(** File identification *)
val _ = Define `
 (elf_ii_mag2 : num= (( 2:num)))`;

(** File identification *)
val _ = Define `
 (elf_ii_mag3 : num= (( 3:num)))`;

(** File class *)
val _ = Define `
 (elf_ii_class : num= (( 4:num)))`;

(** Data encoding *)
val _ = Define `
 (elf_ii_data : num= (( 5:num)))`;

(** File version *)
val _ = Define `
 (elf_ii_version : num= (( 6:num)))`;

(** Operating system/ABI identification *)
val _ = Define `
 (elf_ii_osabi : num= (( 7:num)))`;

(** ABI version *)
val _ = Define `
 (elf_ii_abiversion : num= (( 8:num)))`;

(** Start of padding bytes *)
val _ = Define `
 (elf_ii_pad : num= (( 9:num)))`;

(** Size of e*_ident[] *)
val _ = Define `
 (elf_ii_nident : num= (( 16:num)))`;


(** Magic number indices.  A file's first 4 bytes hold a ``magic number,''
  * identifying the file as an ELF object file.
  *)

(** Position: e*_ident[elf_ii_mag0], 0x7f magic number *)
val _ = Define `
 (elf_mn_mag0 : unsigned_char=  ((n2w : num -> unsigned_char) (( 127:num))))`;

(** Position: e*_ident[elf_ii_mag1], 'E' format identifier *)
val _ = Define `
 (elf_mn_mag1 : unsigned_char=  ((n2w : num -> unsigned_char) (( 69:num))))`;

(** Position: e*_ident[elf_ii_mag2], 'L' format identifier *)
val _ = Define `
 (elf_mn_mag2 : unsigned_char=  ((n2w : num -> unsigned_char) (( 76:num))))`;

(** Position: e*_ident[elf_ii_mag3], 'F' format identifier *)
val _ = Define `
 (elf_mn_mag3 : unsigned_char=  ((n2w : num -> unsigned_char) (( 70:num))))`;


(** ELf file classes.  The file format is designed to be portable among machines
  * of various sizes, without imposing the sizes of the largest machine on the
  * smallest. The class of the file defines the basic types used by the data
  * structures of the object file container itself.
  *)

(** Invalid class *)
val _ = Define `
 (elf_class_none : num= (( 0:num)))`;

(** 32 bit objects *)
val _ = Define `
 (elf_class_32 : num= (( 1:num)))`;

(** 64 bit objects *)
val _ = Define `
 (elf_class_64 : num= (( 2:num)))`;


(** [string_of_elf_file_class m] produces a string representation of the numeric
  * encoding [m] of the ELF file class.
  *)
(*val string_of_elf_file_class : natural -> string*)
val _ = Define `
 (string_of_elf_file_class m=	
 (if m = elf_class_none then
		"Invalid ELF file class"
	else if m = elf_class_32 then
		"ELF32"
	else if m = elf_class_64 then
		"ELF64"
	else
		"Invalid ELF file class"))`;


(** ELF data encodings.  Byte e_ident[elf_ei_data] specifies the encoding of both the
  * data structures used by object file container and data contained in object
  * file sections.
  *)

(** Invalid data encoding *)
val _ = Define `
 (elf_data_none : num= (( 0:num)))`;

(** Two's complement values, least significant byte occupying lowest address *)
val _ = Define `
 (elf_data_2lsb : num= (( 1:num)))`;

(** Two's complement values, most significant byte occupying lowest address *)
val _ = Define `
 (elf_data_2msb : num= (( 2:num)))`;


(** [string_of_elf_data_encoding m] produces a string representation of the
  * numeric encoding [m] of the ELF data encoding.
  *)
(*val string_of_elf_data_encoding : natural -> string*)
val _ = Define `
 (string_of_elf_data_encoding m=	
 (if m = elf_data_none then
		"Invalid data encoding"
	else if m = elf_data_2lsb then
		"2's complement, little endian"
	else if m = elf_data_2msb then
		"2's complement, big endian"
	else
		"Invalid data encoding"))`;


(** OS and ABI versions.  Byte e_ident[elf_ei_osabi] identifies the OS- or
  * ABI-specific ELF extensions used by this file. Some fields in other ELF
  * structures have flags and values that have operating system and/or ABI
  * specific meanings; the interpretation of those fields is determined by the
  * value of this byte.
  *)

(** No extensions or unspecified *)
val _ = Define `
 (elf_osabi_none : num= (( 0:num)))`;

(** Hewlett-Packard HP-UX *)
val _ = Define `
 (elf_osabi_hpux : num= (( 1:num)))`;

(** NetBSD *)
val _ = Define `
 (elf_osabi_netbsd : num= (( 2:num)))`;

(** GNU *)
val _ = Define `
 (elf_osabi_gnu : num= (( 3:num)))`;

(** Linux, historical alias for GNU *)
val _ = Define `
 (elf_osabi_linux : num= (( 3:num)))`;

(** Sun Solaris *)
val _ = Define `
 (elf_osabi_solaris : num= (( 6:num)))`;

(** AIX *)
val _ = Define `
 (elf_osabi_aix : num= (( 7:num)))`;

(** IRIX *)
val _ = Define `
 (elf_osabi_irix : num= (( 8:num)))`;

(** FreeBSD *)
val _ = Define `
 (elf_osabi_freebsd : num= (( 9:num)))`;

(** Compaq Tru64 Unix *)
val _ = Define `
 (elf_osabi_tru64 : num= (( 10:num)))`;

(** Novell Modesto *)
val _ = Define `
 (elf_osabi_modesto : num= (( 11:num)))`;

(** OpenBSD *)
val _ = Define `
 (elf_osabi_openbsd : num= (( 12:num)))`;

(** OpenVMS *)
val _ = Define `
 (elf_osabi_openvms : num= (( 13:num)))`;

(** Hewlett-Packard Non-stop Kernel *)
val _ = Define `
 (elf_osabi_nsk : num= (( 14:num)))`;

(** Amiga Research OS *)
val _ = Define `
 (elf_osabi_aros : num= (( 15:num)))`;

(** FenixOS highly-scalable multi-core OS *)
val _ = Define `
 (elf_osabi_fenixos : num= (( 16:num)))`;

(** Nuxi CloudABI *)
val _ = Define `
 (elf_osabi_cloudabi : num= (( 17:num)))`;

(** Stratus technologies OpenVOS *)
val _ = Define `
 (elf_osabi_openvos : num= (( 18:num)))`;


(** Checks an architecture defined OSABI version is correct, i.e. in the range
  * 64 to 255 inclusive.
  *)
val _ = Define `
 (is_valid_architecture_defined_osabi_version (n : num)=
   ((n >=( 64:num)) /\ (n <=( 255:num))))`;


(** [string_of_elf_osabi_version m] produces a string representation of the
  * numeric encoding [m] of the ELF OSABI version.
  *)
(*val string_of_elf_osabi_version : (natural -> string) -> natural -> string*)
val _ = Define `
 (string_of_elf_osabi_version arch m=	
 (if m = elf_osabi_none then
		"UNIX - System V"
	else if m = elf_osabi_netbsd then
		"Hewlett-Packard HP-UX"
	else if m = elf_osabi_netbsd then
		"NetBSD"
	else if m = elf_osabi_gnu then
		"UNIX - GNU"
	else if m = elf_osabi_linux then
		"Linux"
	else if m = elf_osabi_solaris then
		"Sun Solaris"
	else if m = elf_osabi_aix then
		"AIX"
	else if m = elf_osabi_irix then
		"IRIX"
	else if m = elf_osabi_freebsd then
		"FreeBSD"
	else if m = elf_osabi_tru64 then
		"Compaq Tru64 Unix"
	else if m = elf_osabi_modesto then
		"Novell Modesto"
	else if m = elf_osabi_openbsd then
		"OpenBSD"
	else if m = elf_osabi_openvms then
		"OpenVMS"
	else if m = elf_osabi_nsk then
		"Hewlett-Packard Non-stop Kernel"
	else if m = elf_osabi_aros then
		"Amiga Research OS"
	else if m = elf_osabi_fenixos then
		"FenixOS highly-scalable multi-core OS"
  else if m = elf_osabi_cloudabi then
    "Nuxi CloudABI"
  else if m = elf_osabi_openvos then
    "Stratus technologies OpenVOS"
	else if is_valid_architecture_defined_osabi_version m then
	  arch m
	else
		"Invalid OSABI version"))`;


(** ELF Header type *)

(** [ei_nident] is the fixed length of the identification field in the
  * [elf32_ehdr] type.
  *)
(*val ei_nident : natural*)
val _ = Define `
 (ei_nident= (( 16:num)))`;


(** [elf32_header] is the type of headers for 32-bit ELF files.
  *)
val _ = Hol_datatype `
 elf32_header =
  <| elf32_ident    : unsigned_char list (** Identification field *)
   ; elf32_type     : uint16         (** The object file type *)
   ; elf32_machine  : uint16         (** Required machine architecture *)
   ; elf32_version  : uint32         (** Object file version *)
   ; elf32_entry    : uint32         (** Virtual address for transfer of control *)
   ; elf32_phoff    : uint32          (** Program header table offset in bytes *)
   ; elf32_shoff    : uint32          (** Section header table offset in bytes *)
   ; elf32_flags    : uint32         (** Processor-specific flags *)
   ; elf32_ehsize   : uint16         (** ELF header size in bytes *)
   ; elf32_phentsize: uint16         (** Program header table entry size in bytes *)
   ; elf32_phnum    : uint16         (** Number of entries in program header table *)
   ; elf32_shentsize: uint16         (** Section header table entry size in bytes *)
   ; elf32_shnum    : uint16         (** Number of entries in section header table *)
   ; elf32_shstrndx : uint16         (** Section header table entry for section name string table *)
   |>`;

   
(** [elf64_header] is the type of headers for 64-bit ELF files.
  *)
val _ = Hol_datatype `
 elf64_header =
  <| elf64_ident    : unsigned_char list (** Identification field *)
   ; elf64_type     : uint16         (** The object file type *)
   ; elf64_machine  : uint16         (** Required machine architecture *)
   ; elf64_version  : uint32         (** Object file version *)
   ; elf64_entry    : uint64         (** Virtual address for transfer of control *)
   ; elf64_phoff    : uint64          (** Program header table offset in bytes *)
   ; elf64_shoff    : uint64          (** Section header table offset in bytes *)
   ; elf64_flags    : uint32         (** Processor-specific flags *)
   ; elf64_ehsize   : uint16         (** ELF header size in bytes *)
   ; elf64_phentsize: uint16         (** Program header table entry size in bytes *)
   ; elf64_phnum    : uint16         (** Number of entries in program header table *)
   ; elf64_shentsize: uint16         (** Section header table entry size in bytes *)
   ; elf64_shnum    : uint16         (** Number of entries in section header table *)
   ; elf64_shstrndx : uint16         (** Section header table entry for section name string table *)
   |>`;

   
(** [is_valid_elf32_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
(*val is_valid_elf32_header : elf32_header -> bool*)
val _ = Define `
 (is_valid_elf32_header hdr=  
 (TAKE(( 4 : num)) hdr.elf32_ident = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]))`;

  
(** [is_valid_elf64_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
(*val is_valid_elf64_header : elf64_header -> bool*)
val _ = Define `
 (is_valid_elf64_header hdr=  
 (TAKE(( 4 : num)) hdr.elf64_ident = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]))`;


(** [elf32_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
(*val elf32_header_compare : elf32_header -> elf32_header -> Basic_classes.ordering*)
val _ = Define `
 (elf32_header_compare h1 h2=     
 (pairCompare (lexicographic_compare (genericCompare (<) (=))) (lexicographic_compare (genericCompare (<) (=))) (MAP w2n h1.elf32_ident, [w2n h1.elf32_type; 
            w2n h1.elf32_machine ; w2n h1.elf32_version ; 
            w2n h1.elf32_entry ; w2n h1.elf32_phoff ; w2n h1.elf32_shoff ; 
            w2n h1.elf32_flags ; w2n h1.elf32_ehsize ; 
            w2n h1.elf32_phentsize; w2n h1.elf32_phnum ; 
            w2n h1.elf32_shentsize; w2n h1.elf32_shnum ; 
            w2n h1.elf32_shstrndx])
     (MAP w2n h2.elf32_ident, [w2n h2.elf32_type; 
            w2n h2.elf32_machine ; w2n h2.elf32_version ; 
            w2n h2.elf32_entry ; w2n h2.elf32_phoff ; w2n h2.elf32_shoff ; 
            w2n h2.elf32_flags ; w2n h2.elf32_ehsize ; 
            w2n h2.elf32_phentsize; w2n h2.elf32_phnum ; 
            w2n h2.elf32_shentsize; w2n h2.elf32_shnum ; 
            w2n h2.elf32_shstrndx])))`;


val _ = Define `
(instance_Basic_classes_Ord_Elf_header_elf32_header_dict= (<|

  compare_method := elf32_header_compare;

  isLess_method := (\ f1 .  (\ f2 .  (elf32_header_compare f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (elf32_header_compare f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (elf32_header_compare f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (elf32_header_compare f1 f2) ({GT; EQ})))|>))`;


(** [elf64_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
(*val elf64_header_compare : elf64_header -> elf64_header -> Basic_classes.ordering*)
val _ = Define `
 (elf64_header_compare h1 h2=     
 (pairCompare (lexicographic_compare (genericCompare (<) (=))) (lexicographic_compare (genericCompare (<) (=))) (MAP w2n h1.elf64_ident, [w2n h1.elf64_type; 
            w2n h1.elf64_machine ; w2n h1.elf64_version ; 
            w2n h1.elf64_entry ; w2n h1.elf64_phoff ; w2n h1.elf64_shoff ; 
            w2n h1.elf64_flags ; w2n h1.elf64_ehsize ; 
            w2n h1.elf64_phentsize; w2n h1.elf64_phnum ; 
            w2n h1.elf64_shentsize; w2n h1.elf64_shnum ; 
            w2n h1.elf64_shstrndx])
     (MAP w2n h2.elf64_ident, [w2n h2.elf64_type; 
            w2n h2.elf64_machine ; w2n h2.elf64_version ; 
            w2n h2.elf64_entry ; w2n h2.elf64_phoff ; w2n h2.elf64_shoff ; 
            w2n h2.elf64_flags ; w2n h2.elf64_ehsize ; 
            w2n h2.elf64_phentsize; w2n h2.elf64_phnum ; 
            w2n h2.elf64_shentsize; w2n h2.elf64_shnum ; 
            w2n h2.elf64_shstrndx])))`;


val _ = Define `
(instance_Basic_classes_Ord_Elf_header_elf64_header_dict= (<|

  compare_method := elf64_header_compare;

  isLess_method := (\ f1 .  (\ f2 .  (elf64_header_compare f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (elf64_header_compare f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (elf64_header_compare f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (elf64_header_compare f1 f2) ({GT; EQ})))|>))`;


(** [is_elf32_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
(*val is_elf32_executable_file : elf32_header -> bool*)
val _ = Define `
 (is_elf32_executable_file hdr=  
 (w2n hdr.elf32_type = elf_ft_exec))`;


(** [is_elf64_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
(*val is_elf64_executable_file : elf64_header -> bool*)
val _ = Define `
 (is_elf64_executable_file hdr=  
 (w2n hdr.elf64_type = elf_ft_exec))`;


(** [is_elf32_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
(*val is_elf32_shared_object_file : elf32_header -> bool*)
val _ = Define `
 (is_elf32_shared_object_file hdr=  
 (w2n hdr.elf32_type = elf_ft_dyn))`;


(** [is_elf64_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
(*val is_elf64_shared_object_file : elf64_header -> bool*)
val _ = Define `
 (is_elf64_shared_object_file hdr=  
 (w2n hdr.elf64_type = elf_ft_dyn))`;


(** [is_elf32_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
(*val is_elf32_relocatable_file : elf32_header -> bool*)
val _ = Define `
 (is_elf32_relocatable_file hdr=  
 (w2n hdr.elf32_type = elf_ft_rel))`;


(** [is_elf64_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
(*val is_elf64_relocatable_file : elf64_header -> bool*)
val _ = Define `
 (is_elf64_relocatable_file hdr=  
 (w2n hdr.elf64_type = elf_ft_rel))`;


(** [is_elf32_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
(*val is_elf32_linkable_file : elf32_header -> bool*)
val _ = Define `
 (is_elf32_linkable_file hdr=  
 (is_elf32_shared_object_file hdr \/ is_elf32_relocatable_file hdr))`;


(** [is_elf64_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
(*val is_elf64_linkable_file : elf64_header -> bool*)
val _ = Define `
 (is_elf64_linkable_file hdr=  
 (is_elf64_shared_object_file hdr \/ is_elf64_relocatable_file hdr))`;


(** [get_elf32_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf32_machine_architecture : elf32_header -> natural*)
val _ = Define `
 (get_elf32_machine_architecture hdr=  
 (w2n hdr.elf32_machine))`;


(** [get_elf64_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf64_machine_architecture : elf64_header -> natural*)
val _ = Define `
 (get_elf64_machine_architecture hdr=  
 (w2n hdr.elf64_machine))`;


(** [get_elf32_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf32_osabi : elf32_header -> natural*)
val _ = Define `
 (get_elf32_osabi hdr=  
 ((case lem_list$list_index hdr.elf32_ident ( elf_ii_osabi) of
      SOME osabi => w2n osabi
    | NONE    => failwith "get_elf32_osabi: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf64_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
(*val get_elf64_osabi : elf64_header -> natural*)
val _ = Define `
 (get_elf64_osabi hdr=  
 ((case lem_list$list_index hdr.elf64_ident ( elf_ii_osabi) of
      SOME osabi => w2n osabi
    | NONE    => failwith "get_elf64_osabi: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)
  
(** [get_elf32_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
(*val get_elf32_data_encoding : elf32_header -> natural*)
val _ = Define `
 (get_elf32_data_encoding hdr=  
 ((case lem_list$list_index hdr.elf32_ident ( elf_ii_data) of
      SOME data => w2n data
    | NONE    => failwith "get_elf32_data_encoding: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf64_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
(*val get_elf64_data_encoding : elf64_header -> natural*)
val _ = Define `
 (get_elf64_data_encoding hdr=  
 ((case lem_list$list_index hdr.elf64_ident ( elf_ii_data) of
      SOME data => w2n data
    | NONE    => failwith "get_elf64_data_encoding: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)
  
(** [get_elf32_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
(*val get_elf32_file_class : elf32_header -> natural*)
val _ = Define `
 (get_elf32_file_class hdr=  
 ((case lem_list$list_index hdr.elf32_ident ( elf_ii_class) of
      SOME cls => w2n cls
    | NONE    => failwith "get_elf32_file_class: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf64_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
(*val get_elf64_file_class : elf64_header -> natural*)
val _ = Define `
 (get_elf64_file_class hdr=  
 ((case lem_list$list_index hdr.elf64_ident ( elf_ii_class) of
      SOME cls => w2n cls
    | NONE    => failwith "get_elf64_file_class: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf32_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf32_version_number : elf32_header -> natural*)
val _ = Define `
 (get_elf32_version_number hdr=  
 ((case lem_list$list_index hdr.elf32_ident ( elf_ii_version) of
      SOME ver => w2n ver
    | NONE    => failwith "get_elf32_version_number: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf64_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf64_version_number : elf64_header -> natural*)
val _ = Define `
 (get_elf64_version_number hdr=  
 ((case lem_list$list_index hdr.elf64_ident ( elf_ii_version) of
      SOME ver => w2n ver
    | NONE    => failwith "get_elf64_version_number: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)
  
(** [is_valid_elf32_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf32_header] to create a single
  * correctness check.
  *)
(*val is_valid_elf32_version_number : elf32_header -> bool*)
val _ = Define `
 (is_valid_elf32_version_numer hdr=  
 (get_elf32_version_number hdr = elf_ev_current))`;


(** [is_valid_elf64_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf64_header] to create a single
  * correctness check.
  *)
(*val is_valid_elf64_version_number : elf64_header -> bool*)
val _ = Define `
 (is_valid_elf64_version_numer hdr=  
 (get_elf64_version_number hdr = elf_ev_current))`;

  
(** [get_elf32_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf32_abi_version : elf32_header -> natural*)
val _ = Define `
 (get_elf32_abi_version hdr=  
 ((case lem_list$list_index hdr.elf32_ident ( elf_ii_abiversion) of
      SOME ver => w2n ver
    | NONE    => failwith "get_elf32_abi_version: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)

(** [get_elf64_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
(*val get_elf64_abi_version : elf64_header -> natural*)
val _ = Define `
 (get_elf64_abi_version hdr=  
 ((case lem_list$list_index hdr.elf64_ident ( elf_ii_abiversion) of
      SOME ver => w2n ver
    | NONE    => failwith "get_elf64_abi_version: lookup in ident failed"
  )))`;
 (* Partial: should never return Nothing *)
  
(** [deduce_endianness uc] deduces the endianness of an ELF file based on the ELF
  * header's magic number [uc].
  *)
(*val deduce_endianness : list unsigned_char -> endianness*)
val _ = Define `
 (deduce_endianness id=  
 ((case lem_list$list_index id(( 5 : num)) of
      NONE => failwith "deduce_endianness: read of magic number has failed"
    | SOME v  =>
      if w2n v = elf_data_2lsb then
        Little
      else if w2n v = elf_data_2msb then
        Big
      else
        failwith "deduce_endianness: value is not valid"
  )))`;


(** [get_elf32_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
(*val get_elf32_header_endianness : elf32_header -> endianness*)
val _ = Define `
 (get_elf32_header_endianness hdr=  
 (deduce_endianness (hdr.elf32_ident)))`;


(** [get_elf64_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
(*val get_elf64_header_endianness : elf64_header -> endianness*)
val _ = Define `
 (get_elf64_header_endianness hdr=  
 (deduce_endianness (hdr.elf64_ident)))`;

  
(** [has_elf32_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
(*val has_elf32_header_associated_entry_point : elf32_header -> bool*)
val _ = Define `
 (has_elf32_header_associated_entry_point hdr=  (~ ((w2n hdr.elf32_entry) =(( 0:num)))))`;


(** [has_elf64_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
(*val has_elf64_header_associated_entry_point : elf64_header -> bool*)
val _ = Define `
 (has_elf64_header_associated_entry_point hdr=  (~ ((w2n hdr.elf64_entry) =(( 0:num)))))`;

  
(** [has_elf32_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
(*val has_elf32_header_string_table : elf32_header -> bool*)
val _ = Define `
 (has_elf32_header_string_table hdr=  (~ ((w2n hdr.elf32_shstrndx) = shn_undef)))`;

  
(** [has_elf64_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
(*val has_elf64_header_string_table : elf64_header -> bool*)
val _ = Define `
 (has_elf64_header_string_table hdr=  (~ ((w2n hdr.elf64_shstrndx) = shn_undef)))`;

  
(** [is_elf32_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
(*val is_elf32_header_section_size_in_section_header_table : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_section_size_in_section_header_table hdr=  
 (w2n hdr.elf32_shnum =( 0:num)))`;

  
(** [is_elf64_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
(*val is_elf64_header_section_size_in_section_header_table : elf64_header -> bool*)
val _ = Define `
 (is_elf64_header_section_size_in_section_header_table hdr=  
 (w2n hdr.elf64_shnum =( 0:num)))`;

  
(** [is_elf32_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
(*val is_elf32_header_string_table_index_in_link : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_string_table_index_in_link hdr=  
 (w2n hdr.elf32_shstrndx = shn_xindex))`;

  
(** [is_elf64_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
(*val is_elf64_header_string_table_index_in_link : elf64_header -> bool*)
val _ = Define `
 (is_elf64_header_string_table_index_in_link hdr=  
 (w2n hdr.elf64_shstrndx = shn_xindex))`;


(** The [hdr_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
val _ = type_abbrev( "hdr_print_bundle" , ``: (num -> string) # (num -> string)``);

(** [string_of_elf32_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
(*val string_of_elf32_header : hdr_print_bundle -> elf32_header -> string*)
val _ = Define `
 (string_of_elf32_header (os, proc) hdr=	
 (unlines [
	   STRCAT"\t"  (STRCAT"Magic number: " (string_of_list 
  instance_Show_Show_Elf_types_native_uint_unsigned_char_dict hdr.elf32_ident))
  ;  STRCAT"\t"  (STRCAT"Endianness: " (string_of_endianness (deduce_endianness hdr.elf32_ident)))
	;  STRCAT"\t"  (STRCAT"Type: " (string_of_elf_file_type os proc (w2n hdr.elf32_type)))
  ;  STRCAT"\t"  (STRCAT"Version: " (string_of_elf_version_number (w2n hdr.elf32_version)))
	;  STRCAT"\t"  (STRCAT"Machine: " (string_of_elf_machine_architecture (w2n hdr.elf32_machine)))
  ;  STRCAT"\t"  (STRCAT"Entry point: " ((num_to_dec_string o w2n) hdr.elf32_entry))
  ;  STRCAT"\t"  (STRCAT"Flags: " ((num_to_dec_string o w2n) hdr.elf32_flags))
  ;  STRCAT"\t"  (STRCAT"Entries in program header table: " ((num_to_dec_string o w2n) hdr.elf32_phnum))
  ;  STRCAT"\t"  (STRCAT"Entries in section header table: " ((num_to_dec_string o w2n) hdr.elf32_shnum))
	]))`;


(** [string_of_elf64_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
(*val string_of_elf64_header : hdr_print_bundle -> elf64_header -> string*)
val _ = Define `
 (string_of_elf64_header (os, proc) hdr=  
 (unlines [
     STRCAT"\t"  (STRCAT"Magic number: " (string_of_list 
  instance_Show_Show_Elf_types_native_uint_unsigned_char_dict hdr.elf64_ident))
  ;  STRCAT"\t"  (STRCAT"Endianness: " (string_of_endianness (deduce_endianness hdr.elf64_ident)))
  ;  STRCAT"\t"  (STRCAT"Type: " (string_of_elf_file_type os proc (w2n hdr.elf64_type)))
  ;  STRCAT"\t"  (STRCAT"Version: " (string_of_elf_version_number (w2n hdr.elf64_version)))
  ;  STRCAT"\t"  (STRCAT"Machine: " (string_of_elf_machine_architecture (w2n hdr.elf64_machine)))
  ;  STRCAT"\t"  (STRCAT"Entry point: " ((num_to_dec_string o w2n) hdr.elf64_entry))
  ;  STRCAT"\t"  (STRCAT"Flags: " ((num_to_dec_string o w2n) hdr.elf64_flags))
  ;  STRCAT"\t"  (STRCAT"Entries in program header table: " ((num_to_dec_string o w2n) hdr.elf64_phnum))
  ;  STRCAT"\t"  (STRCAT"Entries in section header table: " ((num_to_dec_string o w2n) hdr.elf64_shnum))
  ]))`;


(** The following are thin wrappers around the pretty-printing functions above
  * using a default print bundle for the header.
  *)
  
(*val string_of_elf32_header_default : elf32_header -> string*)
val _ = Define `
 (string_of_elf32_header_default=	
 (string_of_elf32_header
    (default_os_specific_print,
      default_proc_specific_print)))`;


(*val string_of_elf64_header_default : elf64_header -> string*)
val _ = Define `
 (string_of_elf64_header_default=  
 (string_of_elf64_header
    (default_os_specific_print,
      default_proc_specific_print)))`;

	
val _ = Define `
(instance_Show_Show_Elf_header_elf32_header_dict= (<|

  show_method := string_of_elf32_header_default|>))`;


val _ = Define `
(instance_Show_Show_Elf_header_elf64_header_dict= (<|

  show_method := string_of_elf64_header_default|>))`;


(** [read_elf_ident bs0] reads the initial bytes of an ELF file from byte sequence
  * [bs0], returning the remainder of the byte sequence too.
  * Fails if transcription fails.
  *)
(*val read_elf_ident : byte_sequence -> error (list unsigned_char * byte_sequence)*)
val _ = Define `
 (read_elf_ident bs=  
(repeatM' ei_nident bs (read_unsigned_char default_endianness)))`;


(** [bytes_of_elf32_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
(*val bytes_of_elf32_header : elf32_header -> byte_sequence*)
val _ = Define `
 (bytes_of_elf32_header hdr=  
 (let endian = (deduce_endianness hdr.elf32_ident) in
    byte_sequence$from_byte_lists [
      MAP I hdr.elf32_ident
    ; bytes_of_elf32_half endian hdr.elf32_type
    ; bytes_of_elf32_half endian hdr.elf32_machine
    ; bytes_of_elf32_word endian hdr.elf32_version
    ; bytes_of_elf32_addr endian hdr.elf32_entry
    ; bytes_of_elf32_off  endian hdr.elf32_phoff
    ; bytes_of_elf32_off  endian hdr.elf32_shoff
    ; bytes_of_elf32_word endian hdr.elf32_flags
    ; bytes_of_elf32_half endian hdr.elf32_ehsize
    ; bytes_of_elf32_half endian hdr.elf32_phentsize
    ; bytes_of_elf32_half endian hdr.elf32_phnum
    ; bytes_of_elf32_half endian hdr.elf32_shentsize
    ; bytes_of_elf32_half endian hdr.elf32_shnum
    ; bytes_of_elf32_half endian hdr.elf32_shstrndx
    ]))`;

    
(** [bytes_of_elf64_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
(*val bytes_of_elf64_header : elf64_header -> byte_sequence*)
val _ = Define `
 (bytes_of_elf64_header hdr=  
 (let endian = (deduce_endianness hdr.elf64_ident) in
    byte_sequence$from_byte_lists [
      MAP I hdr.elf64_ident
    ; bytes_of_elf64_half endian hdr.elf64_type
    ; bytes_of_elf64_half endian hdr.elf64_machine
    ; bytes_of_elf64_word endian hdr.elf64_version
    ; bytes_of_elf64_addr endian hdr.elf64_entry
    ; bytes_of_elf64_off  endian hdr.elf64_phoff
    ; bytes_of_elf64_off  endian hdr.elf64_shoff
    ; bytes_of_elf64_word endian hdr.elf64_flags
    ; bytes_of_elf64_half endian hdr.elf64_ehsize
    ; bytes_of_elf64_half endian hdr.elf64_phentsize
    ; bytes_of_elf64_half endian hdr.elf64_phnum
    ; bytes_of_elf64_half endian hdr.elf64_shentsize
    ; bytes_of_elf64_half endian hdr.elf64_shnum
    ; bytes_of_elf64_half endian hdr.elf64_shstrndx
    ]))`;

    
(*val is_elf32_header_padding_correct : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_padding_correct ehdr=
   ((lem_list$list_index ehdr.elf32_ident(( 9 : num))  = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 10 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 11 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 12 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 13 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 14 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num)))) /\  
(lem_list$list_index ehdr.elf32_ident(( 15 : num)) = SOME ((n2w : num -> unsigned_char) (( 0:num))))))`;


(*val is_magic_number_correct : list unsigned_char -> bool*)
val _ = Define `
 (is_magic_number_correct ident=
   ((lem_list$list_index ident(( 0 : num)) = SOME ((n2w : num -> unsigned_char) (( 127:num)))) /\  
(lem_list$list_index ident(( 1 : num)) = SOME ((n2w : num -> unsigned_char) (( 69:num))))  /\  
(lem_list$list_index ident(( 2 : num)) = SOME ((n2w : num -> unsigned_char) (( 76:num))))  /\  
(lem_list$list_index ident(( 3 : num)) = SOME ((n2w : num -> unsigned_char) (( 70:num))))))`;


(** [read_elf32_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
(*val read_elf32_header : byte_sequence -> error (elf32_header * byte_sequence)*)
val _ = Define `
 (read_elf32_header bs=	
 (read_elf_ident bs >>= (\ (ident, bs) . 
	if ~ (is_magic_number_correct ident) then
	  fail0 "read_elf32_header: magic number incorrect"
	else
    let endian = (deduce_endianness ident) in
	  read_elf32_half endian bs >>= (\ (typ, bs) . 
	  read_elf32_half endian bs >>= (\ (machine, bs) . 
	  read_elf32_word endian bs >>= (\ (version, bs) . 
	  read_elf32_addr endian bs >>= (\ (entry, bs) . 
	  read_elf32_off  endian bs >>= (\ (phoff, bs) . 
	  read_elf32_off  endian bs >>= (\ (shoff, bs) . 
	  read_elf32_word endian bs >>= (\ (flags, bs) . 
	  read_elf32_half endian bs >>= (\ (ehsize, bs) . 
	  read_elf32_half endian bs >>= (\ (phentsize, bs) . 
	  read_elf32_half endian bs >>= (\ (phnum, bs) . 
	  read_elf32_half endian bs >>= (\ (shentsize, bs) . 
	  read_elf32_half endian bs >>= (\ (shnum, bs) . 
	  read_elf32_half endian bs >>= (\ (shstrndx, bs) . 
    (case lem_list$list_index ident(( 4 : num)) of
        NONE => fail0 "read_elf32_header: transcription of ELF identifier failed"
      | SOME c  =>
        if w2n c = elf_class_32 then
		      return (<| elf32_ident := ident; elf32_type  := typ;
                      elf32_machine := machine; elf32_version := version;
                      elf32_entry := entry; elf32_phoff := phoff;
                      elf32_shoff := shoff; elf32_flags := flags;
                      elf32_ehsize := ehsize; elf32_phentsize := phentsize;
                      elf32_phnum := phnum; elf32_shentsize := shentsize;
                      elf32_shnum := shnum; elf32_shstrndx := shstrndx |>, bs)
        else
          fail0 "read_elf32_header: not a 32-bit ELF file"
    )))))))))))))))))`;


(** [read_elf64_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
(*val read_elf64_header : byte_sequence -> error (elf64_header * byte_sequence)*)
val _ = Define `
 (read_elf64_header bs=  
 (read_elf_ident bs >>= (\ (ident, bs) . 
  if ~ (is_magic_number_correct ident) then
    fail0 "read_elf64_header: magic number incorrect"
  else
    let endian = (deduce_endianness ident) in
    read_elf64_half endian bs >>= (\ (typ, bs) . 
    read_elf64_half endian bs >>= (\ (machine, bs) . 
    read_elf64_word endian bs >>= (\ (version, bs) . 
    read_elf64_addr endian bs >>= (\ (entry, bs) . 
    read_elf64_off  endian bs >>= (\ (phoff, bs) . 
    read_elf64_off  endian bs >>= (\ (shoff, bs) . 
    read_elf64_word endian bs >>= (\ (flags, bs) . 
    read_elf64_half endian bs >>= (\ (ehsize, bs) . 
    read_elf64_half endian bs >>= (\ (phentsize, bs) . 
    read_elf64_half endian bs >>= (\ (phnum, bs) . 
    read_elf64_half endian bs >>= (\ (shentsize, bs) . 
    read_elf64_half endian bs >>= (\ (shnum, bs) . 
    read_elf64_half endian bs >>= (\ (shstrndx, bs) . 
    (case lem_list$list_index ident(( 4 : num)) of
        NONE => fail0 "read_elf64_header: transcription of ELF identifier failed"
      | SOME c  =>
        if w2n c = elf_class_64 then
          return (<| elf64_ident := ident; elf64_type  := typ;
                     elf64_machine := machine; elf64_version := version;
                     elf64_entry := entry; elf64_phoff := phoff;
                     elf64_shoff := shoff; elf64_flags := flags;
                     elf64_ehsize := ehsize; elf64_phentsize := phentsize;
                     elf64_phnum := phnum; elf64_shentsize := shentsize;
                     elf64_shnum := shnum; elf64_shstrndx := shstrndx |>, bs)
        else
          fail0 "read_elf64_header: not a 64-bit ELF file"
    )))))))))))))))))`;


(** [is_elf32_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
(*val is_elf32_header_class_correct : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_class_correct ehdr=  
 (lem_list$list_index ehdr.elf32_ident(( 4 : num)) = SOME ((n2w : num -> unsigned_char) (( 1:num)))))`;

  
(** [is_elf64_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
(*val is_elf64_header_class_correct : elf64_header -> bool*)
val _ = Define `
 (is_elf64_header_class_correct ehdr=  
 (lem_list$list_index ehdr.elf64_ident(( 4 : num)) = SOME ((n2w : num -> unsigned_char) (( 1:num)))))`;


(** [is_elf32_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
(*val is_elf32_header_version_correct : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_version_correct ehdr=  
 (lem_list$list_index ehdr.elf32_ident(( 6 : num)) = SOME ((n2w : num -> unsigned_char) (( 1:num)))))`;

  
(** [is_elf64_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
(*val is_elf64_header_version_correct : elf64_header -> bool*)
val _ = Define `
 (is_elf64_header_version_correct ehdr=  
 (lem_list$list_index ehdr.elf64_ident(( 6 : num)) = SOME ((n2w : num -> unsigned_char) (( 1:num)))))`;


(** [is_elf32_header_valid] checks whether an [elf32_header] value is a valid 32-bit
  * ELF file header (i.e. [elf32_ident] is [ei_nident] entries long, and other
  * constraints on headers).
  *)
(*val is_elf32_header_valid : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_valid ehdr=
   ((((LENGTH ehdr.elf32_ident):num) = ei_nident) /\
  is_magic_number_correct ehdr.elf32_ident /\
  is_elf32_header_padding_correct ehdr /\
  is_elf32_header_class_correct ehdr /\
  is_elf32_header_version_correct ehdr))`;


(** [get_elf32_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_program_table_size : elf32_header -> natural*)
val _ = Define `
 (get_elf32_header_program_table_size ehdr=  
 (let phentsize = (w2n ehdr.elf32_phentsize) in
  let phnum     = (w2n ehdr.elf32_phnum) in
    phentsize * phnum))`;


(** [get_elf64_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_program_table_size : elf64_header -> natural*)
val _ = Define `
 (get_elf64_header_program_table_size ehdr=  
 (let phentsize = (w2n ehdr.elf64_phentsize) in
  let phnum     = (w2n ehdr.elf64_phnum) in
    phentsize * phnum))`;


(** [is_elf32_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf32_header_section_table_present : elf32_header -> bool*)
val _ = Define `
 (is_elf32_header_section_table_present ehdr=  
 (~ (w2n ehdr.elf32_shoff =( 0:num))))`;


(** [is_elf64_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf64_header_section_table_present : elf64_header -> bool*)
val _ = Define `
 (is_elf64_header_section_table_present ehdr=  
 (~ (w2n ehdr.elf64_shoff =( 0:num))))`;


(** [get_elf32_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_section_table_size : elf32_header -> natural*)
val _ = Define `
 (get_elf32_header_section_table_size ehdr=  
 (let shentsize = (w2n ehdr.elf32_shentsize) in
  let shnum     = (w2n ehdr.elf32_shnum) in
    shentsize * shnum))`;


(** [get_elf64_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_section_table_size : elf64_header -> natural*)
val _ = Define `
 (get_elf64_header_section_table_size ehdr=  
 (let shentsize = (w2n ehdr.elf64_shentsize) in
  let shnum     = (w2n ehdr.elf64_shnum) in
    shentsize * shnum))`;

val _ = export_theory()

