(*Generated by Lem from elf_section_header_table.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_functionTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory showTheory missing_pervasivesTheory errorTheory byte_sequenceTheory endiannessTheory elf_types_native_uintTheory elf_headerTheory string_tableTheory lem_mapTheory elf_program_header_tableTheory;

val _ = numLib.prefer_num();



val _ = new_theory "elf_section_header_table"

(** [elf_section_header_table] provides types, functions and other definitions
  * for working with section header tables and their entries.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Function*)
(*open import List*)
(*open import Map*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(*open import Endianness*)
(*open import String_table*)

(*open import Elf_header*)
(*open import Elf_types_native_uint*)
(*open import Elf_program_header_table*)

(** Special section indices. *)

(** See elf_header.lem for shn_undef *)

(** [shn_loreserve]: this specifies the lower bound of the range of reserved
  * indices.
  *)
val _ = Define `
 (shn_loreserve : num= (( 65280:num)))`;
 (* 0xff00 *)
(** [shn_loproc]: start of the range reserved for processor-specific semantics.
  *)
val _ = Define `
 (shn_loproc : num= (( 65280:num)))`;
 (* 0xff00 *)
(** [shn_hiproc]: end of the range reserved for processor-specific semantics.
  *)
val _ = Define `
 (shn_hiproc : num= (( 65311:num)))`;
 (* 0xff1f *)
(** [shn_loos]: start of the range reserved for operating system-specific
  * semantics.
  *)
val _ = Define `
 (shn_loos : num= (( 65312:num)))`;
 (* 0xff20 *)
(** [shn_hios]: end of the range reserved for operating system-specific
  * semantics.
  *)
val _ = Define `
 (shn_hios : num= (( 65343:num)))`;
 (* 0xff3f *)
(** [shn_abs]: specifies the absolute values for the corresponding reference.
  * Symbols defined relative to section number [shn_abs] have absolute values
  * and are not affected by relocation.
  *)
val _ = Define `
 (shn_abs : num= (( 65521:num)))`;
 (* 0xfff1 *)
(** [shn_common]: symbols defined relative to this index are common symbols,
  * such as unallocated C external variables.
  *)
val _ = Define `
 (shn_common : num= (( 65522:num)))`;
 (* 0xfff2 *)

(** See elf_header.lem for shn_xindex. *)

(** [shn_hireserve]: specifies the upper-bound of reserved values.
  *)
val _ = Define `
 (shn_hireserve : num= (( 65535:num)))`;
 (* 0xffff *)

(** [string_of_special_section_index m] produces a string-based representation
  * of a section header entry's special section index, [m].
  *)
(*val string_of_special_section_index : natural -> string*)
val _ = Define `
 (string_of_special_section_index i=  
 (if i = shn_undef then
    "SHN_UNDEF"
  else if i = shn_loreserve then
    "SHN_LORESERVE"
  else if (i >= shn_loproc) /\ (i <= shn_hiproc) then
    "SHN_PROCESSOR_SPECIFIC"
  else if (i >= shn_loos) /\ (i <= shn_hios) then
    "SHN_OS_SPECIFIC"
  else if i = shn_abs then
    "SHN_ABS"
  else if i = shn_common then
    "SHN_COMMON"
  else if i = shn_xindex then
    "SHN_XINDEX"
  else if i = shn_hireserve then
    "SHN_HIRESERVE"
  else
  	"SHN UNDEFINED"))`;


(** Section types. *)

(** Marks the section header as being inactive. *)
val _ = Define `
 (sht_null : num= (( 0:num)))`;

(** Section holds information defined by the program. *)
val _ = Define `
 (sht_progbits : num= (( 1:num)))`;

(** The following two section types hold a symbol table.  An object file may only
  * have one symbol table of each of the respective types.  The symtab provides
  * a place for link editing, whereas the dynsym section holds a minimal set of
  * dynamic linking symbols
  *)
val _ = Define `
 (sht_symtab : num= (( 2:num)))`;

val _ = Define `
 (sht_dynsym : num= (( 11:num)))`;

(** Section holds a string table *)
val _ = Define `
 (sht_strtab : num= (( 3:num)))`;

(** Section holds relocation entries with explicit addends.  An object file may
  * have multiple section of this type.
  *)
val _ = Define `
 (sht_rela : num= (( 4:num)))`;

(** Section holds a symbol hash table.  An object file may only have a single
  * hash table.
  *)
val _ = Define `
 (sht_hash : num= (( 5:num)))`;

(** Section holds information for dynamic linking.  An object file may only have
  * a single dynamic section.
  *)
val _ = Define `
 (sht_dynamic : num= (( 6:num)))`;

(** Section holds information that marks the file in some way. *)
val _ = Define `
 (sht_note : num= (( 7:num)))`;

(** Section occupies no space in the file but otherwise resembles a progbits
  * section.
  *)
val _ = Define `
 (sht_nobits : num= (( 8:num)))`;

(** Section holds relocation entries without explicit addends.  An object file
  * may have multiple section of this type.
  *)
val _ = Define `
 (sht_rel : num= (( 9:num)))`;

(** Section type is reserved but has an unspecified meaning. *)
val _ = Define `
 (sht_shlib : num= (( 10:num)))`;

(** Section contains an array of pointers to initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
val _ = Define `
 (sht_init_array : num= (( 14:num)))`;

(** Section contains an array of pointers to termination functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
val _ = Define `
 (sht_fini_array : num= (( 15:num)))`;

(** Section contains an array of pointers to initialisation functions that are
  * invoked before all other initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
val _ = Define `
 (sht_preinit_array : num= (( 16:num)))`;

(** Section defines a section group, i.e. a set of sections that are related and
  * must be treated especially by the linker.  May only appear in relocatable
  * objects.
  *)
val _ = Define `
 (sht_group : num= (( 17:num)))`;

(** Section is associated with sections of type SHT_SYMTAB and is required if
  * any of the section header indices referenced by that symbol table contains
  * the escape value SHN_XINDEX.
  *
  * FIXME: Lem bug as [int] type used throughout Lem codebase, rather than
  * [BigInt.t], so Lem chokes on these large constants below, hence the weird
  * way in which they are written.
  *)
val _ = Define `
 (sht_symtab_shndx : num= (( 18:num)))`;


(** The following ranges are reserved solely for OS-, processor- and user-
  * specific semantics, respectively.
  *)
val _ = Define `
 (sht_loos   : num= (((( 3:num) *( 1024:num)) *( 1024:num)) *( 512:num)))`;
 (* 1610612736 (* 0x60000000 *) *)
val _ = Define `
 (sht_hios   : num=  ((( 469762047:num) *( 4:num)) +( 3:num)))`;
 (* 1879048191 (* 0x6fffffff *) *)
val _ = Define `
 (sht_loproc : num=  (( 469762048:num) *( 4:num)))`;
 (* 1879048192 (* 0x70000000 *) *)
val _ = Define `
 (sht_hiproc : num=  ((( 536870911:num) *( 4:num)) +( 3:num)))`;
 (* 2147483647 (* 0x7fffffff *) *)
val _ = Define `
 (sht_louser : num=  (( 536870912:num) *( 4:num)))`;
 (* 2147483648 (* 0x80000000 *) *)
val _ = Define `
 (sht_hiuser : num=  ((( 603979775:num) *( 4:num)) +( 3:num)))`;
 (* 2415919103 (* 0x8fffffff *) *)

(** [string_of_section_type os proc user i] produces a string-based representation
  * of section type [i].  Some section types are defined by ABI-specific supplements
  * in reserved ranges, in which case the functions [os], [proc] and [user] are
  * used to produce the string.
  *)
(*val string_of_section_type : (natural -> string) -> (natural -> string) ->
  (natural -> string) -> natural -> string*)
val _ = Define `
 (string_of_section_type os proc user i=  
 (if i = sht_null then
    "NULL"
  else if i = sht_progbits then
    "PROGBITS"
  else if i = sht_symtab then
    "SYMTAB"
  else if i = sht_strtab then
    "STRTAB"
  else if i = sht_rela then
    "RELA"
  else if i = sht_hash then
    "HASH"
  else if i = sht_dynamic then
    "DYNAMIC"
  else if i = sht_note then
    "NOTE"
  else if i = sht_nobits then
    "NOBITS"
  else if i = sht_rel then
    "REL"
  else if i = sht_shlib then
    "SHLIB"
  else if i = sht_dynsym then
    "DYNSYM"
  else if i = sht_init_array then
    "INIT_ARRAY"
  else if i = sht_fini_array then
    "FINI_ARRAY"
  else if i = sht_preinit_array then
    "PREINIT_ARRAY"
  else if i = sht_group then
    "GROUP"
  else if i = sht_symtab_shndx then
    "SYMTAB_SHNDX"
  else if (i >= sht_loos) /\ (i <= sht_hios) then
    os i 
  else if (i >= sht_loproc) /\ (i <= sht_hiproc) then
    proc i
  else if (i >= sht_louser) /\ (i <= sht_hiuser) then
    user i
  else
    "Undefined or invalid section type"))`;


(** Section flag numeric values. *)

(** The section contains data that should be writable during program execution.
  *)
val _ = Define `
 (shf_write            : num= (( 1:num)))`;

(** The section occupies memory during program execution.
  *)
val _ = Define `
 (shf_alloc            : num= (( 2:num)))`;

(** The section contains executable instructions.
  *)
val _ = Define `
 (shf_execinstr        : num= (( 4:num)))`;

(** The data in the section may be merged to reduce duplication.  Each section
  * is compared based on name, type and flags set with sections with identical
  * values at run time being mergeable.
  *)
val _ = Define `
 (shf_merge            : num= (( 16:num)))`;

(** The section contains null-terminated character strings.
  *)
val _ = Define `
 (shf_strings          : num= (( 32:num)))`;

(** The [info] field of this section header contains a section header table
  * index.
  *)
val _ = Define `
 (shf_info_link        : num= (( 64:num)))`;

(** Adds special link ordering for link editors.
  *)
val _ = Define `
 (shf_link_order       : num= (( 128:num)))`;

(** This section requires special OS-specific processing beyond the standard
  * link rules.
  *)
val _ = Define `
 (shf_os_nonconforming : num= (( 256:num)))`;

(** This section is a member (potentially the only member) of a link group.
  *)
val _ = Define `
 (shf_group            : num= (( 512:num)))`;

(** This section contains Thread Local Storage (TLS) meaning that each thread of
  * execution has its own instance of this data.
  *)
val _ = Define `
 (shf_tls              : num= (( 1024:num)))`;

(** This section contains compressed data.  Compressed data may not be marked as
  * allocatable.
  *)
val _ = Define `
 (shf_compressed       : num= (( 2048:num)))`;

(** All bits included in these masks are reserved for OS and processor specific
  * semantics respectively.
  *)
val _ = Define `
 (shf_mask_os          : num= (( 267386880:num)))`;
      (* 0x0ff00000 *)
val _ = Define `
 (shf_mask_proc        : num= (( 4:num) *( 1006632960:num)))`;
 (* 0xf0000000 *)

(** [string_of_section_flags os proc f] produces a string based representation
  * of section flag [f].  Some section flags are defined by the ABI and are in
  * reserved ranges, in which case the flag string is produced by functions
  * [os] and [proc].
  * TODO: add more as validation tests require them.
  *)
(*val string_of_section_flags : (natural -> string) -> (natural -> string) ->
  natural -> string*)
val _ = Define `
 (string_of_section_flags os proc f=  
 (if f = shf_write then
    "W"
  else if f = shf_alloc then
    "  A"
  else if f = shf_execinstr then
    "  X"
  else if f = (shf_alloc + shf_execinstr) then
    " AX"
  else if f = (shf_write + shf_alloc) then
    " WA"
  else if f = shf_merge then
    " M "
  else if f = (shf_merge + shf_alloc) then
    " AM"
  else if f = ((shf_merge + shf_alloc) + shf_strings) then
    "AMS"
  else if f = ((shf_alloc + shf_execinstr) + shf_group) then
    "AXG"
  else if f = shf_strings then
    "  S"
  else if f = (shf_merge + shf_strings) then
    " MS"
  else if f = shf_tls then
    "  T"
  else if f = (shf_tls + shf_alloc) then
    " AT"
  else if f = ((shf_write + shf_alloc) + shf_tls) then
    "WAT"
  else if f = shf_info_link then
    "  I"
  else if f = (shf_alloc + shf_info_link) then
    " AI"
  else
    "   "))`;


(** Section compression. *)

(** Type [elf32_compression_header] provides information about the compression and
  * decompression of compressed sections.  All compressed sections on ELF32 begin
  * with an [elf32_compression_header] entry.
  *)
val _ = Hol_datatype `
 elf32_compression_header =
  <| elf32_chdr_type      : uint32  (** Specifies the compression algorithm *)
   ; elf32_chdr_size      : uint32  (** Size in bytes of the uncompressed data *)
   ; elf32_chdr_addralign : uint32  (** Specifies the required alignment of the uncompressed data *)
   |>`;


(** Type [elf64_compression_header] provides information about the compression and
  * decompression of compressed sections.  All compressed sections on ELF64 begin
  * with an [elf64_compression_header] entry.
  *)   
val _ = Hol_datatype `
 elf64_compression_header =
  <| elf64_chdr_type      : uint32  (** Specified the compression algorithm *)
   ; elf64_chdr_reserved  : uint32  (** Reserved. *)
   ; elf64_chdr_size      : uint64 (** Size in bytes of the uncompressed data *)
   ; elf64_chdr_addralign : uint64 (** Specifies the required alignment of the uncompressed data *)
   |>`;


(** This section is compressed with the ZLIB algorithm.  The compressed data begins
  * at the first byte immediately following the end of the compression header.
  *)   
val _ = Define `
 (elfcompress_zlib   : num= (( 1:num)))`;


(** Values in these ranges are reserved for OS-specific semantics.
  *)
val _ = Define `
 (elfcompress_loos   : num= (( 4:num) *( 402653184:num)))`;
       (* 0x60000000 *)
val _ = Define `
 (elfcompress_hios   : num=  ((( 2:num) *( 939524095:num)) +( 1:num)))`;
 (* 0x6fffffff *)

(** Values in these ranges are reserved for processor-specific semantics.
  *)
val _ = Define `
 (elfcompress_loproc : num= (( 4:num) *( 469762048:num)))`;
        (* 0x70000000 *)
val _ = Define `
 (elfcompress_hiproc : num=  ((( 2:num) *( 1073741823:num)) +( 1:num)))`;
 (* 0x7fffffff *)

(** [read_elf32_compression_header ed bs0] reads an [elf32_compression_header]
  * entry from byte sequence [bs0], interpreting [bs0] with endianness [ed].
  * Also returns the suffix of [bs0] after reading in the compression header.
  * Fails if the header cannot be read.
  *)
(*val read_elf32_compression_header : endianness -> byte_sequence ->
  error (elf32_compression_header * byte_sequence)*)
val _ = Define `
 (read_elf32_compression_header ed bs0=  
 (read_elf32_word ed bs0 >>= (\ (typ, bs1) . 
  read_elf32_word ed bs1 >>= (\ (siz, bs2) . 
  read_elf32_word ed bs2 >>= (\ (ali, bs3) . 
  return (<| elf32_chdr_type := typ; elf32_chdr_size := siz;
    elf32_chdr_addralign := ali |>, bs3))))))`;


(** [read_elf64_compression_header ed bs0] reads an [elf64_compression_header]
  * entry from byte sequence [bs0], interpreting [bs0] with endianness [ed].
  * Also returns the suffix of [bs0] after reading in the compression header.
  * Fails if the header cannot be read.
  *)
(*val read_elf64_compression_header : endianness -> byte_sequence ->
  error (elf64_compression_header * byte_sequence)*)
val _ = Define `
 (read_elf64_compression_header ed bs0=  
 (read_elf64_word ed bs0  >>= (\ (typ, bs1) . 
  read_elf64_word ed bs1  >>= (\ (res, bs2) . 
  read_elf64_xword ed bs2 >>= (\ (siz, bs3) . 
  read_elf64_xword ed bs3 >>= (\ (ali, bs4) . 
  return (<| elf64_chdr_type := typ; elf64_chdr_reserved := res;
    elf64_chdr_size := siz; elf64_chdr_addralign := ali |>, bs4)))))))`;


(** Section header table entry type. *)

(** [elf32_section_header_table_entry] is the type of entries in the section
  * header table in 32-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
val _ = Hol_datatype `
 elf32_section_header_table_entry =
  <| elf32_sh_name      : uint32 (** Name of the section *)
   ; elf32_sh_type      : uint32 (** Type of the section and its semantics *)
   ; elf32_sh_flags     : uint32 (** Flags associated with the section *)
   ; elf32_sh_addr      : uint32 (** Address of first byte of section in memory image *)
   ; elf32_sh_offset    : uint32  (** Offset from beginning of file of first byte of section *)
   ; elf32_sh_size      : uint32 (** Section size in bytes *)
   ; elf32_sh_link      : uint32 (** Section header table index link *)
   ; elf32_sh_info      : uint32 (** Extra information, contents depends on type of section *)
   ; elf32_sh_addralign : uint32 (** Alignment constraints for section *)
   ; elf32_sh_entsize   : uint32 (** Size of each entry in table, if section is one *)
   |>`;

   
val _ = Define `
(elf32_null_section_header=  
 (<| elf32_sh_name      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_type      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_flags     := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_addr      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_offset    := ((n2w : num -> uint32) (( 0:num))) 
   ; elf32_sh_size      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_link      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_info      := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_addralign := ((n2w : num -> uint32) (( 0:num)))
   ; elf32_sh_entsize   := ((n2w : num -> uint32) (( 0:num)))
   |>))`;

   
(** [compare_elf32_section_header_table_entry ent1 ent2] is an ordering comparison
  * function on section header table entries suitable for use in constructing
  * sets, finite maps and other ordered data types.
  *)
(*val compare_elf32_section_header_table_entry : elf32_section_header_table_entry ->
  elf32_section_header_table_entry -> ordering*)
val _ = Define `
 (compare_elf32_section_header_table_entry h1 h2=    
 (lexicographic_compare (genericCompare (<) (=)) 
    [w2n h1.elf32_sh_name;
    w2n h1.elf32_sh_type; 
    w2n h1.elf32_sh_flags;
    w2n h1.elf32_sh_addr; 
    w2n h1.elf32_sh_offset;
    w2n h1.elf32_sh_size; 
    w2n h1.elf32_sh_link; 
    w2n h1.elf32_sh_info; 
    w2n h1.elf32_sh_addralign; 
    w2n h1.elf32_sh_entsize]
    [w2n h2.elf32_sh_name;
    w2n h2.elf32_sh_type; 
    w2n h2.elf32_sh_flags;
    w2n h2.elf32_sh_addr; 
    w2n h2.elf32_sh_offset;
    w2n h2.elf32_sh_size; 
    w2n h2.elf32_sh_link; 
    w2n h2.elf32_sh_info; 
    w2n h2.elf32_sh_addralign; 
    w2n h2.elf32_sh_entsize]))`;


val _ = Define `
(instance_Basic_classes_Ord_Elf_section_header_table_elf32_section_header_table_entry_dict= (<|

  compare_method := compare_elf32_section_header_table_entry;

  isLess_method := (\ f1 .  (\ f2 .  (compare_elf32_section_header_table_entry f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (compare_elf32_section_header_table_entry f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (compare_elf32_section_header_table_entry f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (compare_elf32_section_header_table_entry f1 f2) ({GT; EQ})))|>))`;


(** [elf64_section_header_table_entry] is the type of entries in the section
  * header table in 64-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
val _ = Hol_datatype `
 elf64_section_header_table_entry =
  <| elf64_sh_name      : uint32  (** Name of the section *)
   ; elf64_sh_type      : uint32  (** Type of the section and its semantics *)
   ; elf64_sh_flags     : uint64 (** Flags associated with the section *)
   ; elf64_sh_addr      : uint64  (** Address of first byte of section in memory image *)
   ; elf64_sh_offset    : uint64   (** Offset from beginning of file of first byte of section *)
   ; elf64_sh_size      : uint64 (** Section size in bytes *)
   ; elf64_sh_link      : uint32  (** Section header table index link *)
   ; elf64_sh_info      : uint32  (** Extra information, contents depends on type of section *)
   ; elf64_sh_addralign : uint64 (** Alignment constraints for section *)
   ; elf64_sh_entsize   : uint64 (** Size of each entry in table, if section is one *)
   |>`;

   
val _ = Define `
(elf64_null_section_header=  
 (<| elf64_sh_name      := ((n2w : num -> uint32) (( 0:num))) 
   ; elf64_sh_type      := ((n2w : num -> uint32) (( 0:num))) 
   ; elf64_sh_flags     := ((n2w : num -> uint64) (( 0:num)))
   ; elf64_sh_addr      := ((n2w : num -> uint64) (( 0:num))) 
   ; elf64_sh_offset    := ((n2w : num -> uint64) (( 0:num)))  
   ; elf64_sh_size      := ((n2w : num -> uint64) (( 0:num)))
   ; elf64_sh_link      := ((n2w : num -> uint32) (( 0:num))) 
   ; elf64_sh_info      := ((n2w : num -> uint32) (( 0:num))) 
   ; elf64_sh_addralign := ((n2w : num -> uint64) (( 0:num)))
   ; elf64_sh_entsize   := ((n2w : num -> uint64) (( 0:num)))
   |>))`;


(** [compare_elf64_section_header_table_entry ent1 ent2] is an ordering comparison
  * function on section header table entries suitable for use in constructing
  * sets, finite maps and other ordered data types.
  *)
(*val compare_elf64_section_header_table_entry : elf64_section_header_table_entry ->
  elf64_section_header_table_entry -> ordering*)
val _ = Define `
 (compare_elf64_section_header_table_entry h1 h2=    
 (lexicographic_compare (genericCompare (<) (=)) 
    [w2n h1.elf64_sh_name;
    w2n h1.elf64_sh_type; 
    w2n h1.elf64_sh_flags;
    w2n h1.elf64_sh_addr; 
    w2n h1.elf64_sh_offset;
    w2n h1.elf64_sh_size; 
    w2n h1.elf64_sh_link; 
    w2n h1.elf64_sh_info; 
    w2n h1.elf64_sh_addralign; 
    w2n h1.elf64_sh_entsize]
    [w2n h2.elf64_sh_name;
    w2n h2.elf64_sh_type; 
    w2n h2.elf64_sh_flags;
    w2n h2.elf64_sh_addr; 
    w2n h2.elf64_sh_offset;
    w2n h2.elf64_sh_size; 
    w2n h2.elf64_sh_link; 
    w2n h2.elf64_sh_info; 
    w2n h2.elf64_sh_addralign; 
    w2n h2.elf64_sh_entsize]))`;


val _ = Define `
(instance_Basic_classes_Ord_Elf_section_header_table_elf64_section_header_table_entry_dict= (<|

  compare_method := compare_elf64_section_header_table_entry;

  isLess_method := (\ f1 .  (\ f2 .  (compare_elf64_section_header_table_entry f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (compare_elf64_section_header_table_entry f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (compare_elf64_section_header_table_entry f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (compare_elf64_section_header_table_entry f1 f2) ({GT; EQ})))|>))`;


(** Section header table type *)

(** Type [elf32_section_header_table] represents a section header table for 32-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
val _ = type_abbrev( "elf32_section_header_table" , ``: elf32_section_header_table_entry
  list``);

(** Type [elf64_section_header_table] represents a section header table for 64-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
val _ = type_abbrev( "elf64_section_header_table" , ``: elf64_section_header_table_entry
  list``);

(** Parsing and blitting *)

(** [bytes_of_elf32_section_header_table_entry ed ent] blits [ent] to a byte sequence
  * assuming endianness [ed].
  *)
(*val bytes_of_elf32_section_header_table_entry : endianness ->
  elf32_section_header_table_entry -> byte_sequence*)
val _ = Define `
 (bytes_of_elf32_section_header_table_entry endian entry=  
 (byte_sequence$from_byte_lists [
    bytes_of_elf32_word endian entry.elf32_sh_name
  ; bytes_of_elf32_word endian entry.elf32_sh_type
  ; bytes_of_elf32_word endian entry.elf32_sh_flags
  ; bytes_of_elf32_addr endian entry.elf32_sh_addr
  ; bytes_of_elf32_off  endian entry.elf32_sh_offset
  ; bytes_of_elf32_word endian entry.elf32_sh_size
  ; bytes_of_elf32_word endian entry.elf32_sh_link
  ; bytes_of_elf32_word endian entry.elf32_sh_info
  ; bytes_of_elf32_word endian entry.elf32_sh_addralign
  ; bytes_of_elf32_word endian entry.elf32_sh_entsize
  ]))`;


(** [read_elf32_section_header_table_entry ed bs0] reads a section header table
  * entry from [bs0] assuming endianness [ed].  Also returns the suffix of [bs0]
  * after parsing.  Fails if the entry cannot be read.
  *)
(*val read_elf32_section_header_table_entry : endianness -> byte_sequence ->
  error (elf32_section_header_table_entry * byte_sequence)*)
val _ = Define `
 (read_elf32_section_header_table_entry endian bs=	
 (read_elf32_word endian bs >>= (\ (sh_name, bs) . 
	read_elf32_word endian bs >>= (\ (sh_type, bs) . 
	read_elf32_word endian bs >>= (\ (sh_flags, bs) . 
	read_elf32_addr endian bs >>= (\ (sh_addr, bs) . 
	read_elf32_off  endian bs >>= (\ (sh_offset, bs) . 
	read_elf32_word endian bs >>= (\ (sh_size, bs) . 
	read_elf32_word endian bs >>= (\ (sh_link, bs) . 
	read_elf32_word endian bs >>= (\ (sh_info, bs) . 
	read_elf32_word endian bs >>= (\ (sh_addralign, bs) . 
	read_elf32_word endian bs >>= (\ (sh_entsize, bs) . 
		return (<| elf32_sh_name := sh_name; elf32_sh_type := sh_type;
                elf32_sh_flags := sh_flags; elf32_sh_addr := sh_addr;
                elf32_sh_offset := sh_offset; elf32_sh_size := sh_size;
                elf32_sh_link := sh_link; elf32_sh_info := sh_info;
                elf32_sh_addralign := sh_addralign; elf32_sh_entsize := sh_entsize |>, bs)))))))))))))`;


(** [bytes_of_elf64_section_header_table_entry ed ent] blits [ent] to a byte sequence
  * assuming endianness [ed].
  *)
(*val bytes_of_elf64_section_header_table_entry : endianness ->
  elf64_section_header_table_entry -> byte_sequence*)
val _ = Define `
 (bytes_of_elf64_section_header_table_entry endian entry=  
 (byte_sequence$from_byte_lists [
    bytes_of_elf64_word  endian entry.elf64_sh_name
  ; bytes_of_elf64_word  endian entry.elf64_sh_type
  ; bytes_of_elf64_xword endian entry.elf64_sh_flags
  ; bytes_of_elf64_addr  endian entry.elf64_sh_addr
  ; bytes_of_elf64_off   endian entry.elf64_sh_offset
  ; bytes_of_elf64_xword endian entry.elf64_sh_size
  ; bytes_of_elf64_word  endian entry.elf64_sh_link
  ; bytes_of_elf64_word  endian entry.elf64_sh_info
  ; bytes_of_elf64_xword endian entry.elf64_sh_addralign
  ; bytes_of_elf64_xword endian entry.elf64_sh_entsize
  ]))`;


(** [read_elf64_section_header_table_entry ed bs0] reads a section header table
  * entry from [bs0] assuming endianness [ed].  Also returns the suffix of [bs0]
  * after parsing.  Fails if the entry cannot be read.
  *)
(*val read_elf64_section_header_table_entry : endianness -> byte_sequence ->
  error (elf64_section_header_table_entry * byte_sequence)*)
val _ = Define `
 (read_elf64_section_header_table_entry endian bs=  
 (read_elf64_word endian bs  >>= (\ (sh_name, bs) . 
  read_elf64_word endian bs  >>= (\ (sh_type, bs) . 
  read_elf64_xword endian bs >>= (\ (sh_flags, bs) . 
  read_elf64_addr endian bs  >>= (\ (sh_addr, bs) . 
  read_elf64_off  endian bs  >>= (\ (sh_offset, bs) . 
  read_elf64_xword endian bs >>= (\ (sh_size, bs) . 
  read_elf64_word endian bs  >>= (\ (sh_link, bs) . 
  read_elf64_word endian bs  >>= (\ (sh_info, bs) . 
  read_elf64_xword endian bs >>= (\ (sh_addralign, bs) . 
  read_elf64_xword endian bs >>= (\ (sh_entsize, bs) . 
    return (<| elf64_sh_name := sh_name; elf64_sh_type := sh_type;
                elf64_sh_flags := sh_flags; elf64_sh_addr := sh_addr;
                elf64_sh_offset := sh_offset; elf64_sh_size := sh_size;
                elf64_sh_link := sh_link; elf64_sh_info := sh_info;
                elf64_sh_addralign := sh_addralign; elf64_sh_entsize := sh_entsize |>, bs)))))))))))))`;


(** [bytes_of_elf32_section_header_table ed tbl] blits section header table [tbl]
  * to a byte sequence assuming endianness [ed].
  *)
(*val bytes_of_elf32_section_header_table : endianness ->
  elf32_section_header_table -> byte_sequence*)
val _ = Define `
 (bytes_of_elf32_section_header_table endian tbl=  
 (byte_sequence$concat0 (MAP (bytes_of_elf32_section_header_table_entry endian) tbl)))`;

  
(** [bytes_of_elf64_section_header_table ed tbl] blits section header table [tbl]
  * to a byte sequence assuming endianness [ed].
  *)
(*val bytes_of_elf64_section_header_table : endianness ->
  elf64_section_header_table -> byte_sequence*)
val _ = Define `
 (bytes_of_elf64_section_header_table endian tbl=  
 (byte_sequence$concat0 (MAP (bytes_of_elf64_section_header_table_entry endian) tbl)))`;


(** [read_elf32_section_header_table' ed bs0] parses an ELF32 section header table
  * from byte sequence [bs0] assuming endianness [ed].  Assumes [bs0] is of the
  * exact length required to parse the entire table.
  * Fails if any of the section header table entries cannot be parsed.
  *)
(*val read_elf32_section_header_table' : endianness -> byte_sequence ->
  error elf32_section_header_table*)
 val read_elf32_section_header_table'_defn = Hol_defn "read_elf32_section_header_table'" `
 (read_elf32_section_header_table' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf32_section_header_table_entry endian bs0 >>= (\ (entry, bs1) . 
    read_elf32_section_header_table' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf32_section_header_table'_defn;
    
(** [read_elf64_section_header_table' ed bs0] parses an ELF64 section header table
  * from byte sequence [bs0] assuming endianness [ed].  Assumes [bs0] is of the
  * exact length required to parse the entire table.
  * Fails if any of the section header table entries cannot be parsed.
  *)
(*val read_elf64_section_header_table' : endianness -> byte_sequence ->
  error elf64_section_header_table*)
 val read_elf64_section_header_table'_defn = Hol_defn "read_elf64_section_header_table'" `
 (read_elf64_section_header_table' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf64_section_header_table_entry endian bs0 >>= (\ (entry, bs1) . 
    read_elf64_section_header_table' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf64_section_header_table'_defn;

(** [read_elf32_section_header_table sz ed bs0] parses an ELF32 section header
  * table from a [sz] sized prefix of byte sequence [bs0] assuming endianness
  * [ed].  The suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the section header entries cannot be parsed or if [sz] is
  * greater than the length of [bs0].
  *)
(*val read_elf32_section_header_table : natural -> endianness -> byte_sequence ->
  error (elf32_section_header_table * byte_sequence)*)
val _ = Define `
 (read_elf32_section_header_table table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf32_section_header_table' endian eat >>= (\ entries . 
  return (entries, rest)))))`;



(** [read_elf64_section_header_table sz ed bs0] parses an ELF64 section header
  * table from a [sz] sized prefix of byte sequence [bs0] assuming endianness
  * [ed].  The suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the section header entries cannot be parsed or if [sz] is
  * greater than the length of [bs0].
  *)
(*val read_elf64_section_header_table : natural -> endianness -> byte_sequence ->
  error (elf64_section_header_table * byte_sequence)*)
val _ = Define `
 (read_elf64_section_header_table table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf64_section_header_table' endian eat >>= (\ entries . 
  return (entries, rest)))))`;



(** Correctness criteria *)

(** TODO: what is going on here? *)
(*val elf32_size_correct : elf32_section_header_table_entry ->
  elf32_section_header_table -> bool*)
val _ = Define `
 (elf32_size_correct hdr tbl=  
 (let m = (w2n hdr.elf32_sh_size) in
    if m =( 0:num) then
      T
    else
      m = ((LENGTH tbl):num)))`;



(** TODO: what is going on here? *)
(*val elf64_size_correct : elf64_section_header_table_entry ->
  elf64_section_header_table -> bool*)
val _ = Define `
 (elf64_size_correct hdr tbl=  
 (let m = (w2n hdr.elf64_sh_size) in
    if m =( 0:num) then
      T
    else
      m = ((LENGTH tbl):num)))`;



(** [is_elf32_addr_addralign_correct ent] checks whether an internal address
  * alignment constraint is met on section header table [ent].
  * TODO: needs tweaking to add in power-of-two constraint, too.
  *)
(*val is_elf32_addr_addralign_correct : elf32_section_header_table_entry -> bool*)
val _ = Define `
 (is_elf32_addr_addralign_correct ent=  
 (let align = (w2n ent.elf32_sh_addralign) in
  let addr  = (w2n ent.elf32_sh_addr) in
    if (addr MOD align) =( 0:num) then      
(align =( 0:num)) \/ (align =( 1:num)) (* TODO: or a power of two *)
    else
      F))`;

    
(** [is_elf64_addr_addralign_correct ent] checks whether an internal address
  * alignment constraint is met on section header table [ent].
  * TODO: needs tweaking to add in power-of-two constraint, too.
  *)
(*val is_elf64_addr_addralign_correct : elf64_section_header_table_entry -> bool*)
val _ = Define `
 (is_elf64_addr_addralign_correct ent=  
 (let align = (w2n ent.elf64_sh_addralign) in
  let addr  = (w2n ent.elf64_sh_addr) in
    if (addr MOD align) =( 0:num) then      
(align =( 0:num)) \/ (align =( 1:num)) (* TODO: or a power of two *)
    else
      F))`;


(** [is_valid_elf32_section_header_table sht] checks whether all entries of
  * section header table [sht] are valid.
  *)
(*val is_valid_elf32_section_header_table : elf32_section_header_table -> bool*)
val _ = Define `
 (is_valid_elf32_section_header_table tbl=  
 ((case tbl of
      []    => T
    | x::xs =>        
(w2n x.elf32_sh_name =( 0:num)) /\        
(w2n x.elf32_sh_type = sht_null) /\        
(w2n x.elf32_sh_flags =( 0:num)) /\        
(w2n x.elf32_sh_addr =( 0:num)) /\        
(w2n x.elf32_sh_offset =( 0:num)) /\        
(w2n x.elf32_sh_info =( 0:num)) /\        
(w2n x.elf32_sh_addralign =( 0:num)) /\        
(w2n x.elf32_sh_entsize =( 0:num)) /\
        elf32_size_correct x tbl
        (* XXX: more correctness criteria in time *)
  )))`;

  
(** [is_valid_elf64_section_header_table sht] checks whether all entries of
  * section header table [sht] are valid.
  *)
(*val is_valid_elf64_section_header_table : elf64_section_header_table -> bool*)
val _ = Define `
 (is_valid_elf64_section_header_table tbl=  
 ((case tbl of
      []    => T
    | x::xs =>        
(w2n x.elf64_sh_name =( 0:num)) /\        
(w2n x.elf64_sh_type = sht_null) /\        
(w2n x.elf64_sh_flags =( 0:num)) /\        
(w2n x.elf64_sh_addr =( 0:num)) /\        
(w2n x.elf64_sh_offset =( 0:num)) /\        
(w2n x.elf64_sh_info =( 0:num)) /\        
(w2n x.elf64_sh_addralign =( 0:num)) /\        
(w2n x.elf64_sh_entsize =( 0:num)) /\
        elf64_size_correct x tbl
        (* XXX: more correctness criteria in time *)
  )))`;


(** Pretty printing *)

(** The [sht_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
val _ = type_abbrev( "sht_print_bundle" , ``:
  (num -> string) # (num -> string) # (num -> string)``);

(** [string_of_elf32_section_header_table_entry sht ent] produces a string
  * representation of section header table entry [ent] using [sht], a
  * [sht_print_bundle].
  * OCaml specific definition.
  *)
(*val string_of_elf32_section_header_table_entry : sht_print_bundle ->
  elf32_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf32_section_header_table_entry (os, proc, user) entry=  
 (unlines [
     STRCAT"\t"     (STRCAT"Name: " ((num_to_dec_string o w2n) entry.elf32_sh_name))
  ;  STRCAT"\t"     (STRCAT"Type: " (string_of_section_type os proc user (w2n entry.elf32_sh_type)))
  ;  STRCAT"\t"    (STRCAT"Flags: " ((num_to_dec_string o w2n) entry.elf32_sh_flags))
  ;  STRCAT"\t"  (STRCAT"Address: " ((num_to_dec_string o w2n) entry.elf32_sh_addr))
  ;  STRCAT"\t"     (STRCAT"Size: " ((num_to_dec_string o w2n) entry.elf32_sh_size))
  ]))`;


(** [string_of_elf64_section_header_table_entry sht ent] produces a string
  * representation of section header table entry [ent] using [sht], a
  * [sht_print_bundle].
  * OCaml specific definition.
  *)
(*val string_of_elf64_section_header_table_entry : sht_print_bundle ->
  elf64_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf64_section_header_table_entry (os, proc, user) entry=  
 (unlines [
     STRCAT"\t"     (STRCAT"Name: " ((num_to_dec_string o w2n) entry.elf64_sh_name))
  ;  STRCAT"\t"     (STRCAT"Type: " (string_of_section_type os proc user (w2n entry.elf64_sh_type)))
  ;  STRCAT"\t"    (STRCAT"Flags: " ((num_to_dec_string o w2n) entry.elf64_sh_flags))
  ;  STRCAT"\t"  (STRCAT"Address: " ((num_to_dec_string o w2n) entry.elf64_sh_addr))
  ;  STRCAT"\t"     (STRCAT"Size: " ((num_to_dec_string o w2n) entry.elf64_sh_size))
  ]))`;


(** [string_of_elf32_section_header_table_entry' sht stab ent] produces a string
  * representation of section header table entry [ent] using [sht] and section
  * header string table [stab] to print the name of the section header entry
  * correctly.
  * OCaml specific definition.
  *)
(*val string_of_elf32_section_header_table_entry' : sht_print_bundle ->
  string_table -> elf32_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf32_section_header_table_entry' (os, proc, user) stbl entry=  
 (let name =    
((case get_string_at (w2n entry.elf32_sh_name) stbl of
        Fail _ => "Invalid index into string table"
      | Success i => i
    ))
  in
    unlines [
       STRCAT"\t"     (STRCAT"Name: " name)
    ;  STRCAT"\t"     (STRCAT"Type: " (string_of_section_type os proc user (w2n entry.elf32_sh_type)))
    ;  STRCAT"\t"    (STRCAT"Flags: " ((num_to_dec_string o w2n) entry.elf32_sh_flags))
    ;  STRCAT"\t"  (STRCAT"Address: " ((num_to_dec_string o w2n) entry.elf32_sh_addr))
    ;  STRCAT"\t"     (STRCAT"Size: " ((num_to_dec_string o w2n) entry.elf32_sh_size))
    ]))`;


(** [string_of_elf64_section_header_table_entry' sht stab ent] produces a string
  * representation of section header table entry [ent] using [sht] and section
  * header string table [stab] to print the name of the section header entry
  * correctly.
  * OCaml specific definition.
  *)
(*val string_of_elf64_section_header_table_entry' : sht_print_bundle ->
  string_table -> elf64_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf64_section_header_table_entry' (os, proc, user) stbl entry=  
 (let name =    
((case get_string_at (w2n entry.elf64_sh_name) stbl of
        Fail _ => "Invalid index into string table"
      | Success i => i
    ))
  in
    unlines [
       STRCAT"\t"     (STRCAT"Name: " name)
    ;  STRCAT"\t"     (STRCAT"Type: " (string_of_section_type os proc user (w2n entry.elf64_sh_type)))
    ;  STRCAT"\t"    (STRCAT"Flags: " ((num_to_dec_string o w2n) entry.elf64_sh_flags))
    ;  STRCAT"\t"  (STRCAT"Address: " ((num_to_dec_string o w2n) entry.elf64_sh_addr))
    ;  STRCAT"\t"     (STRCAT"Size: " ((num_to_dec_string o w2n) entry.elf64_sh_size))
    ]))`;


(** The following defintions are default printing functions, with no ABI-specific
  * functionality, in order to produce a [Show] instance for section header
  * table entries.
  *)
  
(*val string_of_elf32_section_header_table_entry_default : elf32_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf32_section_header_table_entry_default=  
 (string_of_elf32_section_header_table_entry
    ((K "*Default OS specific print*"),
      (K "*Default processor specific print*"),
      (K "*Default user specific print*"))))`;


val _ = Define `
(instance_Show_Show_Elf_section_header_table_elf32_section_header_table_entry_dict= (<|

  show_method := string_of_elf32_section_header_table_entry_default|>))`;


(*val string_of_elf64_section_header_table_entry_default : elf64_section_header_table_entry -> string*)
val _ = Define `
 (string_of_elf64_section_header_table_entry_default=  
 (string_of_elf64_section_header_table_entry
    ((K "*Default OS specific print*"),
      (K "*Default processor specific print*"),
      (K "*Default user specific print*"))))`;


val _ = Define `
(instance_Show_Show_Elf_section_header_table_elf64_section_header_table_entry_dict= (<|

  show_method := string_of_elf64_section_header_table_entry_default|>))`;


(*val string_of_elf32_section_header_table : sht_print_bundle ->
  elf32_section_header_table -> string*)
val _ = Define `
 (string_of_elf32_section_header_table sht_bdl tbl=  
 (unlines (MAP (string_of_elf32_section_header_table_entry sht_bdl) tbl)))`;


(*val string_of_elf32_section_header_table_default : elf32_section_header_table ->
  string*)
val _ = Define `
 (string_of_elf32_section_header_table_default=  
 (string_of_elf32_section_header_table
    ((K "*Default OS specific print*"),
      (K "*Default processor specific print*"),
      (K "*Default user specific print*"))))`;


(*val string_of_elf64_section_header_table : sht_print_bundle ->
  elf64_section_header_table -> string*)
val _ = Define `
 (string_of_elf64_section_header_table sht_bdl tbl=  
 (unlines (MAP (string_of_elf64_section_header_table_entry sht_bdl) tbl)))`;

  
(*val string_of_elf64_section_header_table_default : elf64_section_header_table ->
  string*)
val _ = Define `
 (string_of_elf64_section_header_table_default=  
 (string_of_elf64_section_header_table
    ((K "*Default OS specific print*"),
      (K "*Default processor specific print*"),
      (K "*Default user specific print*"))))`;


(*val string_of_elf32_section_header_table' : sht_print_bundle -> string_table ->
  elf32_section_header_table -> string*)
val _ = Define `
 (string_of_elf32_section_header_table' sht_bdl stbl tbl=  
 (unlines (MAP (string_of_elf32_section_header_table_entry' sht_bdl stbl) tbl)))`;


(*val string_of_elf64_section_header_table' : sht_print_bundle -> string_table ->
  elf64_section_header_table -> string*)
val _ = Define `
 (string_of_elf64_section_header_table' sht_bdl stbl tbl=  
 (unlines (MAP (string_of_elf64_section_header_table_entry' sht_bdl stbl) tbl)))`;

  
(** Section to segment mappings *)

(** [elf32_tbss_special shdr seg] implements the ELF_TBSS_SPECIAL macro from readelf:
  *
  * #define ELF_TBSS_SPECIAL(sec_hdr, segment)			\
  *   (((sec_hdr)->sh_flags & SHF_TLS) != 0				\
  *   && (sec_hdr)->sh_type == SHT_NOBITS				\
  *   && (segment)->p_type != PT_TLS)
  *
  * From readelf source code, file [internal.h].
  *
  *)
(*val is_elf32_tbss_special : elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
val _ = Define `
 (is_elf32_tbss_special sec_hdr segment=  (~ ((word_and sec_hdr.elf32_sh_flags ((n2w : num -> uint32) shf_tls)) = ((n2w : num -> uint32) (( 0:num)))) /\
    ((w2n sec_hdr.elf32_sh_type) = sht_nobits) /\
    ( ~ ((w2n segment.elf32_p_type) = elf_pt_tls))))`;

    
(** [elf64_tbss_special shdr seg] implements the ELF_TBSS_SPECIAL macro from readelf:
  *
  * #define ELF_TBSS_SPECIAL(sec_hdr, segment)			\
  *   (((sec_hdr)->sh_flags & SHF_TLS) != 0				\
  *   && (sec_hdr)->sh_type == SHT_NOBITS				\
  *   && (segment)->p_type != PT_TLS)
  *
  * From readelf source code, file [internal.h].
  *
  *)
(*val is_elf64_tbss_special : elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
val _ = Define `
 (is_elf64_tbss_special sec_hdr segment=  (~ ((word_and sec_hdr.elf64_sh_flags ((n2w : num -> uint64) shf_tls)) = ((n2w : num -> uint64) (( 0:num)))) /\
    ((w2n sec_hdr.elf64_sh_type) = sht_nobits) /\
    ( ~ ((w2n segment.elf64_p_type) = elf_pt_tls))))`;


(** [get_elf32_section_to_segment_mapping hdr sht pht isin stbl] computes the
  * section to segment mapping for an ELF file using information in the section
  * header table [sht], program header table [pht] and file header [hdr].  A
  * string table [stbl] is taken to produce the string output.  The test whether
  * a section lies withing a segment is ABI specific, so [isin] is used to perform
  * the test.
  *)
(*val get_elf32_section_to_segment_mapping : elf32_header -> elf32_section_header_table -> elf32_program_header_table_entry ->
  (elf32_header -> elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool) ->
  string_table -> error (list string)*)
 val get_elf32_section_to_segment_mapping_defn = Hol_defn "get_elf32_section_to_segment_mapping" `
 (get_elf32_section_to_segment_mapping hdr sects pent isin stbl=  
 ((case sects of
      []    => return []
    | x::xs =>
      if is_elf32_tbss_special x pent then
        get_elf32_section_to_segment_mapping hdr xs pent isin stbl
      else if ~ (isin hdr x pent) then
        get_elf32_section_to_segment_mapping hdr xs pent isin stbl
      else
        let nm = (w2n x.elf32_sh_name) in
          get_string_at nm stbl >>= (\ str . 
          get_elf32_section_to_segment_mapping hdr xs pent isin stbl >>= (\ tl . 
          return (str :: tl)))
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn get_elf32_section_to_segment_mapping_defn;
  
(** [get_elf64_section_to_segment_mapping hdr sht pht isin stbl] computes the
  * section to segment mapping for an ELF file using information in the section
  * header table [sht], program header table [pht] and file header [hdr].  A
  * string table [stbl] is taken to produce the string output.  The test whether
  * a section lies withing a segment is ABI specific, so [isin] is used to perform
  * the test.
  *)
(*val get_elf64_section_to_segment_mapping : elf64_header -> elf64_section_header_table -> elf64_program_header_table_entry ->
  (elf64_header -> elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool) ->
  string_table -> error (list string)*)
 val get_elf64_section_to_segment_mapping_defn = Hol_defn "get_elf64_section_to_segment_mapping" `
 (get_elf64_section_to_segment_mapping hdr sects pent isin stbl=  
 ((case sects of
      []    => return []
    | x::xs =>
      if ~ (isin hdr x pent) then
        get_elf64_section_to_segment_mapping hdr xs pent isin stbl
      else if is_elf64_tbss_special x pent then
        get_elf64_section_to_segment_mapping hdr xs pent isin stbl
      else
        let nm = (w2n x.elf64_sh_name) in
          get_string_at nm stbl >>= (\ str . 
          get_elf64_section_to_segment_mapping hdr xs pent isin stbl >>= (\ tl . 
          return (str :: tl)))
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn get_elf64_section_to_segment_mapping_defn;
  
(** Section groups *)

(** This is a COMDAT group and may duplicate other COMDAT groups in other object
  * files.
  *)
val _ = Define `
 (grp_comdat   : num= (( 1:num)))`;


(** Any bits in the following mask ranges are reserved exclusively for OS and
  * processor specific semantics, respectively.
  *)
val _ = Define `
 (grp_maskos   : num= (( 267386880:num)))`;
      (* 0x0ff00000 *)
val _ = Define `
 (grp_maskproc : num= (( 4:num) *( 1006632960:num)))`;
 (* 0xf0000000 *)

(** [obtain_elf32_section_group_indices endian sht bs0] extracts all section header
  * table indices of sections that are marked as being part of a section group.
  *)
(*val obtain_elf32_section_group_indices : endianness -> elf32_section_header_table -> byte_sequence
  -> error (list (natural * list elf32_word))*)
val _ = Define `
 (obtain_elf32_section_group_indices endian sht bs0=  
 (let filtered = (FILTER (\ ent . 
    w2n ent.elf32_sh_type = sht_group) sht)
  in
    mapM (\ grp . 
      let off = (w2n grp.elf32_sh_offset) in
      let siz = (w2n grp.elf32_sh_size) in
      let cnt = (siz DIV( 4:num)) (* size of elf32_word in bytes *) in
      byte_sequence$offset_and_cut off siz bs0 >>= (\ rel . 
      error$repeatM' cnt rel (read_elf32_word endian) >>= 
  (\p .  (case (p ) of
             ( (mems, _) ) =>
         (case mems of
               [] => fail0
                       "obtain_elf32_section_group_indices: section group sections must consist of at least one elf32_word"
           | x::xs =>
         let flag = (w2n x) in return (flag, xs)
         )
         )))
    ) filtered))`;

    
(** [obtain_elf64_section_group_indices endian sht bs0] extracts all section header
  * table indices of sections that are marked as being part of a section group.
  *)
(*val obtain_elf64_section_group_indices : endianness -> elf64_section_header_table -> byte_sequence
  -> error (list (natural * list elf64_word))*)
val _ = Define `
 (obtain_elf64_section_group_indices endian sht bs0=  
 (let filtered = (FILTER (\ ent . 
    w2n ent.elf64_sh_type = sht_group) sht)
  in
    mapM (\ grp . 
      let off = (w2n grp.elf64_sh_offset) in
      let siz = (w2n grp.elf64_sh_size) in
      let cnt = (siz DIV( 4:num)) (* size of elf64_word in bytes *) in
      byte_sequence$offset_and_cut off siz bs0 >>= (\ rel . 
      error$repeatM' cnt rel (read_elf64_word endian) >>= 
  (\p .  (case (p ) of
             ( (mems, _) ) =>
         (case mems of
               [] => fail0
                       "obtain_elf64_section_group_indices: section group sections must consist of at least one elf64_word"
           | x::xs =>
         let flag = (w2n x) in return (flag, xs)
         )
         )))
    ) filtered))`;


(** [obtain_elf32_tls_template sht] extracts the TLS template (i.e. all sections
  * in section header table [sht] that have their TLS flag bit set).
  *)
(*val obtain_elf32_tls_template : elf32_section_header_table -> elf32_section_header_table*)
val _ = Define `
 (obtain_elf32_tls_template sht=  
 (FILTER (\ ent . 
    let flags = (w2n ent.elf32_sh_flags) in ~ ((natural_land flags shf_tls) =(( 0:num)))) sht))`;


(** [obtain_elf64_tls_template sht] extracts the TLS template (i.e. all sections
  * in section header table [sht] that have their TLS flag bit set).
  *)
(*val obtain_elf64_tls_template : elf64_section_header_table -> elf64_section_header_table*)
val _ = Define `
 (obtain_elf64_tls_template sht=  
 (FILTER (\ ent . 
    let flags = (w2n ent.elf64_sh_flags) in ~ ((natural_land flags shf_tls) =(( 0:num)))) sht))`;

      
(** [obtain_elf32_hash_table endian sht bs0] extracts a hash table from an ELF file
  * providing a section of type SHT_HASH exists in section header table [sht].
  * Extraction is from byte sequence [bs0] assuming endianness [endian].  The
  * return type represents the number of buckets, the number of chains, the buckets
  * and finally the chains.
  *)
(*val obtain_elf32_hash_table : endianness -> elf32_section_header_table -> byte_sequence ->
  error (elf32_word * elf32_word * list elf32_word * list elf32_word)*)
val _ = Define `
 (obtain_elf32_hash_table endian sht bs0=  
 (let filtered = (FILTER (\ ent . 
    w2n ent.elf32_sh_type = sht_hash) sht)
  in
    (case filtered of
        []  => fail0 "obtain_elf32_hash_table: no section header table entry of type sht_hash"
      | [x] =>
        let siz = (w2n x.elf32_sh_size) in
        let off = (w2n  x.elf32_sh_offset) in
        byte_sequence$offset_and_cut siz off bs0 >>= (\ rel . 
        read_elf32_word endian rel >>= (\ (nbucket, rel) . 
        read_elf32_word endian rel >>= (\ (nchain, rel) . 
        error$repeatM' (w2n nbucket) rel (read_elf32_word endian) >>= (\ (buckets, rel) . 
        error$repeatM' (w2n nchain) rel (read_elf32_word endian) >>= 
  (\p .  (case (p ) of
             ( (chain1, _) ) =>
         return (nbucket, nchain, buckets, chain1)
         ))))))
      | _   => fail0 "obtain_elf32_hash_table: multiple section header table entries of type sht_hash"
    )))`;

    
(** [obtain_elf64_hash_table endian sht bs0] extracts a hash table from an ELF file
  * providing a section of type SHT_HASH exists in section header table [sht].
  * Extraction is from byte sequence [bs0] assuming endianness [endian].  The
  * return type represents the number of buckets, the number of chains, the buckets
  * and finally the chains.
  *)
(*val obtain_elf64_hash_table : endianness -> elf64_section_header_table -> byte_sequence ->
  error (elf64_word * elf64_word * list elf64_word * list elf64_word)*)
val _ = Define `
 (obtain_elf64_hash_table endian sht bs0=  
 (let filtered = (FILTER (\ ent . 
    w2n ent.elf64_sh_type = sht_hash) sht)
  in
    (case filtered of
        []  => fail0 "obtain_elf64_hash_table: no section header table entry of type sht_hash"
      | [x] =>
        let siz = (w2n x.elf64_sh_size) in
        let off = (w2n  x.elf64_sh_offset) in
        byte_sequence$offset_and_cut siz off bs0 >>= (\ rel . 
        read_elf64_word endian rel >>= (\ (nbucket, rel) . 
        read_elf64_word endian rel >>= (\ (nchain, rel) . 
        error$repeatM' (w2n nbucket) rel (read_elf64_word endian) >>= (\ (buckets, rel) . 
        error$repeatM' (w2n nchain) rel (read_elf64_word endian) >>= 
  (\p .  (case (p ) of
             ( (chain1, _) ) =>
         return (nbucket, nchain, buckets, chain1)
         ))))))
      | _   => fail0 "obtain_elf64_hash_table: multiple section header table entries of type sht_hash"
    )))`;


(** Special sections *)

(** [construct_special_sections] contains a finite map from section name (as
  * a string) to the expected attributes and flags expected of that section,
  * as specified in the ELF specification.
  * NOTE: some of these are overriden by the ABI.
  *)
(*val elf_special_sections : Map.map string (natural * natural)*)
val _ = Define `
 (elf_special_sections=    
 (FUPDATE_LIST FEMPTY [
      (".bss", (sht_nobits, (shf_alloc + shf_write)))
    ; (".comment", (sht_progbits,( 0:num)))
    ; (".data", (sht_progbits, (shf_alloc + shf_write)))
    ; (".data1", (sht_progbits, (shf_alloc + shf_write)))
    ; (".debug", (sht_progbits,( 0:num)))
    (* ; (".dynamic", (sht_dynamic, ?)) *)
    ; (".dynstr", (sht_strtab, shf_alloc))
    ; (".dynsym", (sht_dynsym, shf_alloc))
    ; (".fini", (sht_progbits, (shf_alloc + shf_execinstr)))
    ; (".fini_array", (sht_fini_array, (shf_alloc + shf_write)))
    (* ; (".got", (sht_progbits, ?)) *)
    ; (".hash", (sht_hash, shf_alloc))
    ; (".init", (sht_progbits, (shf_alloc + shf_execinstr)))
    ; (".init_array", (sht_init_array, (shf_alloc + shf_write)))
    (* ; (".interp", (sht_progbits, ?)) *)
    ; (".line", (sht_progbits,( 0:num)))
    ; (".note", (sht_note,( 0:num)))
    (* ; (".plt", (sht_progbits, ?)) *)
    ; (".preinit_array", (sht_preinit_array, (shf_alloc + shf_write)))
    (* ; (".relname", (sht_rel, ?)) *)
    (* ; (".relaname", (sht_rela, ?)) *)
    ; (".rodata", (sht_progbits, shf_alloc))
    ; (".rodata1", (sht_progbits, shf_alloc))
    ; (".shstrtab", (sht_strtab,( 0:num)))
    (* ; (".strtab", (sht_strtab, ?)) *)
    (* ; (".symtab", (sht_symtab, ?)) *)
    (* ; (".symtab_shndx", (sht_symtab_shndx, ?)) *)
    ; (".tbss", (sht_nobits, ((shf_alloc + shf_write) + shf_tls)))
    ; (".tdata", (sht_progbits, ((shf_alloc + shf_write) + shf_tls)))
    ; (".tdata1", (sht_progbits, ((shf_alloc + shf_write) + shf_tls)))
    ; (".text", (sht_progbits, (shf_alloc + shf_execinstr)))
    ]))`;

val _ = export_theory()

