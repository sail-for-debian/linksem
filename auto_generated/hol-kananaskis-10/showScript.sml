(*Generated by Lem from show.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_functionTheory lem_maybeTheory lem_stringTheory lem_string_extraTheory ASCIInumbersTheory elf_localTheory;

val _ = numLib.prefer_num();



val _ = new_theory "show"

(** [show.lem] exports the typeclass [Show] and associated functions for pretty
  * printing arbitrary values.
  *)

(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import String_extra*)

(*open import {hol} `ASCIInumbersTheory`*)
(*open import {hol} `elf_localTheory`*)

val _ = Hol_datatype `
(*  'a *) Show_class= <|
  show_method : 'a -> string
|>`;


(** [string_of_unit u] produces a string representation of unit [u].
  *)
(*val string_of_unit : unit -> string*)
val _ = Define `
 (string_of_unit u=  "()")`;


val _ = Define `
(instance_Show_Show_unit_dict= (<|

  show_method := string_of_unit|>))`;


(** [string_of_bool b] produces a string representation of boolean [b].
  *)
(*val string_of_bool : bool -> string*)
val _ = Define `
 (string_of_bool b=  
 ((case b of
      T  => "true"
    | F => "false"
  )))`;


val _ = Define `
(instance_Show_Show_bool_dict= (<|

  show_method := string_of_bool|>))`;


(** To give control over extraction as instances cannot be target specific, but
  * the functions they are bound to can be...
  *)
(*val string_of_string : string -> string*)
val _ = Define `
 (string_of_string x=  x)`;


val _ = Define `
(instance_Show_Show_string_dict= (<|

  show_method := string_of_string|>))`;


(** [string_of_pair p] produces a string representation of pair [p].
  *)
(*val string_of_pair : forall 'a 'b. Show 'a, Show 'b => ('a * 'b) -> string*)
val _ = Define `
 (string_of_pair dict_Show_Show_a dict_Show_Show_b (left, right)=   
 (STRCAT"("  (STRCAT(
  dict_Show_Show_a.show_method left)  (STRCAT", "  (STRCAT(
  dict_Show_Show_b.show_method right) ")")))))`;


val _ = Define `
(instance_Show_Show_tup2_dict dict_Show_Show_a dict_Show_Show_b= (<|

  show_method := 
  (string_of_pair dict_Show_Show_a dict_Show_Show_b)|>))`;


(** [string_of_triple p] produces a string representation of triple [p].
  *)
(*val string_of_triple : forall 'a 'b 'c. Show 'a, Show 'b, Show 'c => ('a * 'b * 'c) -> string*)
val _ = Define `
 (string_of_triple dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c (left, middle, right)=   
 (STRCAT"("  (STRCAT(
  dict_Show_Show_a.show_method left)  (STRCAT", "  (STRCAT(
  dict_Show_Show_b.show_method middle)  (STRCAT", "  (STRCAT(
  dict_Show_Show_c.show_method right) ")")))))))`;


val _ = Define `
(instance_Show_Show_tup3_dict dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c= (<|

  show_method := 
  (string_of_triple dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c)|>))`;


(** [string_of_quad p] produces a string representation of quad [p].
  *)
(*val string_of_quad : forall 'a 'b 'c 'd. Show 'a, Show 'b, Show 'c, Show 'd => ('a * 'b * 'c * 'd) -> string*)
val _ = Define `
 (string_of_quad dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c dict_Show_Show_d (left, middle1, middle2, right)=   
 (STRCAT"("  (STRCAT(
  dict_Show_Show_a.show_method left)  (STRCAT", "  (STRCAT(
  dict_Show_Show_b.show_method middle1)  (STRCAT", "  (STRCAT(
  dict_Show_Show_c.show_method middle2)  (STRCAT", "  (STRCAT(
  dict_Show_Show_d.show_method right) ")")))))))))`;


val _ = Define `
(instance_Show_Show_tup4_dict dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c dict_Show_Show_d= (<|

  show_method := 
  (string_of_quad dict_Show_Show_a dict_Show_Show_b dict_Show_Show_c
     dict_Show_Show_d)|>))`;


(** [string_of_maybe m] produces a string representation of maybe value [m].
  *)
(*val string_of_maybe : forall 'a. Show 'a => maybe 'a -> string*)
val _ = Define `
 (string_of_maybe dict_Show_Show_a m=  
 ((case m of
      NONE => "Nothing"
    | SOME e  =>  STRCAT"Just " (
  dict_Show_Show_a.show_method e)
  )))`;


val _ = Define `
(instance_Show_Show_Maybe_maybe_dict dict_Show_Show_a= (<|

  show_method := 
  (string_of_maybe dict_Show_Show_a)|>))`;


(** [show_else s m] produces a string representation of maybe [m], using [s] 
  * in the case [m] = Nothing. *)
(*val show_else : forall 'a. Show 'a => string -> maybe 'a -> string*)
val _ = Define `
 (show_else dict_Show_Show_a subst m=    
  ((case m of 
          SOME x => dict_Show_Show_a.show_method x 
        | NONE => subst 
    )))`;


(** [string_of_nat m] produces a string representation of nat value [m].
  *)
(*val string_of_nat : nat -> string*)

val _ = Define `
(instance_Show_Show_nat_dict= (<|

  show_method := num_to_dec_string|>))`;


val _ = Define `
(instance_Show_Show_Num_natural_dict= (<|

  show_method := num_to_dec_string|>))`;


(*val string_of_integer : integer -> string*)

val _ = Define `
(instance_Show_Show_Num_integer_dict= (<|

  show_method := int_to_dec_string|>))`;

val _ = export_theory()

