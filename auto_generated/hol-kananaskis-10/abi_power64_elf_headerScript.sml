(*Generated by Lem from abis/power64/abi_power64_elf_header.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory missing_pervasivesTheory endiannessTheory elf_types_native_uintTheory elf_headerTheory;

val _ = numLib.prefer_num();



val _ = new_theory "abi_power64_elf_header"

(** [abi_power64_elf_header], Power64 ABI specific definitions related to the 
  * ELF file header.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Maybe*)
(*open import Missing_pervasives*)

(*open import Elf_header*)
(*open import Elf_types_native_uint*)

(*open import Endianness*)

(** [is_valid_abi_power64_machine_architecture m] checks whether the ELF header's
  * machine architecture is valid according to the ABI-specific specification.
  * Machine architecture must be Power64 (Section 4.1).
  *)
(*val is_valid_abi_power64_machine_architecture : nat -> bool*)
val _ = Define `
 (is_valid_abi_power64_machine_architecture m=  
 (m =  elf_ma_ppc64))`;


(** [is_valid_abi_power64_magic_number magic] checks whether the ELF header's
  * magic number is valid according to the ABI-specific specification.
  * File class must be 64-bit (Section 4.1)
  * Data encoding must be little or big endian and must match the data encoding
  * of the file. (Section 4.1)
  *)
(*val is_valid_abi_power64_magic_number : list unsigned_char -> endianness -> bool*)
val _ = Define `
 (is_valid_abi_power64_magic_number magic endian=  
 ((case lem_list$list_index magic ( elf_ii_class) of
      NONE  => F
    | SOME cls =>
      (case lem_list$list_index magic ( elf_ii_data) of
          NONE => F
        | SOME ed =>
          (case endian of
              Little =>
                (w2n cls = elf_class_64) /\
                  (w2n ed = elf_data_2lsb)
            | Big    =>
                (w2n cls = elf_class_64) /\
                  (w2n ed = elf_data_2msb)
          )
      )
  )))`;

val _ = export_theory()

