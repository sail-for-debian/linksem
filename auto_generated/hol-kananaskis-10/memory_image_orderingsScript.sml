(*Generated by Lem from memory_image_orderings.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_setTheory lem_functionTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory lem_sortingTheory missing_pervasivesTheory byte_sequenceTheory elf_types_native_uintTheory lem_tupleTheory elf_headerTheory lem_mapTheory elf_program_header_tableTheory elf_section_header_tableTheory elf_interpreted_sectionTheory elf_interpreted_segmentTheory elf_symbol_tableTheory elf_fileTheory elf_relocationTheory multimapTheory memory_imageTheory abi_classesTheory;

val _ = numLib.prefer_num();



val _ = new_theory "memory_image_orderings"

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*open import Set*)
(*open import Multimap*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Show*)

(*open import Byte_sequence*)
(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)
(*open import Memory_image*)
(*open import Abi_classes*)
(* open import Abis *)

(*open import Missing_pervasives*)

(*val elfFileFeatureCompare : elf_file_feature -> elf_file_feature -> Basic_classes.ordering*)
val _ = Define `
 (elfFileFeatureCompare f1 f2= 
  (
  (* order is: *) (case (f1, f2) of
      (ElfHeader (x1), ElfHeader (x2)) => (* equal tags, so ... *) elf64_header_compare
                                            x1 x2
    | (ElfHeader (x1), _) => LT
    | (ElfSectionHeaderTable (x1), ElfHeader (x2)) => GT
    | (ElfSectionHeaderTable (x1), ElfSectionHeaderTable (x2)) => ( (* equal tags, so ... *) lexicographic_compare
                                                                    compare_elf64_section_header_table_entry
                                                                    x1 
                                                                    x2)
    | (ElfSectionHeaderTable (x1), _) => LT
    | (ElfProgramHeaderTable (x1), ElfHeader (x2)) => GT
    | (ElfProgramHeaderTable (x1), ElfSectionHeaderTable (x2)) => GT
    | (ElfProgramHeaderTable (x1), ElfProgramHeaderTable (x2)) => (lexicographic_compare
                                                                    compare_elf64_program_header_table_entry
                                                                    x1 
                                                                   x2)
    | (ElfProgramHeaderTable (x1), _) => LT
    | (ElfSection (x1), ElfHeader (x2)) => GT
    | (ElfSection (x1), ElfSectionHeaderTable (x2)) => GT
    | (ElfSection (x1), ElfProgramHeaderTable (x2)) => GT
    | (ElfSection (x1), ElfSection (x2)) => (pairCompare
                                               (genericCompare (<) (=))
                                               compare_elf64_interpreted_section
                                               x1 x2)
    | (ElfSection (x1), _) => LT
    | (ElfSegment (x1), ElfHeader (x2)) => GT
    | (ElfSegment (x1), ElfSectionHeaderTable (x2)) => GT
    | (ElfSegment (x1), ElfProgramHeaderTable (x2)) => GT
    | (ElfSegment (x1), ElfSection (x2)) => GT
    | (ElfSegment (x1), ElfSegment (x2)) => (pairCompare
                                               (genericCompare (<) (=))
                                               compare_elf64_interpreted_segment
                                               x1 x2)
  )))`;


(*val elfFileFeatureTagEquiv : elf_file_feature -> elf_file_feature -> bool*)
val _ = Define `
 (elfFileFeatureTagEquiv f1 f2=    
(  
    (* order is: *)(case (f1, f2) of
        (ElfHeader(x1), ElfHeader(x2)) => (* equal tags, so ... *) T
      | (ElfSectionHeaderTable(x1), ElfSectionHeaderTable(x2)) => T
      | (ElfProgramHeaderTable(x1), ElfProgramHeaderTable(x2)) => T
      | (ElfSection(x1), ElfSection(x2)) => T
      | (ElfSegment(x1), ElfSegment(x2)) => T
      | (_, _) => F
    )))`;


val _ = Define `
(instance_Basic_classes_Ord_Memory_image_elf_file_feature_dict= (<|

  compare_method := elfFileFeatureCompare;

  isLess_method := (\ f1 .  (\ f2 .  (elfFileFeatureCompare f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (elfFileFeatureCompare f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (elfFileFeatureCompare f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (elfFileFeatureCompare f1 f2) ({GT; EQ})))|>))`;


(*val tagCompare : forall 'abifeature. Ord 'abifeature =>
    range_tag 'abifeature -> range_tag 'abifeature -> Basic_classes.ordering*)
val _ = Define `
 (tagCompare dict_Basic_classes_Ord_abifeature k1 k2= 
  ((case (k1, k2) of
       (ImageBase, ImageBase) => EQ
     | (ImageBase, _) => LT
     | (EntryPoint, ImageBase) => GT
     | (EntryPoint, EntryPoint) => EQ
     | (EntryPoint, _) => LT
     | (SymbolDef (_), ImageBase) => GT
     | (SymbolDef (_), EntryPoint) => GT
     | (SymbolDef (x1), SymbolDef (x2)) => symDefCompare x1 x2
     | (SymbolDef (_), _) => LT
     | (SymbolRef (_), ImageBase) => GT
     | (SymbolRef (_), EntryPoint) => GT
     | (SymbolRef (_), SymbolDef (_)) => GT
     | (SymbolRef (x1), SymbolRef (x2)) => symRefAndRelocSiteCompare x1 x2
     | (SymbolRef (_), _) => LT
     | (FileFeature (_), ImageBase) => GT
     | (FileFeature (_), EntryPoint) => GT
     | (FileFeature (_), SymbolDef (_)) => GT
     | (FileFeature (_), SymbolRef (_)) => GT
     | (FileFeature (x1), FileFeature (x2)) => elfFileFeatureCompare x1 x2
     | (FileFeature (_), _) => LT
     | (AbiFeature (_), ImageBase) => GT
     | (AbiFeature (_), EntryPoint) => GT
     | (AbiFeature (_), SymbolDef (_)) => GT
     | (AbiFeature (_), SymbolRef (_)) => GT
     | (AbiFeature (_), FileFeature (_)) => GT
     | (AbiFeature (x1), AbiFeature (x2)) => dict_Basic_classes_Ord_abifeature.compare_method
                                               x1 x2
   )))`;


val _ = Define `
(instance_Basic_classes_Ord_Memory_image_range_tag_dict dict_Basic_classes_Ord_abifeature= (<|

  compare_method := 
  (tagCompare dict_Basic_classes_Ord_abifeature);

  isLess_method := (\ tag1 .  (\ tag2 .  (tagCompare 
  dict_Basic_classes_Ord_abifeature tag1 tag2 = LT)));

  isLessEqual_method := (\ tag1 .  (\ tag2 .  (IN) (tagCompare 
  dict_Basic_classes_Ord_abifeature tag1 tag2) ({LT; EQ})));

  isGreater_method := (\ tag1 .  (\ tag2 .  (tagCompare 
  dict_Basic_classes_Ord_abifeature tag1 tag2 = GT)));

  isGreaterEqual_method := (\ tag1 .  (\ tag2 .  (IN) (tagCompare 
  dict_Basic_classes_Ord_abifeature tag1 tag2) ({GT; EQ})))|>))`;


(*val tagEquiv : forall 'abifeature. AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> range_tag 'abifeature -> bool*)
val _ = Define `
 (tagEquiv dict_Abi_classes_AbiFeatureTagEquiv_abifeature k1 k2=    
  ((case (k1, k2) of
        (ImageBase, ImageBase) => T
        | (EntryPoint, EntryPoint) => T
        | (SymbolDef(x1), SymbolDef(x2)) => T
        | (SymbolRef(_), SymbolRef(_)) => T
        | (FileFeature(x1), FileFeature(x2)) => elfFileFeatureTagEquiv x1 x2
        | (AbiFeature(x1), AbiFeature(x2)) => 
  dict_Abi_classes_AbiFeatureTagEquiv_abifeature.abiFeatureTagEquiv_method x1 x2
        | (_, _) => F
    )))`;


(* ------- end of Ord / compare / ConstructorToNaturalList functions *)


(*val unique_tag_matching : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> range_tag 'abifeature*)
val _ = Define `
 (unique_tag_matching dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature tag img=    
  ((case multimap$lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     dict_Basic_classes_Ord_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      lem_string_extra$instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv dict_Abi_classes_AbiFeatureTagEquiv_abifeature) tag img.by_tag of
        [] => failwith "no tag match found"
        | [(t, r)] => t
        | x => failwith ("more than one tag match") (* (ranges: " ^ 
            (show (List.map (fun (t, r) -> r) x))
            ^  ") when asserted unique")" *)
    )))`;

    
(*val tagged_ranges_matching_tag : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> list (range_tag 'abifeature * maybe element_range)*)
val _ = Define `
 (tagged_ranges_matching_tag dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature tag img=    
  (multimap$lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     dict_Basic_classes_Ord_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      lem_string_extra$instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv dict_Abi_classes_AbiFeatureTagEquiv_abifeature) tag img.by_tag))`;


(*val element_range_compare : element_range -> element_range -> Basic_classes.ordering*)
val _ = Define `
 (element_range_compare=  (pairCompare (\ x y. EQ) (pairCompare (genericCompare (<) (=)) (genericCompare (<) (=)))))`;


(*val unique_tag_matching_at_range_exact : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature =>
    maybe element_range
    -> range_tag 'abifeature
    -> annotated_memory_image 'abifeature
    -> range_tag 'abifeature*)
val _ = Define `
 (unique_tag_matching_at_range_exact dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature r tag img= 
  (
  (* 1. find tags a unique range labelled as ELF section header table. *) (case 
  UNZIP
    (multimap$lookupBy0
       (instance_Basic_classes_Ord_Maybe_maybe_dict
          (instance_Basic_classes_Ord_tup2_dict
             lem_string_extra$instance_Basic_classes_Ord_string_dict
             (instance_Basic_classes_Ord_tup2_dict
                instance_Basic_classes_Ord_Num_natural_dict
                instance_Basic_classes_Ord_Num_natural_dict)))
       (instance_Basic_classes_Ord_Memory_image_range_tag_dict
          dict_Basic_classes_Ord_abifeature) (=) r img.by_range) of
      (_, (allRangeMatches : ( 'abifeature range_tag) list)) =>
  let (tagAlsoMatches : ( 'abifeature range_tag) list) = (FILTER
                                                            (\ x .  tagEquiv
                                                                    dict_Abi_classes_AbiFeatureTagEquiv_abifeature
                                                                    x 
                                                                    tag)
                                                            allRangeMatches)
  in
  (case tagAlsoMatches of
      [] => failwith "no range/tag match when asserted to exist"
    | [x] => x
    | _ => failwith "multiple range/tag match when asserted unique"
  )
  )))`;


(*val symbol_def_ranges : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => annotated_memory_image 'abifeature -> (list (range_tag 'abifeature) * list (maybe element_range))*)
val _ = Define `
 (symbol_def_ranges dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img=    
(  
    (* find all element ranges labelled as ELF symbols *)let (tags, maybe_ranges) = (UNZIP (
        tagged_ranges_matching_tag 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolDef(null_symbol_definition)) img
    ))
    in
    (* some symbols, specifically ABS symbols, needn't label a range. *)
    (tags, maybe_ranges)))`;


(*val name_of_symbol_def : symbol_definition -> string*)
val _ = Define `
 (name_of_symbol_def sym=  (sym.def_symname))`;


(*val defined_symbols_and_ranges : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => annotated_memory_image 'abifeature -> list ((maybe element_range) * symbol_definition)*)
val _ = Define `
 (defined_symbols_and_ranges dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img=    
  (lem_list$mapMaybe (\ (tag, maybeRange) .  
        (case tag of
            SymbolDef(ent) => SOME (maybeRange, ent)
            | _ => failwith "impossible: non-symbol def in list of symbol defs"
        )) (tagged_ranges_matching_tag 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolDef(null_symbol_definition)) img)))`;

    
(*val make_ranges_definite : list (maybe element_range) -> list element_range*)
val _ = Define `
 (make_ranges_definite rs=    
  (MAP (\ (maybeR :  element_range option) .  (case maybeR of
            SOME r => r
            | NONE => failwith "impossible: range not definite, but asserted to be"
        )) rs))`;


(*val find_defs_matching : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => symbol_definition -> annotated_memory_image 'abifeature -> list ((maybe element_range) * symbol_definition)*)
val _ = Define `
 (find_defs_matching dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature bound_def img=    
  (let (ranges_and_defs : ( element_range option # symbol_definition) list) = (defined_symbols_and_ranges 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img)
    in 
    (*let _ = errln ("Searching (among " ^ (show (length ranges_and_defs)) ^ ") for the bound-to symbol `" ^ bound_def.def_symname 
        ^ "', which came from linkable idx " ^ 
        (show bound_def.def_linkable_idx) ^ ", section " ^ 
        (show bound_def.def_syment.elf64_st_shndx) ^ 
        ", symtab shndx " ^ (show bound_def.def_sym_scn) ^ 
        ", symind " ^ (show bound_def.def_sym_idx))
    in*)
    lem_list$mapMaybe (\ (maybe_some_range, some_def) .  
       (* let _ = errln ("Considering one: `" ^ some_def.def_symname ^ "'") in *)
       (* match maybe_some_range with
            Nothing -> failwith "symbol definition not over a definite range"
            | Just some_range -> *)
                (* if some_def.def_symname = bound_def.def_symname 
                && some_def.def_linkable_idx = bound_def.def_linkable_idx then
                if some_def = bound_def 
                    then Just(maybe_some_range, some_def) else Nothing*)
                    (*let _ = errln ("Found one in the same linkable: syment is " ^
                        (show some_def.def_syment))
                    in*) 
                (*else*) if some_def = bound_def 
                            then (
                                (*let _ = errln ("Found one: syment is " ^ (show some_def.def_syment))
                                in*)
                                SOME(maybe_some_range, some_def)
                            )
                            else if some_def.def_symname = bound_def.def_symname then
                                (*let _ = errln ("Warning: passing over name-matching def with section " ^ 
                                    (show some_def.def_syment.elf64_st_shndx) ^ 
                                    ", symtab shndx " ^ (show some_def.def_sym_scn) ^ 
                                    ", symind " ^ (show some_def.def_sym_idx) ^
                                    ", linkable idx " ^ (show some_def.def_linkable_idx))
                                in*) NONE
                            else NONE
       (* end *)
    ) ranges_and_defs))`;



(*val defined_symbols : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature =>  annotated_memory_image 'abifeature -> list symbol_definition*)
val _ = Define `
 (defined_symbols dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img=    
  (let (all_symbol_tags, all_symbol_ranges) = (symbol_def_ranges 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img) in
    lem_list$mapMaybe (\ tag .  
        (case tag of
            SymbolDef(ent) => SOME ent
            | _ => failwith "impossible: non-symbol def in list of symbol defs"
        )) all_symbol_tags))`;



val _ = Define `
 (default_get_reloc_symaddr dict_Basic_classes_Ord_a dict_Abi_classes_AbiFeatureTagEquiv_a bound_def_in_input output_img maybe_reloc=    
  ((case find_defs_matching 
  dict_Basic_classes_Ord_a dict_Abi_classes_AbiFeatureTagEquiv_a bound_def_in_input output_img of
        [] => failwith ( STRCAT"internal error: bound-to symbol (name ^`"  (STRCAT bound_def_in_input.def_symname "') not defined"))
        | (maybe_range, d) :: more =>
            let v =                
 ((case maybe_range of 
                    SOME(el_name, (start, len)) =>
                    (case element_and_offset_to_address (el_name, start) output_img of
                        SOME a => a
                        | NONE => failwith "internal error: could not get address for symbol"
                    )
                    | NONE =>
                        (* okay, it'd better be an ABS symbol. *)
                        if w2n d.def_syment.elf64_st_shndx = shn_abs
                            then w2n d.def_syment.elf64_st_value
                            else failwith "no range for non-ABS symbol"
                ))
            in
            (case more of 
                [] => v
                | _ => (*let _ = errln ("FIXME: internal error: more than one def matching bound def `" ^
                    bound_def_in_input.def_symname ^ "'")
                    in *) v
            )
    )))`;

val _ = export_theory()

