(*Generated by Lem from elf_file.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory showTheory missing_pervasivesTheory errorTheory byte_sequenceTheory elf_types_native_uintTheory elf_headerTheory string_tableTheory elf_program_header_tableTheory elf_section_header_tableTheory elf_interpreted_sectionTheory elf_interpreted_segmentTheory elf_symbol_tableTheory;

val _ = numLib.prefer_num();



val _ = new_theory "elf_file"

(** Module [elf_file] packages all components of an ELF file up into a single
  * record, provides I/O routines for this record, as well as other utility
  * functions that operate on an entire ELF file.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)

(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_types_native_uint*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_program_header_table*)

(*open import String_table*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** [elf32_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
val _ = Hol_datatype `
 elf32_file =
  <| elf32_file_header               : elf32_header                   (** The file header. *)
   ; elf32_file_program_header_table : elf32_program_header_table     (** The program header table. *)
   ; elf32_file_section_header_table : elf32_section_header_table     (** The section header table. *)
   ; elf32_file_interpreted_segments : elf32_interpreted_segments     (** A more usable interpretation of the file's segments. *)
   ; elf32_file_interpreted_sections : elf32_interpreted_sections     (** A more usable interpretation of the file's sections. *)
   ; elf32_file_bits_and_bobs        : (num # byte_sequence) list (** The uninterpreted "rubbish" that may appear in gaps in the binary file. *)
   |>`;


(** [bytes_of_elf32_file f1] blits ELF file [f1] to a byte sequence, ready for
  * writing to a binary file.  Fails if the invariant on [elf32_file] mentioned
  * above is not respected.
  *)
(*val bytes_of_elf32_file : elf32_file -> error byte_sequence*)
val _ = Define `
 (bytes_of_elf32_file ef=  
 (let endian      = (get_elf32_header_endianness ef.elf32_file_header) in
  let hdr_bytes   = (bytes_of_elf32_header ef.elf32_file_header) in
  let hdr_layout  = (( 0:num), hdr_bytes) in
  let pht_bytes   = (bytes_of_elf32_program_header_table endian ef.elf32_file_program_header_table) in
  let sht_bytes   = (bytes_of_elf32_section_header_table endian ef.elf32_file_section_header_table) in
  let pht_off     = (w2n ef.elf32_file_header.elf32_phoff) in
  let sht_off     = (w2n ef.elf32_file_header.elf32_shoff) in
  let pht_layout  = (pht_off, pht_bytes) in
  let sht_layout  = (sht_off, sht_bytes) in
  let bab_layout  = (ef.elf32_file_bits_and_bobs) in
  if LENGTH ef.elf32_file_program_header_table =
    LENGTH ef.elf32_file_interpreted_segments then
    if LENGTH ef.elf32_file_section_header_table =
      LENGTH ef.elf32_file_interpreted_sections then
      let segs_zip  = (lem_list$list_combine ef.elf32_file_program_header_table ef.elf32_file_interpreted_segments) in
      let sects_zip = (lem_list$list_combine ef.elf32_file_section_header_table ef.elf32_file_interpreted_sections) in
      let segs_layout =        
(MAP (\ (seg, interp_seg) . 
          (w2n seg.elf32_p_offset, interp_seg.elf32_segment_body)
        ) (FILTER (\p .  
  (case (p ) of
      ( (x, _) ) => ~
                      (x.elf32_p_filesz = ((n2w : num -> uint32) (( 0: num))))
  )) segs_zip))
      in
      let sects_layout =        
(MAP (\ (sect, interp_sect) . 
          (w2n sect.elf32_sh_offset, interp_sect.elf32_section_body)
        ) (FILTER (\p .  
  (case (p ) of
      ( (x, _) ) => ~ (x.elf32_sh_type = ((n2w : num -> uint32) sht_nobits))
  )) sects_zip))
      in
      let pre_layout = ((([hdr_layout; pht_layout; sht_layout] ++ sects_layout) ++ segs_layout) ++ bab_layout) in
      let final_layout =        
(sort_by (\p p0 .  (case (p ,p0 ) of
     ( (off_x, _) , (off_y, _) ) => natural_ordering off_x off_y
 ))
          pre_layout)
      in
      let concats =        
(foldM (\ x y . 
          let (current_offset, so_far) = x in
          let (point_to_add, body) = y in
            if point_to_add < current_offset then
              let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if byte_sequence$length0 body < diff then
                  return (current_offset, so_far)
                else
                  byte_sequence$partition0 diff body >>= 
  (\p .  (case (p ) of
             ( (_, cut) ) =>
         let concat = (byte_sequence$concat0 [so_far; cut]) in
         let delta = (current_offset + byte_sequence$length0 cut) in
         return (delta, concat)
         ))
            else
              let diff   = (point_to_add - current_offset) in
              let reps   = (byte_sequence$create diff (0w : 8 word)) in
              let concat = (byte_sequence$concat0 [so_far; reps; body]) in
              let delta  = (point_to_add + byte_sequence$length0 body) in
                return (delta, concat)
        ) (( 0:num), byte_sequence$empty) final_layout)
      in
        concats >>= (\ (offset, body) . 
        return body)
    else
      fail0 "bytes_of_elf32_file: interpreted sections and section header table must have same length"
  else
    fail0 "bytes_of_elf32_file: interpreted segments and program header table must have same length"))`;


(** [elf64_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
val _ = Hol_datatype `
 elf64_file =
  <| elf64_file_header               : elf64_header                   (** The file header. *)
   ; elf64_file_program_header_table : elf64_program_header_table     (** The program header table. *)
   ; elf64_file_section_header_table : elf64_section_header_table     (** The section header table. *)
   ; elf64_file_interpreted_segments : elf64_interpreted_segments     (** A more usable interpretation of the file's segments. *)
   ; elf64_file_interpreted_sections : elf64_interpreted_sections     (** A more usable interpretation of the file's sections. *)
   ; elf64_file_bits_and_bobs        : (num # byte_sequence) list (** The uninterpreted "rubbish" that may appear in gaps in the binary file. *)
   |>`;


(** [bytes_of_elf64_file f1] blits ELF file [f1] to a byte sequence, ready for
  * writing to a binary file.  Fails if the invariant on [elf64_file] mentioned
  * above is not respected.
  *)
(*val bytes_of_elf64_file : elf64_file -> error byte_sequence*)
val _ = Define `
 (bytes_of_elf64_file ef=  
 (let endian      = (get_elf64_header_endianness ef.elf64_file_header) in
  let hdr_bytes   = (bytes_of_elf64_header ef.elf64_file_header) in
  let hdr_layout  = (( 0:num), hdr_bytes) in
  let pht_bytes   = (bytes_of_elf64_program_header_table endian ef.elf64_file_program_header_table) in
  let sht_bytes   = (bytes_of_elf64_section_header_table endian ef.elf64_file_section_header_table) in
  let pht_off     = (w2n ef.elf64_file_header.elf64_phoff) in
  let sht_off     = (w2n ef.elf64_file_header.elf64_shoff) in
  let pht_layout  = (pht_off, pht_bytes) in
  let sht_layout  = (sht_off, sht_bytes) in
  let bab_layout  = (ef.elf64_file_bits_and_bobs) in
  if (* List.length ef.elf64_file_program_header_table =
    List.length ef.elf64_file_interpreted_segments *) T then
    if LENGTH ef.elf64_file_section_header_table =
      LENGTH ef.elf64_file_interpreted_sections then
      let segs_zip  = (lem_list$list_combine ef.elf64_file_program_header_table ef.elf64_file_interpreted_segments) in
      let sects_zip = (lem_list$list_combine ef.elf64_file_section_header_table ef.elf64_file_interpreted_sections) in
      let segs_layout = ([]) (*
        List.map (fun (seg, interp_seg) ->
          (natural_of_elf64_off seg.elf64_p_offset, interp_seg.elf64_segment_body)
        ) (List.filter (fun (x, _) -> x.elf64_p_filesz <> elf64_xword_of_natural 0) segs_zip) *)
      in
      let sects_layout =        
(MAP (\ (sect, interp_sect) . 
          (w2n sect.elf64_sh_offset, interp_sect.elf64_section_body)
        ) (FILTER (\p .  
  (case (p ) of
      ( (x, _) ) => ~ (x.elf64_sh_type = ((n2w : num -> uint32) sht_nobits))
  )) sects_zip))
      in
      let pre_layout = ((([hdr_layout; pht_layout; sht_layout] ++ sects_layout) ++ segs_layout) ++ bab_layout) in
      let final_layout =        
(sort_by (\p p0 .  (case (p ,p0 ) of
     ( (off_x, _) , (off_y, _) ) => natural_ordering off_x off_y
 ))
          pre_layout)
      in
      let concats =        
(foldM (\ x y . 
          let (current_offset, so_far) = x in
          let (point_to_add, body) = y in
            if point_to_add < current_offset then
              let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if byte_sequence$length0 body < diff then
                  return (current_offset, so_far)
                else
                  byte_sequence$partition0 diff body >>= 
  (\p .  (case (p ) of
             ( (_, cut) ) =>
         let concat = (byte_sequence$concat0 [so_far; cut]) in
         let delta = (current_offset + byte_sequence$length0 cut) in
         return (delta, concat)
         ))
            else
              let diff   = (point_to_add - current_offset) in
              let reps   = (byte_sequence$create diff (0w : 8 word)) in
              let concat = (byte_sequence$concat0 [so_far; reps; body]) in
              let delta  = (point_to_add + byte_sequence$length0 body) in
                return (delta, concat)
        ) (( 0:num), byte_sequence$empty) final_layout)
      in
        concats >>= (\ (offset, body) . 
        return body)
    else
      fail0 "bytes_of_elf64_file: interpreted sections and section header table must have same length"
  else
    fail0 "bytes_of_elf64_file: interpreted segments and program header table must have same length"))`;


(** [obtain_elf32_program_header_table hdr bs0] reads a file's program header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_program_header_table : elf32_header -> byte_sequence
  -> error elf32_program_header_table*)
val _ = Define `
 (obtain_elf32_program_header_table hdr bs0=  
 (let endian      = (get_elf32_header_endianness hdr) in
  let pentries    = (w2n hdr.elf32_phnum)     in
  let pentry_size = (w2n hdr.elf32_phentsize) in
  let psize       = (pentries * pentry_size) in
    if psize =( 0:num) then
      return []
    else
      let poffset = (w2n hdr.elf32_phoff) in
      byte_sequence$offset_and_cut poffset psize bs0 >>= (\ pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_program_header_table psize endian pexact >>= 
  (\p .  (case (p ) of ( (pht, _) ) => return pht )))))`;


(** [obtain_elf64_program_header_table hdr bs0] reads a file's program header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_program_header_table : elf64_header -> byte_sequence
  -> error elf64_program_header_table*)
val _ = Define `
 (obtain_elf64_program_header_table hdr bs0=  
 (let endian      = (get_elf64_header_endianness hdr) in
  let pentries    = (w2n hdr.elf64_phnum)     in
  let pentry_size = (w2n hdr.elf64_phentsize) in
  let psize       = (pentries * pentry_size) in
    if psize =( 0:num) then
      return []
    else
      let poffset = (w2n hdr.elf64_phoff) in
      byte_sequence$offset_and_cut poffset psize bs0 >>= (\ pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_program_header_table psize endian pexact >>= 
  (\p .  (case (p ) of ( (pht, _) ) => return pht )))))`;


(** [obtain_elf32_section_header_table hdr bs0] reads a file's section header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_section_header_table : elf32_header -> byte_sequence
  -> error elf32_section_header_table*)
val _ = Define `
 (obtain_elf32_section_header_table hdr bs0=  
 (let endian      = (get_elf32_header_endianness hdr) in
  let sentries    = (w2n hdr.elf32_shnum) in
  let sentry_size = (w2n hdr.elf32_shentsize) in
  let ssize       = (sentries * sentry_size) in
    if ssize =( 0:num) then
      return []
    else
      let soffset = (w2n hdr.elf32_shoff) in
      byte_sequence$offset_and_cut soffset ssize bs0 >>= (\ sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_section_header_table ssize endian sexact >>= 
  (\p .  (case (p ) of ( (sht, _) ) => return sht )))))`;


(** [obtain_elf64_section_header_table hdr bs0] reads a file's section header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_section_header_table : elf64_header -> byte_sequence -> error elf64_section_header_table*)
val _ = Define `
 (obtain_elf64_section_header_table hdr bs0=  
 (let endian      = (get_elf64_header_endianness hdr) in
  let sentries    = (w2n hdr.elf64_shnum) in
  let sentry_size = (w2n hdr.elf64_shentsize) in
  let ssize       = (sentries * sentry_size) in
    if ssize =( 0:num) then
      return []
    else
      let soffset = (w2n hdr.elf64_shoff) in
      byte_sequence$offset_and_cut soffset ssize bs0 >>= (\ sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_section_header_table ssize endian sexact >>= 
  (\p .  (case (p ) of ( (sht, _) ) => return sht )))))`;

      
(** [obtain_elf32_section_header_string_table hdr sht bs0] reads a file's section
  * header string table from byte sequence [bs0] using information gleaned from
  * the file header [hdr] and section header table [sht].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_section_header_string_table : elf32_header ->
  elf32_section_header_table -> byte_sequence -> error (maybe string_table)*)
val _ = Define `
 (obtain_elf32_section_header_string_table hdr sht bs0=  
 (if (w2n hdr.elf32_shstrndx) = shn_undef then
    return NONE
  else
    (case index (w2n hdr.elf32_shstrndx) sht of 
      NONE => fail0 "no section header string table"
      | SOME x => return x
    ) >>= (\ sh . 
    byte_sequence$offset_and_cut (w2n sh.elf32_sh_offset) (w2n sh.elf32_sh_size) bs0 >>= (\ sexact . 
    return (SOME (string_table_of_byte_sequence sexact))))))`;

      
(** [obtain_elf64_section_header_string_table hdr sht bs0] reads a file's section
  * header string table from byte sequence [bs0] using information gleaned from
  * the file header [hdr] and section header table [sht].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_section_header_string_table : elf64_header ->
  elf64_section_header_table -> byte_sequence -> error (maybe string_table)*)
val _ = Define `
 (obtain_elf64_section_header_string_table hdr sht bs0=  
 (if (w2n hdr.elf64_shstrndx) = shn_undef then
    return NONE
  else
    (case index (w2n hdr.elf64_shstrndx) sht of 
      NONE => fail0 "no section header string table"
      | SOME x => return x
    ) >>= (\ sh . 
    byte_sequence$offset_and_cut (w2n sh.elf64_sh_offset) (w2n sh.elf64_sh_size) bs0 >>= (\ sexact . 
    return (SOME (string_table_of_byte_sequence sexact))))))`;


(** [obtain_elf32_interpreted_segments pht bs0] generates the interpreted segments
  * of an ELF file from the uninterpreted program header table entries in [pht],
  * read from byte sequence [bs0].  Makes working with segments easier.
  * May fail if transcription of any segment fails.
  *)
(*val obtain_elf32_interpreted_segments : elf32_program_header_table -> byte_sequence
  -> error elf32_interpreted_segments*)
val _ = Define `
 (obtain_elf32_interpreted_segments pht bdy=  
 (mapM (\ ph . 
    let offset   = (w2n ph.elf32_p_offset)  in
    let size1     = (w2n ph.elf32_p_filesz) in
      (if size1 =( 0:num) then
         return byte_sequence$empty
       else
         byte_sequence$offset_and_cut offset size1 bdy) >>= (\ relevant . 
    let vaddr    = (w2n ph.elf32_p_vaddr) in
    let paddr    = (w2n ph.elf32_p_paddr) in
    let memsz    = (w2n ph.elf32_p_memsz) in
    let typ      = (w2n ph.elf32_p_type)  in
    let align    = (w2n ph.elf32_p_align) in
    let flags    = (elf32_interpret_program_header_flags ph.elf32_p_flags) in
      if memsz < size1 then
        fail0 "obtain_elf32_interpreted_segments: memory size of segment cannot be less than file size"
      else
        return <| elf32_segment_body := relevant; elf32_segment_type := typ;
                    elf32_segment_size := size1; elf32_segment_memsz := memsz;
                    elf32_segment_base  := vaddr; elf32_segment_flags := flags;
                    elf32_segment_paddr := paddr; elf32_segment_align := align;
                    elf32_segment_offset := offset |>)
    ) pht))`;


(** [obtain_elf64_interpreted_segments pht bs0] generates the interpreted segments
  * of an ELF file from the uninterpreted program header table entries in [pht],
  * read from byte sequence [bs0].  Makes working with segments easier.
  * May fail if transcription of any segment fails.
  *)
(*val obtain_elf64_interpreted_segments : elf64_program_header_table -> byte_sequence
  -> error elf64_interpreted_segments*)
val _ = Define `
 (obtain_elf64_interpreted_segments pht bdy=  
 (mapM (\ ph . 
    let offset   = (w2n   ph.elf64_p_offset)  in
    let size1     = (w2n ph.elf64_p_filesz) in
      (if size1 =( 0:num) then
         return byte_sequence$empty
       else
         byte_sequence$offset_and_cut offset size1 bdy) >>= (\ relevant . 
    let vaddr    = (w2n  ph.elf64_p_vaddr) in
    let paddr    = (w2n  ph.elf64_p_paddr) in
    let memsz    = (w2n ph.elf64_p_memsz) in
    let typ      = (w2n  ph.elf64_p_type)  in
    let align    = (w2n ph.elf64_p_align) in
    let flags    = (elf64_interpret_program_header_flags ph.elf64_p_flags) in
      if memsz < size1 then
        fail0 "obtain_elf64_interpreted_segments: memory size of segment cannot be less than file size"
      else
        return <| elf64_segment_body := relevant; elf64_segment_type := typ;
                    elf64_segment_size := size1; elf64_segment_memsz := memsz;
                    elf64_segment_base  := vaddr; elf64_segment_flags := flags;
                    elf64_segment_align := align; elf64_segment_paddr := paddr;
                    elf64_segment_offset := offset |>)
    ) pht))`;


(** [obtain_elf32_interpreted_section sht bs0] generates the interpreted sections
  * of an ELF file from the uninterpreted section header table entries in [sht],
  * read from byte sequence [bs0].  Makes working with sections easier.
  * May fail if transcription of any section fails.
  *)
(*val obtain_elf32_interpreted_sections : maybe string_table -> elf32_section_header_table
  -> byte_sequence -> error elf32_interpreted_sections*)
val _ = Define `
 (obtain_elf32_interpreted_sections shstrtab sht bs0=  
 (mapM (\ sh . 
    let offset = (w2n  sh.elf32_sh_offset) in
    let size1   = (w2n sh.elf32_sh_size) in
    let name   = (w2n sh.elf32_sh_name) in
    let typ    = (w2n sh.elf32_sh_type) in
    let filesz = (if typ = sht_nobits then( 0:num) else size1) in
    let flags  = (w2n sh.elf32_sh_flags) in
    let base   = (w2n sh.elf32_sh_addr) in
    let link   = (w2n sh.elf32_sh_link) in
    let info   = (w2n sh.elf32_sh_info) in
    let align  = (w2n sh.elf32_sh_addralign) in
    let entry_size = (w2n sh.elf32_sh_entsize) in
    let name_string =      
((case shstrtab of
        NONE => ""
      | SOME shstrtab =>
          (case (get_string_at name shstrtab) of
              Success n => n
            | Fail _ => ""
          )
      ))
    in
      (if filesz =( 0:num) then
        return byte_sequence$empty
      else
        byte_sequence$offset_and_cut offset filesz bs0) >>= (\ relevant . 
      return <| elf32_section_name := name; elf32_section_type := typ;
          elf32_section_size := size1; elf32_section_offset := offset;
          elf32_section_flags := flags; elf32_section_addr := base;
          elf32_section_link := link; elf32_section_info := info;
          elf32_section_align := align; elf32_section_body := relevant;
          elf32_section_entsize := entry_size;
          elf32_section_name_as_string := name_string |>)
  ) sht))`;


(** [obtain_elf64_interpreted_section sht bs0] generates the interpreted sections
  * of an ELF file from the uninterpreted section header table entries in [sht],
  * read from byte sequence [bs0].  Makes working with sections easier.
  * May fail if transcription of any section fails.
  *)
(*val obtain_elf64_interpreted_sections : maybe string_table -> elf64_section_header_table
  -> byte_sequence -> error elf64_interpreted_sections*)
val _ = Define `
 (obtain_elf64_interpreted_sections shstrtab sht bs0=  
 (mapM (\ sh . 
    let offset = (w2n   sh.elf64_sh_offset) in
    let size1   = (w2n sh.elf64_sh_size) in
    let name   = (w2n  sh.elf64_sh_name) in
    let typ    = (w2n  sh.elf64_sh_type) in
    let filesz = (if typ = sht_nobits then( 0:num) else size1) in
    let flags  = (w2n sh.elf64_sh_flags) in
    let base   = (w2n  sh.elf64_sh_addr) in
    let link   = (w2n  sh.elf64_sh_link) in
    let info   = (w2n  sh.elf64_sh_info) in
    let align  = (w2n sh.elf64_sh_addralign) in
    let entry_size = (w2n sh.elf64_sh_entsize) in
    let name_string =      
((case shstrtab of
        NONE => ""
      | SOME shstrtab =>
          (case (get_string_at name shstrtab) of
              Success n => n
            | Fail _ => ""
          )
      ))
    in
      (if filesz =( 0:num) then
        return byte_sequence$empty
      else
        byte_sequence$offset_and_cut offset filesz bs0) >>= (\ relevant . 
      return <| elf64_section_name := name; elf64_section_type := typ;
          elf64_section_size := size1; elf64_section_offset := offset;
          elf64_section_flags := flags; elf64_section_addr := base;
          elf64_section_link := link; elf64_section_info := info;
          elf64_section_align := align; elf64_section_body := relevant;
          elf64_section_entsize := entry_size;
          elf64_section_name_as_string := name_string |>)
  ) sht))`;


(** [find_first_not_in_range e rngs] for every pair (start, end) in [rngs], finds
  * the first element, beginning counting from [e], that does not lie between
  * a start and end value.
  *)
(*val find_first_not_in_range : natural -> list (natural * natural) -> natural*)
 val find_first_not_in_range_defn = Hol_defn "find_first_not_in_range" `
 (find_first_not_in_range start ranges=  
 ((case FILTER (\ (x, y) .  (start >= x) /\ (start <= y)) ranges of
      [] => start
    | _  => find_first_not_in_range (start +( 1:num)) ranges
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn find_first_not_in_range_defn;

(** [find_first_in_range e rngs] for every pair (start, end) in [rngs], finds
  * the first element, beginning counting from [e], that lies between
  * a start and end value.
  *)
(*val find_first_in_range : natural -> list (natural * natural) -> natural*)
 val find_first_in_range_defn = Hol_defn "find_first_in_range" `
 (find_first_in_range start ranges=  
 ((case FILTER (\ (x, y) .  (start >= x) /\ (start <= y)) ranges of
      [] => find_first_in_range (start +( 1:num)) ranges
    | _  => start
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn find_first_in_range_defn;

(** [compute_differences start max ranges] is a utility function used for calculating
  * "dead" spots in an ELF file not covered by any of the interpreted structure
  * that nevertheless need recording in the bits_and_bobs field of each ELF record
  * in order to maintain in-out roundtripping up to exact binary equivalence.
  *)
(*val compute_differences : natural -> natural -> list (natural * natural) -> error (list (natural * natural))*)
 val compute_differences_defn = Hol_defn "compute_differences" `
 (compute_differences start max ranges=  
 (if start = max then
    return []
  else if start > max then
    fail0 "compute_differences: passed maximum"
  else
    let first = (find_first_not_in_range start ranges) in
      if first >= max then
        return []
      else
        let last = (find_first_in_range first ranges) in
          if last > max then
            return [(first, max)]
          else
            compute_differences last max ranges >>= (\ tail . 
            return ((first, last)::tail))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compute_differences_defn;

(** [obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0] identifies and records
  * the "dead" spots of an ELF file not covered by any meaningful structure of the
  * ELF file format.
  *)
(*val obtain_elf32_bits_and_bobs : elf32_header -> elf32_program_header_table -> elf32_interpreted_segments
  -> elf32_section_header_table -> elf32_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
val _ = Define `
 (obtain_elf32_bits_and_bobs hdr segs interp_segs sects interp_sects bs0=  
 (let hdr_off_len  = (( 0:num), w2n hdr.elf32_ehsize) in
  let pht_off      = (w2n hdr.elf32_phoff) in
  let pht_len      = (w2n hdr.elf32_phentsize * w2n hdr.elf32_phnum) in
  let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  let sht_off      = (w2n hdr.elf32_shoff) in
  let sht_len      = (w2n hdr.elf32_shentsize * w2n hdr.elf32_shnum) in
  let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if LENGTH interp_segs = LENGTH segs then
      let seg_zip = (lem_list$list_combine segs interp_segs) in
      if LENGTH interp_sects = LENGTH sects then
        let sect_zip = (lem_list$list_combine sects interp_sects) in
        let seg_off_len  =          
(MAP (\ (seg, interp_seg) . 
            let start = (w2n seg.elf32_p_offset) in
            let len   = (interp_seg.elf32_segment_size) in
            (start, (start + len))) seg_zip)
        in
        let sect_off_len =          
(MAP (\ (sect, interp_sect) . 
            let start = (w2n sect.elf32_sh_offset) in
            let len   = (interp_sect.elf32_section_size) in
            (start, (start + len))) sect_zip)
        in
        let pre_layout   = (hdr_off_len :: (pht_off_len :: (sht_off_len :: (seg_off_len ++ sect_off_len)))) in
        let layout       =          
(sort_by (\p p0 .  (case (p ,p0 ) of
     ( (off_x, _) , (off_y, _) ) =>
 natural_ordering off_x off_y
 )
          ) pre_layout)
        in
          compute_differences(( 0:num)) (byte_sequence$length0 bs0) layout >>= (\ diffs . 
            mapM (\ (start, len) . 
              byte_sequence$offset_and_cut start (len - start) bs0 >>= (\ rel . 
              return (start, rel))
            ) diffs)
      else
        fail0 "obtain_elf32_bits_and_bobs: section header table and interpreted section differ in length"
    else
      fail0 "obtain_elf32_bits_and_bobs: program header table and interpreted segments differ in length"))`;


(** [obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0] identifies and records
  * the "dead" spots of an ELF file not covered by any meaningful structure of the
  * ELF file format.
  *)
(*val obtain_elf64_bits_and_bobs : elf64_header -> elf64_program_header_table -> elf64_interpreted_segments
  -> elf64_section_header_table -> elf64_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
val _ = Define `
 (obtain_elf64_bits_and_bobs hdr segs interp_segs sects interp_sects bs0=  
 (let hdr_off_len  = (( 0:num), w2n hdr.elf64_ehsize) in
  
  let pht_off      = (w2n hdr.elf64_phoff) in
  let pht_len      = (w2n hdr.elf64_phentsize * w2n hdr.elf64_phnum) in
  let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  let sht_off      = (w2n hdr.elf64_shoff) in
  let sht_len      = (w2n hdr.elf64_shentsize * w2n hdr.elf64_shnum) in
  let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if LENGTH interp_segs = LENGTH segs then
      let seg_zip = (lem_list$list_combine segs interp_segs) in
      if LENGTH interp_sects = LENGTH sects then
        let sect_zip = (lem_list$list_combine sects interp_sects) in
        let seg_off_len  =          
(MAP (\ (seg, interp_seg) . 
            let start = (w2n seg.elf64_p_offset) in
            let len   = (interp_seg.elf64_segment_size) in
            (start, (start + len))) seg_zip)
        in
        let sect_off_len =          
(MAP (\ (sect, interp_sect) . 
            let start = (w2n sect.elf64_sh_offset) in
            let len   = (interp_sect.elf64_section_size) in
            (start, (start + len))) sect_zip)
        in
        let pre_layout   = (hdr_off_len :: (pht_off_len :: (sht_off_len :: (seg_off_len ++ sect_off_len)))) in
        let layout       =          
(sort_by (\p p0 .  (case (p ,p0 ) of
     ( (off_x, _) , (off_y, _) ) =>
 natural_ordering off_x off_y
 )
          ) pre_layout)
        in
          compute_differences(( 0:num)) (byte_sequence$length0 bs0) layout >>= (\ diffs . 
            mapM (\ (start, finish) . 
              byte_sequence$offset_and_cut start (finish - start) bs0 >>= (\ rel . 
              return (start, rel))
            ) diffs)
      else
        fail0 "obtain_elf64_bits_and_bobs: section header table and interpreted section differ in length"
    else
      fail0 "obtain_elf64_bits_and_bobs: program header table and interpreted segments differ in length"))`;


(** [read_elf32_file bs0] reads an ELF32 file from byte sequence [bs0].  Fails if
  * transcription fails.
  *)
(*val read_elf32_file : byte_sequence -> error elf32_file*)
val _ = Define `
 (read_elf32_file bs0=  
 (read_elf32_header bs0 >>= (\ (hdr, bs1) . 
  obtain_elf32_program_header_table hdr bs0 >>= (\ pht  . 
  obtain_elf32_section_header_table hdr bs0 >>= (\ sht  . 
  obtain_elf32_section_header_string_table hdr sht bs0 >>= (\ shstrtab . 
  obtain_elf32_interpreted_segments pht bs0 >>= (\ segs . 
  obtain_elf32_interpreted_sections shstrtab sht bs0 >>= (\ sects . 
  obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0 >>= (\ bits_and_bobs . 
  return <| elf32_file_header := hdr;
              elf32_file_program_header_table := pht;
              elf32_file_section_header_table := sht;
              elf32_file_interpreted_segments := segs;
              elf32_file_interpreted_sections := sects;
              elf32_file_bits_and_bobs := bits_and_bobs |>)))))))))`;


(** [read_elf64_file bs0] reads an ELF64 file from byte sequence [bs0].  Fails if
  * transcription fails.
  *)
(*val read_elf64_file : byte_sequence -> error elf64_file*)
val _ = Define `
 (read_elf64_file bs0=  
 (read_elf64_header bs0 >>= (\ (hdr, bs1) . 
  obtain_elf64_program_header_table hdr bs0 >>= (\ pht  . 
  obtain_elf64_section_header_table hdr bs0 >>= (\ sht  . 
  obtain_elf64_section_header_string_table hdr sht bs0 >>= (\ shstrtab . 
  obtain_elf64_interpreted_segments pht bs0 >>= (\ segs . 
  obtain_elf64_interpreted_sections shstrtab sht bs0 >>= (\ sects . 
  obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0 >>= (\ bits_and_bobs . 
  return <| elf64_file_header := hdr;
              elf64_file_program_header_table := pht;
              elf64_file_section_header_table := sht;
              elf64_file_interpreted_segments := segs;
              elf64_file_interpreted_sections := sects;
              elf64_file_bits_and_bobs := bits_and_bobs |>)))))))))`;


(** [get_elf32_file_secton_header_string_table f1] returns the ELF file, [f1],
  * section header string table.
  * TODO: why is this not using obtain_elf32_section_header_string_table above?
  *)
(*val get_elf32_file_section_header_string_table : elf32_file -> error string_table*)
val _ = Define `
 (get_elf32_file_section_header_string_table f3=  
 (let hdr  = (f3.elf32_file_header) in
  let sht  = (f3.elf32_file_section_header_table) in
  let segs = (f3.elf32_file_interpreted_segments) in
  let idx  = (w2n hdr.elf32_shstrndx) in
  bytes_of_elf32_file f3 >>= (\ bs0 . 
    (case missing_pervasives$index idx sht of
        NONE => fail0 "obtain_elf32_string_table: invalid offset into section header table"
      | SOME sect =>
          let offset = (w2n sect.elf32_sh_offset) in
          let size1   = (w2n sect.elf32_sh_size) in
          byte_sequence$offset_and_cut offset size1 bs0 >>= (\ rel . 
          let strings  = (byte_sequence$string_of_byte_sequence rel) in
          return (string_table$mk_string_table strings (CHR 0)))
    ))))`;


(** [get_elf64_file_secton_header_string_table f1] returns the ELF file, [f1],
  * section header string table.
  * TODO: why is this not using obtain_elf64_section_header_string_table above?
  *)
(*val get_elf64_file_section_header_string_table : elf64_file -> error string_table*)
val _ = Define `
 (get_elf64_file_section_header_string_table f3=  
 (let hdr  = (f3.elf64_file_header) in
  let sht  = (f3.elf64_file_section_header_table) in
  let segs = (f3.elf64_file_interpreted_segments) in
  let idx  = (w2n hdr.elf64_shstrndx) in
  bytes_of_elf64_file f3 >>= (\ bs0 . 
    (case missing_pervasives$index idx sht of
        NONE => fail0 "obtain_elf64_string_table: invalid offset into section header table"
      | SOME sect =>
          let offset = (w2n   sect.elf64_sh_offset) in
          let size1   = (w2n sect.elf64_sh_size) in
          byte_sequence$offset_and_cut offset size1 bs0 >>= (\ rel . 
          let strings  = (byte_sequence$string_of_byte_sequence rel) in
          return (string_table$mk_string_table strings (CHR 0)))
    ))))`;

    
(*val find_elf32_symbols_by_symtab_idx : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
val _ = Define `
 (find_elf32_symbols_by_symtab_idx sec_idx f=    
 ((case lem_list$list_index f.elf32_file_interpreted_sections (( sec_idx:num)) of
        NONE => fail0 "impossible: interpreted section found but not indexable"
        | SOME sec => return sec
    ) >>= (\ sec .  
    (case lem_list$list_index f.elf32_file_interpreted_sections (( sec.elf32_section_link:num)) of
        NONE => fail0 "no associated strtab"
        | SOME strs => return strs
    ) >>= (\ strs .  
    let strings = (byte_sequence$string_of_byte_sequence strs.elf32_section_body) in
    let strtab = (string_table$mk_string_table strings (CHR 0)) in
    let endian = (get_elf32_header_endianness f.elf32_file_header) in
    read_elf32_symbol_table endian sec.elf32_section_body >>= (\ symtab . 
    return (symtab, strtab, sec_idx))))))`;


(*val find_elf32_symtab_by_type : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
val _ = Define `
 (find_elf32_symtab_by_type t f=    
 (let found_symtab_index = (find_index0 (\ sh .  sh.elf32_section_type = t) f.elf32_file_interpreted_sections) in
    (case found_symtab_index of 
        NONE => fail0 "no such symtab"
        | SOME sec_idx => return sec_idx
    ) >>= (\ sec_idx .  find_elf32_symbols_by_symtab_idx sec_idx f)))`;


(*val find_elf64_symbols_by_symtab_idx : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
val _ = Define `
 (find_elf64_symbols_by_symtab_idx sec_idx f=    
 ((case lem_list$list_index f.elf64_file_interpreted_sections (( sec_idx:num)) of
        NONE => fail0 "impossible: interpreted section found but not indexable"
        | SOME sec => return sec
    ) >>= (\ sec .  
    (case lem_list$list_index f.elf64_file_interpreted_sections (( sec.elf64_section_link:num)) of
        NONE => fail0 "no associated strtab"
        | SOME strs => return strs
    ) >>= (\ strs .  
    let strings = (byte_sequence$string_of_byte_sequence strs.elf64_section_body) in
    let strtab = (string_table$mk_string_table strings (CHR 0)) in
    let endian = (get_elf64_header_endianness f.elf64_file_header) in
    read_elf64_symbol_table endian sec.elf64_section_body >>= (\ symtab . 
    return (symtab, strtab, sec_idx))))))`;


(*val find_elf64_symtab_by_type : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
val _ = Define `
 (find_elf64_symtab_by_type t f=    
 (let found_symtab_index = (find_index0 (\ sh .  sh.elf64_section_type = t) f.elf64_file_interpreted_sections) in
    (case found_symtab_index of 
        NONE => fail0 "no such symtab"
        | SOME sec_idx => return sec_idx
    ) >>= (\ sec_idx .  find_elf64_symbols_by_symtab_idx sec_idx f)))`;


(** [get_elf32_file_symbol_string_table f1] returns the ELF file [f1] symbol
  * string table.  May fail.
  *)
(*val get_elf32_file_symbol_string_table : elf32_file -> error string_table*)
val _ = Define `
 (get_elf32_file_symbol_string_table f3=  
 (let hdr     = (f3.elf32_file_header) in
  let sht     = (f3.elf32_file_section_header_table) in
  let segs    = (f3.elf32_file_interpreted_segments) in
  let strtabs = (missing_pervasives$mapMaybei (\ index sect . 
    if w2n sect.elf32_sh_type = sht_strtab then
      if index = w2n hdr.elf32_shstrndx then
        NONE
      else
        SOME sect
    else
      NONE) sht)
  in
    bytes_of_elf32_file f3 >>= (\ bs0 . 
    mapM (\ sect . 
      let offset  = (w2n  sect.elf32_sh_offset) in
      let size1    = (w2n sect.elf32_sh_size) in
      byte_sequence$offset_and_cut offset size1 bs0 >>= (\ bs1 . 
      let strings = (byte_sequence$string_of_byte_sequence bs1) in
      return (string_table$mk_string_table strings (CHR 0)))) strtabs
    >>= (\ strings . 
      string_table$concat1 strings))))`;


(** [get_elf64_file_symbol_string_table f1] returns the ELF file [f1] symbol
  * string table.  May fail.
  *)
(*val get_elf64_file_symbol_string_table : elf64_file -> error string_table*)
val _ = Define `
 (get_elf64_file_symbol_string_table f3=  
 (let hdr     = (f3.elf64_file_header) in
  let sht     = (f3.elf64_file_section_header_table) in
  let segs    = (f3.elf64_file_interpreted_segments) in
  let strtabs = (missing_pervasives$mapMaybei (\ index sect . 
    if w2n sect.elf64_sh_type = sht_strtab then
      if index = w2n hdr.elf64_shstrndx then
        NONE
      else
        SOME sect
    else
      NONE) sht)
  in
    bytes_of_elf64_file f3 >>= (\ bs0 . 
    mapM (\ sect . 
      let offset  = (w2n   sect.elf64_sh_offset) in
      let size1    = (w2n sect.elf64_sh_size) in
      byte_sequence$offset_and_cut offset size1 bs0 >>= (\ bs1 . 
      let strings = (byte_sequence$string_of_byte_sequence bs1) in
      return (string_table$mk_string_table strings (CHR 0)))) strtabs
    >>= (\ strings . 
      string_table$concat1 strings))))`;


(** [get_elf32_file_symbol_table f1] returns the ELF file [f1] symbol
  * table.  May fail.
  *)
(*val get_elf32_file_symbol_table : elf32_file -> error elf32_symbol_table*)
val _ = Define `
 (get_elf32_file_symbol_table f3=  
 (let hdr     = (f3.elf32_file_header) in
  let sht     = (f3.elf32_file_section_header_table) in
  let segs    = (f3.elf32_file_interpreted_segments) in
  let endian  = (get_elf32_header_endianness hdr) in
  let symtabs = (FILTER (\ sect . 
    w2n sect.elf32_sh_type = sht_symtab
    ) sht)
  in
    (case symtabs of
        [] => return []
      | [symtab] =>
        let offset = (w2n symtab.elf32_sh_offset) in
        let size1   = (w2n symtab.elf32_sh_size) in
        bytes_of_elf32_file f3 >>= (\ bs0 . 
        byte_sequence$offset_and_cut offset size1 bs0 >>= (\ relevant . 
        read_elf32_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf32_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB"
    )))`;


(** [get_elf64_file_symbol_table f1] returns the ELF file [f1] symbol
  * table.  May fail.
  *)
(*val get_elf64_file_symbol_table : elf64_file -> error elf64_symbol_table*)
val _ = Define `
 (get_elf64_file_symbol_table f3=  
 (let hdr     = (f3.elf64_file_header) in
  let sht     = (f3.elf64_file_section_header_table) in
  let segs    = (f3.elf64_file_interpreted_segments) in
  let endian  = (get_elf64_header_endianness hdr) in
  let symtabs = (FILTER (\ sect . 
    w2n sect.elf64_sh_type = sht_symtab
    ) sht)
  in
    (case symtabs of
        [] => return []
      | [symtab] =>
        let offset = (w2n   symtab.elf64_sh_offset) in
        let size1   = (w2n symtab.elf64_sh_size) in
        bytes_of_elf64_file f3 >>= (\ bs0 . 
        byte_sequence$offset_and_cut offset size1 bs0 >>= (\ relevant . 
        read_elf64_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf64_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB"
    )))`;


(** [get_elf32_file_dynamic_symbol_table f1] returns the ELF file [f1] dynamic
  * symbol table.  May fail.
  *)
(*val get_elf32_file_dynamic_symbol_table : elf32_file -> error elf32_symbol_table*)
val _ = Define `
 (get_elf32_file_dynamic_symbol_table ef=  
 (let hdr     = (ef.elf32_file_header) in
  let sht     = (ef.elf32_file_section_header_table) in
  let segs    = (ef.elf32_file_interpreted_segments) in
  let endian  = (get_elf32_header_endianness hdr) in
  let symtabs = (FILTER (\ sect . 
    w2n sect.elf32_sh_type = sht_dynsym
    ) sht)
  in
    (case symtabs of
        [] => return []
      | [symtab] =>
        let offset = (w2n symtab.elf32_sh_offset) in
        let size1   = (w2n symtab.elf32_sh_size) in
        bytes_of_elf32_file ef >>= (\ bs0 . 
        byte_sequence$offset_and_cut offset size1 bs0 >>= (\ relevant . 
        read_elf32_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf32_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM"
    )))`;


(** [get_elf64_file_dynamic_symbol_table f1] returns the ELF file [f1] dynamic
  * symbol table.  May fail.
  *)
(*val get_elf64_file_dynamic_symbol_table : elf64_file -> error elf64_symbol_table*)
val _ = Define `
 (get_elf64_file_dynamic_symbol_table ef=  
 (let hdr     = (ef.elf64_file_header) in
  let sht     = (ef.elf64_file_section_header_table) in
  let segs    = (ef.elf64_file_interpreted_segments) in
  let endian  = (get_elf64_header_endianness hdr) in
  let symtabs = (FILTER (\ sect . 
    w2n sect.elf64_sh_type = sht_dynsym
    ) sht)
  in
    (case symtabs of
        [] => return []
      | [symtab] =>
        let offset = (w2n   symtab.elf64_sh_offset) in
        let size1   = (w2n symtab.elf64_sh_size) in
        bytes_of_elf64_file ef >>= (\ bs0 . 
        byte_sequence$offset_and_cut offset size1 bs0 >>= (\ relevant . 
        read_elf64_symbol_table endian relevant))
      | _ =>
        fail0 "obtain_elf64_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM"
    )))`;

    
(** [get_elf32_file_symbol_table_by_index f1 index] returns the ELF file [f1] 
  * symbol table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf32_symbol_table_by_index : elf32_file -> natural -> error elf32_symbol_table*)
val _ = Define `
 (get_elf32_symbol_table_by_index ef link=  
 (let hdr     = (ef.elf32_file_header) in
  let sht     = (ef.elf32_file_section_header_table) in
  let sects   = (ef.elf32_file_interpreted_sections) in
  let endian  = (get_elf32_header_endianness hdr) in
    (case lem_list$list_index sects ( link) of
        NONE  => fail0 "get_elf32_symbol_table_by_index: invalid index"
      | SOME sym =>
        read_elf32_symbol_table endian sym.elf32_section_body
    )))`;

    
(** [get_elf32_file_string_table_by_index f1 index] returns the ELF file [f1] 
  * string table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf32_string_table_by_index : elf32_file -> natural -> error string_table*)
val _ = Define `
 (get_elf32_string_table_by_index ef link=  
 (let hdr     = (ef.elf32_file_header) in
  let sht     = (ef.elf32_file_section_header_table) in
  let sects   = (ef.elf32_file_interpreted_sections) in
    (case lem_list$list_index sects ( link) of
        NONE  => fail0 "get_elf32_string_table_by_index: invalid index"
      | SOME sym => return (mk_string_table (byte_sequence$string_of_byte_sequence sym.elf32_section_body) (CHR 0))
    )))`;

    
(** [get_elf64_file_symbol_table_by_index f1 index] returns the ELF file [f1] 
  * symbol table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf64_symbol_table_by_index : elf64_file -> natural -> error elf64_symbol_table*)
val _ = Define `
 (get_elf64_symbol_table_by_index ef link=  
 (let hdr     = (ef.elf64_file_header) in
  let sht     = (ef.elf64_file_section_header_table) in
  let sects   = (ef.elf64_file_interpreted_sections) in
  let endian  = (get_elf64_header_endianness hdr) in
    (case lem_list$list_index sects ( link) of
        NONE  => fail0 "get_elf64_symbol_table_by_index: invalid index"
      | SOME sym =>
        read_elf64_symbol_table endian sym.elf64_section_body
    )))`;

    
(** [get_elf64_file_string_table_by_index f1 index] returns the ELF file [f1] 
  * string table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf64_string_table_by_index : elf64_file -> natural -> error string_table*)
val _ = Define `
 (get_elf64_string_table_by_index ef link=  
 (let hdr     = (ef.elf64_file_header) in
  let sht     = (ef.elf64_file_section_header_table) in
  let sects   = (ef.elf64_file_interpreted_sections) in
    (case lem_list$list_index sects ( link) of
        NONE  => fail0 "get_elf64_string_table_by_index: invalid index"
      | SOME sym => return (mk_string_table (byte_sequence$string_of_byte_sequence sym.elf64_section_body) (CHR 0))
    )))`;


(** [segment_provenance] records whether a segment that appears in an executable
  * process image has been derived directly from an ELF file, or was automatically
  * created when the image calculation process noticed a segment with a memory
  * size greater than its file size.
  * Really a PPCMemism and not strictly needed for the ELF model itself.
  *)
val _ = Hol_datatype `
 segment_provenance
  = FromELF       (** Segment derived directly from the source ELF file. *)
  | AutoGenerated`;
 (** Automatically generated during process extraction as memory size is greater than file size. *)

(** [elf32_executable_process_image] is a process image for ELF32 files.  Contains
  * all that is necessary to load the executable components of an ELF32 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
val _ = type_abbrev( "elf32_executable_process_image" , ``:
  ( (elf32_interpreted_segment # segment_provenance)list # num # num)``);

(** [elf64_executable_process_image] is a process image for ELF64 files.  Contains
  * all that is necessary to load the executable components of an ELF64 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
val _ = type_abbrev( "elf64_executable_process_image" , ``:
  ( (elf64_interpreted_segment # segment_provenance)list # num # num)``);

(** [get_elf32_executable_image f1] extracts an executable process image from an
  * executable ELF file.  May fail if extraction is impossible.
  *)
(*val get_elf32_executable_image : elf32_file -> error elf32_executable_process_image*)
val _ = Define `
 (get_elf32_executable_image f3=  
 (if is_elf32_executable_file f3.elf32_file_header then
    let entr = (f3.elf32_file_header.elf32_entry) in
    let segs = (f3.elf32_file_interpreted_segments) in
    let mach = (f3.elf32_file_header.elf32_machine) in
      (case FILTER (\ sg .  sg.elf32_segment_type = elf_pt_load) segs of
          []    => fail0 "get_elf32_executable_image: an executable ELF file must have at least one loadable segment"
        | load  =>
            mapM (\ sg . 
              if sg.elf32_segment_memsz =( 0:num) then
                return []
              else if sg.elf32_segment_memsz = sg.elf32_segment_size then
                return [(sg, FromELF)]
              else if sg.elf32_segment_size < sg.elf32_segment_memsz then
                (* Cannot be negative due to check in constructing [segs]. *)
                let diff  = (sg.elf32_segment_memsz - sg.elf32_segment_size) in
                let zeros = (byte_sequence$zeros diff) in
                let addr  = (sg.elf32_segment_base + sg.elf32_segment_size) in
                let align = (sg.elf32_segment_align) in
                let paddr = (sg.elf32_segment_paddr) in
                let seg   =                  
(<| elf32_segment_body := zeros; elf32_segment_type := (sg.elf32_segment_type);
                      elf32_segment_size := diff; elf32_segment_memsz := diff;
                      elf32_segment_base := addr; elf32_segment_flags := (sg.elf32_segment_flags);
                      elf32_segment_align := align; elf32_segment_paddr := paddr;
                      elf32_segment_offset := (sg.elf32_segment_offset) |>)
                in
                  return [(sg, FromELF); (seg, AutoGenerated)]
              else
                fail0 "get_elf32_executable_image: invariant invalidated") load >>= (\ bs_base . 
            return (FLAT bs_base, w2n entr, w2n mach))
      )
  else
    fail0 "get_elf32_executable_image: not an ELF executable file"))`;


(** [get_elf64_executable_image f1] extracts an executable process image from an
  * executable ELF file.  May fail if extraction is impossible.
  *)
(*val get_elf64_executable_image : elf64_file -> error elf64_executable_process_image*)
val _ = Define `
 (get_elf64_executable_image f3=  
  (if is_elf64_executable_file f3.elf64_file_header then
    let entr = (f3.elf64_file_header.elf64_entry) in
    let segs = (f3.elf64_file_interpreted_segments) in
    let mach = (f3.elf64_file_header.elf64_machine) in
      (case FILTER (\ sg .  sg.elf64_segment_type = elf_pt_load) segs of
          []    => fail0 "get_elf64_executable_image: an executable ELF file must have at least one loadable segment"
        | load  =>
            mapM (\ sg . 
              if sg.elf64_segment_memsz =( 0:num) then
                return []
              else if sg.elf64_segment_memsz = sg.elf64_segment_size then
                return [(sg, FromELF)]
              else if sg.elf64_segment_size < sg.elf64_segment_memsz then
                (* Cannot be negative due to check in constructing [segs]. *)
                let diff  = (sg.elf64_segment_memsz - sg.elf64_segment_size) in
                let zeros = (byte_sequence$zeros diff) in
                let addr  = (sg.elf64_segment_base + sg.elf64_segment_size) in
                let align = (sg.elf64_segment_align) in
                let paddr = (sg.elf64_segment_paddr) in
                let seg   =                  
(<| elf64_segment_body := zeros; elf64_segment_type := (sg.elf64_segment_type);
                      elf64_segment_size := diff; elf64_segment_memsz := diff;
                      elf64_segment_base := addr; elf64_segment_flags := (sg.elf64_segment_flags);
                      elf64_segment_align := align; elf64_segment_paddr := paddr;
                      elf64_segment_offset := (sg.elf64_segment_offset) |>)
                in
                  return [(sg, FromELF); (seg, AutoGenerated)]
              else
                fail0 "get_elf64_executable_image: invariant invalidated") load >>= (\ bs_base . 
            return (FLAT bs_base, w2n entr, w2n mach))
      )
  else
    fail0 "elf64_get_executable_image: not an executable ELF file"))`;


(** [global_symbol_init_info] records the name, type, size, address, chunk
  * of initialisation data (if relevant for that symbol), and binding, of every
  * global symbol in an ELF file.
  * Another PPCMemism.
  *)
val _ = type_abbrev( "global_symbol_init_info"
  , ``: (string # (num # num # num #  byte_sequence option # num)) list``);

(** [get_elf32_file_global_symbol_init f1] extracts the global symbol init info
  * for ELF file [f1].  May fail.
  *)
(*val get_elf32_file_global_symbol_init : elf32_file -> error global_symbol_init_info*)
val _ = Define `
 (get_elf32_file_global_symbol_init f3=  
 (if is_elf32_executable_file f3.elf32_file_header then
    let segs   = (f3.elf32_file_interpreted_segments) in
    bytes_of_elf32_file f3 >>= (\ bs0 . 
    get_elf32_file_symbol_table f3 >>= (\ symtab . 
    get_elf32_file_symbol_string_table f3 >>= (\ strtab . 
    elf_symbol_table$get_elf32_symbol_image_address symtab strtab >>= (\ strs . 
      let mapped = (mapM (\ (symbol, (typ, size1, addr, bind)) . 
        if typ = elf_symbol_table$stt_object then
          get_elf32_executable_image f3 >>= (\ (img, entry, mach) . 
          let chunks =            
(FILTER (\p .  (case (p ) of
     ( (chunk, _) ) =>
 (addr >= chunk.elf32_segment_base) /\
   ((addr + size1) <= (chunk.elf32_segment_base + chunk.elf32_segment_size))
 )
            ) img)
          in
            (case chunks of
                []    => fail0 "get_elf32_global_symbol_init: global variable not present in executable image"
              | [(x, _)]   =>
                let rebase   = (addr - x.elf32_segment_base) in
                byte_sequence$offset_and_cut rebase size1 x.elf32_segment_body >>= (\ relevant . 
                  return (symbol, (typ, size1, addr, SOME relevant, bind)))
              | x::xs => fail0 "get_elf32_global_symbol_init: invariant failed, global variable appears in multiple segments"
            ))
        else
          return (symbol, (typ, size1, addr, NONE, bind))) strs)
      in
        mapped))))
  else
    fail0 "get_elf32_file_global_symbol_init: not an executable ELF file"))`;


(** [get_elf64_file_global_symbol_init f1] extracts the global symbol init info
  * for ELF file [f1].  May fail.
  *)
(*val get_elf64_file_global_symbol_init : elf64_file -> error global_symbol_init_info*)
val _ = Define `
 (get_elf64_file_global_symbol_init f3=  
 (if is_elf64_executable_file f3.elf64_file_header then
    let segs   = (f3.elf64_file_interpreted_segments) in
    bytes_of_elf64_file f3 >>= (\ bs0 . 
    get_elf64_file_symbol_table f3 >>= (\ symtab . 
    get_elf64_file_symbol_string_table f3 >>= (\ strtab . 
    elf_symbol_table$get_elf64_symbol_image_address symtab strtab >>= (\ strs . 
      let mapped = (mapM (\ (symbol, (typ, size1, addr, bind)) . 
        if typ = elf_symbol_table$stt_object then
          get_elf64_executable_image f3 >>= (\ (img, entry, mach) . 
          let chunks =            
(FILTER (\p .  (case (p ) of
     ( (chunk, _) ) =>
 (addr >= chunk.elf64_segment_base) /\
   ((addr + size1) <= (chunk.elf64_segment_base + chunk.elf64_segment_size))
 )
            ) img)
          in
            (case chunks of
                []    => fail0 "get_elf64_global_symbol_init: global variable not present in executable image"
              | [(x, _)]   =>
                let rebase   = (addr - x.elf64_segment_base) in
                byte_sequence$offset_and_cut rebase size1 x.elf64_segment_body >>= (\ relevant . 
                  return (symbol, (typ, size1, addr, SOME relevant, bind)))
              | x::xs => fail0 "get_elf64_global_symbol_init: invariant failed, global variable appears in multiple segments"
            ))
        else
          return (symbol, (typ, size1, addr, NONE, bind))) strs)
      in
        mapped))))
  else
    fail0 "get_elf64_global_symbol_init: not an executable ELF file"))`;


(** [string_of_elf32_file hdr_bdl pht_bdl sht_bdl f1] produces a string-based
  * representation of ELF file [f1] using ABI-specific print bundles [hdr_bdl],
  * [pht_bdl] and [sht_bdl].
  *)
(*val string_of_elf32_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf32_file -> string*)

(** [string_of_elf64_file hdr_bdl pht_bdl sht_bdl f1] produces a string-based
  * representation of ELF file [f1] using ABI-specific print bundles [hdr_bdl],
  * [pht_bdl] and [sht_bdl].
  *)
(*val string_of_elf64_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf64_file -> string*)

(** [flag_is_set flag v] checks whether flag [flag] is set in [v].
  * TODO: move elsewhere.  Check whether this is still being used.
  *)
(*val flag_is_set : natural -> natural -> bool*)
val _ = Define `
 (flag_is_set flag v=    
(  
    (* HACK: convert to elf64_xword first. Flags never live 
     * in objects bigger than 64 bits. *)word_and 
            ((n2w : num -> uint64) v) 
            ((n2w : num -> uint64) flag)
    = ((n2w : num -> uint64) flag)))`;

val _ = export_theory()

