(*Generated by Lem from archive.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory missing_pervasivesTheory errorTheory byte_sequenceTheory;

val _ = numLib.prefer_num();



val _ = new_theory "archive"

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)
(*open import Show*)
(*open import Assert_extra*)

(*open import Missing_pervasives*)
(*open import Byte_sequence*)
(*open import Error*)

val _ = Hol_datatype `
 archive_entry_header =
  <| name      : string
   ; timestamp : num
   ; uid       : num
   ; gid       : num
   ; mode      : num
   ; size0      : num (* 1GB should be enough *)
   |>`;


val _ = type_abbrev( "archive_global_header" , ``: char
  list``);

(*val string_of_byte_sequence : byte_sequence -> string*)
val _ = Define `
 (string_of_byte_sequence0 seq=  
 ((case seq of
      Sequence bs => IMPLODE (MAP (CHR o w2n) bs)
  )))`;


(*val read_archive_entry_header : natural -> byte_sequence -> error (archive_entry_header * natural * byte_sequence)*)
val _ = Define `
 (read_archive_entry_header seq_length seq=  
 (let magic_bytes = ([(n2w : num -> 8 word(( 96:num))) (* 0x60 *); (n2w : num -> 8 word(( 10:num))) (* 0x0a *)]) in
        let header_length =(( 60:num)) in
        (* let _ = Missing_pervasives.errs ("Archive entry header? " ^ (show (take 16 bs)) ^ "? ") in *)
        partition_with_length header_length seq_length seq >>= (\ (header, rest) .  
        offset_and_cut(( 58:num))(( 2:num)) header >>= (\ magic .  
        offset_and_cut(( 0:num))(( 16:num)) header >>= (\ name .  
        offset_and_cut(( 16:num))(( 12:num)) header >>= (\ timestamp_str .  
        offset_and_cut(( 28:num))(( 6:num))  header >>= (\ uid_str .  
        offset_and_cut(( 34:num))(( 6:num))  header >>= (\ gid_str .  
        offset_and_cut(( 40:num))(( 8:num))  header >>= (\ mode_str .  
        offset_and_cut(( 48:num))(( 10:num)) header >>= (\ size_str .  
        let size1 = (natural_of_decimal_string (string_of_byte_sequence0 size_str)) in 
                (* let _ = Missing_pervasives.errln (": yes, size " ^ (show size)) in *)
        return (<| name := (string_of_byte_sequence0 name); timestamp := ((( 0:num) : num)) (* FIXME *);
          uid :=(( 0 : num)) (* FIXME *) ; gid :=(( 0 : num)) (* FIXME *) ; mode :=(( 0 : num)) (* FIXME *);
            size0 := ( size1) (* FIXME *) |>, (seq_length - header_length), rest)))))))))))`;


(*val read_archive_global_header : byte_sequence -> error (archive_global_header * byte_sequence)*)
val _ = Define `
 (read_archive_global_header seq=  
 ((case seq of
      Sequence bs =>
            (* let _ = Missing_pervasives.errs ("Archive? " ^ (show (take 16 bs)) ^ "? ")
            in*)
      let chars = (MAP (CHR o w2n) (take(( 8:num)) bs)) in 
        if IMPLODE chars = "!<arch>\n" then
          (* let _ = Missing_pervasives.errln ": yes" in *)
          return (chars, Sequence(drop(( 8:num)) bs))
        else
          (* let _ = Missing_pervasives.errln ": no" in *)
          fail0 "read_archive_global_header: not an archive"
    )))`;


(*val accum_archive_contents : (list (string * byte_sequence)) -> maybe string -> natural -> byte_sequence -> error (list (string * byte_sequence))*)
 val accum_archive_contents_defn = Hol_defn "accum_archive_contents" `
 (accum_archive_contents accum extended_filenames whole_seq_length whole_seq=  
(  
  (* let _ = Missing_pervasives.errs "Can read a header? " in *)if ~ ((byte_sequence$length0 whole_seq) = whole_seq_length) then
    lem_assert_extra$fail (* invariant: whole_seq_length always equal to length of whole_seq, so the length is only
      computed one.  This "fail" needed for Isabelle termination proofs... *)
  else
  (case (read_archive_entry_header whole_seq_length whole_seq) of
      Fail _ => return accum
    | Success (hdr, (seq_length : num), seq) =>
    (case seq of
        Sequence next_bs =>
        (* let _ = Missing_pervasives.errln ("yes; next_bs has length " ^ (show (List.length next_bs))) in *)
        let amount_to_drop =          
(if (hdr.size0 MOD( 2 : num)) =( 0 : num) then
            (( hdr.size0:num))
          else
            (( hdr.size0:num)) +( 1:num))
        in
        if amount_to_drop =( 0:num) then
          fail0 "accum_archive_contents: amount to drop from byte sequence is 0"
        else
        (*let _ = Missing_pervasives.errln ("amount_to_drop is " ^ (show amount_to_drop)) in*)
        let chunk = (Sequence(TAKE hdr.size0 next_bs))
        in
        (*let _ = Missing_pervasives.errs ("Processing archive header named " ^ hdr.name)
        in*)
        let (new_accum, (new_extended_filenames :  string option)) =          
(let name = (EXPLODE hdr.name) in
            if name = [#"/"; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "; #" "] then
              (* SystemV symbol lookup table; we skip this *) (accum, extended_filenames)
            else
              (case name of
                  x::xs =>
                  if x = #"/" then
                    (case xs of
                        y::ys =>
                        if y = #"/" then
                          (accum, SOME (string_of_byte_sequence0 chunk))
                        else
                          let index = (natural_of_decimal_string (IMPLODE xs)) in
                            (case extended_filenames of 
                                NONE => failwith "corrupt archive: reference to non-existent extended filenames"
                              | SOME s => 
                                let table_suffix = ((case string_suffix index s of SOME x => x | NONE => "" )) in
                                let index = ((case string_index_of #"/" table_suffix of SOME x => x | NONE => (((STRLEN table_suffix):num)) )) in 
                                let ext_name = ((case string_prefix index table_suffix of SOME x => x | NONE => "" )) in
                                  (*let _ = Missing_pervasives.errln ("Got ext_name " ^ ext_name) in*)
                                  (((ext_name, chunk) :: accum), extended_filenames)
                           )
                      | [] =>
                        let index = (natural_of_decimal_string (IMPLODE xs)) in
                          (case extended_filenames of 
                              NONE => failwith "corrupt archive: reference to non-existent extended filenames"
                            | SOME s => 
                              let table_suffix = ((case string_suffix index s of SOME x => x | NONE => "" )) in
                              let index = ((case string_index_of #"/" table_suffix of SOME x => x | NONE => (((STRLEN table_suffix):num)) )) in 
                              let ext_name = ((case string_prefix index table_suffix of SOME x => x | NONE => "" )) in
                                (*let _ = Missing_pervasives.errln ("Got ext_name " ^ ext_name) in*)
                                (((ext_name, chunk) :: accum), extended_filenames)
                         )
                    )
                  else
                    (((hdr.name, chunk) :: accum), extended_filenames)
                | [] => (((hdr.name, chunk) :: accum), extended_filenames)
              ))
        in
          (case (byte_sequence$dropbytes amount_to_drop seq) of
              Fail _ => return accum
            | Success new_seq =>
              accum_archive_contents new_accum new_extended_filenames (seq_length - amount_to_drop) new_seq
          )
    )
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn accum_archive_contents_defn;

(*val read_archive : byte_sequence -> error (list (string * byte_sequence))*)
val _ = Define `
 (read_archive bs=    
  (read_archive_global_header bs >>= (\ (hdr, seq) .  
    let result = (accum_archive_contents [] NONE (byte_sequence$length0 seq) seq)  in 
    (* let _ = Missing_pervasives.errln "Finished reading archive" in *)
    (case result of
        Success r => Success (REVERSE r)
        | Fail x => Fail x
    ))))`;

val _ = export_theory()

