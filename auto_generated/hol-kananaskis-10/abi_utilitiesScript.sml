(*Generated by Lem from abis/abi_utilities.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_basic_classesTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory missing_pervasivesTheory errorTheory elf_types_native_uintTheory lem_mapTheory elf_symbol_tableTheory elf_relocationTheory memory_imageTheory abi_classesTheory memory_image_orderingsTheory;

val _ = numLib.prefer_num();



val _ = new_theory "abi_utilities"

(** [abi_utilities], generic utilities shared between all ABIs.
  *)

(*open import Map*)
(*open import Maybe*)
(*open import Num*)
(*open import Basic_classes*)
(*open import Maybe*)
(*open import String*)
(*open import Error*)
(*open import Assert_extra*)

(*open import Abi_classes*)
(*open import Missing_pervasives*)
(*open import Elf_types_native_uint*)
(*open import Elf_symbol_table*)
(*open import Elf_relocation*)
(*open import Memory_image*)
(*open import Memory_image_orderings*)


(*open import Error*)

(** [integer_bit_width] records various bit widths for integral types, as used
  * in relocation calculations. The names are taken directly from the processor
  * supplements to keep the calculations as close as possible
  * to the specification of relocations.
  *)
val _ = Hol_datatype `
 integer_bit_width
  = I8        (** Signed 8 bit *)
  | I12
  | U12       (** Unsigned 12 bit *)
  | Low14
  | U15       (** Unsigned 15 bit *)
  | I15
  | I16       (** Signed 16 bit *)
  | Half16ds
  | I20       (** Signed 20 bit *)
  | Low24
  | I27
  | Word30
  | I32       (** Signed 32 bit *)
  | I48       (** Signed 48 bit *)
  | I64       (** Signed 64 bit *)
  | I64X2     (** Signed 128 bit *)
  | U16       (** Unsigned 16 bit *)
  | U24       (** Unsigned 24 bit *)
  | U32       (** Unsigned 32 bit *)
  | U48       (** Unsigned 48 bit *)
  | U64`;
       (** Unsigned 64 bit *)
  
(** [natural_of_integer_bit_width i] computes the bit width of integer bit width
  * [i].
  *)
(*val natural_of_integer_bit_width : integer_bit_width -> natural*)
val _ = Define `
 (natural_of_integer_bit_width i=  
 ((case i of
      I8       =>( 8:num)
    | I12      =>( 12:num)
    | U12      =>( 12:num)
    | Low14    =>( 14:num)
    | I15      =>( 15:num)
    | U15      =>( 15:num)
    | I16      =>( 16:num)
    | Half16ds =>( 16:num)
    | U16      =>( 16:num)
    | I20      =>( 20:num)
    | Low24    =>( 24:num)
    | U24      =>( 24:num)
    | I27      =>( 27:num)
    | Word30   =>( 30:num)
    | I32      =>( 32:num)
    | U32      =>( 32:num)
    | I48      =>( 48:num)
    | U48      =>( 48:num)
    | I64      =>( 64:num)
    | U64      =>( 64:num)
    | I64X2    =>( 128:num)
  )))`;

  
(** [relocation_operator] records the operators used to calculate relocations by
  * the various ABIs.  Each ABI will only use a subset of these, and they should
  * be interpreted on a per-ABI basis.  As more ABIs are added, more operators
  * will be needed, and therefore more constructors in this type will need to
  * be added.  These are unary operators, operating on a single integral type.
  *)
val _ = Hol_datatype `
 relocation_operator
  = TPRel
  | LTOff
  | DTPMod
  | DTPRel
  | Page
  | GDat
  | G
  | GLDM
  | GTPRel
  | GTLSDesc
  | Delta
  | LDM
  | TLSDesc
  | Indirect
  | Lo
  | Hi
  | Ha
  | Higher
  | HigherA
  | Highest
  | HighestA`;

  
(** [relocation_operator2] is a binary relocation operator, as detailed above.
  *)
val _ = Hol_datatype `
 relocation_operator2 =
    GTLSIdx`;

  
(** Generalising and abstracting over relocation calculations and their return
  * types
  *)
  
val _ = type_abbrev((* ( 'k, 'v) *) "val_map" , ``: ('k, 'v)
  fmap``);

(*val lookupM : forall 'k 'v. MapKeyType 'k => 'k -> val_map 'k 'v -> error 'v*)
val _ = Define `
 (lookupM key val_map=  
 ((case FLOOKUP val_map key of
      NONE => fail0 "lookupM: key not found in val_map"
    | SOME j  => return j
  )))`;

  
(** Some relocations may fail, for example:
  * Page 58, Power ABI: relocation types whose Field column is marked with an
  * asterisk are subject to failure is the value computed does not fit in the
  * allocated bits.  [can_fail] type passes this information back to the caller
  * of the relocation application function.
  *)
val _ = Hol_datatype `
 can_fail
  = CanFail                       (** [CanFail] signals a potential failing relocation calculation when width constraints are invalidated *)
  | CanFailOnTest of ('a -> bool) (** [CanFailOnTest p] signals a potentially failing relocation calculation when predicate [p] on the result of the calculation returns [false] *)
  | CannotFail`;
                    (** [CannotFail] states the relocation calculation cannot fail and bit-width constraints should be ignored *)
  
(** [relocation_operator_expression] is an AST of expressions describing a relocation
  * calculation.  An AST is used as it allows us to unify the treatment of relocation
  * calculation: rather than passing in dozens of functions to the calculation function
  * that perform the actual relocation, we can simply return a description (in the form
  * of the AST below) of the calculation to be carried out and have it interpreted
  * separately from the function that produces it.  The type parameter 'a is the
  * type of base integral type.  This AST suffices for the relocation calculations we
  * currently have implemented, but adding more ABIs may require that this type is
  * expanded.
  *)
val _ = Hol_datatype `
 relocation_operator_expression
  = Lift   of 'a                                                                                             (** Lift a base type into an AST *)
  | Apply  of (relocation_operator # relocation_operator_expression)                                      (** Apply a unary operator to an expression *)
  | Apply2 of (relocation_operator2 # relocation_operator_expression # relocation_operator_expression) (** Apply a binary operator to two expressions *)
  | Plus   of (relocation_operator_expression # relocation_operator_expression)                        (** Add two expressions. *)
  | Minus  of (relocation_operator_expression # relocation_operator_expression)                        (** Subtract two expressions. *)
  | RShift of (relocation_operator_expression # num)`;
                                                  (** Right shift the result of an expression [m] places. *)
  
val _ = Hol_datatype `
 relocation_frame =
    Copy
  | NoCopy of ( ('addr, ( 'res relocation_operator_expression # integer_bit_width # 'res can_fail))fmap)`;


(*val size_of_def : symbol_reference_and_reloc_site -> natural*)
val _ = Define `
 (size_of_def rr=  
 (let rf = (rr.ref) in
  let sm = (rf.ref_syment) in
    w2n sm.elf64_st_size))`;


(*val size_of_copy_reloc : forall 'abifeature. annotated_memory_image 'abifeature -> symbol_reference_and_reloc_site -> natural*)
val _ = Define `
 (size_of_copy_reloc img rr=    
(  
    (* it's the minimum of the two definition symbol sizes. FIXME: for now, just use the rr *)size_of_def rr))`;


(*val reloc_site_address : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => 
    annotated_memory_image 'abifeature -> symbol_reference_and_reloc_site -> natural*)
val _ = Define `
 (reloc_site_address dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img rr=    
(  
    (* find the element range that's tagged with this reloc site *)let found_kvs = (multimap$lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     dict_Basic_classes_Ord_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      lem_string_extra$instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict))) (=) (SymbolRef(rr)) img.by_tag)
    in
    (case found_kvs of
        [] => failwith "impossible: reloc site not marked in memory image"
        | [(_, maybe_range)] => (case maybe_range of 
                NONE => failwith "impossible: reloc site has no element range"
                | SOME (el_name, el_range) => 
                    let element_addr = ((case FLOOKUP img.elements el_name of
                        NONE => failwith "impossible: non-existent element"
                        | SOME el => (case el.startpos of
                            NONE => failwith "error: resolving relocation site address before address has been assigned"
                            | SOME addr => addr
                        )
                    ))
                    in
                    let site_offset = (* match rr.maybe_reloc with 
                        Just reloc -> natural_of_elf64_addr reloc.ref_relent.elf64_ra_offset
                        | Nothing -> failwith "symbol reference with range but no reloc site"
                    end*) (
  (case el_range of (start, _) => start ))
                    in
                    element_addr + site_offset
            )
        | _ => failwith "error: more than one address with identical relocation record"
    )))`;

val _ = export_theory()

