(*Generated by Lem from gnu_extensions/gnu_ext_note.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory missing_pervasivesTheory errorTheory byte_sequenceTheory endiannessTheory elf_types_native_uintTheory string_tableTheory elf_section_header_tableTheory gnu_ext_section_header_tableTheory elf_noteTheory;

val _ = numLib.prefer_num();



val _ = new_theory "gnu_ext_note"

(** [gnu_ext_note] contains GNU extension specific definitions relating to the
  * .note section/segment of an ELF file.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Maybe*)
(*open import String*)

(*open import Byte_sequence*)
(*open import Endianness*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import String_table*)

(*open import Elf_note*)
(*open import Elf_section_header_table*)
(*open import Elf_types_native_uint*)

(*open import Gnu_ext_section_header_table*)

(** The following two functions are utility functions to convert a list of bytes
  * into words, ready for further processing into strings.
  *)
  
(*val group_elf32_words : endianness -> list byte -> error (list elf32_word)*)
 val group_elf32_words_defn = Hol_defn "group_elf32_words" `
 (group_elf32_words endian xs=  
 ((case xs of
      []                 => return []
    | x1::x2::x3::x4::xs =>
      let bs0 = (byte_sequence$from_byte_lists [[x1;x2;x3;x4]]) in
      read_elf32_word   endian bs0 >>= 
  (\p .  (case (p ) of
             ( (w, _) ) =>
         group_elf32_words endian xs >>= (\ ws .  return (w :: ws))
         ))
    | xs                 => fail0 "group_elf32_words: the impossible happened"
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn group_elf32_words_defn;
  
(*val group_elf64_words : endianness -> list byte -> error (list elf64_word)*)
 val group_elf64_words_defn = Hol_defn "group_elf64_words" `
 (group_elf64_words endian xs=  
 ((case xs of
      []                 => return []
    | x1::x2::x3::x4::xs =>
      let bs0 = (byte_sequence$from_byte_lists [[x1;x2;x3;x4]]) in
      read_elf64_word   endian bs0 >>= 
  (\p .  (case (p ) of
             ( (w, _) ) =>
         group_elf64_words endian xs >>= (\ ws .  return (w :: ws))
         ))
    | xs                 => fail0 "group_elf64_words: the impossible happened"
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn group_elf64_words_defn;

(** [gnu_ext_check_elf32_abi_note_tag_section endain sht stbl bs0] checks the
  * .note.ABI-tag section of an ELF file to ensure conformance with the GNU
  * extensions.  The string in this note should contain the string "GNU".
  *)
(*val gnu_ext_check_elf32_abi_note_tag_section : endianness -> elf32_section_header_table ->
  string_table -> byte_sequence -> bool*)
val _ = Define `
 (gnu_ext_check_elf32_abi_note_tag_section endian sht sect_hdr_tbl bs0=  
 (let abi_note_sects =    
(FILTER (\ x . 
      if w2n x.elf32_sh_type = sht_note then
        let nm = (w2n x.elf32_sh_name) in
          (case string_table$get_string_at nm sect_hdr_tbl of
              Success name => name = ".note.ABI-tag"
            | Fail _       => F
          )
      else
        F
    ) sht)
  in
    (case abi_note_sects of
        [note] =>
        let off = (w2n note.elf32_sh_offset) in
        let siz = (w2n note.elf32_sh_size) in
        let abi_tag =          
(byte_sequence$offset_and_cut off siz bs0 >>= (\ rel . 
          elf_note$read_elf32_note endian rel >>= 
  (\p .  (case (p ) of ( (abi_tag, _) ) => return abi_tag ))))
        in
          (case abi_tag of
              Fail _          => F
            | Success abi_tag =>
              let str = (name_string_of_elf32_note abi_tag) in
                if str = "GNU\^^@" then
                  if w2n abi_tag.elf32_note_descsz >=( 16:num) then
                    let take = (TAKE(( 16 : num)) abi_tag.elf32_note_desc) in
                      if LENGTH take <( 16 : num) then
                        F
                      else
                        T
                  else
                    F
                else
                  F
          )
      | _      =>
          F
    )))`;


(** [gnu_ext_check_elf64_abi_note_tag_section endain sht stbl bs0] checks the
  * .note.ABI-tag section of an ELF file to ensure conformance with the GNU
  * extensions.  The string in this note should contain the string "GNU".
  *)
(*val gnu_ext_check_elf64_abi_note_tag_section : endianness -> elf64_section_header_table ->
  string_table -> byte_sequence -> bool*)
val _ = Define `
 (gnu_ext_check_elf64_abi_note_tag_section endian sht sect_hdr_tbl bs0=  
 (let abi_note_sects =    
(FILTER (\ x . 
      if w2n x.elf64_sh_type = sht_note then
        let nm = (w2n x.elf64_sh_name) in
          (case string_table$get_string_at nm sect_hdr_tbl of
              Success name => name = ".note.ABI-tag"
            | Fail _       => F
          )
      else
        F
    ) sht)
  in
    (case abi_note_sects of
        [note] =>
        let off = (w2n note.elf64_sh_offset) in
        let siz = (w2n note.elf64_sh_size) in
        let abi_tag =          
(byte_sequence$offset_and_cut off siz bs0 >>= (\ rel . 
          elf_note$read_elf64_note endian rel >>= 
  (\p .  (case (p ) of ( (abi_tag, _) ) => return abi_tag ))))
        in
          (case abi_tag of
              Fail _          => F
            | Success abi_tag =>
              let str = (name_string_of_elf64_note abi_tag) in
                if str = "GNU\^^@" then
                  if w2n abi_tag.elf64_note_descsz >=( 16:num) then
                    let take = (TAKE(( 16 : num)) abi_tag.elf64_note_desc) in
                      if LENGTH take <( 16 : num) then
                        F
                      else
                        T
                  else
                    F
                else
                  F
          )
      | _      =>
          F
    )))`;

    
(** [gnu_ext_extract_elf32_earliest_compatible_kernel end sht stab bs0] extracts
  * the earliest compatible Linux kernel with the given ELF file from its section
  * header table [sht], and string table [stbl], assuming endianness [endian].
  * NB: marked as OCaml only as need to extract a string from integers.
  * TODO: implement some string parsing functions in Isabelle/HOL so things like
  * this can be extracted.
  *)
(*val gnu_ext_extract_elf32_earliest_compatible_kernel : endianness -> elf32_section_header_table ->
  string_table -> byte_sequence -> error string*)
    
(** [gnu_ext_extract_elf64_earliest_compatible_kernel end sht stab bs0] extracts
  * the earliest compatible Linux kernel with the given ELF file from its section
  * header table [sht], and string table [stbl], assuming endianness [endian].
  * NB: marked as OCaml only as need to extract a string from integers.
  * TODO: implement some string parsing functions in Isabelle/HOL so things like
  * this can be extracted.
  *)
(*val gnu_ext_extract_elf64_earliest_compatible_kernel : endianness -> elf64_section_header_table ->
  string_table -> byte_sequence -> error string*)
val _ = export_theory()

