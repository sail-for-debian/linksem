(*Generated by Lem from elf_relocation.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_setTheory lem_basic_classesTheory lem_stringTheory showTheory missing_pervasivesTheory errorTheory byte_sequenceTheory endiannessTheory elf_types_native_uintTheory;

val _ = numLib.prefer_num();



val _ = new_theory "elf_relocation"

(** [elf_relocation] formalises types, functions and other definitions for working
  * with ELF relocation and relocation with addend entries.
  *)

(*open import Basic_classes*)
(*open import Num*)
(*open import List*)
(*import Set*)

(*open import Endianness*)
(*open import Byte_sequence*)
(*open import Error*)

(*open import String*)
(*open import Show*)
(*open import Missing_pervasives*)

(*open import Elf_types_native_uint*)

(** ELF relocation records *)

(** [elf32_relocation] is a simple relocation record (without addend).
  *)
val _ = Hol_datatype `
 elf32_relocation =
  <| elf32_r_offset : uint32 (** Address at which to relocate *)
   ; elf32_r_info   : uint32 (** Symbol table index/type of relocation to apply *)
   |>`;


(** [elf32_relocation_a] is a relocation record with addend.
  *)
val _ = Hol_datatype `
 elf32_relocation_a =
  <| elf32_ra_offset : uint32  (** Address at which to relocate *)
   ; elf32_ra_info   : uint32  (** Symbol table index/type of relocation to apply *)
   ; elf32_ra_addend : sint32 (** Addend used to compute value to be stored *)
   |>`;


(** [elf64_relocation] is a simple relocation record (without addend).
  *)
val _ = Hol_datatype `
 elf64_relocation =
  <| elf64_r_offset : uint64  (** Address at which to relocate *)
   ; elf64_r_info   : uint64 (** Symbol table index/type of relocation to apply *)
   |>`;


(** [elf64_relocation_a] is a relocation record with addend.
  *)
val _ = Hol_datatype `
 elf64_relocation_a =
  <| elf64_ra_offset : uint64   (** Address at which to relocate *)
   ; elf64_ra_info   : uint64  (** Symbol table index/type of relocation to apply *)
   ; elf64_ra_addend : sint64 (** Addend used to compute value to be stored *)
   |>`;


(** [elf64_relocation_a_compare r1 r2] is an ordering comparison function for
  * relocation with addend records suitable for constructing sets, finite map
  * and other ordered data structures.
  * NB: we exclusively use elf64_relocation_a in range tags, regardless of what
  * file/reloc  the info came from, so only this one needs an Ord instance.
  *)
(*val elf64_relocation_a_compare : elf64_relocation_a -> elf64_relocation_a ->
  ordering*)
val _ = Define `
 (elf64_relocation_a_compare ent1 ent2=     
 (tripleCompare (genericCompare (<) (=)) (genericCompare (<) (=)) (genericCompare (<) (=)) (w2n ent1.elf64_ra_offset, w2n ent1.elf64_ra_info,
        w2i ent1.elf64_ra_addend) 
        (w2n ent2.elf64_ra_offset, w2n ent2.elf64_ra_info,
        w2i ent2.elf64_ra_addend)))`;


val _ = Define `
(instance_Basic_classes_Ord_Elf_relocation_elf64_relocation_a_dict= (<|

  compare_method := elf64_relocation_a_compare;

  isLess_method := (\ f1 .  (\ f2 .  (elf64_relocation_a_compare f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (elf64_relocation_a_compare f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (elf64_relocation_a_compare f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (elf64_relocation_a_compare f1 f2) ({GT; EQ})))|>))`;
   

(** Extracting useful information *)

(** [extract_elf32_relocation_r_sym w] computes the symbol table index associated with
  * an ELF32 relocation(a) entry.
  * [w] here is the [r_info] member of the [elf32_relocation(a)] type.
  *)
(*val extract_elf32_relocation_r_sym : elf32_word -> natural*)
val _ = Define `
 (extract_elf32_relocation_r_sym w=  
 (w2n (word_lsr w(( 8 : num)))))`;


(** [extract_elf64_relocation_r_sym w] computes the symbol table index associated with
  * an ELF64 relocation(a) entry.
  * [w] here is the [r_info] member of the [elf64_relocation(a)] type.
  *)
(*val extract_elf64_relocation_r_sym : elf64_xword -> natural*)
val _ = Define `
 (extract_elf64_relocation_r_sym w=  
 (w2n (word_lsr w(( 32 : num)))))`;


(** [extract_elf32_relocation_r_type w] computes the symbol type associated with an ELF32
  * relocation(a) entry.
  * [w] here is the [r_info] member of the [elf32_relocation(a)] type.
  *)
(*val extract_elf32_relocation_r_type : elf32_word -> natural*)
val _ = Define `
 (extract_elf32_relocation_r_type w=  
 ((w2n w) MOD( 256:num)))`;


(** [extract_elf64_relocation_r_type w] computes the symbol type associated with an ELF64
  * relocation(a) entry.
  * [w] here is the [r_info] member of the [elf64_relocation(a)] type.
  *)
(*val extract_elf64_relocation_r_type : elf64_xword -> natural*)
val _ = Define `
 (extract_elf64_relocation_r_type w=  
 (let magic = ((( 65536:num) *( 65536:num)) -( 1:num)) in (* 0xffffffffL *)
    w2n (word_and w ((n2w : num -> uint64) magic))))`;

    
(* Accessors *) 

(*val get_elf32_relocation_r_sym : elf32_relocation -> natural*)
val _ = Define `
 (get_elf32_relocation_r_sym r=  
 (extract_elf32_relocation_r_sym r.elf32_r_info))`;


(*val get_elf32_relocation_a_sym :  elf32_relocation_a -> natural*)
val _ = Define `
 (get_elf32_relocation_a_sym r=  
  (extract_elf32_relocation_r_sym r.elf32_ra_info))`;
  

(*val get_elf64_relocation_sym : elf64_relocation -> natural*)
val _ = Define `
 (get_elf64_relocation_sym r=  
 (extract_elf64_relocation_r_sym r.elf64_r_info))`;
  
  
(*val get_elf64_relocation_a_sym :  elf64_relocation_a -> natural*)
val _ = Define `
 (get_elf64_relocation_a_sym r=  
  (extract_elf64_relocation_r_sym r.elf64_ra_info))`;
  

(*val get_elf32_relocation_type : elf32_relocation -> natural*)
val _ = Define `
 (get_elf32_relocation_type r=  
 (extract_elf32_relocation_r_type r.elf32_r_info))`;


(*val get_elf32_relocation_a_type  : elf32_relocation_a -> natural*)
val _ = Define `
 (get_elf32_relocation_a_type  r=  
 (extract_elf32_relocation_r_type r.elf32_ra_info))`;
  

(*val get_elf64_relocation_type : elf64_relocation -> natural*)
val _ = Define `
 (get_elf64_relocation_type r=  
 (extract_elf64_relocation_r_type r.elf64_r_info))`;
  

(*val get_elf64_relocation_a_type  : elf64_relocation_a -> natural*)
val _ = Define `
 (get_elf64_relocation_a_type  r=  
 (extract_elf64_relocation_r_type r.elf64_ra_info))`;
  

    
(** Reading relocation entries *)
    
(** [read_elf32_relocation ed bs0] parses an [elf32_relocation] record from
  * byte sequence [bs0] assuming endianness [ed].  The suffix of [bs0] remaining
  * after parsing is also returned.
  * Fails if the relocation record cannot be parsed.
  *)
(*val read_elf32_relocation : endianness -> byte_sequence ->
  error (elf32_relocation * byte_sequence)*)
val _ = Define `
 (read_elf32_relocation endian bs=  
 (read_elf32_addr endian bs >>= (\ (r_offset, bs) . 
  read_elf32_word endian bs >>= (\ (r_info, bs) . 
  return (<| elf32_r_offset := r_offset; elf32_r_info := r_info |>, bs)))))`;

    
(** [read_elf64_relocation ed bs0] parses an [elf64_relocation] record from
  * byte sequence [bs0] assuming endianness [ed].  The suffix of [bs0] remaining
  * after parsing is also returned.
  * Fails if the relocation record cannot be parsed.
  *)
(*val read_elf64_relocation : endianness -> byte_sequence ->
  error (elf64_relocation * byte_sequence)*)
val _ = Define `
 (read_elf64_relocation endian bs=  
 (read_elf64_addr endian bs  >>= (\ (r_offset, bs) . 
  read_elf64_xword endian bs >>= (\ (r_info, bs) . 
  return (<| elf64_r_offset := r_offset; elf64_r_info := r_info |>, bs)))))`;


(** [read_elf32_relocation_a ed bs0] parses an [elf32_relocation_a] record from
  * byte sequence [bs0] assuming endianness [ed].  The suffix of [bs0] remaining
  * after parsing is also returned.
  * Fails if the relocation record cannot be parsed.
  *)
(*val read_elf32_relocation_a : endianness -> byte_sequence ->
  error (elf32_relocation_a * byte_sequence)*)
val _ = Define `
 (read_elf32_relocation_a endian bs=  
 (read_elf32_addr endian bs  >>= (\ (r_offset, bs) . 
  read_elf32_word endian bs  >>= (\ (r_info, bs) . 
  read_elf32_sword endian bs >>= (\ (r_addend, bs) . 
  return (<| elf32_ra_offset := r_offset; elf32_ra_info := r_info;
    elf32_ra_addend := r_addend |>, bs))))))`;


(** [read_elf64_relocation_a ed bs0] parses an [elf64_relocation_a] record from
  * byte sequence [bs0] assuming endianness [ed].  The suffix of [bs0] remaining
  * after parsing is also returned.
  * Fails if the relocation record cannot be parsed.
  *)
(*val read_elf64_relocation_a : endianness -> byte_sequence -> error (elf64_relocation_a * byte_sequence)*)
val _ = Define `
 (read_elf64_relocation_a endian bs=  
 (read_elf64_addr endian bs   >>= (\ (r_offset, bs) . 
  read_elf64_xword endian bs  >>= (\ (r_info, bs) . 
  read_elf64_sxword endian bs >>= (\ (r_addend, bs) . 
  return (<| elf64_ra_offset := r_offset; elf64_ra_info := r_info;
    elf64_ra_addend := r_addend |>, bs))))))`;


(** [read_elf32_relocation_section' ed bs0] parses a list of [elf32_relocation]
  * records from byte sequence [bs0], which is assumed to have the exact size
  * required, assuming endianness [ed].
  * Fails if any of the records cannot be parsed.
  *)
(*val read_elf32_relocation_section' : endianness -> byte_sequence ->
  error (list elf32_relocation)*)
 val read_elf32_relocation_section'_defn = Hol_defn "read_elf32_relocation_section'" `
 (read_elf32_relocation_section' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf32_relocation endian bs0 >>= (\ (entry, bs1) . 
    read_elf32_relocation_section' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf32_relocation_section'_defn;

(** [read_elf64_relocation_section' ed bs0] parses a list of [elf64_relocation]
  * records from byte sequence [bs0], which is assumed to have the exact size
  * required, assuming endianness [ed].
  * Fails if any of the records cannot be parsed.
  *)
(*val read_elf64_relocation_section' : endianness -> byte_sequence ->
  error (list elf64_relocation)*)
 val read_elf64_relocation_section'_defn = Hol_defn "read_elf64_relocation_section'" `
 (read_elf64_relocation_section' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf64_relocation endian bs0 >>= (\ (entry, bs1) . 
    read_elf64_relocation_section' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf64_relocation_section'_defn;
    
(** [read_elf32_relocation_a_section' ed bs0] parses a list of [elf32_relocation_a]
  * records from byte sequence [bs0], which is assumed to have the exact size
  * required, assuming endianness [ed].
  * Fails if any of the records cannot be parsed.
  *)
(*val read_elf32_relocation_a_section' : endianness -> byte_sequence ->
  error (list elf32_relocation_a)*)
 val read_elf32_relocation_a_section'_defn = Hol_defn "read_elf32_relocation_a_section'" `
 (read_elf32_relocation_a_section' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf32_relocation_a endian bs0 >>= (\ (entry, bs1) . 
    read_elf32_relocation_a_section' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf32_relocation_a_section'_defn;
    
(** [read_elf64_relocation_a_section' ed bs0] parses a list of [elf64_relocation_a]
  * records from byte sequence [bs0], which is assumed to have the exact size
  * required, assuming endianness [ed].
  * Fails if any of the records cannot be parsed.
  *)
(*val read_elf64_relocation_a_section' : endianness -> byte_sequence ->
  error (list elf64_relocation_a)*)
 val read_elf64_relocation_a_section'_defn = Hol_defn "read_elf64_relocation_a_section'" `
 (read_elf64_relocation_a_section' endian bs0=  
 (if byte_sequence$length0 bs0 =( 0:num) then
    return []
  else
    read_elf64_relocation_a endian bs0 >>= (\ (entry, bs1) . 
    read_elf64_relocation_a_section' endian bs1 >>= (\ tail . 
    return (entry::tail)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn read_elf64_relocation_a_section'_defn;
    
(** [read_elf32_relocation_section sz ed bs0] reads in a list of [elf32_relocation]
  * records from a prefix of [bs0] of size [sz] assuming endianness [ed].  The
  * suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the records cannot be parsed or if the length of [bs0] is
  * less than [sz].
  *)
(*val read_elf32_relocation_section : natural -> endianness -> byte_sequence
  -> error (list elf32_relocation * byte_sequence)*)
val _ = Define `
 (read_elf32_relocation_section table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf32_relocation_section' endian eat >>= (\ entries . 
  return (entries, rest)))))`;


(** [read_elf64_relocation_section sz ed bs0] reads in a list of [elf64_relocation]
  * records from a prefix of [bs0] of size [sz] assuming endianness [ed].  The
  * suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the records cannot be parsed or if the length of [bs0] is
  * less than [sz].
  *)
(*val read_elf64_relocation_section : natural -> endianness -> byte_sequence
  -> error (list elf64_relocation * byte_sequence)*)
val _ = Define `
 (read_elf64_relocation_section table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf64_relocation_section' endian eat >>= (\ entries . 
  return (entries, rest)))))`;


(** [read_elf32_relocation_a_section sz ed bs0] reads in a list of [elf32_relocation_a]
  * records from a prefix of [bs0] of size [sz] assuming endianness [ed].  The
  * suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the records cannot be parsed or if the length of [bs0] is
  * less than [sz].
  *)
(*val read_elf32_relocation_a_section : natural -> endianness -> byte_sequence ->
  error (list elf32_relocation_a * byte_sequence)*)
val _ = Define `
 (read_elf32_relocation_a_section table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf32_relocation_a_section' endian eat >>= (\ entries . 
  return (entries, rest)))))`;


(** [read_elf64_relocation_a_section sz ed bs0] reads in a list of [elf64_relocation_a]
  * records from a prefix of [bs0] of size [sz] assuming endianness [ed].  The
  * suffix of [bs0] remaining after parsing is also returned.
  * Fails if any of the records cannot be parsed or if the length of [bs0] is
  * less than [sz].
  *)
(*val read_elf64_relocation_a_section : natural -> endianness -> byte_sequence ->
  error (list elf64_relocation_a * byte_sequence)*)
val _ = Define `
 (read_elf64_relocation_a_section table_size endian bs0=  
 (partition0 table_size bs0 >>= (\ (eat, rest) . 
  read_elf64_relocation_a_section' endian eat >>= (\ entries . 
  return (entries, rest)))))`;

val _ = export_theory()

