(*Generated by Lem from abis/amd64/abi_amd64.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_assert_extraTheory missing_pervasivesTheory errorTheory endiannessTheory elf_types_native_uintTheory elf_headerTheory lem_mapTheory elf_interpreted_sectionTheory elf_interpreted_segmentTheory elf_fileTheory memory_imageTheory abi_classesTheory abi_amd64_elf_headerTheory abi_amd64_relocationTheory;

val _ = numLib.prefer_num();



val _ = new_theory "abi_amd64"

(** [abi_amd64] contains top-level definition for the AMD64 ABI.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import Error*)
(*open import Map*)
(*open import Assert_extra*)

(*open import Missing_pervasives*)
(*open import Elf_header*)
(*open import Elf_types_native_uint*)
(*open import Elf_file*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)

(*open import Endianness*)
(*open import Memory_image*)
(* open import Elf_memory_image *)

(*open import Abi_classes*)
(*open import Abi_amd64_relocation*)
(*open import Abi_amd64_elf_header*)

(** [abi_amd64_compute_program_entry_point segs entry] computes the program
  * entry point using ABI-specific conventions.  On AMD64 the entry point in
  * the ELF header ([entry] here) is the real entry point.  On other ABIs, e.g.
  * PowerPC64, the entry point [entry] is a pointer into one of the segments
  * constituting the process image (passed in as [segs] here for a uniform
  * interface).
  *)
(*val abi_amd64_compute_program_entry_point : list elf64_interpreted_segments -> elf64_addr -> error natural*)
val _ = Define `
 (abi_amd64_compute_program_entry_point segs entry=	
 (return (w2n entry)))`;


(*val header_is_amd64 : elf64_header -> bool*)
val _ = Define `
 (header_is_amd64 h=    
   (is_valid_elf64_header h
    /\ (lem_list$list_index h.elf64_ident ( elf_ii_data) = SOME ((n2w : num -> unsigned_char) elf_data_2lsb))
    /\ is_valid_abi_amd64_machine_architecture (w2n h.elf64_machine)
    /\ is_valid_abi_amd64_magic_number h.elf64_ident))`;


val _ = Define `
 (shf_x86_64_large : num=  (( 256:num) *( 1048576:num)))`;
 (* 0x10000000 a.k.a. 2^28 *)

(* We model the PLT as a list of symbol name, maybe def, and a function
 * - from the PLT slot offset and the whole with-addresses image (overkill)
 * - to... what? currently it's the address of the named symbol *)
val _ = type_abbrev((*  'abifeature *) "plt_entry_content_fn" , ``: num -> num -> (num # word8 list)``);
                                     (* PLT base addr, GOT base addr (the rest is closure-captured) -> slot_addr, slot contents *)

val _ = Hol_datatype `
 amd64_abi_feature = 
    GOT0 of  ( (string # ( symbol_definition option))list)
    | PLT0 of ( (string # ( symbol_definition option) # 'abifeature plt_entry_content_fn)list)`;

    
(*val abiFeatureCompare : forall 'abifeature. amd64_abi_feature 'abifeature -> amd64_abi_feature 'abifeature -> Basic_classes.ordering*)
val _ = Define `
 (abiFeatureCompare0 f1 f2=    
  ((case (f1, f2) of
        (GOT0(_), GOT0(_)) => EQ
        | (GOT0(_), PLT0(_)) => LT
        | (PLT0(_), PLT0(_)) => EQ
        | (PLT0(_), GOT0(_)) => GT
    )))`;


(*val abiFeatureTagEq : forall 'abifeature. amd64_abi_feature 'abifeature -> amd64_abi_feature 'abifeature -> bool*)
val _ = Define `
 (abiFeatureTagEq0 f1 f2=    
 ((case (f1, f2) of
        (GOT0(_), GOT0(_)) => T
        | (PLT0(_), PLT0(_)) => T
        | (_, _) => F
    )))`;


val _ = Define `
(instance_Abi_classes_AbiFeatureTagEquiv_Abi_amd64_amd64_abi_feature_dict= (<|

  abiFeatureTagEquiv_method := abiFeatureTagEq0|>))`;


val _ = Define `
(instance_Basic_classes_Ord_Abi_amd64_amd64_abi_feature_dict= (<|

  compare_method := abiFeatureCompare0;

  isLess_method := (\ f1 .  (\ f2 .  (abiFeatureCompare0 f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (abiFeatureCompare0 f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (abiFeatureCompare0 f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (abiFeatureCompare0 f1 f2) ({GT; EQ})))|>))`;


(*val section_is_special : forall 'abifeature. elf64_interpreted_section -> annotated_memory_image 'abifeature -> bool*)
val _ = Define `
 (section_is_special1 s img=    
  (elf_section_is_special s img \/
    (case s.elf64_section_name_as_string of 
        ".eh_frame" => T (* HACK needed because SHT_X86_64_UNWIND is often not used *)
       | _ => F
    )))`;

val _ = export_theory()

