(*Generated by Lem from missing_pervasives.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory lem_sortingTheory elf_localTheory;

val _ = numLib.prefer_num();



val _ = new_theory "missing_pervasives"

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import Assert_extra*)
(*open import Show*)
(*open import Sorting*)

(*open import {isabelle} `$ISABELLE_HOME/src/HOL/Word/Word`*)
(*open import {isabelle} `Elf_Types_Local`*)
(*open import {coq} `elf_types_local`*)
(*open import {hol} `elf_localTheory`*)

(*val naturalZero : natural*)
val _ = Define `
 (naturalZero= (( 0:num)))`;


(*val id : forall 'a. 'a -> 'a*)
val _ = Define `
 (id x=  x)`;


(*type byte*)
(*val natural_of_byte : byte -> natural*)

val _ = Define `
 (compare_byte b1 b2=  (genericCompare (<) (=) (w2n b1) (w2n b2)))`;


val _ = Define `
(instance_Basic_classes_Ord_Missing_pervasives_byte_dict= (<|

  compare_method := compare_byte;

  isLess_method := (\ f1 .  (\ f2 .  (compare_byte f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  let result = (compare_byte f1 f2) in (result = LT) \/ (result = EQ)));

  isGreater_method := (\ f1 .  (\ f2 .  (compare_byte f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  let result = (compare_byte f1 f2) in (result = GT) \/ (result =  EQ)))|>))`;


(*val char_of_byte : byte -> char*)

(*val byte_of_char : char -> byte*)

(* Define how to print a byte in hex *)
(*val hex_char_of_nibble : natural -> char*)
val _ = Define `
 (hex_char_of_nibble n=  
 (if n =( 0:num) then
    #"0"
  else if n =( 1:num) then
    #"1"
  else if n =( 2:num) then
    #"2"
  else if n =( 3:num) then
    #"3"
  else if n =( 4:num) then
    #"4"
  else if n =( 5:num) then
    #"5"
  else if n =( 6:num) then
    #"6"
  else if n =( 7:num) then
    #"7"
  else if n =( 8:num) then
    #"8"
  else if n =( 9:num) then
    #"9"
  else if n =( 10:num) then
    #"a"
  else if n =( 11:num) then
    #"b"
  else if n =( 12:num) then
    #"c"
  else if n =( 13:num) then
    #"d"
  else if n =( 14:num) then
    #"e"
  else if n =( 15:num) then
    #"f"
   else
     fail))`;


val _ = Define `
 (hex_string_of_byte b=    
  (IMPLODE [ hex_char_of_nibble ((w2n b) DIV( 16:num))
             ; hex_char_of_nibble ((w2n b) MOD( 16:num))]))`;


val _ = Define `
(instance_Show_Show_Missing_pervasives_byte_dict= (<|

  show_method := hex_string_of_byte|>))`;


(*val natural_of_decimal_digit : char -> maybe natural*)
val _ = Define `
 (natural_of_decimal_digit c=  
 (if c = #"0" then
    SOME(( 0:num))
  else if c = #"1" then
    SOME(( 1:num))
  else if c = #"2" then
    SOME(( 2:num))
  else if c = #"3" then
    SOME(( 3:num))
  else if c = #"4" then
    SOME(( 4:num))
  else if c = #"5" then
    SOME(( 5:num))
  else if c = #"6" then
    SOME(( 6:num))
  else if c = #"7" then
    SOME(( 7:num))
  else if c = #"8" then
    SOME(( 8:num))
  else if c = #"9" then
    SOME(( 9:num))
  else
    NONE))`;


(*val natural_of_decimal_string_helper : natural -> list char -> natural*)
 val natural_of_decimal_string_helper_defn = Hol_defn "natural_of_decimal_string_helper" `
 (natural_of_decimal_string_helper acc chars=    
 ((case chars of 
        [] => acc
        | c :: cs => (case natural_of_decimal_digit c of
            SOME dig => natural_of_decimal_string_helper ((( 10:num) * acc) + dig) cs
            | NONE => acc
        )
    )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn natural_of_decimal_string_helper_defn;

(*val natural_of_decimal_string : string -> natural*)
val _ = Define `
 (natural_of_decimal_string s=    
  (natural_of_decimal_string_helper(( 0:num)) (EXPLODE s)))`;


(*val hex_string_of_natural : natural -> string*)
 val hex_string_of_natural_defn = Hol_defn "hex_string_of_natural" `
 (hex_string_of_natural n=    
  (if n <( 16:num) then IMPLODE [hex_char_of_nibble n]
    else  STRCAT(hex_string_of_natural (n DIV( 16:num))) (IMPLODE [hex_char_of_nibble (n MOD( 16:num))])))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn hex_string_of_natural_defn;

(*val natural_of_bool : bool -> natural*)
val _ = Define `
 (natural_of_bool b=  
 ((case b of
      T  =>( 1:num)
    | F =>( 0:num)
  )))`;


(*val unsafe_nat_of_natural : natural -> nat*)

(*val unsafe_int_of_natural   : natural -> int*)

(*val byte_of_natural : natural -> byte*)

(*val natural_ordering : natural -> natural -> ordering*)
val _ = Define `
 (natural_ordering left right=  
 (if left = right then
    EQ
  else if left < right then
    LT
  else
    GT))`;


(*val merge_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a -> list 'a*)
 val merge_by_defn = Hol_defn "merge_by" `
 (merge_by comp xs ys=  
 ((case (xs, ys) of
      ([], ys)      => ys
    | (xs, [])     => xs
    | (x::xs, y::ys) =>
      if comp x y = LT then
        x::(merge_by comp xs (y::ys))
      else
        y::(merge_by comp (x::xs) ys)
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn merge_by_defn;

(*val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a*)
 val sort_by_defn = Hol_defn "sort_by" `
 (sort_by comp xs=  
 ((case xs of
      [] => []
    | [x] => [x]
    | xs =>
      let ls = (TAKE (LENGTH xs DIV( 2 : num)) xs) in
      let rs = (DROP (LENGTH xs DIV( 2 : num)) xs) in
        merge_by comp (sort_by comp ls) (sort_by comp rs)
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn sort_by_defn;

(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
(*val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b*)
 val mapMaybei'_defn = Hol_defn "mapMaybei'" `
 (mapMaybei' f idx xs=  
 ((case xs of
    []    => []
  | x::xs =>
      (case f idx x of
        NONE => mapMaybei' f (( 1:num) + idx) xs
      | SOME e  => e :: mapMaybei' f (( 1:num) + idx) xs
      )
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn mapMaybei'_defn;

(*val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b*)
    
val _ = Define `
 (mapMaybei f xs=  
 (mapMaybei' f(( 0:num)) xs))`;


(** [partitionii is xs] returns a pair of lists: firstly those elements in [xs] that are
    at indices in [is], and secondly the remaining elements. 
    It preserves the order of elements in xs. *)
(*val partitionii' : forall 'a. natural -> list natural -> list 'a 
    -> list (natural * 'a) (* accumulates the 'in' partition *)
    -> list (natural * 'a) (* accumulates the 'out' partition *)
    -> (list (natural * 'a) * list (natural * 'a))*)
 val partitionii'_defn = Hol_defn "partitionii'" `
 (partitionii' (offset : num) sorted_is xs reverse_accum reverse_accum_compl=    
(  
    (* offset o means "xs begins at index o, as reckoned by the indices in sorted_is" *)(case sorted_is of
        [] => (REVERSE reverse_accum, REVERSE reverse_accum_compl)
        | i :: more_is => 
            let (length_to_split_off : num) = (((i - offset):num))
            in
            let (left, right) = (TAKE length_to_split_off xs, DROP length_to_split_off xs) in
            let left_indices : num list = (GENLIST 
                (\ j .  (( j:num)) + offset)
                (LENGTH left)) 
            in
            let left_with_indices = (list_combine left_indices left) in
            (* left begins at offset, right begins at offset + i *)
            (case right of 
                [] => (* We got to the end of the list before the target index. *) 
                    (REVERSE reverse_accum, 
                     REV reverse_accum_compl left_with_indices)
                | x :: more_xs => 
                    (* x is at index i by definition, so more_xs starts with index i + 1 *)
                    partitionii' (i+( 1:num)) more_is more_xs ((i, x) :: reverse_accum) 
                        (REV left_with_indices reverse_accum_compl)
            )
    )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn partitionii'_defn;

(*val filteri : forall 'a. list natural -> list 'a -> list 'a*)
val _ = Define `
 (filteri is xs=    
  (let sorted_is = (QSORT (<=) is) in
    let (accum, accum_compl) = (partitionii'(( 0:num)) sorted_is xs [] [])
    in 
    let (just_indices, just_items) = (UNZIP accum)
    in 
    just_items))`;


(*val filterii : forall 'a. list natural -> list 'a -> list (natural * 'a)*)
val _ = Define `
 (filterii is xs=    
  (let sorted_is = (QSORT (<=) is) in
    let (accum, accum_compl) = (partitionii'(( 0:num)) sorted_is xs [] [])
    in 
    accum))`;


(*val partitioni : forall 'a. list natural -> list 'a -> (list 'a * list 'a)*)
val _ = Define `
 (partitioni is xs=    
  (let sorted_is = (QSORT (<=) is) in
    let (accum, accum_compl) = (partitionii'(( 0:num)) sorted_is xs [] [])
    in
    let (just_indices, just_items) = (UNZIP accum)
    in
    let (just_indices_compl, just_items_compl) = (UNZIP accum_compl)
    in
    (just_items, just_items_compl)))`;


(*val partitionii : forall 'a. list natural -> list 'a -> (list (natural * 'a) * list (natural * 'a))*)
val _ = Define `
 (partitionii is xs=    
  (let sorted_is = (QSORT (<=) is) in
    partitionii'(( 0:num)) sorted_is xs [] []))`;


(** [unzip3 ls] takes a list of triples and returns a triple of lists. *)
(*val unzip3: forall 'a 'b 'c. list ('a * 'b * 'c) -> (list 'a * list 'b * list 'c)*)
 val _ = Define `
 (unzip3 l=  ((case l of
    [] => ([], [], [])
  | (x, y, z) :: xyzs => let (xs, ys, zs) = (unzip3 xyzs) in ((x :: xs), (y :: ys), (z :: zs))
)))`;


(** [zip3 ls] takes a triple of lists and returns a list of triples. *)
(*val zip3: forall 'a 'b 'c. list 'a -> list 'b -> list 'c -> list ('a * 'b * 'c)*)
 val zip3_defn = Hol_defn "zip3" `
 (zip3 alist blist clist=  ((case (alist, blist, clist) of
    ([], [], []) => []
  | (x :: morex, y :: morey, z :: morez) => let more_xyz = (zip3 morex morey morez) in (x, y, z) :: more_xyz
)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn zip3_defn;

(** [null_byte] is the null character a a byte. *)
(*val null_byte : byte*)

(** [null_char] is the null character. *)
(*val null_char : char*)

(** [println s] prints [s] to stdout, adding a trailing newline. *)
(* val println : string -> unit *)
(* declare ocaml target_rep function println = `print_endline` *)

(** [prints s] prints [s] to stdout, without adding a trailing newline. *)
(* val prints : string -> unit *)
(* declare ocaml target_rep function prints = `print_string` *)

(** [errln s] prints [s] to stderr, adding a trailing newline. *)
(*val errln : string -> unit*)

(** [errs s] prints [s] to stderr, without adding a trailing newline. *)
(*val errs : string -> unit*)

(** [outln s] prints [s] to stdout, adding a trailing newline. *)
(*val outln : string -> unit*)

(** [outs s] prints [s] to stdout, without adding a trailing newline. *)
(*val outs : string -> unit*)

(** [intercalate sep xs] places [sep] between all elements of [xs].
  * Made tail recursive and unrolled slightly to improve performance on large
  * lists.*)
(*val intercalate' : forall 'a. 'a -> list 'a -> list 'a -> list 'a*)
 val intercalate'_defn = Hol_defn "intercalate'" `
 (intercalate' sep xs accum=	
 ((case xs of
		  []       => REVERSE accum
		| [x]      => REVERSE accum ++ [x]
		| [x; y]   => REVERSE accum ++ [x; sep; y]
		| x::y::xs => intercalate' sep xs (sep::(y::(sep::(x::accum))))
	)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn intercalate'_defn;
	
(*val intercalate : forall 'a. 'a -> list 'a -> list 'a*)
val _ = Define `
 (intercalate sep xs=  (intercalate' sep xs []))`;


(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
(*val unlines : list string -> string*)
val _ = Define `
 (unlines xs=  
 (FOLDL STRCAT "" (intercalate "\n" xs)))`;


(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
(*val bracket : list string -> string*)
val _ = Define `
 (bracket xs=   
 (STRCAT"("  (STRCAT(FOLDL STRCAT "" (intercalate " " xs)) ")")))`;

	
(** [string_of_list l] produces a string representation of list [l].
  *)
(*val string_of_list : forall 'a. Show 'a => list 'a -> string*)
val _ = Define `
 (string_of_list dict_Show_Show_a l=  
 (let result = (intercalate "," (MAP  
  dict_Show_Show_a.show_method l)) in
  let folded = (FOLDL STRCAT "" result) in
     STRCAT"["  (STRCAT folded "]")))`;


val _ = Define `
(instance_Show_Show_list_dict dict_Show_Show_a= (<|

  show_method := 
  (string_of_list dict_Show_Show_a)|>))`;


(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  * 
  * NOTE: quirkily, this doesn't discard separators (e.g. because NUL characters 
  * are significant when indexing into string tables). FIXME: given this, is this 
  * function really reusable? I suspect not.
  *)
(*val split_string_on_char : string -> char -> list string*)

(* [find_substring sub s] returns the index at which *)
(*val find_substring : string -> string -> maybe natural*)

(** [string_of_nat m] produces a string representation of natural number [m]. *)
(*val string_of_nat : nat -> string*)

(** [string_suffix i s] returns all but the first [i] characters of [s].
  * Fails if the index is negative, or beyond the end of the string.
  *)
(*val string_suffix : natural -> string -> maybe string*)
  
(*val nat_length : forall 'a. list 'a -> nat*)
  
(*val length : forall 'a. list 'a -> natural*)
val _ = Define `
 (length xs=  (FOLDL (\y x .  
  (case (y ,x ) of ( y , _ ) =>( 1: num) + y ))(( 0:num)) xs))`;


(*val takeRevAcc : forall 'a. natural -> list 'a -> list 'a -> list 'a*)
 val takeRevAcc_defn = Hol_defn "takeRevAcc" `
 (takeRevAcc m xs rev_acc=  
 ((case xs of
      []    => REVERSE rev_acc
    | x::xs =>
      if m =( 0:num) then
        REVERSE rev_acc
      else
        takeRevAcc (m -( 1:num)) xs (x::rev_acc)
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn takeRevAcc_defn;

(** [take cnt xs] takes the first [cnt] elements of list [xs].  Returns a truncation
  * if [cnt] is greater than the length of [xs].
  *)
(*val take : forall 'a. natural -> list 'a -> list 'a*)
 val _ = Define `
 (take m xs=  
 (takeRevAcc m xs []))`;

  
(** [drop cnt xs] returns all but the first [cnt] elements of list [xs].  Returns an empty list
  * if [cnt] is greater than the length of [xs].
  *)
(*val drop : forall 'a. natural -> list 'a -> list 'a*)
 val drop_defn = Hol_defn "drop" `
 (drop m xs=  
 ((case xs of
      []    => []
    | x::xs =>
      if m =( 0:num) then
        x::xs
      else
        drop (m -( 1:num)) xs
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn drop_defn;
  
(** [string_prefix i s] returns the first [i] characters of [s].
  * Fails if the index is negative, or beyond the end of the string.
  *)
(*val string_prefix : natural -> string -> maybe string*)
val _ = Define `
 (string_prefix m s=  
 (let cs = (EXPLODE s) in
    if m > length cs then
      NONE
    else
      SOME (IMPLODE (take m cs))))`;

(* FIXME: isabelle *)

(** [string_index_of c s] returns [Just(i)] where [i] is the index of the first 
  * occurrence if [c] in [s], if it exists, otherwise returns [Nothing]. *)
(*val string_index_of' : char -> list char -> natural -> maybe natural*)
 val string_index_of'_defn = Hol_defn "string_index_of'" `
 (string_index_of' e ss idx=  
 ((case ss of
      []    => NONE
    | s::ss =>
      if s = e then
        SOME idx
      else
        string_index_of' e ss (( 1:num) + idx)
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn string_index_of'_defn;
  
(*val string_index_of : char -> string -> maybe natural*)
val _ = Define `
 (string_index_of e s=  (string_index_of' e (EXPLODE s)(( 0:num))))`;


(*val index : forall 'a. natural -> list 'a -> maybe 'a*)
 val index_defn = Hol_defn "index" `
 (index m xs=  
 ((case xs of
      []    => NONE
    | x::xs =>
        if m =( 0:num) then
          SOME x
        else
          index (m -( 1:num)) xs
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn index_defn;

(*val find_index_helper : forall 'a. natural -> ('a -> bool) -> list 'a -> maybe natural*)
 val find_index_helper_defn = Hol_defn "find_index_helper" `
 (find_index_helper count1 p xs=	
 ((case xs of
		  []    => NONE
		| y::ys =>
			if p y then
				SOME count1
			else
				find_index_helper (count1 +( 1:num)) p ys
	)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn find_index_helper_defn;

(*val find_index : forall 'a. ('a -> bool) -> list 'a -> maybe natural*)
val _ = Define `
 (find_index0 p xs=  (find_index_helper(( 0:num)) p xs))`;


(*val argv : list string*)

(*val replicate_revacc : forall 'a. list 'a -> natural -> 'a -> list 'a*)
 val replicate_revacc_defn = Hol_defn "replicate_revacc" `
 (replicate_revacc revacc len e=	
 ((case len of
		  0 => REVERSE revacc
		| m => replicate_revacc (e :: revacc) (m -( 1:num)) e
	)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn replicate_revacc_defn;

(*val replicate : forall 'a. natural -> 'a -> list 'a*)
 val _ = Define `
 (replicate len e=	
 (replicate_revacc [] len e))`;


(* We want a tail-recursive append. reverse_append l1 l2 appends l2 to the
 * reverse of l1. So we get [l1-backwards] [l2]. So just reverse l1. *)
(*val list_append : forall 'a. list 'a -> list 'a -> list 'a*)
val _ = Define `
 (list_append l1 l2=    
 (REV (REVERSE l1) l2))`;


(*val list_concat : forall 'a. list (list 'a) -> list 'a*) 
val _ = Define `
 (list_concat ll=  (FOLDL list_append [] ll))`;


(*val list_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b*)
val _ = Define `
 (list_concat_map f l=    
  (list_concat (MAP f l)))`;


(*val list_reverse_concat_map_helper : forall 'a 'b. ('a -> list 'b) -> list 'b -> list 'a -> list 'b*)
 val list_reverse_concat_map_helper_defn = Hol_defn "list_reverse_concat_map_helper" `
 (list_reverse_concat_map_helper f acc ll=    
  (let lcons = (\ l .  (\ i .  i :: l))
    in
    (case ll of
        []      => acc
      | item :: items => 
            (* item is a thing that maps to a list. it needn't be a list yet *)
            let mapped_list = (f item)
            in 
            (* let _ = Missing_pervasives.errln ("Map function gave us a list of " ^ (show (List.length mapped_list)) ^ " items") in *)
            list_reverse_concat_map_helper f (FOLDL lcons acc (f item)) items
    )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn list_reverse_concat_map_helper_defn;

(*val list_reverse_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b*)
val _ = Define `
 (list_reverse_concat_map f ll=  (list_reverse_concat_map_helper f [] ll))`;


(*val list_take_with_accum : forall 'a. nat -> list 'a -> list 'a -> list 'a*)
 val list_take_with_accum_defn = Hol_defn "list_take_with_accum" `
 (list_take_with_accum n reverse_acc l=   
( 
  (*  let _ = Missing_pervasives.errs ("Taking a byte; have accumulated " ^ (show (List.length acc) ^ " so far\n"))
   in *)(case n of
        0 => REVERSE reverse_acc
      | _ => (case l of
            [] => failwith "list_take_with_accum: not enough elements"
            | x :: xs => list_take_with_accum (n -( 1 : num)) (x :: reverse_acc) xs
        )
    )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn list_take_with_accum_defn;

(*val unsafe_string_take : natural -> string -> string*)
val _ = Define `
 (unsafe_string_take m str=  
 (let m = ( m) in
    IMPLODE (TAKE m (EXPLODE str))))`;


(** [padding_and_maybe_newline c w s] creates enough of char [c] to pad string [s] to [w] characters, 
  * unless [s] is of length [w - 1] or greater, in which case it generates [w] copies preceded by a newline.
  * This style of formatting is used by the GNU linker in its link map output, so we
  * reproduce it using this function. Note that string [s] does not appear in the
  * output. *)
(*val padding_and_maybe_newline : char -> natural -> string -> string*)
val _ = Define `
 (padding_and_maybe_newline c width str=    
  (let padlen = (width - (((STRLEN str):num))) in
    
     STRCAT(if padlen <=( 1:num) then "\n" else "") (IMPLODE (replicate (if padlen <=( 1:num) then width else padlen) c))))`;


(** [space_padding_and_maybe_newline w s] creates enoughspaces to pad string [s] to [w] characters, 
  * unless [s] is of length [w - 1] or greater, in which case it generates [w] copies preceded by a newline.
  * This style of formatting is used by the GNU linker in its link map output, so we
  * reproduce it using this function. Note that string [s] does not appear in the
  * output. *)
(*val space_padding_and_maybe_newline : natural -> string -> string*)
val _ = Define `
 (space_padding_and_maybe_newline width str=    
  (padding_and_maybe_newline #" " width str))`;


(** [padded_and_maybe_newline w s] pads string [s] to [w] characters, using char [c]
  * unless [s] is of length [w - 1] or greater, in which case the padding consists of
  * [w] copies of [c] preceded by a newline.
  * This style of formatting is used by the GNU linker in its link map output, so we
  * reproduce it using this function. *)
(*val padded_and_maybe_newline : char -> natural -> string -> string*)
val _ = Define `
 (padded_and_maybe_newline c width str=     
  (STRCAT str (padding_and_maybe_newline c width str)))`;


(** [padding_to c w s] creates enough copies of [c] to pad string [s] to [w] characters, 
  * or 0 characters if [s] is of length [w] or greater. Note that string [s] does not appear in the
  * output. *)
(*val padding_to : char -> natural -> string -> string*)
val _ = Define `
 (padding_to c width str=    
  (let padlen = (width - (((STRLEN str):num))) in
    if padlen <=( 0:num) then "" else (IMPLODE (replicate padlen c))))`;


(** [left_padded_to c w s] left-pads string [s] to [w] characters using [c], 
  * returning it unchanged if [s] is of length [w] or greater. *)
(*val left_padded_to : char -> natural -> string -> string*)
val _ = Define `
 (left_padded_to c width str=     
  (STRCAT(padding_to c width str) str))`;

    
(** [right_padded_to c w s] right-pads string [s] to [w] characters using [c], 
  * returning it unchanged if [s] is of length [w] or greater. *)
(*val right_padded_to : char -> natural -> string -> string*)
val _ = Define `
 (right_padded_to c width str=     
  (STRCAT str (padding_to c width str)))`;


(** [space_padded_and_maybe_newline w s] pads string [s] to [w] characters, using spaces,
  * unless [s] is of length [w - 1] or greater, in which case the padding consists of
  * [w] spaces preceded by a newline.
  * This style of formatting is used by the GNU linker in its link map output, so we
  * reproduce it using this function. *)
(*val space_padded_and_maybe_newline : natural -> string -> string*)
val _ = Define `
 (space_padded_and_maybe_newline width str=     
  (STRCAT str (padding_and_maybe_newline #" " width str)))`;


(** [left_space_padded_to w s] left-pads string [s] to [w] characters using spaces, 
  * returning it unchanged if [s] is of length [w] or greater. *)
(*val left_space_padded_to : natural -> string -> string*)
val _ = Define `
 (left_space_padded_to width str=     
  (STRCAT(padding_to #" " width str) str))`;

    
(** [right_space_padded_to w s] right-pads string [s] to [w] characters using spaces, 
  * returning it unchanged if [s] is of length [w] or greater. *)
(*val right_space_padded_to : natural -> string -> string*)
val _ = Define `
 (right_space_padded_to width str=     
  (STRCAT str (padding_to #" " width str)))`;


(** [left_zero_padded_to w s] left-pads string [s] to [w] characters using zeroes, 
  * returning it unchanged if [s] is of length [w] or greater. *)
(*val left_zero_padded_to : natural -> string -> string*)
val _ = Define `
 (left_zero_padded_to width str=     
  (STRCAT(padding_to #"0" width str) str))`;

 
val _ = export_theory()

