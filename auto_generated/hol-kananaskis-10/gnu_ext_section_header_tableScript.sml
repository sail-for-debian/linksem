(*Generated by Lem from gnu_extensions/gnu_ext_section_header_table.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory showTheory errorTheory string_tableTheory lem_mapTheory hex_printingTheory elf_section_header_tableTheory elf_interpreted_sectionTheory;

val _ = numLib.prefer_num();



val _ = new_theory "gnu_ext_section_header_table"

(** The module [gnu_ext_section_header_table] implements function, definitions
  * and types relating to the GNU extensions to the standard ELF section header
  * table.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Map*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import Hex_printing*)

(*open import Error*)
(*open import String_table*)
(*open import Show*)

(*open import Elf_section_header_table*)
(*open import Elf_interpreted_section*)

(** GNU extended section types *)

(** [GNU_HASH] does not appear to be defined in the LSB but is present in
  * several ELF binaries collected in the wild...
  *
  * TODO: find out where this comes from?
  * ANSW: a mailing list apparently!  See here:
  *   https://sourceware.org/ml/binutils/2006-10/msg00377.html
  *)
val _ = Define `
 (sht_gnu_hash    : num=  (( 2:num) *( 939524091:num)))`;
     (* 0x6FFFFFF6 *)

(** The following are all defined in Section 10.2.2.2 of the LSB as additional
  * section types over the ones defined in the SCO ELF spec.
  *)

(** [sht_gnu_verdef] contains the symbol versions that are provided.
  *)
val _ = Define `
 (sht_gnu_verdef  : num=  ((( 2:num) *( 939524095:num)) -( 1:num)))`;
 (* 0x6ffffffd *)
(** [sht_gnu_verneed] contains the symbol versions that are required.
  *)
val _ = Define `
 (sht_gnu_verneed : num=  (( 2:num) *( 939524095:num)))`;
     (* 0x6ffffffe *)
(** [sht_gnu_versym] contains the symbol version table.
  *)
val _ = Define `
 (sht_gnu_versym  : num=  ((( 2:num) *( 939524095:num)) +( 1:num)))`;
 (* 0x6fffffff *)
(** [sht_gnu_liblist] appears to be undocumented but appears in PowerPC 64 ELF
  * binaries in "the wild".
  *)
val _ = Define `
 (sht_gnu_liblist : num=  ((( 2:num) *( 939524091:num)) +( 1:num)))`;
 (* 0x6FFFFFF7 *)

(** [string_of_gnu_ext_section_type m] produces a string based representation of
  * GNU extension section type [m].
  *)
(*val string_of_gnu_ext_section_type : natural -> string*)
    
(** [gnu_ext_additionall_special_sections] records additional section names that
  * map appear in GNU ELF binaries and their required associated types and
  * attributes.  See Section 10.3.1.1 of the LSB and the related map
  * [elf_special_sections] in [Elf_section_header_table] which records section
  * names and their required types and attributes that all ELF binaries share.
  *)
(*val gnu_ext_additional_special_sections : Map.map string (natural * natural)*)
val _ = Define `
 (gnu_ext_additional_special_sections=  
 (FUPDATE_LIST FEMPTY [
    (".ctors", (sht_progbits, (shf_alloc + shf_write)))
  ; (".data.rel.ro", (sht_progbits, (shf_alloc + shf_write)))
  ; (".dtors", (sht_progbits, (shf_alloc + shf_write)))
  ; (".eh_frame", (sht_progbits, shf_alloc))
  ; (".eh_frame_hdr", (sht_progbits, shf_alloc))
  ; (".gcc_execpt_table", (sht_progbits, shf_alloc))
  ; (".gnu.version", (sht_gnu_versym, shf_alloc))
  ; (".gnu.version_d", (sht_gnu_verdef, shf_alloc))
  ; (".gnu.version_r", (sht_gnu_verneed, shf_alloc))
  ; (".got.plt", (sht_progbits, (shf_alloc + shf_write)))
  ; (".jcr", (sht_progbits, (shf_alloc + shf_write)))
  ; (".note.ABI-tag", (sht_note, shf_alloc))
  ; (".stab", (sht_progbits,( 0:num)))
  ; (".stabstr", (sht_strtab,( 0:num)))
  ]))`;

  
(** [is_valid_gnu_ext_elf32_section_header_table_entry scts stbl] checks whether
  * sections [scts] conforms with the contents of the special sections table.
  * Fails otherwise.
  *)
(*val is_valid_gnu_ext_elf32_section_header_table_entry : elf32_interpreted_section ->
  string_table -> bool*)
val _ = Define `
 (is_valid_gnu_ext_elf32_section_header_table_entry ent stbl=  
 ((case string_table$get_string_at ent.elf32_section_name stbl of
      Fail    f    => F
    | Success name =>
      (case FLOOKUP gnu_ext_additional_special_sections name of
          NONE           =>
            is_valid_elf32_section_header_table_entry ent stbl
        | SOME (typ, flags) =>            
(typ = ent.elf32_section_type) /\ (flags = ent.elf32_section_flags)
      )
  )))`;

  
(** [is_valid_gnu_ext_elf32_section_header_table sht stbl] checks whether every
  * member of the section header table [sht] conforms with the special sections
  * table.
  *)
(*val is_valid_gnu_ext_elf32_section_header_table : list elf32_interpreted_section ->
  string_table -> bool*)
val _ = Define `
 (is_valid_gnu_ext_elf32_section_header_table ents stbl=  
 (EVERY (\ x .  is_valid_gnu_ext_elf32_section_header_table_entry x stbl) ents))`;

  
(** [is_valid_gnu_ext_elf64_section_header_table_entry scts stbl] checks whether
  * sections [scts] conforms with the contents of the special sections table.
  * Fails otherwise.
  *)
(*val is_valid_gnu_ext_elf64_section_header_table_entry : elf64_interpreted_section ->
  string_table -> bool*)
val _ = Define `
 (is_valid_gnu_ext_elf64_section_header_table_entry ent stbl=  
 ((case string_table$get_string_at ent.elf64_section_name stbl of
      Fail    f    => F
    | Success name =>
      (case FLOOKUP gnu_ext_additional_special_sections name of
          NONE           =>
            is_valid_elf64_section_header_table_entry ent stbl
        | SOME (typ, flags) =>            
(typ = ent.elf64_section_type) /\ (flags = ent.elf64_section_flags)
      )
  )))`;

  
(** [is_valid_gnu_ext_elf64_section_header_table sht stbl] checks whether every
  * member of the section header table [sht] conforms with the special sections
  * table.
  *)
(*val is_valid_gnu_ext_elf64_section_header_table : list elf64_interpreted_section ->
  string_table -> bool*)
val _ = Define `
 (is_valid_gnu_ext_elf64_section_header_table ents stbl=  
 (EVERY (\ x .  is_valid_gnu_ext_elf64_section_header_table_entry x stbl) ents))`;

val _ = export_theory()

