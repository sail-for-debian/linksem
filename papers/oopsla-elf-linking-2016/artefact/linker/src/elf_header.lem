(** [elf_header] includes types, functions and other definitions for working with
  * ELF headers.
  *)

open import Basic_classes
open import Bool
open import Function
open import List
open import Maybe
open import Num
open import String
import Set

open import Assert_extra

open import Default_printing
open import Endianness

open import Elf_types_native_uint

open import Byte_sequence
open import Error
open import Missing_pervasives
open import Show

(** Special section header table indices *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  * Present here instead of in elf_section_header_table.lem because a calculation
  * below requires this constant (i.e. forward reference in the ELF spec).
  *)
let shn_undef : natural = 0

(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears). Present here instead
  * of in elf_section_header_table.lem because a calculation below requires this
  * constant (i.e. forward reference in the ELF spec).
  *)
let shn_xindex : natural = 65535 (* 0xffff *)

(** ELF object file types.  Enumerates the ELF object file types specified in the
 *  System V ABI.  Values between [elf_ft_lo_os] and [elf_ft_hi_os] inclusive are
 *  reserved for operating system specific values typically defined in an
 *  addendum to the System V ABI for that operating system.  Values between
 *  [elf_ft_lo_proc] and [elf_ft_hi_proc] inclusive are processor specific and
 *  are typically defined in an addendum to the System V ABI for that processor
 *  series.
 *)

(** No file type *)
let elf_ft_none : natural = 0
(** Relocatable file *)
let elf_ft_rel : natural = 1
(** Executable file *)
let elf_ft_exec : natural = 2
(** Shared object file *)
let elf_ft_dyn : natural = 3
(** Core file *)
let elf_ft_core : natural = 4
(** Operating-system specific *)
let elf_ft_lo_os : natural = 65024 (* 0xfe00 *)
(** Operating-system specific *)
let elf_ft_hi_os : natural = 65279 (* 0xfeff *)
(** Processor specific *)
let elf_ft_lo_proc : natural = 65280 (* 0xff00 *)
(** Processor specific *)
let elf_ft_hi_proc : natural = 65535 (* 0xffff *)

(** [string_of_elf_file_type os proc m] produces a string representation of the
  * numeric encoding [m] of the ELF file type.  For values reserved for OS or
  * processor specific values, the higher-order functions [os] and [proc] are
  * used for printing, respectively.
  *)
val string_of_elf_file_type : (natural -> string) -> (natural -> string) -> natural -> string
let string_of_elf_file_type os_specific proc_specific m =
	if m = elf_ft_none then
		"No file type"
	else if m = elf_ft_rel then
		"REL (Relocatable file)"
	else if m = elf_ft_exec then
		"EXEC (Executable file)"
	else if m = elf_ft_dyn then
		"DYN (Shared object file)"
	else if m = elf_ft_core then
		"CORE (Core file)"
	else if m >= elf_ft_lo_os && m <= elf_ft_hi_os then
		os_specific m
	else if m >= elf_ft_lo_proc && m <= elf_ft_hi_proc then
		proc_specific m
	else
		"Invalid file type"

(** [is_operating_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for operating system-specific purposes.
  *)
val is_operating_system_specific_object_file_type_value : natural -> bool
let is_operating_system_specific_object_file_type_value v =
  v >= 65024 && v <= 65279

(** [is_processor_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for processor-specific purposes.
  *)
val is_processor_specific_object_file_type_value : natural -> bool
let is_processor_specific_object_file_type_value v =
  v >= 65280 && v <= 65535

(** ELF machine architectures *)

(** RISC-V *)
let elf_ma_riscv : natural = 243
(** AMD GPU architecture *)
let elf_ma_amdgpu : natural = 224
(** Moxie processor family *)
let elf_ma_moxie : natural = 223
(** FTDI Chip FT32 high performance 32-bit RISC architecture *)
let elf_ma_ft32 : natural = 222
(** Controls and Data Services VISIUMcore processor *)
let elf_ma_visium : natural = 221
(** Zilog Z80 *)
let elf_ma_z80 : natural = 220
(** CSR Kalimba architecture family *)
let elf_ma_kalimba : natural = 219
(** Nanoradio optimised RISC *)
let elf_ma_norc : natural = 218
(** iCelero CoolEngine *)
let elf_ma_cool : natural = 217
(** Cognitive Smart Memory Processor *)
let elf_ma_coge : natural = 216
(** Paneve CDP architecture family *)
let elf_ma_cdp : natural = 215
(** KM211 KVARC processor *)
let elf_ma_kvarc : natural = 214
(** KM211 KMX8 8-bit processor *)
let elf_ma_kmx8 : natural = 213
(** KM211 KMX16 16-bit processor *)
let elf_ma_kmx16 : natural = 212
(** KM211 KMX32 32-bit processor *)
let elf_ma_kmx32 : natural = 211
(** KM211 KM32 32-bit processor *)
let elf_ma_km32 : natural = 210
(** Microchip 8-bit PIC(r) family *)
let elf_ma_mchp_pic : natural = 204
(** XMOS xCORE processor family *)
let elf_ma_xcore : natural = 203
(** Beyond BA2 CPU architecture *)
let elf_ma_ba2 : natural = 202
(** Beyond BA1 CPU architecture *)  
let elf_ma_ba1 : natural = 201
(** Freescale 56800EX Digital Signal Controller (DSC) *)
let elf_ma_5600ex : natural = 200
(** 199 Renesas 78KOR family *)
let elf_ma_78kor : natural = 199
(** Broadcom VideoCore V processor *)
let elf_ma_videocore5 : natural = 198
(** Renesas RL78 family *)
let elf_ma_rl78 : natural = 197
(** Open8 8-bit RISC soft processing core *)
let elf_ma_open8 : natural = 196
(** Synopsys ARCompact V2 *)
let elf_ma_arc_compact2 : natural = 195
(** KIPO_KAIST Core-A 2nd generation processor family *)
let elf_ma_corea_2nd : natural = 194
(** KIPO_KAIST Core-A 1st generation processor family *)
let elf_ma_corea_1st : natural = 193
(** CloudShield architecture family *)
let elf_ma_cloudshield : natural = 192
(** Infineon Technologies SLE9X core *)
let elf_ma_sle9x : natural = 179
(** Intel L10M *)
let elf_ma_l10m : natural = 180
(** Intel K10M *)
let elf_ma_k10m : natural = 181
(** ARM 64-bit architecture (AARCH64) *)
let elf_ma_aarch64 : natural = 183
(** Atmel Corporation 32-bit microprocessor family *)
let elf_ma_avr32 : natural = 185
(** STMicroelectronics STM8 8-bit microcontroller *)
let elf_ma_stm8 : natural = 186
(** Tilera TILE64 multicore architecture family *)
let elf_ma_tile64 : natural = 187
(** Tilera TILEPro multicore architecture family *)
let elf_ma_tilepro : natural = 188
(** Xilinix MicroBlaze 32-bit RISC soft processor core *)
let elf_ma_microblaze : natural = 189
(** NVIDIA CUDA architecture *)
let elf_ma_cuda : natural = 190
(** Tilera TILE-Gx multicore architecture family *)
let elf_ma_tilegx : natural = 191
(** Cypress M8C microprocessor *)
let elf_ma_cypress : natural = 161
(** Renesas R32C series microprocessors *)
let elf_ma_r32c : natural = 162
(** NXP Semiconductors TriMedia architecture family *)
let elf_ma_trimedia : natural = 163
(** QUALCOMM DSP6 processor *)
let elf_ma_qdsp6 : natural = 164
(** Intel 8051 and variants *)
let elf_ma_8051 : natural = 165
(** STMicroelectronics STxP7x family of configurable and extensible RISC processors *)
let elf_ma_stxp7x : natural = 166
(** Andes Technology compact code size embedded RISC processor family *)
let elf_ma_nds32 : natural = 167
(** Cyan Technology eCOG1X family *)
let elf_ma_ecog1x : natural = 168
(** Dallas Semiconductor MAXQ30 Core Micro-controllers *)
let elf_ma_maxq30 : natural = 169
(** New Japan Radio (NJR) 16-bit DSP Processor *)
let elf_ma_ximo16 : natural = 170
(** M2000 Reconfigurable RISC Microprocessor *)
let elf_ma_manik : natural = 171
(** Cray Inc. NV2 vector architecture *)
let elf_ma_craynv2 : natural = 172
(** Renesas RX family *)
let elf_ma_rx : natural = 173
(** Imagination Technologies META processor architecture *)
let elf_ma_metag : natural = 174
(** MCST Elbrus general purpose hardware architecture *)
let elf_ma_mcst_elbrus : natural = 175
(** Cyan Technology eCOG16 family *)
let elf_ma_ecog16 : natural = 176
(** National Semiconductor CompactRISC CR16 16-bit microprocessor *)
let elf_ma_cr16 : natural = 177
(** Freescale Extended Time Processing Unit *)
let elf_ma_etpu : natural = 178
(** Altium TSK3000 core *)
let elf_ma_tsk3000 : natural = 131
(** Freescale RS08 embedded processor *)
let elf_ma_rs08 : natural = 132
(** Analog Devices SHARC family of 32-bit DSP processors *)
let elf_ma_sharc : natural = 133
(** Cyan Technology eCOG2 microprocessor *)
let elf_ma_ecog2 : natural = 134
(** Sunplus S+core7 RISC processor *)
let elf_ma_ccore7 : natural = 135
(** New Japan Radio (NJR) 24-bit DSP Processor *)
let elf_ma_dsp24 : natural = 136
(** Broadcom VideoCore III processor *)
let elf_ma_videocore3 : natural = 137
(** RISC processor for Lattice FPGA architecture *)
let elf_ma_latticemico32 : natural = 138
(** Seiko Epson C17 family *)
let elf_ma_c17 : natural = 139
(** The Texas Instruments TMS320C6000 DSP family *)
let elf_ma_c6000 : natural = 140
(** The Texas Instruments TMS320C2000 DSP family *)
let elf_ma_c2000 : natural = 141
(** The Texas Instruments TMS320C55x DSP family *)
let elf_ma_c5500 : natural = 142
(** STMicroelectronics 64bit VLIW Data Signal Processor *)
let elf_ma_mmdsp_plus : natural = 160
(** LSI Logic 16-bit DSP Processor *)
let elf_ma_zsp : natural = 79
(** Donald Knuth's educational 64-bit processor *)
let elf_ma_mmix : natural = 80
(** Harvard University machine-independent object files *)
let elf_ma_huany : natural = 81
(** SiTera Prism *)
let elf_ma_prism : natural = 82
(** Atmel AVR 8-bit microcontroller *)
let elf_ma_avr : natural = 83
(** Fujitsu FR30 *)
let elf_ma_fr30 : natural = 84
(** Mitsubishi D10V *)
let elf_ma_d10v : natural = 85
(** Mitsubishi D30V *)
let elf_ma_d30v : natural = 86
(** NEC v850 *)
let elf_ma_v850 : natural = 87
(** Mitsubishi M32R *)
let elf_ma_m32r : natural = 88
(** Matsushita MN10300 *)
let elf_ma_mn10300 : natural = 89
(** Matsushita MN10200 *)
let elf_ma_mn10200 : natural = 90
(** picoJava *)
let elf_ma_pj : natural = 91
(** OpenRISC 32-bit embedded processor *)
let elf_ma_openrisc : natural = 92
(** ARC International ARCompact processor (old spelling/synonym: ELF_MA_ARC_A5) *)
let elf_ma_arc_compact : natural = 93
(** Tensilica Xtensa Architecture *)
let elf_ma_xtensa : natural = 94
(** Alphamosaic VideoCore processor *)
let elf_ma_videocore : natural = 95
(** Thompson Multimedia General Purpose Processor *)
let elf_ma_tmm_gpp : natural = 96
(** National Semiconductor 32000 series *)
let elf_ma_ns32k : natural = 97
(** Tenor Network TPC processor *)
let elf_ma_tpc : natural = 98
(** Trebia SNP 1000 processor *)
let elf_ma_snp1k : natural = 99
(** STMicroelectronics ST200 microcontroller *)
let elf_ma_st200 : natural = 100
(** Ubicom IP2xxx microcontroller family *)
let elf_ma_ip2k : natural = 101
(** MAX Processor *)
let elf_ma_max : natural = 102
(** National Semiconductor CompactRISC microprocessor *)
let elf_ma_cr : natural = 103
(** Fujitsu F2MC16 *)
let elf_ma_f2mc16 : natural = 104
(** Texas Instruments embedded microcontroller msp430 *)
let elf_ma_msp430 : natural = 105
(** Analog Devices Blackfin (DSP) processor *)
let elf_ma_blackfin : natural = 106
(** S1C33 Family of Seiko Epson processors *)
let elf_ma_se_c33 : natural = 107
(** Sharp embedded microprocessor *)
let elf_ma_sep : natural = 108
(** Arca RISC Microprocessor *)
let elf_ma_arca : natural = 109
(** Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University *)
let elf_ma_unicore : natural = 110
(** eXcess: 16/32/64-bit configurable embedded CPU *)
let elf_ma_excess : natural = 111
(** Icera Semiconductor Inc. Deep Execution Processor *)
let elf_ma_dxp : natural = 112
(** Altera Nios II soft-core processor *)
let elf_ma_altera_nios2 : natural = 113
(** National Semiconductor CompactRISC CRX microprocessor *)
let elf_ma_crx : natural = 114
(** Motorola XGATE embedded processor *)
let elf_ma_xgate : natural = 115
(** Infineon C16x/XC16x processor *)
let elf_ma_c166 : natural = 116
(** Renesas M16C series microprocessors *)
let elf_ma_m16c : natural = 117
(** Microchip Technology dsPIC30F Digital Signal Controller *)
let elf_ma_dspic30f : natural = 118
(** Freescale Communication Engine RISC core *)
let elf_ma_ce : natural = 119
(** Renesas M32C series microprocessors *)
let elf_ma_m32c : natural = 120
(** No machine *)
let elf_ma_none : natural = 0
(** AT&T WE 32100 *)
let elf_ma_m32 : natural = 1
(** SPARC *)
let elf_ma_sparc : natural = 2
(** Intel 80386 *)
let elf_ma_386 : natural = 3
(** Motorola 68000 *)
let elf_ma_68k : natural = 4
(** Motorola 88000 *)
let elf_ma_88k : natural = 5
(** Intel 80860 *)
let elf_ma_860 : natural = 7
(** MIPS I Architecture *)
let elf_ma_mips : natural = 8
(** IBM System/370 Processor *)
let elf_ma_s370 : natural = 9
(** MIPS RS3000 Little-endian *)
let elf_ma_mips_rs3_le : natural = 10
(** Hewlett-Packard PA-RISC *)
let elf_ma_parisc : natural = 15
(** Fujitsu VPP500 *)
let elf_ma_vpp500 : natural = 17
(** Enhanced instruction set SPARC *)
let elf_ma_sparc32plus : natural = 18
(** Intel 80960 *)
let elf_ma_960 : natural = 19
(** PowerPC *)
let elf_ma_ppc : natural = 20
(** 64-bit PowerPC *)
let elf_ma_ppc64 : natural = 21
(** IBM System/390 Processor *)
let elf_ma_s390 : natural = 22
(** IBM SPU/SPC *)
let elf_ma_spu : natural = 23
(** NEC V800 *)
let elf_ma_v800 : natural = 36
(** Fujitsu FR20 *)
let elf_ma_fr20 : natural = 37
(** TRW RH-32 *)
let elf_ma_rh32 : natural = 38
(** Motorola RCE *)
let elf_ma_rce : natural = 39
(** ARM 32-bit architecture (AARCH32) *)
let elf_ma_arm : natural = 40
(** Digital Alpha *)
let elf_ma_alpha : natural = 41
(** Hitachi SH *)
let elf_ma_sh : natural = 42
(** SPARC Version 9 *)
let elf_ma_sparcv9 : natural = 43
(** Siemens TriCore embedded processor *)
let elf_ma_tricore : natural = 44
(** Argonaut RISC Core, Argonaut Technologies Inc. *)
let elf_ma_arc : natural = 45
(** Hitachi H8/300 *)
let elf_ma_h8_300 : natural = 46
(** Hitachi H8/300H *)
let elf_ma_h8_300h : natural = 47
(** Hitachi H8S *)
let elf_ma_h8s : natural = 48
(** Hitachi H8/500 *)
let elf_ma_h8_500 : natural = 49
(** Intel IA-64 processor architecture *)
let elf_ma_ia_64 : natural = 50
(** Stanford MIPS-X *)
let elf_ma_mips_x : natural = 51
(** Motorola ColdFire *)
let elf_ma_coldfire : natural = 52
(** Motorola M68HC12 *)
let elf_ma_68hc12 : natural = 53
(** Fujitsu MMA Multimedia Accelerator *)
let elf_ma_mma : natural = 54
(** Siemens PCP *)
let elf_ma_pcp : natural = 55
(** Sony nCPU embedded RISC processor *)
let elf_ma_ncpu : natural = 56
(** Denso NDR1 microprocessor *)
let elf_ma_ndr1 : natural = 57
(** Motorola Star*Core processor *)
let elf_ma_starcore : natural = 58
(** Toyota ME16 processor *)
let elf_ma_me16 : natural = 59
(** STMicroelectronics ST100 processor *)
let elf_ma_st100 : natural = 60
(** Advanced Logic Corp. TinyJ embedded processor family *)
let elf_ma_tinyj : natural = 61
(** AMD x86-64 architecture *)
let elf_ma_x86_64 : natural = 62
(** Sony DSP Processor *)
let elf_ma_pdsp : natural = 63
(** Digital Equipment Corp. PDP-10 *)
let elf_ma_pdp10 : natural = 64
(** Digital Equipment Corp. PDP-11 *)
let elf_ma_pdp11 : natural = 65
(** Siemens FX66 microcontroller *)
let elf_ma_fx66 : natural = 66
(** STMicroelectronics ST9+ 8/16 bit microcontroller *)
let elf_ma_st9plus : natural = 67
(** STMicroelectronics ST7 8-bit microcontroller *)
let elf_ma_st7 : natural = 68
(** Motorola MC68HC16 Microcontroller *)
let elf_ma_68hc16 : natural = 69
(** Motorola MC68HC11 Microcontroller *)
let elf_ma_68hc11 : natural = 70
(** Motorola MC68HC08 Microcontroller *)
let elf_ma_68hc08 : natural = 71
(** Motorola MC68HC05 Microcontroller *)
let elf_ma_68hc05 : natural = 72
(** Silicon Graphics SVx *)
let elf_ma_svx : natural = 73
(** STMicroelectronics ST19 8-bit microcontroller *)
let elf_ma_st19 : natural = 74
(** Digital VAX *)
let elf_ma_vax : natural = 75
(** Axis Communications 32-bit embedded processor *)
let elf_ma_cris : natural = 76
(** Infineon Technologies 32-bit embedded processor *)
let elf_ma_javelin : natural = 77
(** Element 14 64-bit DSP Processor *)
let elf_ma_firepath : natural = 78
(** Reserved by Intel *)
let elf_ma_intel209 : natural = 209
(** Reserved by Intel *)
let elf_ma_intel208 : natural = 208
(** Reserved by Intel *)
let elf_ma_intel207 : natural = 207
(** Reserved by Intel *)
let elf_ma_intel206 : natural = 206
(** Reserved by Intel *)
let elf_ma_intel205 : natural = 205
(** Reserved by Intel *)
let elf_ma_intel182 : natural = 182
(** Reserved by ARM *)
let elf_ma_arm184 : natural = 184
(** Reserved for future use *)
let elf_ma_reserved6 : natural = 6
(** Reserved for future use *)
let elf_ma_reserved11 : natural = 11
(** Reserved for future use *)
let elf_ma_reserved12 : natural = 12
(** Reserved for future use *)
let elf_ma_reserved13 : natural = 13
(** Reserved for future use *)
let elf_ma_reserved14 : natural = 14
(** Reserved for future use *)
let elf_ma_reserved16 : natural = 16
(** Reserved for future use *)
let elf_ma_reserved24 : natural = 24
(** Reserved for future use *)
let elf_ma_reserved25 : natural = 25
(** Reserved for future use *)
let elf_ma_reserved26 : natural = 26
(** Reserved for future use *)
let elf_ma_reserved27 : natural = 27
(** Reserved for future use *)
let elf_ma_reserved28 : natural = 28
(** Reserved for future use *)
let elf_ma_reserved29 : natural = 29
(** Reserved for future use *)
let elf_ma_reserved30 : natural = 30
(** Reserved for future use *)
let elf_ma_reserved31 : natural = 31
(** Reserved for future use *)
let elf_ma_reserved32 : natural = 32
(** Reserved for future use *)
let elf_ma_reserved33 : natural = 33
(** Reserved for future use *)
let elf_ma_reserved34 : natural = 34
(** Reserved for future use *)
let elf_ma_reserved35 : natural = 35
(** Reserved for future use *)
let elf_ma_reserved121 : natural = 121
(** Reserved for future use *)
let elf_ma_reserved122 : natural = 122
(** Reserved for future use *)
let elf_ma_reserved123 : natural = 123
(** Reserved for future use *)
let elf_ma_reserved124 : natural = 124
(** Reserved for future use *)
let elf_ma_reserved125 : natural = 125
(** Reserved for future use *)
let elf_ma_reserved126 : natural = 126
(** Reserved for future use *)
let elf_ma_reserved127 : natural = 127
(** Reserved for future use *)
let elf_ma_reserved128 : natural = 128
(** Reserved for future use *)
let elf_ma_reserved129 : natural = 129
(** Reserved for future use *)
let elf_ma_reserved130 : natural = 130
(** Reserved for future use *)
let elf_ma_reserved143 : natural = 143
(** Reserved for future use *)
let elf_ma_reserved144 : natural = 144
(** Reserved for future use *)
let elf_ma_reserved145 : natural = 145
(** Reserved for future use *)
let elf_ma_reserved146 : natural = 146
(** Reserved for future use *)
let elf_ma_reserved147 : natural = 147
(** Reserved for future use *)
let elf_ma_reserved148 : natural = 148
(** Reserved for future use *)
let elf_ma_reserved149 : natural = 149
(** Reserved for future use *)
let elf_ma_reserved150 : natural = 150
(** Reserved for future use *)
let elf_ma_reserved151 : natural = 151
(** Reserved for future use *)
let elf_ma_reserved152 : natural = 152
(** Reserved for future use *)
let elf_ma_reserved153 : natural = 153
(** Reserved for future use *)
let elf_ma_reserved154 : natural = 154
(** Reserved for future use *)
let elf_ma_reserved155 : natural = 155
(** Reserved for future use *)
let elf_ma_reserved156 : natural = 156
(** Reserved for future use *)
let elf_ma_reserved157 : natural = 157
(** Reserved for future use *)
let elf_ma_reserved158 : natural = 158
(** Reserved for future use *)
let elf_ma_reserved159 : natural = 159

(** [string_of_elf_machine_architecture m] produces a string representation of
  * the numeric encoding [m] of the ELF machine architecture.
  * TODO: finish this .
  *)
val string_of_elf_machine_architecture : natural -> string
let string_of_elf_machine_architecture m =
	if m = elf_ma_386 then
		"Intel 80386"
  else if m = elf_ma_ppc then
    "PowerPC"
  else if m = elf_ma_ppc64 then
    "PowerPC64"
  else if m = elf_ma_arm then
    "AArch"
  else if m = elf_ma_x86_64 then
    "Advanced Micro Devices X86-64"
  else if m = elf_ma_aarch64 then
    "AArch64"
	else
		"Other architecture"

(** ELF version numbers.  Denotes the ELF version number of an ELF file.  Current is
  * defined to have a value of 1 with the present specification.  Extensions
  * may create versions of ELF with higher version numbers.
  *)

(** Invalid version *)
let elf_ev_none : natural = 0
(** Current version *)
let elf_ev_current : natural = 1

(** [string_of_elf_version_number m] produces a string representation of the
  * numeric encoding [m] of the ELF version number.
  *)
val string_of_elf_version_number : natural -> string
let string_of_elf_version_number m =
	if m = elf_ev_none then
		"Invalid ELF version"
	else if m = elf_ev_current then
		"1 (current)"
	else
		"Extended ELF version"

(** Check that an extended version number is correct (i.e. greater than 1). *)
let is_valid_extended_version_number (n : natural) = n > 1

(** Identification indices.  The initial bytes of an ELF header (and an object
  * file) correspond to the e_ident member.
  *)

(** File identification *)
let elf_ii_mag0 : natural = 0
(** File identification *)
let elf_ii_mag1 : natural = 1
(** File identification *)
let elf_ii_mag2 : natural = 2
(** File identification *)
let elf_ii_mag3 : natural = 3
(** File class *)
let elf_ii_class : natural = 4
(** Data encoding *)
let elf_ii_data : natural = 5
(** File version *)
let elf_ii_version : natural = 6
(** Operating system/ABI identification *)
let elf_ii_osabi : natural = 7
(** ABI version *)
let elf_ii_abiversion : natural = 8
(** Start of padding bytes *)
let elf_ii_pad : natural = 9
(** Size of e*_ident[] *)
let elf_ii_nident : natural = 16

(** Magic number indices.  A file's first 4 bytes hold a ``magic number,''
  * identifying the file as an ELF object file.
  *)

(** Position: e*_ident[elf_ii_mag0], 0x7f magic number *)
let elf_mn_mag0 : unsigned_char = unsigned_char_of_natural 127
(** Position: e*_ident[elf_ii_mag1], 'E' format identifier *)
let elf_mn_mag1 : unsigned_char = unsigned_char_of_natural 69
(** Position: e*_ident[elf_ii_mag2], 'L' format identifier *)
let elf_mn_mag2 : unsigned_char = unsigned_char_of_natural 76
(** Position: e*_ident[elf_ii_mag3], 'F' format identifier *)
let elf_mn_mag3 : unsigned_char = unsigned_char_of_natural 70

(** ELf file classes.  The file format is designed to be portable among machines
  * of various sizes, without imposing the sizes of the largest machine on the
  * smallest. The class of the file defines the basic types used by the data
  * structures of the object file container itself.
  *)

(** Invalid class *)
let elf_class_none : natural = 0
(** 32 bit objects *)
let elf_class_32 : natural = 1
(** 64 bit objects *)
let elf_class_64 : natural = 2

(** [string_of_elf_file_class m] produces a string representation of the numeric
  * encoding [m] of the ELF file class.
  *)
val string_of_elf_file_class : natural -> string
let string_of_elf_file_class m =
	if m = elf_class_none then
		"Invalid ELF file class"
	else if m = elf_class_32 then
		"ELF32"
	else if m = elf_class_64 then
		"ELF64"
	else
		"Invalid ELF file class"

(** ELF data encodings.  Byte e_ident[elf_ei_data] specifies the encoding of both the
  * data structures used by object file container and data contained in object
  * file sections.
  *)

(** Invalid data encoding *)
let elf_data_none : natural = 0
(** Two's complement values, least significant byte occupying lowest address *)
let elf_data_2lsb : natural = 1
(** Two's complement values, most significant byte occupying lowest address *)
let elf_data_2msb : natural = 2

(** [string_of_elf_data_encoding m] produces a string representation of the
  * numeric encoding [m] of the ELF data encoding.
  *)
val string_of_elf_data_encoding : natural -> string
let string_of_elf_data_encoding m =
	if m = elf_data_none then
		"Invalid data encoding"
	else if m = elf_data_2lsb then
		"2's complement, little endian"
	else if m = elf_data_2msb then
		"2's complement, big endian"
	else
		"Invalid data encoding"

(** OS and ABI versions.  Byte e_ident[elf_ei_osabi] identifies the OS- or
  * ABI-specific ELF extensions used by this file. Some fields in other ELF
  * structures have flags and values that have operating system and/or ABI
  * specific meanings; the interpretation of those fields is determined by the
  * value of this byte.
  *)

(** No extensions or unspecified *)
let elf_osabi_none : natural = 0
(** Hewlett-Packard HP-UX *)
let elf_osabi_hpux : natural = 1
(** NetBSD *)
let elf_osabi_netbsd : natural = 2
(** GNU *)
let elf_osabi_gnu : natural = 3
(** Linux, historical alias for GNU *)
let elf_osabi_linux : natural = 3
(** Sun Solaris *)
let elf_osabi_solaris : natural = 6
(** AIX *)
let elf_osabi_aix : natural = 7
(** IRIX *)
let elf_osabi_irix : natural = 8
(** FreeBSD *)
let elf_osabi_freebsd : natural = 9
(** Compaq Tru64 Unix *)
let elf_osabi_tru64 : natural = 10
(** Novell Modesto *)
let elf_osabi_modesto : natural = 11
(** OpenBSD *)
let elf_osabi_openbsd : natural = 12
(** OpenVMS *)
let elf_osabi_openvms : natural = 13
(** Hewlett-Packard Non-stop Kernel *)
let elf_osabi_nsk : natural = 14
(** Amiga Research OS *)
let elf_osabi_aros : natural = 15
(** FenixOS highly-scalable multi-core OS *)
let elf_osabi_fenixos : natural = 16
(** Nuxi CloudABI *)
let elf_osabi_cloudabi : natural = 17
(** Stratus technologies OpenVOS *)
let elf_osabi_openvos : natural = 18

(** Checks an architecture defined OSABI version is correct, i.e. in the range
  * 64 to 255 inclusive.
  *)
let is_valid_architecture_defined_osabi_version (n : natural) =
  n >= 64 && n <= 255

(** [string_of_elf_osabi_version m] produces a string representation of the
  * numeric encoding [m] of the ELF OSABI version.
  *)
val string_of_elf_osabi_version : (natural -> string) -> natural -> string
let string_of_elf_osabi_version arch m =
	if m = elf_osabi_none then
		"UNIX - System V"
	else if m = elf_osabi_netbsd then
		"Hewlett-Packard HP-UX"
	else if m = elf_osabi_netbsd then
		"NetBSD"
	else if m = elf_osabi_gnu then
		"UNIX - GNU"
	else if m = elf_osabi_linux then
		"Linux"
	else if m = elf_osabi_solaris then
		"Sun Solaris"
	else if m = elf_osabi_aix then
		"AIX"
	else if m = elf_osabi_irix then
		"IRIX"
	else if m = elf_osabi_freebsd then
		"FreeBSD"
	else if m = elf_osabi_tru64 then
		"Compaq Tru64 Unix"
	else if m = elf_osabi_modesto then
		"Novell Modesto"
	else if m = elf_osabi_openbsd then
		"OpenBSD"
	else if m = elf_osabi_openvms then
		"OpenVMS"
	else if m = elf_osabi_nsk then
		"Hewlett-Packard Non-stop Kernel"
	else if m = elf_osabi_aros then
		"Amiga Research OS"
	else if m = elf_osabi_fenixos then
		"FenixOS highly-scalable multi-core OS"
  else if m = elf_osabi_cloudabi then
    "Nuxi CloudABI"
  else if m = elf_osabi_openvos then
    "Stratus technologies OpenVOS"
	else if is_valid_architecture_defined_osabi_version m then
	  arch m
	else
		"Invalid OSABI version"

(** ELF Header type *)

(** [ei_nident] is the fixed length of the identification field in the
  * [elf32_ehdr] type.
  *)
val ei_nident : natural
let ei_nident = 16

(** [elf32_header] is the type of headers for 32-bit ELF files.
  *)
type elf32_header =
  <| elf32_ident    : list unsigned_char (** Identification field *)
   ; elf32_type     : elf32_half         (** The object file type *)
   ; elf32_machine  : elf32_half         (** Required machine architecture *)
   ; elf32_version  : elf32_word         (** Object file version *)
   ; elf32_entry    : elf32_addr         (** Virtual address for transfer of control *)
   ; elf32_phoff    : elf32_off          (** Program header table offset in bytes *)
   ; elf32_shoff    : elf32_off          (** Section header table offset in bytes *)
   ; elf32_flags    : elf32_word         (** Processor-specific flags *)
   ; elf32_ehsize   : elf32_half         (** ELF header size in bytes *)
   ; elf32_phentsize: elf32_half         (** Program header table entry size in bytes *)
   ; elf32_phnum    : elf32_half         (** Number of entries in program header table *)
   ; elf32_shentsize: elf32_half         (** Section header table entry size in bytes *)
   ; elf32_shnum    : elf32_half         (** Number of entries in section header table *)
   ; elf32_shstrndx : elf32_half         (** Section header table entry for section name string table *)
   |>
   
(** [elf64_header] is the type of headers for 64-bit ELF files.
  *)
type elf64_header =
  <| elf64_ident    : list unsigned_char (** Identification field *)
   ; elf64_type     : elf64_half         (** The object file type *)
   ; elf64_machine  : elf64_half         (** Required machine architecture *)
   ; elf64_version  : elf64_word         (** Object file version *)
   ; elf64_entry    : elf64_addr         (** Virtual address for transfer of control *)
   ; elf64_phoff    : elf64_off          (** Program header table offset in bytes *)
   ; elf64_shoff    : elf64_off          (** Section header table offset in bytes *)
   ; elf64_flags    : elf64_word         (** Processor-specific flags *)
   ; elf64_ehsize   : elf64_half         (** ELF header size in bytes *)
   ; elf64_phentsize: elf64_half         (** Program header table entry size in bytes *)
   ; elf64_phnum    : elf64_half         (** Number of entries in program header table *)
   ; elf64_shentsize: elf64_half         (** Section header table entry size in bytes *)
   ; elf64_shnum    : elf64_half         (** Number of entries in section header table *)
   ; elf64_shstrndx : elf64_half         (** Section header table entry for section name string table *)
   |>
   
(** [is_valid_elf32_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
val is_valid_elf32_header : elf32_header -> bool
let is_valid_elf32_header hdr =
  List.take 4 hdr.elf32_ident = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]
  
(** [is_valid_elf64_header hdr] checks whether header [hdr] is valid, i.e. has
  * the correct magic numbers.
  * TODO: this should be expanded, presumably, or merged with some of the other
  * checks.
  *)
val is_valid_elf64_header : elf64_header -> bool
let is_valid_elf64_header hdr =
  List.take 4 hdr.elf64_ident = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]

(** [elf32_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
val elf32_header_compare : elf32_header -> elf32_header -> Basic_classes.ordering
let elf32_header_compare h1 h2 = 
    compare (List.map natural_of_unsigned_char h1.elf32_ident, [natural_of_elf32_half h1.elf32_type; 
            natural_of_elf32_half h1.elf32_machine ; natural_of_elf32_word h1.elf32_version ; 
            natural_of_elf32_addr h1.elf32_entry ; natural_of_elf32_off h1.elf32_phoff ; natural_of_elf32_off h1.elf32_shoff ; 
            natural_of_elf32_word h1.elf32_flags ; natural_of_elf32_half h1.elf32_ehsize ; 
            natural_of_elf32_half h1.elf32_phentsize; natural_of_elf32_half h1.elf32_phnum ; 
            natural_of_elf32_half h1.elf32_shentsize; natural_of_elf32_half h1.elf32_shnum ; 
            natural_of_elf32_half h1.elf32_shstrndx])
     (List.map natural_of_unsigned_char h2.elf32_ident, [natural_of_elf32_half h2.elf32_type; 
            natural_of_elf32_half h2.elf32_machine ; natural_of_elf32_word h2.elf32_version ; 
            natural_of_elf32_addr h2.elf32_entry ; natural_of_elf32_off h2.elf32_phoff ; natural_of_elf32_off h2.elf32_shoff ; 
            natural_of_elf32_word h2.elf32_flags ; natural_of_elf32_half h2.elf32_ehsize ; 
            natural_of_elf32_half h2.elf32_phentsize; natural_of_elf32_half h2.elf32_phnum ; 
            natural_of_elf32_half h2.elf32_shentsize; natural_of_elf32_half h2.elf32_shnum ; 
            natural_of_elf32_half h2.elf32_shstrndx])

instance (Ord elf32_header)
    let compare = elf32_header_compare
    let (<) = fun f1 -> (fun f2 -> (elf32_header_compare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (elf32_header_compare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (elf32_header_compare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (elf32_header_compare f1 f2) {GT; EQ})
end

(** [elf64_header_compare hdr1 hdr2] is an ordering comparison function for
  * ELF headers suitable for use in sets, finite maps and other ordered
  * data types.
  *)
val elf64_header_compare : elf64_header -> elf64_header -> Basic_classes.ordering
let elf64_header_compare h1 h2 = 
    compare (List.map natural_of_unsigned_char h1.elf64_ident, [natural_of_elf64_half h1.elf64_type; 
            natural_of_elf64_half h1.elf64_machine ; natural_of_elf64_word h1.elf64_version ; 
            natural_of_elf64_addr h1.elf64_entry ; natural_of_elf64_off h1.elf64_phoff ; natural_of_elf64_off h1.elf64_shoff ; 
            natural_of_elf64_word h1.elf64_flags ; natural_of_elf64_half h1.elf64_ehsize ; 
            natural_of_elf64_half h1.elf64_phentsize; natural_of_elf64_half h1.elf64_phnum ; 
            natural_of_elf64_half h1.elf64_shentsize; natural_of_elf64_half h1.elf64_shnum ; 
            natural_of_elf64_half h1.elf64_shstrndx])
     (List.map natural_of_unsigned_char h2.elf64_ident, [natural_of_elf64_half h2.elf64_type; 
            natural_of_elf64_half h2.elf64_machine ; natural_of_elf64_word h2.elf64_version ; 
            natural_of_elf64_addr h2.elf64_entry ; natural_of_elf64_off h2.elf64_phoff ; natural_of_elf64_off h2.elf64_shoff ; 
            natural_of_elf64_word h2.elf64_flags ; natural_of_elf64_half h2.elf64_ehsize ; 
            natural_of_elf64_half h2.elf64_phentsize; natural_of_elf64_half h2.elf64_phnum ; 
            natural_of_elf64_half h2.elf64_shentsize; natural_of_elf64_half h2.elf64_shnum ; 
            natural_of_elf64_half h2.elf64_shstrndx])

instance (Ord elf64_header)
    let compare = elf64_header_compare
    let (<) = fun f1 -> (fun f2 -> (elf64_header_compare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (elf64_header_compare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (elf64_header_compare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (elf64_header_compare f1 f2) {GT; EQ})
end

(** [is_elf32_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
val is_elf32_executable_file : elf32_header -> bool
let is_elf32_executable_file hdr =
  natural_of_elf32_half hdr.elf32_type = elf_ft_exec

(** [is_elf64_executable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of executable type.
  *)
val is_elf64_executable_file : elf64_header -> bool
let is_elf64_executable_file hdr =
  natural_of_elf64_half hdr.elf64_type = elf_ft_exec

(** [is_elf32_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
val is_elf32_shared_object_file : elf32_header -> bool
let is_elf32_shared_object_file hdr =
  natural_of_elf32_half hdr.elf32_type = elf_ft_dyn

(** [is_elf64_shared_object_file hdr] checks whether the header [hdr] states if the
  * ELF file is of shared object type.
  *)
val is_elf64_shared_object_file : elf64_header -> bool
let is_elf64_shared_object_file hdr =
  natural_of_elf64_half hdr.elf64_type = elf_ft_dyn

(** [is_elf32_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
val is_elf32_relocatable_file : elf32_header -> bool
let is_elf32_relocatable_file hdr =
  natural_of_elf32_half hdr.elf32_type = elf_ft_rel

(** [is_elf64_relocatable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of relocatable type.
  *)
val is_elf64_relocatable_file : elf64_header -> bool
let is_elf64_relocatable_file hdr =
  natural_of_elf64_half hdr.elf64_type = elf_ft_rel

(** [is_elf32_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
val is_elf32_linkable_file : elf32_header -> bool
let is_elf32_linkable_file hdr =
  is_elf32_shared_object_file hdr || is_elf32_relocatable_file hdr

(** [is_elf64_linkable_file hdr] checks whether the header [hdr] states if the
  * ELF file is of linkable (shared object or relocatable) type.
  *)
val is_elf64_linkable_file : elf64_header -> bool
let is_elf64_linkable_file hdr =
  is_elf64_shared_object_file hdr || is_elf64_relocatable_file hdr

(** [get_elf32_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
val get_elf32_machine_architecture : elf32_header -> natural
let get_elf32_machine_architecture hdr =
  natural_of_elf32_half hdr.elf32_machine

(** [get_elf64_machine_architecture hdr] returns the ELF file's declared machine
  * architecture, extracting the information from header [hdr].
  *)
val get_elf64_machine_architecture : elf64_header -> natural
let get_elf64_machine_architecture hdr =
  natural_of_elf64_half hdr.elf64_machine

(** [get_elf32_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
val get_elf32_osabi : elf32_header -> natural
let get_elf32_osabi hdr =
  match List.index hdr.elf32_ident (unsafe_nat_of_natural elf_ii_osabi) with
    | Just osabi -> natural_of_unsigned_char osabi
    | Nothing    -> failwith "get_elf32_osabi: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf64_osabi hdr] returns the ELF file's declared OS/ABI
  * architecture, extracting the information from header [hdr].
  *)
val get_elf64_osabi : elf64_header -> natural
let get_elf64_osabi hdr =
  match List.index hdr.elf64_ident (unsafe_nat_of_natural elf_ii_osabi) with
    | Just osabi -> natural_of_unsigned_char osabi
    | Nothing    -> failwith "get_elf64_osabi: lookup in ident failed"
  end (* Partial: should never return Nothing *)
  
(** [get_elf32_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
val get_elf32_data_encoding : elf32_header -> natural
let get_elf32_data_encoding hdr =
  match List.index hdr.elf32_ident (unsafe_nat_of_natural elf_ii_data) with
    | Just data -> natural_of_unsigned_char data
    | Nothing    -> failwith "get_elf32_data_encoding: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf64_data_encoding hdr] returns the ELF file's declared data
  * encoding, extracting the information from header [hdr].
  *)
val get_elf64_data_encoding : elf64_header -> natural
let get_elf64_data_encoding hdr =
  match List.index hdr.elf64_ident (unsafe_nat_of_natural elf_ii_data) with
    | Just data -> natural_of_unsigned_char data
    | Nothing    -> failwith "get_elf64_data_encoding: lookup in ident failed"
  end (* Partial: should never return Nothing *)
  
(** [get_elf32_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
val get_elf32_file_class : elf32_header -> natural
let get_elf32_file_class hdr =
  match List.index hdr.elf32_ident (unsafe_nat_of_natural elf_ii_class) with
    | Just cls -> natural_of_unsigned_char cls
    | Nothing    -> failwith "get_elf32_file_class: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf64_file_class hdr] returns the ELF file's declared file
  * class, extracting the information from header [hdr].
  *)
val get_elf64_file_class : elf64_header -> natural
let get_elf64_file_class hdr =
  match List.index hdr.elf64_ident (unsafe_nat_of_natural elf_ii_class) with
    | Just cls -> natural_of_unsigned_char cls
    | Nothing    -> failwith "get_elf64_file_class: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf32_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
val get_elf32_version_number : elf32_header -> natural
let get_elf32_version_number hdr =
  match List.index hdr.elf32_ident (unsafe_nat_of_natural elf_ii_version) with
    | Just ver -> natural_of_unsigned_char ver
    | Nothing    -> failwith "get_elf32_version_number: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf64_version_number hdr] returns the ELF file's declared version
  * number, extracting the information from header [hdr].
  *)
val get_elf64_version_number : elf64_header -> natural
let get_elf64_version_number hdr =
  match List.index hdr.elf64_ident (unsafe_nat_of_natural elf_ii_version) with
    | Just ver -> natural_of_unsigned_char ver
    | Nothing    -> failwith "get_elf64_version_number: lookup in ident failed"
  end (* Partial: should never return Nothing *)
  
(** [is_valid_elf32_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf32_header] to create a single
  * correctness check.
  *)
val is_valid_elf32_version_number : elf32_header -> bool
let is_valid_elf32_version_numer hdr =
  get_elf32_version_number hdr = elf_ev_current

(** [is_valid_elf64_version_number hdr] checks whether an ELF file's declared
  * version number matches the current, mandatory version number.
  * TODO: this should be merged into [is_valid_elf64_header] to create a single
  * correctness check.
  *)
val is_valid_elf64_version_number : elf64_header -> bool
let is_valid_elf64_version_numer hdr =
  get_elf64_version_number hdr = elf_ev_current
  
(** [get_elf32_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
val get_elf32_abi_version : elf32_header -> natural
let get_elf32_abi_version hdr =
  match List.index hdr.elf32_ident (unsafe_nat_of_natural elf_ii_abiversion) with
    | Just ver -> natural_of_unsigned_char ver
    | Nothing    -> failwith "get_elf32_abi_version: lookup in ident failed"
  end (* Partial: should never return Nothing *)

(** [get_elf64_abi_version hdr] returns the ELF file's declared ABI version
  * number, extracting the information from header [hdr].
  *)
val get_elf64_abi_version : elf64_header -> natural
let get_elf64_abi_version hdr =
  match List.index hdr.elf64_ident (unsafe_nat_of_natural elf_ii_abiversion) with
    | Just ver -> natural_of_unsigned_char ver
    | Nothing    -> failwith "get_elf64_abi_version: lookup in ident failed"
  end (* Partial: should never return Nothing *)
  
(** [deduce_endianness uc] deduces the endianness of an ELF file based on the ELF
  * header's magic number [uc].
  *)
val deduce_endianness : list unsigned_char -> endianness
let deduce_endianness id =
  match List.index id 5 with
    | Nothing -> failwith "deduce_endianness: read of magic number has failed"
    | Just v  ->
      if natural_of_unsigned_char v = elf_data_2lsb then
        Little
      else if natural_of_unsigned_char v = elf_data_2msb then
        Big
      else
        failwith "deduce_endianness: value is not valid"
  end

(** [get_elf32_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
val get_elf32_header_endianness : elf32_header -> endianness
let get_elf32_header_endianness hdr =
  deduce_endianness (hdr.elf32_ident)

(** [get_elf64_header_endianness hdr] returns the endianness of the ELF file
  * as declared in its header, [hdr].
  *)
val get_elf64_header_endianness : elf64_header -> endianness
let get_elf64_header_endianness hdr =
  deduce_endianness (hdr.elf64_ident)
  
(** [has_elf32_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
val has_elf32_header_associated_entry_point : elf32_header -> bool
let has_elf32_header_associated_entry_point hdr =
  natural_of_elf32_addr hdr.elf32_entry <> 0

(** [has_elf64_header_associated_entry_point hdr] checks whether the header
  * [hdr] declares an entry point for the program.
  *)
val has_elf64_header_associated_entry_point : elf64_header -> bool
let has_elf64_header_associated_entry_point hdr =
  natural_of_elf64_addr hdr.elf64_entry <> 0
  
(** [has_elf32_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
val has_elf32_header_string_table : elf32_header -> bool
let has_elf32_header_string_table hdr =
  natural_of_elf32_half hdr.elf32_shstrndx <> shn_undef
  
(** [has_elf64_header_string_table hdr] checks whether the header
  * [hdr] declares whether the program has a string table or not.
  *)
val has_elf64_header_string_table : elf64_header -> bool
let has_elf64_header_string_table hdr =
  natural_of_elf64_half hdr.elf64_shstrndx <> shn_undef
  
(** [is_elf32_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
val is_elf32_header_section_size_in_section_header_table : elf32_header -> bool
let is_elf32_header_section_size_in_section_header_table hdr =
  natural_of_elf32_half hdr.elf32_shnum = 0
  
(** [is_elf64_header_section_size_in_section_header_table hdr] checks whether the header
  * [hdr] declares whether the section size is too large to fit in the header
  * field and is instead stored in the section header table.
  *)
val is_elf64_header_section_size_in_section_header_table : elf64_header -> bool
let is_elf64_header_section_size_in_section_header_table hdr =
  natural_of_elf64_half hdr.elf64_shnum = 0
  
(** [is_elf32_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
val is_elf32_header_string_table_index_in_link : elf32_header -> bool
let is_elf32_header_string_table_index_in_link hdr =
  natural_of_elf32_half hdr.elf32_shstrndx = shn_xindex
  
(** [is_elf64_header_string_table_index_in_link hdr] checks whether the header
  * [hdr] declares whether the string table index is too large to fit in the
  * header's field and is instead stored in the link field of an entry in the
  * section header table.
  *)
val is_elf64_header_string_table_index_in_link : elf64_header -> bool
let is_elf64_header_string_table_index_in_link hdr =
  natural_of_elf64_half hdr.elf64_shstrndx = shn_xindex

(** The [hdr_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
type hdr_print_bundle = (natural -> string) * (natural -> string)

(** [string_of_elf32_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
val string_of_elf32_header : hdr_print_bundle -> elf32_header -> string
let string_of_elf32_header (os, proc) hdr =
	unlines [
	  "\t" ^ "Magic number: " ^ show hdr.elf32_ident
  ; "\t" ^ "Endianness: " ^ show (deduce_endianness hdr.elf32_ident)
	; "\t" ^ "Type: " ^ string_of_elf_file_type os proc (natural_of_elf32_half hdr.elf32_type)
  ; "\t" ^ "Version: " ^ string_of_elf_version_number (natural_of_elf32_word hdr.elf32_version)
	; "\t" ^ "Machine: " ^ string_of_elf_machine_architecture (natural_of_elf32_half hdr.elf32_machine)
  ; "\t" ^ "Entry point: " ^ show hdr.elf32_entry
  ; "\t" ^ "Flags: " ^ show hdr.elf32_flags
  ; "\t" ^ "Entries in program header table: " ^ show hdr.elf32_phnum
  ; "\t" ^ "Entries in section header table: " ^ show hdr.elf32_shnum
	]

(** [string_of_elf64_header hdr_bdl hdr] returns a string-based representation
  * of header [hdr] using the ABI-specific print bundle [hdr_bdl].
  *)
val string_of_elf64_header : hdr_print_bundle -> elf64_header -> string
let string_of_elf64_header (os, proc) hdr =
  unlines [
    "\t" ^ "Magic number: " ^ show hdr.elf64_ident
  ; "\t" ^ "Endianness: " ^ show (deduce_endianness hdr.elf64_ident)
  ; "\t" ^ "Type: " ^ string_of_elf_file_type os proc (natural_of_elf64_half hdr.elf64_type)
  ; "\t" ^ "Version: " ^ string_of_elf_version_number (natural_of_elf64_word hdr.elf64_version)
  ; "\t" ^ "Machine: " ^ string_of_elf_machine_architecture (natural_of_elf64_half hdr.elf64_machine)
  ; "\t" ^ "Entry point: " ^ show hdr.elf64_entry
  ; "\t" ^ "Flags: " ^ show hdr.elf64_flags
  ; "\t" ^ "Entries in program header table: " ^ show hdr.elf64_phnum
  ; "\t" ^ "Entries in section header table: " ^ show hdr.elf64_shnum
  ]

(** The following are thin wrappers around the pretty-printing functions above
  * using a default print bundle for the header.
  *)
  
val string_of_elf32_header_default : elf32_header -> string
let string_of_elf32_header_default =
	string_of_elf32_header
    (default_os_specific_print,
      default_proc_specific_print)

val string_of_elf64_header_default : elf64_header -> string
let string_of_elf64_header_default =
  string_of_elf64_header
    (default_os_specific_print,
      default_proc_specific_print)
	
instance (Show elf32_header)
	let show = string_of_elf32_header_default
end

instance (Show elf64_header)
  let show = string_of_elf64_header_default
end

(** [read_elf_ident bs0] reads the initial bytes of an ELF file from byte sequence
  * [bs0], returning the remainder of the byte sequence too.
  * Fails if transcription fails.
  *)
val read_elf_ident : byte_sequence -> error (list unsigned_char * byte_sequence)
let read_elf_ident bs
 = repeatM' ei_nident bs (read_unsigned_char default_endianness)

(** [bytes_of_elf32_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
val bytes_of_elf32_header : elf32_header -> byte_sequence
let bytes_of_elf32_header hdr =
  let endian = deduce_endianness hdr.elf32_ident in
    Byte_sequence.from_byte_lists [
      List.map byte_of_unsigned_char hdr.elf32_ident
    ; bytes_of_elf32_half endian hdr.elf32_type
    ; bytes_of_elf32_half endian hdr.elf32_machine
    ; bytes_of_elf32_word endian hdr.elf32_version
    ; bytes_of_elf32_addr endian hdr.elf32_entry
    ; bytes_of_elf32_off  endian hdr.elf32_phoff
    ; bytes_of_elf32_off  endian hdr.elf32_shoff
    ; bytes_of_elf32_word endian hdr.elf32_flags
    ; bytes_of_elf32_half endian hdr.elf32_ehsize
    ; bytes_of_elf32_half endian hdr.elf32_phentsize
    ; bytes_of_elf32_half endian hdr.elf32_phnum
    ; bytes_of_elf32_half endian hdr.elf32_shentsize
    ; bytes_of_elf32_half endian hdr.elf32_shnum
    ; bytes_of_elf32_half endian hdr.elf32_shstrndx
    ]
    
(** [bytes_of_elf64_header hdr] blits an ELF header [hdr] to a byte sequence,
  * ready for transcription to a binary file.
  *)
val bytes_of_elf64_header : elf64_header -> byte_sequence
let bytes_of_elf64_header hdr =
  let endian = deduce_endianness hdr.elf64_ident in
    Byte_sequence.from_byte_lists [
      List.map byte_of_unsigned_char hdr.elf64_ident
    ; bytes_of_elf64_half endian hdr.elf64_type
    ; bytes_of_elf64_half endian hdr.elf64_machine
    ; bytes_of_elf64_word endian hdr.elf64_version
    ; bytes_of_elf64_addr endian hdr.elf64_entry
    ; bytes_of_elf64_off  endian hdr.elf64_phoff
    ; bytes_of_elf64_off  endian hdr.elf64_shoff
    ; bytes_of_elf64_word endian hdr.elf64_flags
    ; bytes_of_elf64_half endian hdr.elf64_ehsize
    ; bytes_of_elf64_half endian hdr.elf64_phentsize
    ; bytes_of_elf64_half endian hdr.elf64_phnum
    ; bytes_of_elf64_half endian hdr.elf64_shentsize
    ; bytes_of_elf64_half endian hdr.elf64_shnum
    ; bytes_of_elf64_half endian hdr.elf64_shstrndx
    ]
    
val is_elf32_header_padding_correct : elf32_header -> bool
let is_elf32_header_padding_correct ehdr =
  List.index ehdr.elf32_ident 9  = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 10 = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 11 = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 12 = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 13 = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 14 = Just (unsigned_char_of_natural 0) &&
  List.index ehdr.elf32_ident 15 = Just (unsigned_char_of_natural 0)

val is_magic_number_correct : list unsigned_char -> bool
let is_magic_number_correct ident =
  List.index ident 0 = Just (unsigned_char_of_natural 127) &&
  List.index ident 1 = Just (unsigned_char_of_natural 69)  &&
  List.index ident 2 = Just (unsigned_char_of_natural 76)  &&
  List.index ident 3 = Just (unsigned_char_of_natural 70)

(** [read_elf32_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
val read_elf32_header : byte_sequence -> error (elf32_header * byte_sequence)
let read_elf32_header bs =
	read_elf_ident bs >>= fun (ident, bs) ->
	if not (is_magic_number_correct ident) then
	  fail "read_elf32_header: magic number incorrect"
	else
    let endian = deduce_endianness ident in
	  read_elf32_half endian bs >>= fun (typ, bs) ->
	  read_elf32_half endian bs >>= fun (machine, bs) ->
	  read_elf32_word endian bs >>= fun (version, bs) ->
	  read_elf32_addr endian bs >>= fun (entry, bs) ->
	  read_elf32_off  endian bs >>= fun (phoff, bs) ->
	  read_elf32_off  endian bs >>= fun (shoff, bs) ->
	  read_elf32_word endian bs >>= fun (flags, bs) ->
	  read_elf32_half endian bs >>= fun (ehsize, bs) ->
	  read_elf32_half endian bs >>= fun (phentsize, bs) ->
	  read_elf32_half endian bs >>= fun (phnum, bs) ->
	  read_elf32_half endian bs >>= fun (shentsize, bs) ->
	  read_elf32_half endian bs >>= fun (shnum, bs) ->
	  read_elf32_half endian bs >>= fun (shstrndx, bs) ->
    match List.index ident 4 with
      | Nothing -> fail "read_elf32_header: transcription of ELF identifier failed"
      | Just c  ->
        if natural_of_unsigned_char c = elf_class_32 then
		      return (<| elf32_ident = ident; elf32_type  = typ;
                      elf32_machine = machine; elf32_version = version;
                      elf32_entry = entry; elf32_phoff = phoff;
                      elf32_shoff = shoff; elf32_flags = flags;
                      elf32_ehsize = ehsize; elf32_phentsize = phentsize;
                      elf32_phnum = phnum; elf32_shentsize = shentsize;
                      elf32_shnum = shnum; elf32_shstrndx = shstrndx |>, bs)
        else
          fail "read_elf32_header: not a 32-bit ELF file"
    end

(** [read_elf64_header bs0] reads an ELF header from the byte sequence [bs0].
  * Fails if transcription fails.
  *)
val read_elf64_header : byte_sequence -> error (elf64_header * byte_sequence)
let read_elf64_header bs =
  read_elf_ident bs >>= fun (ident, bs) ->
  if not (is_magic_number_correct ident) then
    fail "read_elf64_header: magic number incorrect"
  else
    let endian = deduce_endianness ident in
    read_elf64_half endian bs >>= fun (typ, bs) ->
    read_elf64_half endian bs >>= fun (machine, bs) ->
    read_elf64_word endian bs >>= fun (version, bs) ->
    read_elf64_addr endian bs >>= fun (entry, bs) ->
    read_elf64_off  endian bs >>= fun (phoff, bs) ->
    read_elf64_off  endian bs >>= fun (shoff, bs) ->
    read_elf64_word endian bs >>= fun (flags, bs) ->
    read_elf64_half endian bs >>= fun (ehsize, bs) ->
    read_elf64_half endian bs >>= fun (phentsize, bs) ->
    read_elf64_half endian bs >>= fun (phnum, bs) ->
    read_elf64_half endian bs >>= fun (shentsize, bs) ->
    read_elf64_half endian bs >>= fun (shnum, bs) ->
    read_elf64_half endian bs >>= fun (shstrndx, bs) ->
    match List.index ident 4 with
      | Nothing -> fail "read_elf64_header: transcription of ELF identifier failed"
      | Just c  ->
        if natural_of_unsigned_char c = elf_class_64 then
          return (<| elf64_ident = ident; elf64_type  = typ;
                     elf64_machine = machine; elf64_version = version;
                     elf64_entry = entry; elf64_phoff = phoff;
                     elf64_shoff = shoff; elf64_flags = flags;
                     elf64_ehsize = ehsize; elf64_phentsize = phentsize;
                     elf64_phnum = phnum; elf64_shentsize = shentsize;
                     elf64_shnum = shnum; elf64_shstrndx = shstrndx |>, bs)
        else
          fail "read_elf64_header: not a 64-bit ELF file"
    end

(** [is_elf32_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
val is_elf32_header_class_correct : elf32_header -> bool
let is_elf32_header_class_correct ehdr =
  List.index ehdr.elf32_ident 4 = Just (unsigned_char_of_natural 1)
  
(** [is_elf64_header_class_correct hdr] checks whether the declared file class
  * is correct.
  *)
val is_elf64_header_class_correct : elf64_header -> bool
let is_elf64_header_class_correct ehdr =
  List.index ehdr.elf64_ident 4 = Just (unsigned_char_of_natural 1)

(** [is_elf32_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
val is_elf32_header_version_correct : elf32_header -> bool
let is_elf32_header_version_correct ehdr =
  List.index ehdr.elf32_ident 6 = Just (unsigned_char_of_natural 1)
  
(** [is_elf64_header_version_correct hdr] checks whether the declared file version
  * is correct.
  *)
val is_elf64_header_version_correct : elf64_header -> bool
let is_elf64_header_version_correct ehdr =
  List.index ehdr.elf64_ident 6 = Just (unsigned_char_of_natural 1)

(** [is_elf32_header_valid] checks whether an [elf32_header] value is a valid 32-bit
  * ELF file header (i.e. [elf32_ident] is [ei_nident] entries long, and other
  * constraints on headers).
  *)
val is_elf32_header_valid : elf32_header -> bool
let is_elf32_header_valid ehdr =
  naturalFromNat (List.length ehdr.elf32_ident) = ei_nident &&
  is_magic_number_correct ehdr.elf32_ident &&
  is_elf32_header_padding_correct ehdr &&
  is_elf32_header_class_correct ehdr &&
  is_elf32_header_version_correct ehdr

(** [get_elf32_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
val get_elf32_header_program_table_size : elf32_header -> natural
let get_elf32_header_program_table_size ehdr =
  let phentsize = natural_of_elf32_half ehdr.elf32_phentsize in
  let phnum     = natural_of_elf32_half ehdr.elf32_phnum in
    phentsize * phnum

(** [get_elf64_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
val get_elf64_header_program_table_size : elf64_header -> natural
let get_elf64_header_program_table_size ehdr =
  let phentsize = natural_of_elf64_half ehdr.elf64_phentsize in
  let phnum     = natural_of_elf64_half ehdr.elf64_phnum in
    phentsize * phnum

(** [is_elf32_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
val is_elf32_header_section_table_present : elf32_header -> bool
let is_elf32_header_section_table_present ehdr =
  not (natural_of_elf32_off ehdr.elf32_shoff = 0)

(** [is_elf64_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
val is_elf64_header_section_table_present : elf64_header -> bool
let is_elf64_header_section_table_present ehdr =
  not (natural_of_elf64_off ehdr.elf64_shoff = 0)

(** [get_elf32_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
val get_elf32_header_section_table_size : elf32_header -> natural
let get_elf32_header_section_table_size ehdr =
  let shentsize = natural_of_elf32_half ehdr.elf32_shentsize in
  let shnum     = natural_of_elf32_half ehdr.elf32_shnum in
    shentsize * shnum

(** [get_elf64_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
val get_elf64_header_section_table_size : elf64_header -> natural
let get_elf64_header_section_table_size ehdr =
  let shentsize = natural_of_elf64_half ehdr.elf64_shentsize in
  let shnum     = natural_of_elf64_half ehdr.elf64_shnum in
    shentsize * shnum
