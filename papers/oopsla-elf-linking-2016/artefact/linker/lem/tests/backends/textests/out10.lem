(* generated by Ott 0.23 from: ../tests/test10.ott *)
open import Pervasives

type var = string (* term variable *)

type term =  (* term *)
 | T_var of var (* variable *)
 | T_lam of var * term (* lambda *)
 | T_app of term * term (* app *)

(*tex \textbf{THIS IS NOT CORRECTLY INLINED AT TOP-LEVEL (it's inside the preceding \texttt{$\backslash$lemdefn})}*)

(*--- \textbf{THIS IS CORRECTLY SUPPRESSED IN TEX OUTPUT}*)

(*tex \textbf{THERE IS A (*--- *) COMMENT JUST BEFORE THIS which is correctly suppressed except for the extra newline after the comment - if there isn't anything else on the line except comment, we should suppress the following newline too}*)

(*tex \textbf{AND THE NEW LATEX OUTPUT DOESN'T SEEM TO WRAP LONG LINES PROPERLY - DID TABBING DO THAT FOR US?} *)

(** subrules *)
let (*tex \textbf{THIS IS CORRECTLY INLINED}*) is_val_of_term (t5:term) : bool =
  match t5 with
   | (T_var x) -> false
   | (T_lam x t) -> (true)
   | (T_app t t') -> false (*--- \textbf{THIS IS CORRECTLY SUPPRESSED IN TEX OUTPUT}*)
  end


(** substitutions *)
let rec tsubst_term (t5:term) (x5:var) (t_6:term) : term =
  match t_6 with
   | (T_var x) -> (if x=x5 then t5 else (T_var x))
   | (T_lam x t) -> T_lam x (if  List.elem x5 ([x]) then t else (tsubst_term t5 x5 t))
   | (T_app t t') -> T_app (tsubst_term t5 x5 t) (tsubst_term t5 x5 t')
  end

(** definitions *)
(* defns Jop *)
indreln
[reduce : term -> term -> bool witness type reduce_witness; check reduce_check; eval : input -> output]
(* defn reduce *)


(* #source file ../tests/test10.ott  lines 34 - 36 *)
ax_app: forall x t1 v2 .
(is_val_of_term v2)
 ==> 
reduce (T_app  (T_lam x t1)  v2)  (tsubst_term  v2   x   t1 ) 

and

(* #source file ../tests/test10.ott  lines 37 - 40 *)
ctx_app_fun: forall t1 t t1' .
(reduce t1 t1')
 ==> 
reduce (T_app t1 t) (T_app t1' t)

and

(* #source file ../tests/test10.ott  lines 41 - 44 *)
ctx_app_arg: forall v t1 t1' .
(is_val_of_term v) &&
(reduce t1 t1')
 ==> 
reduce (T_app v t1) (T_app v t1')




