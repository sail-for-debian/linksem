<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Trans.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Ast_util" rel="Chapter" href="Ast_util.html">
<link title="Backend" rel="Chapter" href="Backend.html">
<link title="Backend_common" rel="Chapter" href="Backend_common.html">
<link title="Coq_decidable_equality" rel="Chapter" href="Coq_decidable_equality.html">
<link title="Def_trans" rel="Chapter" href="Def_trans.html">
<link title="Finite_map" rel="Chapter" href="Finite_map.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Initial_env" rel="Chapter" href="Initial_env.html">
<link title="Macro_expander" rel="Chapter" href="Macro_expander.html">
<link title="Main" rel="Chapter" href="Main.html">
<link title="Module_dependencies" rel="Chapter" href="Module_dependencies.html">
<link title="Name" rel="Chapter" href="Name.html">
<link title="Nvar" rel="Chapter" href="Nvar.html">
<link title="Output" rel="Chapter" href="Output.html">
<link title="Path" rel="Chapter" href="Path.html">
<link title="Pattern_syntax" rel="Chapter" href="Pattern_syntax.html">
<link title="Patterns" rel="Chapter" href="Patterns.html">
<link title="Pcombinators" rel="Chapter" href="Pcombinators.html">
<link title="Pp" rel="Chapter" href="Pp.html">
<link title="Precedence" rel="Chapter" href="Precedence.html">
<link title="Process_file" rel="Chapter" href="Process_file.html">
<link title="Rename_top_level" rel="Chapter" href="Rename_top_level.html">
<link title="Reporting" rel="Chapter" href="Reporting.html">
<link title="Reporting_basic" rel="Chapter" href="Reporting_basic.html">
<link title="Seplist" rel="Chapter" href="Seplist.html">
<link title="Syntactic_tests" rel="Chapter" href="Syntactic_tests.html">
<link title="Target" rel="Chapter" href="Target.html">
<link title="Target_binding" rel="Chapter" href="Target_binding.html">
<link title="Target_syntax" rel="Chapter" href="Target_syntax.html">
<link title="Target_trans" rel="Chapter" href="Target_trans.html">
<link title="Trans" rel="Chapter" href="Trans.html">
<link title="Typecheck" rel="Chapter" href="Typecheck.html">
<link title="Typecheck_ctxt" rel="Chapter" href="Typecheck_ctxt.html">
<link title="Typed_ast" rel="Chapter" href="Typed_ast.html">
<link title="Typed_ast_syntax" rel="Chapter" href="Typed_ast_syntax.html">
<link title="Types" rel="Chapter" href="Types.html">
<link title="Tyvar" rel="Chapter" href="Tyvar.html">
<link title="Util" rel="Chapter" href="Util.html"><link title="Record Macros" rel="Section" href="#2_RecordMacros">
<link title="Set and List Comprehension Macros" rel="Section" href="#2_SetandListComprehensionMacros">
<link title="Quantifier Macros" rel="Section" href="#2_QuantifierMacros">
<link title="Pattern Macros" rel="Section" href="#2_PatternMacros">
<link title="Type Class Macros " rel="Section" href="#2_TypeClassMacros">
<link title="Misc" rel="Section" href="#2_Misc">
<link title="Macros I don't understand" rel="Section" href="#2_MacrosIdontunderstand">
<title>Trans.Macros</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Trans.html">Up</a>
&nbsp;</div>
<center><h1>Functor <a href="type_Trans.Macros.html">Trans.Macros</a></h1></center>
<br>
<pre><span class="keyword">module</span> Macros: <div class="sig_block"><code class="code">functor (</code><code class="code">E</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="VALenv"><span class="keyword">val</span> env</span> : <code class="type"><a href="Typed_ast.html#TYPEenv">Typed_ast.env</a></code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Trans.Macros.html">..</a> <code class="code">end</code></div></pre><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>E</code></td>
<td align="center" valign="top">:</td>
<td><code class="type">sig val env : env end</code>
</table>
</td>
</tr>
</table>
<hr width="100%">
<br>
<span id="2_RecordMacros"><h2>Record Macros</h2></span><br>
<pre><span id="VALremove_singleton_record_updates"><span class="keyword">val</span> remove_singleton_record_updates</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_singleton_record_updates</code> replaces updates of
      records that have only one field with the construction
      of a completely new record.<br>
</div>
<pre><span id="VALremove_multiple_record_updates"><span class="keyword">val</span> remove_multiple_record_updates</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_multiple_record_updates</code> replaces record updates
      simultaneously updating multiple fields with a nested record
      update, each affecting only one field, that achieves the same
      effect.<br>
</div>
<pre><span id="VALsort_record_fields"><span class="keyword">val</span> sort_record_fields</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">sort_record_fields</code> sorts the fields of a record expression
      into the same order as in the definition of the record
      type. If they do not need resorting, everything is fine,
      otherwise a warning is produced.<br>
</div>
<br>
<span id="2_SetandListComprehensionMacros"><h2>Set and List Comprehension Macros</h2></span><br>
<pre><span id="VALremove_list_comprehension"><span class="keyword">val</span> remove_list_comprehension</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_list_comprehension</code> removes list comprehensions by turning
      them into fold and insert operations. A <code class="code">Trans_error</code> exception is
      thrown, if not only bounded quantification is used.<br>
</div>
<pre><span id="VALremove_set_comprehension"><span class="keyword">val</span> remove_set_comprehension</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_set_comprehension</code> removes set comprehensions by turning
      them into fold and insert operations. A <code class="code">Trans_error</code> exception is
      thrown, if not only bounded quantification is used.<br>
</div>
<pre><span id="VALremove_set_comprehension_image_filter"><span class="keyword">val</span> remove_set_comprehension_image_filter</span> : <code class="type">bool -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_set_comprehension allow_sigma</code> removes set comprehensions by turning
      them into set-image, set-filter and set-product operations. For example
      <code class="code">{ f (x,y,z) | forall ((x,y) IN A) (z IN B) | P (x, y, z)}</code> is turned into
      <code class="code">Set.image f (Set.filter P (Set.cross A B))</code>. If <code class="code">allow_sigma</code> is set and the
      quantifiers depend on each other, <code class="code">set_sigma</code> is used instead. So, for example
      <code class="code">{ f (x,y,z) | forall ((x,y) IN A) (z IN B x) | P (x, y, z)}</code> is turned into
      <code class="code">Set.image f (Set.filter P (Set.set_sigma A (fun (x, y) -&gt; B x)))</code>.
<p>

      In contrast to <code class="code">remove_set_comprehension</code> no exception is thrown, if the translation fails. 
      This is because it is intended to be used
      with theorem prover backends, which can handle unbounded quantification differently.<br>
</div>
<pre><span id="VALremove_setcomp"><span class="keyword">val</span> remove_setcomp</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_setcomp</code> removes set comprehensions with implicit bound variable to ones with
      explicitly bound onces. For example <code class="code">{ (x, y) | x &gt; y }</code> might, depending on context be turned
      in <code class="code">{ (x, y) | forall x | x &gt; y}</code>, <code class="code">{ (x, y) | forall x y | x &gt; y}</code> or something similar.<br>
</div>
<pre><span id="VALcleanup_set_quant"><span class="keyword">val</span> cleanup_set_quant</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">cleanup_set_quant</code> moves restricted and unrestricted quantification 
      in set comprehensions to the condition part, if the bound variables are only used by the condition.
      This means, that expressions of the form <code class="code">{ f x | forall (p IN e) ... | P x }</code> become
      <code class="code">{ f x | forall ... | exists (p IN e). P x }</code> if <code class="code">x</code> is not a member of <code class="code">FV p</code>.<br>
</div>
<pre><span id="VALremove_set_comp_binding"><span class="keyword">val</span> remove_set_comp_binding</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_set_comp_binding</code> tries to turn <code class="code">Comb_binding</code> expressions into <code class="code">Set_comb</code> ones. 
      Given a term of the form <code class="code">{ f x z | forall x z | P x z y1 ... yn }</code> it checks that only
      unbounded quantification is used and that the set of bound variables is exactly the set of free
      variables of the expression <code class="code">f x z</code>. If this is the case, the expression is transformed to 
      <code class="code">{ f x z | P x z y1 ... yn }</code>. Otherwise <code class="code">remove_set_comp_binding</code> fails.<br>
</div>
<pre><span id="VALremove_set_restr_quant"><span class="keyword">val</span> remove_set_restr_quant</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_set_restr_quant</code> turns restricted quantification in set comprehensions 
      into unrestricted quantification. Expressions of the form <code class="code">{ f x | forall (p IN e) | P x }</code> become
      <code class="code">{ f x | FV(p) | forall FV(p). p IN e /\ P x }</code>. This requires turning pattern <code class="code">p</code> into
      an expression. This is likely to fail for more complex patterns. In these cases, <code class="code">remove_set_restr_quant</code>
      fails and pattern compilation is needed.<br>
</div>
<br>
<span id="2_QuantifierMacros"><h2>Quantifier Macros</h2></span><br>
<pre><span id="VALlist_quant_to_set_quant"><span class="keyword">val</span> list_quant_to_set_quant</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">list_quant_to_set_quant</code> turns <code class="code">forall (x MEM L). P x</code> into <code class="code">forall (x IN Set.from_list L). P x</code><br>
</div>
<pre><span id="VALremove_restr_quant"><span class="keyword">val</span> remove_restr_quant</span> : <code class="type">(<a href="Typed_ast.html#TYPEpat">Typed_ast.pat</a> -> bool) -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_restr_quant pat_OK</code> turns restricted quantification into unrestricted quantification,
      if then pattern does not satisfy <code class="code">pat_OK</code>. For example, expressions of the from <code class="code">forall (p IN e). P x</code> becomes
      <code class="code">forall FV(p). p IN e --&gt; P x</code>, if <code class="code">pat_OK p</code> does not hold. <code class="code">pat_OK</code> is used to configure, which types
      of restricted quantification are supported by the backend. For example, HOL 4 supports 
      patterns consisting of variables, tuples and wildcard patterns, while Isabelle does not like wildcard ones.
      This macros tries to turn pattern <code class="code">p</code> into
      an expression. This is likely to fail for more complex patterns. In these cases, <code class="code">remove_restr_quant pat_OK</code>
      fails and pattern compilation is needed.<br>
</div>
<pre><span id="VALremove_quant"><span class="keyword">val</span> remove_quant</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_quant</code> turns quantifiers into iteration. It throws an <code class="code">Trans_error</code> exception, if used
      on unrestricted quantification. Given an expression <code class="code">forall (x IN X). P x</code> this returns
      <code class="code">Set.forall X (fun x -&gt; P x)</code>. It also works for existential quantification and quantification
      over lists.<br>
</div>
<pre><span id="VALremove_quant_coq"><span class="keyword">val</span> remove_quant_coq</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_quant_coq</code> the same as above but does not apply in the body of lemma or theorem
      statements.  Specific to the Coq backend.<br>
</div>
<br>
<span id="2_PatternMacros"><h2>Pattern Macros</h2></span><br>
<pre><span id="VALremove_unit_pats"><span class="keyword">val</span> remove_unit_pats</span> : <code class="type"><a href="Trans.html#TYPEpat_macro">Trans.pat_macro</a></code></pre><div class="info">
<code class="code">remove_unit_pats</code> replaces unit-patterns <code class="code">()</code> with wildcard ones <code class="code">_</code>.<br>
</div>
<pre><span id="VALcoq_type_annot_pat_vars"><span class="keyword">val</span> coq_type_annot_pat_vars</span> : <code class="type"><a href="Trans.html#TYPEpat_macro">Trans.pat_macro</a></code></pre><div class="info">
Add type annotations to pattern variables whose type contains a type variable
     (only add for arguments to top-level functions)<br>
</div>
<br>
<span id="2_TypeClassMacros"><h2>Type Class Macros </h2></span><br>
<pre><span id="VALremove_method"><span class="keyword">val</span> remove_method</span> : <code class="type"><a href="Target.html#TYPEtarget">Target.target</a> -> bool -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_method target add_dict</code> is used to remove occurrences of class methods. 
       If a class method is encountered, the <code class="code">remove_method</code> macro first tries to 
       resolve the type-class instantiation statically and replace the method with it's
       instantiation. If this static resolving attempt fails, it is checked, whether the method
       is inlined for this target. If this is not the case and the flag <code class="code">add_dict</code> is set, 
       the method is replaced with a lookup in a dictionary. This dictionary is added by the
       <code class="code">Def_trans.class_constraint_to_parameter</code> to the arguments of each definition that
       has type class constraints.<br>
</div>
<pre><span id="VALremove_method_pat"><span class="keyword">val</span> remove_method_pat</span> : <code class="type"><a href="Trans.html#TYPEpat_macro">Trans.pat_macro</a></code></pre><div class="info">
<code class="code">remove_method_pat</code> is used to remove occurrences of class methods. 
       If a class method is encountered, <code class="code">remove_method_pat</code> macro tries to 
       resolve the type-class instantiation statically and replace the method with it's
       instantiation.<br>
</div>
<pre><span id="VALremove_num_lit"><span class="keyword">val</span> remove_num_lit</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_num_lit</code> replaces <code class="code">L_num (sk, i)</code> with <code class="code">fromNumeral (L_numeral (sk, i))</code>.
       This is the first step into using type classes to handle numerals.<br>
</div>
<pre><span id="VALremove_class_const"><span class="keyword">val</span> remove_class_const</span> : <code class="type"><a href="Target.html#TYPEtarget">Target.target</a> -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_class_const</code> remove constants that have class constraints by adding
      explicit dictionary parameters.<br>
</div>
<br>
<span id="2_Misc"><h2>Misc</h2></span><br>
<pre><span id="VALremove_function"><span class="keyword">val</span> remove_function</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_function</code> turns <code class="code">function | pat1 -&gt; exp1 ... | patn -&gt; expn end</code> into
      <code class="code">fun x -&gt; match x with | pat1 -&gt; exp1 ... | patn -&gt; expn end</code>.<br>
</div>
<pre><span id="VALremove_sets"><span class="keyword">val</span> remove_sets</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
Warning: OCaml specific! <code class="code">remove_sets</code> transforms set expressions like <code class="code">{e1, ..., en}</code> into
      <code class="code">Ocaml.Pset.from_list (type_specific compare) [e1, ..., en]</code><br>
</div>
<pre><span id="VALstring_lits_isa"><span class="keyword">val</span> string_lits_isa</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">string_lits_isa</code> translates non-representable string literals into list
      of characters for Isabelle<br>
</div>
<pre><span id="VALremove_fun_pats"><span class="keyword">val</span> remove_fun_pats</span> : <code class="type">bool -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><div class="info">
<code class="code">remove_fun_pats keep_tup</code> removes patterns from expressions of the from
      <code class="code">fun p1 ... pn -&gt; e</code> by introducing <code class="code">function</code> expressions. 
      Variable patterns and - if <code class="code">keep_tup</code> is set - tuple patterns are kept.<br>
</div>
<br>
<span id="2_MacrosIdontunderstand"><h2>Macros I don't understand</h2></span><br>
<pre><span id="VALadd_nexp_param_in_const"><span class="keyword">val</span> add_nexp_param_in_const</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><pre><span id="VALremove_vector_access"><span class="keyword">val</span> remove_vector_access</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><pre><span id="VALremove_vector_sub"><span class="keyword">val</span> remove_vector_sub</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre><pre><span id="VALremove_do"><span class="keyword">val</span> remove_do</span> : <code class="type"><a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> <a href="Trans.html#TYPEmacro">Trans.macro</a></code></pre></body></html>