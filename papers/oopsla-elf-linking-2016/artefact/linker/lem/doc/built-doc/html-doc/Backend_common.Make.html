<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Backend_common.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Ast_util" rel="Chapter" href="Ast_util.html">
<link title="Backend" rel="Chapter" href="Backend.html">
<link title="Backend_common" rel="Chapter" href="Backend_common.html">
<link title="Coq_decidable_equality" rel="Chapter" href="Coq_decidable_equality.html">
<link title="Def_trans" rel="Chapter" href="Def_trans.html">
<link title="Finite_map" rel="Chapter" href="Finite_map.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Initial_env" rel="Chapter" href="Initial_env.html">
<link title="Macro_expander" rel="Chapter" href="Macro_expander.html">
<link title="Main" rel="Chapter" href="Main.html">
<link title="Module_dependencies" rel="Chapter" href="Module_dependencies.html">
<link title="Name" rel="Chapter" href="Name.html">
<link title="Nvar" rel="Chapter" href="Nvar.html">
<link title="Output" rel="Chapter" href="Output.html">
<link title="Path" rel="Chapter" href="Path.html">
<link title="Pattern_syntax" rel="Chapter" href="Pattern_syntax.html">
<link title="Patterns" rel="Chapter" href="Patterns.html">
<link title="Pcombinators" rel="Chapter" href="Pcombinators.html">
<link title="Pp" rel="Chapter" href="Pp.html">
<link title="Precedence" rel="Chapter" href="Precedence.html">
<link title="Process_file" rel="Chapter" href="Process_file.html">
<link title="Rename_top_level" rel="Chapter" href="Rename_top_level.html">
<link title="Reporting" rel="Chapter" href="Reporting.html">
<link title="Reporting_basic" rel="Chapter" href="Reporting_basic.html">
<link title="Seplist" rel="Chapter" href="Seplist.html">
<link title="Syntactic_tests" rel="Chapter" href="Syntactic_tests.html">
<link title="Target" rel="Chapter" href="Target.html">
<link title="Target_binding" rel="Chapter" href="Target_binding.html">
<link title="Target_syntax" rel="Chapter" href="Target_syntax.html">
<link title="Target_trans" rel="Chapter" href="Target_trans.html">
<link title="Trans" rel="Chapter" href="Trans.html">
<link title="Typecheck" rel="Chapter" href="Typecheck.html">
<link title="Typecheck_ctxt" rel="Chapter" href="Typecheck_ctxt.html">
<link title="Typed_ast" rel="Chapter" href="Typed_ast.html">
<link title="Typed_ast_syntax" rel="Chapter" href="Typed_ast_syntax.html">
<link title="Types" rel="Chapter" href="Types.html">
<link title="Tyvar" rel="Chapter" href="Tyvar.html">
<link title="Util" rel="Chapter" href="Util.html"><title>Backend_common.Make</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Backend_common.html">Up</a>
&nbsp;</div>
<center><h1>Functor <a href="type_Backend_common.Make.html">Backend_common.Make</a></h1></center>
<br>
<pre><span class="keyword">module</span> Make: <div class="sig_block"><code class="code">functor (</code><code class="code">A</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="VALenv"><span class="keyword">val</span> env</span> : <code class="type"><a href="Typed_ast.html#TYPEenv">Typed_ast.env</a></code></pre><pre><span id="VALtarget"><span class="keyword">val</span> target</span> : <code class="type"><a href="Target.html#TYPEtarget">Target.target</a></code></pre><pre><span id="VALdir"><span class="keyword">val</span> dir</span> : <code class="type">string</code></pre><pre><span id="VALid_format_args"><span class="keyword">val</span> id_format_args</span> : <code class="type">(bool -> <a href="Output.html#TYPEid_annot">Output.id_annot</a> -> Ulib.Text.t -> <a href="Output.html#TYPEt">Output.t</a>) * Ulib.Text.t</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Backend_common.Make.html">..</a> <code class="code">end</code></div></pre><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>A</code></td>
<td align="center" valign="top">:</td>
<td><code class="type">sig
  val env : env;; 
  val target : Target.target;;
  val dir : string;;
  val id_format_args : (bool -> Output.id_annot -> Ulib.Text.t -> Output.t) * Ulib.Text.t
 end</code>
</table>
</td>
</tr>
</table>
<hr width="100%">
<pre><span id="VALopen_to_open_target"><span class="keyword">val</span> open_to_open_target</span> : <code class="type"><a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> list -> (<a href="Typed_ast.html#TYPElskips">Typed_ast.lskips</a> * string) list * <a href="Typed_ast.html#TYPElskips">Typed_ast.lskips</a></code></pre><pre><span id="VALfunction_application_to_output"><span class="keyword">val</span> function_application_to_output</span> : <code class="type">Ast.l -><br>       (<a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> -> <a href="Output.html#TYPEt">Output.t</a>) -><br>       bool -><br>       <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> -><br>       <a href="Types.html#TYPEconst_descr_ref">Types.const_descr_ref</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Typed_ast.html#TYPEexp">Typed_ast.exp</a> list -> bool -> <a href="Output.html#TYPEt">Output.t</a> list</code></pre><div class="info">
<code class="code">function_application_to_output l exp inf full_exp c_id args</code> tries to format
    a function application as output. It gets an expression <code class="code">full_ex</code> of the from
    <code class="code">c arg1 ... argn</code>. The id <code class="code">c_id</code> corresponds to constant <code class="code">c</code>. The arguments <code class="code">arg1, ... argn</code> are 
    handed over as <code class="code">args</code>. The description corresponding to <code class="code">c</code> is looked up in <code class="code">A.env</code>. Depending on
    this description and the backend-specific formats therein, the
    function and its arguments are formated as output.  In the
    simplest case the representation is an identifier (<code class="code">Ident.t</code>),
    which is formated using <code class="code">A.id_format_args</code> and the information, 
    whether it the whole expression is an infix one <code class="code">inf</code>. In more complicated
    cases, formating of expressions is needed, which is done via the
    callback <code class="code">exp</code>. In particular if some arguments are not needed by
    the formating of the function application, the function <code class="code">exp</code> is
    called on these remaining arguments. The original expression <code class="code">full_exp</code> is
    needed, if not enough parameters are present to format the definition correctly. 
    In this case, eta-expansion is applied and the resulting expression formatting via <code class="code">exp</code>.
    <code class="code">ascii_alternative</code> denotes whether an ascii alternative representation for this
    function name is required.<br>
</div>
<pre><span id="VALpattern_application_to_output"><span class="keyword">val</span> pattern_application_to_output</span> : <code class="type">Ast.l -><br>       (<a href="Typed_ast.html#TYPEpat">Typed_ast.pat</a> -> <a href="Output.html#TYPEt">Output.t</a>) -><br>       <a href="Types.html#TYPEconst_descr_ref">Types.const_descr_ref</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Typed_ast.html#TYPEpat">Typed_ast.pat</a> list -> bool -> <a href="Output.html#TYPEt">Output.t</a> list</code></pre><div class="info">
<code class="code">pattern_application_to_output l pat c_id args</code> tries to
    format a function application in a pattern as output. It does otherwise the same as
    function_application_to_output. However, since there are no infix patterns, the
    parameter <code class="code">inf</code> is always set to <code class="code">false</code>.<br>
</div>
<pre><span id="VALconst_id_to_ident"><span class="keyword">val</span> const_id_to_ident</span> : <code class="type"><a href="Types.html#TYPEconst_descr_ref">Types.const_descr_ref</a> <a href="Types.html#TYPEid">Types.id</a> -> bool -> <a href="Ident.html#TYPEt">Ident.t</a></code></pre><div class="info">
<code class="code">const_id_to_ident c_id use_ascii</code> tries to format a constant, constructor or field
    <code class="code">c_id</code> as an identifier for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>. If the flag <code class="code">use_ascii</code> is set, the ascii representation of the
    constant should be used, if there is one. Depending on the formating rules for the
    constant, <code class="code">const_id_to_ident</code> might raise an exception.<br>
</div>
<pre><span id="VALconst_ref_to_name"><span class="keyword">val</span> const_ref_to_name</span> : <code class="type"><a href="Name.html#TYPElskips_t">Name.lskips_t</a> -> bool -> <a href="Types.html#TYPEconst_descr_ref">Types.const_descr_ref</a> -> <a href="Name.html#TYPElskips_t">Name.lskips_t</a></code></pre><div class="info">
<code class="code">const_ref_to_name n use_ascii c</code> tries to format a constant
    <code class="code">c</code> for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>. If <code class="code">use_ascii</code> is set, the ascii-representation is
    returned. <code class="code">const_ref_to_name</code> always returns a name <code class="code">n'</code>. If special formatting
    rules are installed, this name might not be the one used by <code class="code">function_application_to_output</code>, though.
    The argument <code class="code">n</code> is the name used in the original input. It's whitespace is used to
    format <code class="code">n'</code>.<br>
</div>
<pre><span id="VALtype_path_to_name"><span class="keyword">val</span> type_path_to_name</span> : <code class="type"><a href="Name.html#TYPElskips_t">Name.lskips_t</a> -> <a href="Path.html#TYPEt">Path.t</a> -> <a href="Name.html#TYPElskips_t">Name.lskips_t</a></code></pre><div class="info">
<code class="code">type_path_to_name n p</code> tries to format a type-path
    <code class="code">p</code> for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>. It always returns a name <code class="code">n'</code>. If special formatting
    rules are installed, this name might not be the one used by <code class="code">function_application_to_output</code>, though.
    The argument <code class="code">n</code> is the name used in the original input. It's whitespace is used to
    format <code class="code">n'</code>.<br>
</div>
<pre><span id="VALtype_id_to_ident"><span class="keyword">val</span> type_id_to_ident</span> : <code class="type"><a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Ident.html#TYPEt">Ident.t</a></code></pre><div class="info">
<code class="code">type_id_to_ident ty_id</code> tries to format a type
    <code class="code">ty_id</code> as an identifier for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>.<br>
</div>
<pre><span id="VALtype_id_to_output"><span class="keyword">val</span> type_id_to_output</span> : <code class="type"><a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Output.html#TYPEt">Output.t</a></code></pre><div class="info">
<code class="code">type_id_to_output ty_id</code> tries to format a type
    <code class="code">ty_id</code> as an identifier for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>.<br>
</div>
<pre><span id="VALtype_id_to_ident_no_modify"><span class="keyword">val</span> type_id_to_ident_no_modify</span> : <code class="type"><a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Ident.html#TYPEt">Ident.t</a></code></pre><div class="info">
<code class="code">type_id_to_ident_no_modify ty_id</code> formats <code class="code">ty_id</code> as an identifier.
    In contrast to <code class="code">type_id_to_ident</code> neither the target <code class="code">A.target</code> nor the rules stored
    in environment <code class="code">A.env</code> are used. Instead the type is translated without any
    modifications. This method is intended to be used for backend types, which
    are already formatted.<br>
</div>
<pre><span id="VALtype_app_to_output"><span class="keyword">val</span> type_app_to_output</span> : <code class="type">(<a href="Types.html#TYPEsrc_t">Types.src_t</a> -> <a href="Output.html#TYPEt">Output.t</a>) -><br>       <a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Types.html#TYPEsrc_t">Types.src_t</a> list -> <a href="Types.html#TYPEsrc_t">Types.src_t</a> list * <a href="Output.html#TYPEt">Output.t</a></code></pre><pre><span id="VALmodule_id_to_ident"><span class="keyword">val</span> module_id_to_ident</span> : <code class="type"><a href="Path.html#TYPEt">Path.t</a> <a href="Types.html#TYPEid">Types.id</a> -> <a href="Ident.html#TYPEt">Ident.t</a></code></pre><div class="info">
<code class="code">module_id_to_ident m_id</code> tries to format a module
    <code class="code">m_id</code> as an identifier for target <code class="code">A.target</code> using the rules stored
    in environment <code class="code">A.env</code>.<br>
</div>
</body></html>