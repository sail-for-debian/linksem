chapter {* Generated by Lem from abstract_linker_script.lem. *}

theory "Abstract_linker_script" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_list" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 

begin 

(*open import Basic_classes*)
(*open import List*)
(*open import Num*)

datatype binary_relation
  = Eq0
  | Lt0

datatype binary_connective
  = And0 (** Conjunction *)
  | Or0  (** Disjunction *)

(** The type [expression] denotes addresses, whether known or to be ascertained.
  *)
datatype expression
  = Var0   " string "   (** Ranges over memory addresses *)
  | Const " nat "  (** Fixed memory address *)

(* These are *one-place* predicates on unsigned integer solutions (usually representing 
 * addresses). Implicitly, every binary relation is being applied to the solution. HMM: is 
 * this sane? Taking my lead from KLEE / SMT solver formulae. What we're describing is a
 * big SMT instance; it's sane if we can always factor the instances we want into this 
 * form, i.e. into a big conjunction of per-variable formulae where each two-place relation
 * has the variable in one of its places. 
 * 
 * Could try to claim it follows from taking CNF and assigning
 * each conjunct to one of the variables it contains. But what if that conjunct is a big 
 * disjunction including some other binary operators applied to two other variables?
 * Might need to factor those out into a global extra conjunct. YES. *)
datatype value_formula
  = VFTrue
  | VFFalse
  | VFBinaryRelation " (binary_relation * expression)"
  | VFBinaryConnective " (binary_connective * value_formula * value_formula)"
  | VFNot " value_formula "

datatype memory_image_formula
  = MIFTrue
  | MIFFalse
  | MIFExists " (string * memory_image_formula)"
  | MIFBinaryRelation " (binary_relation * expression * expression)"
  | MIFBinaryConnective " (binary_connective * memory_image_formula * memory_image_formula)"
  | MIFAssertValueFormula " (expression * value_formula)"
  | MIFNot " memory_image_formula "

datatype memory_image0
  = MemoryImage " memory_image_formula "

(*val mk_range : natural -> natural -> value_formula*)
fun  mk_range  :: " nat \<Rightarrow> nat \<Rightarrow> value_formula "  where 
     " mk_range left right = (
  if left = right then
    VFTrue
  else if right < left then
    VFFalse
  else
    (let l = (Const left) in
    (let r = (Const right) in
    VFBinaryConnective(And0, VFBinaryRelation(Lt0, r), VFNot(VFBinaryRelation(Lt0, l))))))" 
declare mk_range.simps [simp del]

end
