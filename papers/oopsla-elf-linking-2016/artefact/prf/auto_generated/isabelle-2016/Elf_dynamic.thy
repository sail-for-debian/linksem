chapter {* Generated by Lem from elf_dynamic.lem. *}

theory "Elf_dynamic" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_list" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 
	 "../../lem-libs/isabelle-lib/Lem_bool" 
	 "../../lem-libs/isabelle-lib/Lem_string" 
	 "Show" 
	 "Error" 
	 "Byte_sequence" 
	 "Endianness" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "String_table" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_file" 
	 "Elf_relocation" 

begin 

(** [elf_dynamic] module exports types and definitions relating to the dynamic
  * section and dynamic linking functionality of an ELF file.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import String*)

(*open import Byte_sequence*)
(*open import Endianness*)
(*open import Error*)
(*open import Show*)
(*open import String_table*)

(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_relocation*)
(*open import Elf_section_header_table*)
(*open import Elf_program_header_table*)
(*open import Elf_types_native_uint*)

(** Validity checks *)

(** [is_elf32_valid_program_header_table_for_dynamic_linking pht] checks whether
  * a program header table [pht] is a valid program header table for an ELF file
  * that will be potentially dynamically linked.  Returns true if there is exactly
  * one segment header of type [elf_pt_interp], i.e. contains a string pointing
  * to the requested dynamic interpreter.
  *)
(*val is_elf32_valid_program_header_table_for_dynamic_linking : elf32_program_header_table ->
  bool*)
definition is_elf32_valid_program_header_table_for_dynamic_linking  :: "(elf32_program_header_table_entry)list \<Rightarrow> bool "  where 
     " is_elf32_valid_program_header_table_for_dynamic_linking pht = (
  List.length (List.filter (\<lambda> x .  unat(elf32_p_type   x) = elf_pt_interp) pht) =( 1 :: nat))"

  
(** [is_elf64_valid_program_header_table_for_dynamic_linking pht] checks whether
  * a program header table [pht] is a valid program header table for an ELF file
  * that will be potentially dynamically linked.  Returns true if there is exactly
  * one segment header of type [elf_pt_interp], i.e. contains a string pointing
  * to the requested dynamic interpreter.
  *)
(*val is_elf64_valid_program_header_table_for_dynamic_linking : elf64_program_header_table ->
  bool*)
definition is_elf64_valid_program_header_table_for_dynamic_linking  :: "(elf64_program_header_table_entry)list \<Rightarrow> bool "  where 
     " is_elf64_valid_program_header_table_for_dynamic_linking pht = (
  List.length (List.filter (\<lambda> x .  unat(elf64_p_type   x) = elf_pt_interp) pht) =( 1 :: nat))"


(** Dynamic section entry *)

(** [dyn_union] represents the C-union type used in the definition of [elf32_dyn]
  * and [elf64_dyn] types below.  Some section tags correspond to entries where
  * the fields are either unspecified or ignored, hence the presence of the
  * [D_Ignored] constructor.
  *)
datatype( 'a, 'b) dyn_union
  = D_Val " 'a "
  | D_Ptr " 'b "
  | D_Ignored " byte_sequence "
  
(** [elf32_dyn] captures the notion of an ELF32 dynamic section entry.
  * Specialises the [dyn_union] type above to using [elf32_word] values and
  * [elf32_addr] pointers.
  *)
record elf32_dyn =
  
 elf32_dyn_tag  ::" sint32 "                     (** The type of the entry. *)
   
 elf32_dyn_d_un ::" (uint32, uint32) dyn_union " (** The value of the entry, stored as a union. *)
   

   
(** [elf64_dyn] captures the notion of an ELF32 dynamic section entry.
  * Specialises the [dyn_union] type above to using [elf64_xword] values and
  * [elf64_addr] pointers.
  *)
record elf64_dyn =
  
 elf64_dyn_tag  ::" sint64 "                     (** The type of the entry. *)
   
 elf64_dyn_d_un ::" (uint64, Elf_Types_Local.uint64) dyn_union " (** The value of the entry, stored as a union. *)
   


(** Dynamic section tags *)

(** [dt_null] marks the end of the dynamic array *)
definition dt_null  :: " nat "  where 
     " dt_null = (( 0 :: nat))"

(** [dt_needed] holds the string table offset of a string containing the name of
  * a needed library.
  *)
definition dt_needed  :: " nat "  where 
     " dt_needed = (( 1 :: nat))"

(** [dt_pltrelsz] holds the size in bytes of relocation entries associated with
  * the PLT.
  *)
definition dt_pltrelsz  :: " nat "  where 
     " dt_pltrelsz = (( 2 :: nat))"

(** [dt_pltgot] holds an address associated with the PLT or GOT. *)
definition dt_pltgot  :: " nat "  where 
     " dt_pltgot = (( 3 :: nat))"

(** [dt_hash] holds the address of a symbol-table hash. *)
definition dt_hash  :: " nat "  where 
     " dt_hash = (( 4 :: nat))"

(** [dt_strtab] holds the address of the string table. *)
definition dt_strtab  :: " nat "  where 
     " dt_strtab = (( 5 :: nat))"

(** [dt_symtab] holds the address of a symbol table. *)
definition dt_symtab  :: " nat "  where 
     " dt_symtab = (( 6 :: nat))"

(** [dt_rela] holds the address of a relocation table. *)
definition dt_rela  :: " nat "  where 
     " dt_rela = (( 7 :: nat))"

(** [dt_relasz] holds the size in bytes of the relocation table. *)
definition dt_relasz  :: " nat "  where 
     " dt_relasz = (( 8 :: nat))"

(** [dt_relaent] holds the size in bytes of a relocation table entry. *)
definition dt_relaent  :: " nat "  where 
     " dt_relaent = (( 9 :: nat))"

(** [dt_strsz] holds the size in bytes of the string table. *)
definition dt_strsz  :: " nat "  where 
     " dt_strsz = (( 10 :: nat))"

(** [dt_syment] holds the size in bytes of a symbol table entry. *)
definition dt_syment  :: " nat "  where 
     " dt_syment = (( 11 :: nat))"

(** [dt_init] holds the address of the initialisation function. *)
definition dt_init  :: " nat "  where 
     " dt_init = (( 12 :: nat))"

(** [dt_fini] holds the address of the finalisation function. *)
definition dt_fini  :: " nat "  where 
     " dt_fini = (( 13 :: nat))"

(** [dt_soname] holds the string table offset of a string containing the shared-
  * object name.
  *)
definition dt_soname  :: " nat "  where 
     " dt_soname = (( 14 :: nat))"

(** [dt_rpath] holds the string table offset of a string containing the library
  * search path.
  *)
definition dt_rpath  :: " nat "  where 
     " dt_rpath = (( 15 :: nat))"

(** [dt_symbolic] alters the linker's symbol resolution algorithm so that names
  * are resolved first from the shared object file itself, rather than the
  * executable file.
  *)
definition dt_symbolic  :: " nat "  where 
     " dt_symbolic = (( 16 :: nat))"

(** [dt_rel] is similar to [dt_rela] except its table has implicit addends. *)
definition dt_rel  :: " nat "  where 
     " dt_rel = (( 17 :: nat))"

(** [dt_relsz] holds the size in bytes of the [dt_rel] relocation table. *)
definition dt_relsz  :: " nat "  where 
     " dt_relsz = (( 18 :: nat))"

(** [dt_relent] holds the size in bytes of a [dt_rel] relocation entry. *)
definition dt_relent  :: " nat "  where 
     " dt_relent = (( 19 :: nat))"

(** [dt_pltrel] specifies the type of relocation entry to which the PLT refers. *)
definition dt_pltrel  :: " nat "  where 
     " dt_pltrel = (( 20 :: nat))"

(** [dt_debug] is used for debugging and its purpose is not specified in the ABI.
  * Programs using this entry are not ABI-conformant.
  *)
definition dt_debug  :: " nat "  where 
     " dt_debug = (( 21 :: nat))"

(** [dt_textrel] absence of this entry indicates that no relocation entry should
  * cause a modification to a non-writable segment.  Otherwise, if present, one
  * or more relocation entries may request modifications to a non-writable
  * segment.
  *)
definition dt_textrel  :: " nat "  where 
     " dt_textrel = (( 22 :: nat))"

(** [dt_jmprel]'s member holds the address of relocation entries associated with
  * the PLT.
  *)
definition dt_jmprel  :: " nat "  where 
     " dt_jmprel = (( 23 :: nat))"

(** [dt_bindnow] instructs the linker to process all relocations for the object
  * containing the entry before transferring control to the program.
  *)
definition dt_bindnow  :: " nat "  where 
     " dt_bindnow = (( 24 :: nat))"

(** [dt_init_array] holds the address to the array of pointers to initialisation
  * functions.
  *)
definition dt_init_array  :: " nat "  where 
     " dt_init_array = (( 25 :: nat))"

(** [dt_fini_array] holds the address to the array of pointers to finalisation
  * functions.
  *)
definition dt_fini_array  :: " nat "  where 
     " dt_fini_array = (( 26 :: nat))"

(** [dt_init_arraysz] holds the size in bytes of the array of pointers to
  * initialisation functions.
  *)
definition dt_init_arraysz  :: " nat "  where 
     " dt_init_arraysz = (( 27 :: nat))"

(** [dt_fini_arraysz] holds the size in bytes of the array of pointers to
  * finalisation functions.
  *)
definition dt_fini_arraysz  :: " nat "  where 
     " dt_fini_arraysz = (( 28 :: nat))"

(** [dt_runpath] holds an offset into the string table holding a string containing
  * the library search path.
  *)
definition dt_runpath  :: " nat "  where 
     " dt_runpath = (( 29 :: nat))"

(** [dt_flags] holds flag values specific to the object being loaded. *)
definition dt_flags  :: " nat "  where 
     " dt_flags = (( 30 :: nat))"

definition dt_encoding  :: " nat "  where 
     " dt_encoding = (( 32 :: nat))"

(** [dt_preinit_array] holds the address to the array of pointers of pre-
  * initialisation functions.
  *)
definition dt_preinit_array  :: " nat "  where 
     " dt_preinit_array = (( 32 :: nat))"

(** [dt_preinit_arraysz] holds the size in bytes of the array of pointers of
  * pre-initialisation functions.
  *)
definition dt_preinit_arraysz  :: " nat "  where 
     " dt_preinit_arraysz = (( 33 :: nat))"

(** [dt_loos] and [dt_hios]: this inclusive range is reserved for OS-specific
  * semantics.
  *)
definition dt_loos  :: " nat "  where 
     " dt_loos = ( (( 2 :: nat) *( 805306374 :: nat)) +( 1 :: nat))"
 (* 0x6000000D *)
definition dt_hios  :: " nat "  where 
     " dt_hios = ( (( 2 :: nat) *( 939522048 :: nat)))"
 (* 0x6ffff000 *)
(** [dt_loproc] and [dt_hiproc]: this inclusive range is reserved for processor
  * specific semantics.
  *)
definition dt_loproc  :: " nat "  where 
     " dt_loproc = ( (( 2 :: nat) *( 939524096 :: nat)))"
 (* 0x70000000 *)
definition dt_hiproc  :: " nat "  where 
     " dt_hiproc = ( (( 2 :: nat) *( 1073741823 :: nat)) +( 1 :: nat))"
 (* 0x7fffffff *)

(** [string_of_dynamic_tag so t os proc] produces a string-based representation of
  * dynamic section tag [t].  For tag values between LO_OS and HI_OS [os] is
  * used to produce the resulting value.  For tag values between LO_PROC and
  * HI_PROC [proc] is used to produce the resulting value.  Boolean flag [so]
  * indicates whether the flag in question is derived from a shared object file,
  * which alters the printing of ENCODING and PRE_INITARRAY flags.
  *)
(*val string_of_dynamic_tag : bool -> natural -> (natural -> bool) -> (natural -> string) -> (natural -> string)
  -> string*)
definition string_of_dynamic_tag  :: " bool \<Rightarrow> nat \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow> string "  where 
     " string_of_dynamic_tag shared_object tag os_additional_ranges os proc = (
  if tag = dt_null then
    (''NULL'')
  else if tag = dt_needed then
    (''NEEDED'')
  else if tag = dt_pltrelsz then
    (''PLTRELSZ'')
  else if tag = dt_pltgot then
    (''PLTGOT'')
  else if tag = dt_hash then
    (''HASH'')
  else if tag = dt_strtab then
    (''STRTAB'')
  else if tag = dt_symtab then
    (''SYMTAB'')
  else if tag = dt_rela then
    (''RELA'')
  else if tag = dt_relasz then
    (''RELASZ'')
  else if tag = dt_relaent then
    (''RELAENT'')
  else if tag = dt_strsz then
    (''STRSZ'')
  else if tag = dt_syment then
    (''SYMENT'')
  else if tag = dt_init then
    (''INIT'')
  else if tag = dt_fini then
    (''FINI'')
  else if tag = dt_soname then
    (''SONAME'')
  else if tag = dt_rpath then
    (''RPATH'')
  else if tag = dt_symbolic then
    (''SYMBOLIC'')
  else if tag = dt_rel then
    (''REL'')
  else if tag = dt_relsz then
    (''RELSZ'')
  else if tag = dt_relent then
    (''RELENT'')
  else if tag = dt_pltrel then
    (''PLTREL'')
  else if tag = dt_debug then
    (''DEBUG'')
  else if tag = dt_textrel then
    (''TEXTREL'')
  else if tag = dt_jmprel then
    (''JMPREL'')
  else if tag = dt_bindnow then
    (''BIND_NOW'')
  else if tag = dt_init_array then
    (''INIT_ARRAY'')
  else if tag = dt_fini_array then
    (''FINI_ARRAY'')
  else if tag = dt_init_arraysz then
    (''INIT_ARRAYSZ'')
  else if tag = dt_fini_arraysz then
    (''FINI_ARRAYSZ'')
  else if tag = dt_runpath then
    (''RUNPATH'')
  else if tag = dt_flags then
    (''FLAGS'')
  else if tag = dt_encoding then
    if \<not> shared_object then
      (''ENCODING'')
    else
      (''PREINIT_ARRAY'')
  else if tag = dt_preinit_arraysz then
    (''PREINIT_ARRAYSZ'')
  else if (tag \<ge> dt_loproc) \<and> (tag \<le> dt_hiproc) then
    proc tag
  else if (tag \<ge> dt_loos) \<and> (tag \<le> dt_hios) then
    os tag
  else if os_additional_ranges tag then
    os tag
  else
    (''Invalid dynamic section tag''))"

    
(** [tag_correspondence] is a type used to emulate the functionality of a C-union
  * in Lem.  The type records whether the union should be interpreted as a value,
  * a pointer, or a do not care value.  An accompanying function will map a
  * dynamic section tag to a [tag_correspondence], so that transcription functions
  * know how to properly use the [dyn_union] value in a dynamic section entry.
  *)
datatype tag_correspondence
  = C_Val     (** [dyn_union] should be interpreted as a value. *)
  | C_Ptr     (** [dyn_union] should be interpreted as a pointer. *)
  | C_Ignored (** [dyn_union] is irrelevant, so we do not care. *)
  
(** [tag_correspondence_of_tag tag os_additional_ranges os proc] produces a
  * [tag_correspondence] value for a given dynamic tag, [tag].  Some tag values
  * are reserved for interpretation by the OS or processor supplement (i.e. the
  * ABI).  We therefore also take in a predicate, [os_additional_ranges], that
  * recognises when a tag is special for a given ABI, and a means of interpreting
  * that tag, using [os] and [proc] functions.
  *)
(*val tag_correspondence_of_tag : bool -> natural -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error tag_correspondence*)
definition tag_correspondence_of_tag  :: " bool \<Rightarrow> nat \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(tag_correspondence)error "  where 
     " tag_correspondence_of_tag shared_object tag os_additional_ranges os proc = (
  if tag = dt_null then
    error_return C_Ignored
  else if tag = dt_needed then
    error_return C_Val
  else if tag = dt_pltrelsz then
    error_return C_Val
  else if tag = dt_pltgot then
    error_return C_Ptr
  else if tag = dt_hash then
    error_return C_Ptr
  else if tag = dt_strtab then
    error_return C_Ptr
  else if tag = dt_symtab then
    error_return C_Ptr
  else if tag = dt_rela then
    error_return C_Ptr
  else if tag = dt_relasz then
    error_return C_Val
  else if tag = dt_relaent then
    error_return C_Val
  else if tag = dt_strsz then
    error_return C_Val
  else if tag = dt_syment then
    error_return C_Val
  else if tag = dt_init then
    error_return C_Ptr
  else if tag = dt_fini then
    error_return C_Ptr
  else if tag = dt_soname then
    error_return C_Val
  else if tag = dt_rpath then
    error_return C_Val
  else if tag = dt_symbolic then
    error_return C_Ignored
  else if tag = dt_rel then
    error_return C_Ptr
  else if tag = dt_relsz then
    error_return C_Val
  else if tag = dt_relent then
    error_return C_Val
  else if tag = dt_pltrel then
    error_return C_Val
  else if tag = dt_debug then
    error_return C_Ptr
  else if tag = dt_textrel then
    error_return C_Ignored
  else if tag = dt_jmprel then
    error_return C_Ptr
  else if tag = dt_bindnow then
    error_return C_Ignored
  else if tag = dt_init_array then
    error_return C_Ptr
  else if tag = dt_fini_array then
    error_return C_Ptr
  else if tag = dt_init_arraysz then
    error_return C_Val
  else if tag = dt_fini_arraysz then
    error_return C_Val
  else if tag = dt_runpath then
    error_return C_Val
  else if tag = dt_flags then
    error_return C_Val
  else if tag = dt_encoding then
    if \<not> shared_object then
      error_return C_Ignored
    else
      error_return C_Ptr
  else if tag = dt_preinit_arraysz then
    error_return C_Val
  else if (tag \<ge> dt_loproc) \<and> (tag \<le> dt_hiproc) then
    proc tag
  else if (tag \<ge> dt_loos) \<and> (tag \<le> dt_hios) then
    os tag
  else if os_additional_ranges tag then
    os tag
  else
    error_fail ((''tag_correspondence_of_tag: invalid dynamic section tag'')))"

    
(** [read_elf32_dyn endian bs0 so os_additional_ranges os proc] reads an [elf32_dyn]
  * record from byte sequence [bs0], assuming endianness [endian].  As mentioned
  * above some ABIs reserve additional tag values for their own purposes.  These
  * are recognised by the predicate [os_additional_ranges] and interpreted by
  * the functions [os] and [proc].  Fails if the transcription of the record from
  * [bs0] fails, or if [os] or [proc] fail.
  *)
(*val read_elf32_dyn : endianness -> byte_sequence -> bool -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (elf32_dyn * byte_sequence)*)
definition read_elf32_dyn  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow> bool \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(elf32_dyn*byte_sequence)error "  where 
     " read_elf32_dyn endian bs0 shared_object os_additional_ranges os proc = (
  read_elf32_sword endian bs0 >>= (\<lambda> (tag0, bs1) . 
  (let tag = (nat (abs (sint tag0))) in
  tag_correspondence_of_tag shared_object tag os_additional_ranges os proc >>= (\<lambda> corr . 
    (case  corr of
        C_Ptr =>
        read_elf32_addr endian bs1 >>= (\<lambda> (ptr, bs2) . 
        error_return ((| elf32_dyn_tag = tag0 , elf32_dyn_d_un = (D_Ptr ptr) |), bs2))
      | C_Val =>
        read_elf32_word endian bs1 >>= (\<lambda> (vl, bs2) . 
        error_return ((| elf32_dyn_tag = tag0 , elf32_dyn_d_un = (D_Val vl) |), bs2))
      | C_Ignored =>
        (case  endian of
            Big    =>
            read_4_bytes_be bs1 >>= (\<lambda> ((b1, b2, b3, b4), bs2) . 
            (let cut1 = (Byte_sequence.from_byte_lists [[b1, b2, b3, b4]]) in
            error_return ((| elf32_dyn_tag = tag0 , elf32_dyn_d_un = (D_Ignored cut1) |), bs2)))
          | Little =>
            read_4_bytes_le bs1 >>= (\<lambda> ((b1, b2, b3, b4), bs2) . 
            (let cut1 = (Byte_sequence.from_byte_lists [[b1, b2, b3, b4]]) in
            error_return ((| elf32_dyn_tag = tag0 , elf32_dyn_d_un = (D_Ignored cut1) |), bs2)))
        )
    )))))"

    
(** [read_elf64_dyn endian bs0 os_additional_ranges os proc] reads an [elf64_dyn]
  * record from byte sequence [bs0], assuming endianness [endian].  As mentioned
  * above some ABIs reserve additional tag values for their own purposes.  These
  * are recognised by the predicate [os_additional_ranges] and interpreted by
  * the functions [os] and [proc].  Fails if the transcription of the record from
  * [bs0] fails, or if [os] or [proc] fail.
  *)
(*val read_elf64_dyn : endianness -> byte_sequence -> bool -> (natural -> bool) ->
  (natural -> error tag_correspondence) -> (natural -> error tag_correspondence) ->
    error (elf64_dyn * byte_sequence)*)
definition read_elf64_dyn  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow> bool \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(elf64_dyn*byte_sequence)error "  where 
     " read_elf64_dyn endian bs0 shared_object os_additional_ranges os proc = (
  read_elf64_sxword endian bs0 >>= (\<lambda> (tag0, bs1) . 
  (let tag = (nat (abs (sint tag0))) in
  tag_correspondence_of_tag shared_object tag os_additional_ranges os proc >>= (\<lambda> corr . 
    (case  corr of
        C_Ptr =>
        read_elf64_addr endian bs1 >>= (\<lambda> (ptr, bs2) . 
        error_return ((| elf64_dyn_tag = tag0 , elf64_dyn_d_un = (D_Ptr ptr) |), bs2))
      | C_Val =>
        read_elf64_xword endian bs1 >>= (\<lambda> (vl, bs2) . 
        error_return ((| elf64_dyn_tag = tag0 , elf64_dyn_d_un = (D_Val vl) |), bs2))
      | C_Ignored =>
        (case  endian of
            Big    =>
            read_8_bytes_be bs1 >>= (\<lambda> ((b1, b2, b3, b4, b5, b6, b7, b8), bs2) . 
            (let cut1 = (Byte_sequence.from_byte_lists [[b1, b2, b3, b4, b5, b6, b7, b8]]) in
            error_return ((| elf64_dyn_tag = tag0 , elf64_dyn_d_un = (D_Ignored cut1) |), bs2)))
          | Little =>
            read_8_bytes_le bs1 >>= (\<lambda> ((b1, b2, b3, b4, b5, b6, b7, b8), bs2) . 
            (let cut1 = (Byte_sequence.from_byte_lists [[b1, b2, b3, b4, b5, b6, b7, b8]]) in
            error_return ((| elf64_dyn_tag = tag0 , elf64_dyn_d_un = (D_Ignored cut1) |), bs2)))
        )
    )))))"

    
(** [obtain_elf32_dynamic_section_contents' endian bs0 os_additional_ranges os
  * proc] exhaustively reads in [elf32_dyn] values from byte sequence [bs0],
  * interpreting ABI-specific dynamic tags with [os_additional_ranges], [os], and
  * [proc] as mentioned above.  Fails if [bs0]'s length modulo the size of an
  * [elf32_dyn] entry is not 0.
  *)
(*val obtain_elf32_dynamic_section_contents' : endianness -> byte_sequence ->
  bool -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (list elf32_dyn)*)
function (sequential,domintros)  obtain_elf32_dynamic_section_contents'  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow> bool \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>((elf32_dyn)list)error "  where 
     " obtain_elf32_dynamic_section_contents' endian bs0 shared_object os_additional_ranges os proc = (
  if Byte_sequence.length0 bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf32_dyn endian bs0 shared_object os_additional_ranges os proc >>= (\<lambda> (head, bs0) . 
    if sint(elf32_dyn_tag   head) = int dt_null then (* DT_NULL marks end of array *)
      error_return [head]
    else
    obtain_elf32_dynamic_section_contents' endian bs0 shared_object os_additional_ranges os proc >>= (\<lambda> tail . 
    error_return (head # tail))))" 
by pat_completeness auto

    
(** [obtain_elf64_dynamic_section_contents' endian bs0 os_additional_ranges os
  * proc] exhaustively reads in [elf64_dyn] values from byte sequence [bs0],
  * interpreting ABI-specific dynamic tags with [os_additional_ranges], [os], and
  * [proc] as mentioned above.  Fails if [bs0]'s length modulo the size of an
  * [elf64_dyn] entry is not 0.
  *)
(*val obtain_elf64_dynamic_section_contents' : endianness -> byte_sequence ->
  bool -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (list elf64_dyn)*)
function (sequential,domintros)  obtain_elf64_dynamic_section_contents'  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow> bool \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>((elf64_dyn)list)error "  where 
     " obtain_elf64_dynamic_section_contents' endian bs0 shared_object os_additional_ranges os proc = (
  if Byte_sequence.length0 bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf64_dyn endian bs0 shared_object os_additional_ranges os proc >>= (\<lambda> (head, bs0) . 
    if sint(elf64_dyn_tag   head) = int dt_null then (* DT_NULL marks end of array *)
      error_return [head]
    else
      obtain_elf64_dynamic_section_contents' endian bs0 shared_object os_additional_ranges os proc >>= (\<lambda> tail . 
      error_return (head # tail))))" 
by pat_completeness auto


(** [obtain_elf32_dynamic_section_contents' f1 os_additional_ranges os
  * proc bs0] exhaustively reads in [elf32_dyn] values from byte sequence [bs0],
  * obtaining endianness and the section header table from [elf32_file] f1,
  * interpreting ABI-specific dynamic tags with [os_additional_ranges], [os], and
  * [proc] as mentioned above.  Fails if [bs0]'s length modulo the size of an
  * [elf32_dyn] entry is not 0.
  *)
(*val obtain_elf32_dynamic_section_contents : elf32_file ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> byte_sequence -> error (list elf32_dyn)*)
definition obtain_elf32_dynamic_section_contents  :: " elf32_file \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow> byte_sequence \<Rightarrow>((elf32_dyn)list)error "  where 
     " obtain_elf32_dynamic_section_contents f1 os_additional_ranges os proc bs0 = (
  (let endian = (get_elf32_header_endianness(elf32_file_header   f1)) in
  (let sht = ((elf32_file_section_header_table   f1)) in
  (let shared_object = (is_elf32_shared_object_file(elf32_file_header   f1)) in
    (case  List.filter (\<lambda> ent .  unat(elf32_sh_type   ent) = sht_dynamic) sht of
        [] => error_fail (''obtain_elf32_dynamic_section_contents: no SHT_DYNAMIC section header entries'')
      | [dyn] =>
        (let off = (unat(elf32_sh_offset   dyn)) in
        (let siz = (unat(elf32_sh_size   dyn)) in
        Byte_sequence.offset_and_cut off siz bs0 >>= (\<lambda> rel . 
        obtain_elf32_dynamic_section_contents' endian rel shared_object os_additional_ranges os proc)))
      | _ => error_fail (''obtain_elf32_dynamic_section_contents: multiple SHT_DYNAMIC section header entries'')
    )))))"


(** [obtain_elf64_dynamic_section_contents' f1 os_additional_ranges os
  * proc bs0] exhaustively reads in [elf64_dyn] values from byte sequence [bs0],
  * obtaining endianness and the section header table from [elf64_file] f1,
  * interpreting ABI-specific dynamic tags with [os_additional_ranges], [os], and
  * [proc] as mentioned above.  Fails if [bs0]'s length modulo the size of an
  * [elf64_dyn] entry is not 0.
  *)
(*val obtain_elf64_dynamic_section_contents : elf64_file ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> byte_sequence -> error (list elf64_dyn)*)
definition obtain_elf64_dynamic_section_contents  :: " elf64_file \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow>(nat \<Rightarrow>(tag_correspondence)error)\<Rightarrow> byte_sequence \<Rightarrow>((elf64_dyn)list)error "  where 
     " obtain_elf64_dynamic_section_contents f1 os_additional_ranges os proc bs0 = (
  (let endian = (get_elf64_header_endianness(elf64_file_header   f1)) in
  (let sht = ((elf64_file_section_header_table   f1)) in
  (let shared_object = (is_elf64_shared_object_file(elf64_file_header   f1)) in
    (case  List.filter (\<lambda> ent .  unat(elf64_sh_type   ent) = sht_dynamic) sht of
        [] => error_fail (''obtain_elf64_dynamic_section_contents: no SHT_DYNAMIC section header entries'')
      | [dyn] =>
        (let off = (unat(elf64_sh_offset   dyn)) in
        (let siz = (unat(elf64_sh_size   dyn)) in
        Byte_sequence.offset_and_cut off siz bs0 >>= (\<lambda> rel . 
        obtain_elf64_dynamic_section_contents' endian rel shared_object os_additional_ranges os proc)))
      | _ => error_fail (''obtain_elf64_dynamic_section_contents: multiple SHT_DYNAMIC section header entries'')
    )))))"


(** DT Flags values *)

(** [df_origin] specific that the object being loaded may make reference to the
  * $(ORIGIN) substitution string.
  *)
definition df_origin  :: " nat "  where 
     " df_origin = (( 1 :: nat))"
 (* 0x1 *)
(** [df_symbolic] changes the linker's symbol resolution algorithm, resolving
  * symbols first from the shared object file rather than the executable file.
  *)
definition df_symbolic  :: " nat "  where 
     " df_symbolic = (( 2 :: nat))"
 (* 0x2 *)
(** [df_textrel] if this flag is not set then no relocation entry should cause
  * modification to a non-writable segment.
  *)
definition df_textrel  :: " nat "  where 
     " df_textrel = (( 4 :: nat))"
 (* 0x4 *)
(** [df_bindnow] if set this instructs the linker to process all relocation entries
  * of the containing object before transferring control to the program.
  *)
definition df_bindnow  :: " nat "  where 
     " df_bindnow = (( 8 :: nat))"
 (* 0x8 *)
(** [df_static_tls] if set instructs the linker to reject all attempts to load
  * the containing file dynamically.
  *)
definition df_static_tls  :: " nat "  where 
     " df_static_tls = (( 16 :: nat))"
 (* 0x10 *)

(** [check_flag] is a utility function for testing whether a flag is set.
  * TODO: so simple it is probably unneccessary now.
  *)
(*val check_flag : natural -> natural -> bool*)
definition check_flag  :: " nat \<Rightarrow> nat \<Rightarrow> bool "  where 
     " check_flag m pos = ( (m = pos))"


(** [string_of_dt_flag f] produces a string-based representation of dynamic
  * section flag [f].
  *)
(*val string_of_dt_flag : natural -> string*)
definition string_of_dt_flag  :: " nat \<Rightarrow> string "  where 
     " string_of_dt_flag flag = (
  if check_flag flag(( 0 :: nat)) then
    (''None'')
  else if check_flag flag df_origin then
    (''ORIGIN'')
  else if check_flag flag df_bindnow then
    (''BIND_NOW'')
  else if check_flag flag df_symbolic then
    (''SYMBOLIC'')
  else if check_flag flag df_textrel then
    (''TEXTREL'')
  else if check_flag flag df_static_tls then
    (''STATIC_TLS'')
  else if check_flag flag (df_bindnow + df_static_tls) then
    (''BIND_NOW STATIC_TLS'')
  else if check_flag flag (df_static_tls + df_symbolic) then
    (''SYMBOLIC STATIC_TLS'')
  else (* XXX: add more as needed *)
    (''Invalid dynamic section flag''))"

    
(** [rel_type] represents the two types of relocation records potentially present
  * in an ELF file: relocation, and relocation with addends.
  *)
datatype rel_type
  = Rel  (** Plain relocation type. *)
  | RelA (** Relocation with addends type. *)
  
(** [string_of_rel_type r] produces a string-based representation of [rel_type],
  * [r].
  *)
(*val string_of_rel_type : rel_type -> string*)
fun string_of_rel_type  :: " rel_type \<Rightarrow> string "  where 
     " string_of_rel_type Rel = ( (''REL''))"
|" string_of_rel_type RelA = ( (''RELA''))" 
declare string_of_rel_type.simps [simp del]

    
(** Type [dyn_value] represents the value of an ELF dynamic section entry.  Values
  * can represent various different types of objects (e.g. paths to libraries, or
  * flags, or sizes of other entries in a file), and this type collates them all.
  * Parameterised over two type variables so the type can be shared between ELF32
  * and ELF64.
  *)
datatype( 'addr, 'size) dyn_value
  = Address   " 'addr "    (** An address. *)
  | Size      " 'size "    (** A size (in bytes). *)
  | FName     " string "   (** A filename. *)
  | SOName    " string "   (** A shared object name. *)
  | Path      " string "   (** A path to some directory. *)
  | RPath     " string "   (** A run path. *)
  | RunPath   " string "   (** A run path. *)
  | Library   " string "   (** A library path. *)
  | Flags1    " nat "  (** Flags. *)
  | Flags     " nat "  (** Flags. *)
  | Numeric   " nat "  (** An uninterpreted numeric value. *)
  | Checksum  " nat "  (** A checksum value *)
  | RelType   " rel_type " (** A relocation entry type. *)
  | Timestamp " nat "  (** A timestamp value. *)
  | Null                  (** A null (0) value. *)
  | Ignored               (** An ignored value. *)
  
(** [elf32_dyn_value] and [elf64_dyn_value] are specialisations of [dyn_value]
  * fixing the correct types for the ['addr] and ['size] type variables.
  *)
type_synonym elf32_dyn_value =" (uint32, uint32) dyn_value "
type_synonym elf64_dyn_value =" (Elf_Types_Local.uint64, uint64) dyn_value "

(** [get_string_table_of_elf32_dyn_section endian dyns sht bs0] searches through
  * dynamic section entries [dyns] looking for one pointing to a string table, looks
  * up the corresponding section header [sht] pointed to by that dynamic
  * section entry, finds the section in [bs0] and decodes a string table from that
  * section assuming endianness [endian].  May fail.
  *)
(*val get_string_table_of_elf32_dyn_section : endianness -> list elf32_dyn ->
  elf32_section_header_table -> byte_sequence -> error string_table*)
definition get_string_table_of_elf32_dyn_section  :: " endianness \<Rightarrow>(elf32_dyn)list \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " get_string_table_of_elf32_dyn_section endian dyns sht bs0 = (
  (let strtabs =    
(List.filter (\<lambda> x . 
      sint(elf32_dyn_tag   x) = int dt_strtab
    ) dyns)
  in
    (case  strtabs of
        [strtab] =>
        (case (elf32_dyn_d_un   strtab) of
            D_Val     v => error_fail (''get_string_table_of_elf32_dyn_section: STRTAB must be a PTR'')
          | D_Ptr     p =>
            (let sect1 =              
(List.filter (\<lambda> s .                 
((elf32_sh_addr   s) = p) \<and>                  
((elf32_sh_type   s) = Elf_Types_Local.uint32_of_nat sht_strtab)
              ) sht)
            in
              (case  sect1 of
                  []  => error_fail (''get_string_table_of_elf32_dyn_section: no section entry with same address as STRTAB'')
                | [s] =>
                  (let off = (unat(elf32_sh_offset    s)) in
                  (let siz = (unat(elf32_sh_size   s)) in
                  Byte_sequence.offset_and_cut off siz bs0 >>= (\<lambda> rel . 
                  (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
                  error_return (String_table.mk_string_table strings ((String.char_of_nat 0)))))))
                | _   => error_fail (''get_string_table_of_elf32_dyn_section: multiple section entries with same address as STRTAB'')
              ))
          | D_Ignored i => error_fail (''get_string_table_of_elf32_dyn_section: STRTAB must be a PTR'')
        )
      | []       => error_fail (''get_string_table_of_elf32_dyn_section: no string table entry'')
      | _        => error_fail (''get_string_table_of_elf32_dyn_section: multiple string table entries'')
    )))"

    
(** [get_string_table_of_elf64_dyn_section endian dyns sht bs0] searches through
  * dynamic section entries [dyns] looking for one pointing to a string table, looks
  * up the corresponding section header [sht] pointed to by that dynamic
  * section entry, finds the section in [bs0] and decodes a string table from that
  * section assuming endianness [endian].  May fail.
  *)
(*val get_string_table_of_elf64_dyn_section : endianness -> list elf64_dyn ->
  elf64_section_header_table -> byte_sequence -> error string_table*)
definition get_string_table_of_elf64_dyn_section  :: " endianness \<Rightarrow>(elf64_dyn)list \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " get_string_table_of_elf64_dyn_section endian dyns sht bs0 = (
  (let strtabs =    
(List.filter (\<lambda> x . 
      sint(elf64_dyn_tag   x) = int dt_strtab
    ) dyns)
  in
    (case  strtabs of
        [strtab] =>
        (case (elf64_dyn_d_un   strtab) of
            D_Val     v => error_fail (''get_string_table_of_elf64_dyn_section: STRTAB must be a PTR'')
          | D_Ptr     p =>
            (let sect1 =              
(List.filter (\<lambda> s .                 
((elf64_sh_addr   s) = p) \<and>                  
((elf64_sh_type   s) = Elf_Types_Local.uint32_of_nat sht_strtab)
              ) sht)
            in
              (case  sect1 of
                  []  => error_fail (''get_string_table_of_elf64_dyn_section: no section entry with same address as STRTAB'')
                | [s] =>
                  (let off = (unat(elf64_sh_offset    s)) in
                  (let siz = (unat(elf64_sh_size   s)) in
                  Byte_sequence.offset_and_cut off siz bs0 >>= (\<lambda> rel . 
                  (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
                  error_return (String_table.mk_string_table strings (String.char_of_nat 0))))))
                | _   => error_fail (''get_string_table_of_elf64_dyn_section: multiple section entries with same address as STRTAB'')
              ))
          | D_Ignored i => error_fail (''get_string_table_of_elf64_dyn_section: STRTAB must be a PTR'')
        )
      | []       => error_fail (''get_string_table_of_elf64_dyn_section: no string table entry'')
      | _        => error_fail (''get_string_table_of_elf64_dyn_section: multiple string table entries'')
    )))"

    
(** [get_value_of_elf32_dyn so dyn os_additional_ranges os proc stab] returns the value
  * stored in a dynamic section entry [dyn], using [os_additional_ranges] and
  * [os] to decode ABI-reserved tags.  String table [stab] is used to correctly
  * decode library and run paths, etc.
  * May fail.
  *)
(*val get_value_of_elf32_dyn : bool -> elf32_dyn -> (natural -> bool) ->
  (elf32_dyn -> string_table -> error elf32_dyn_value) ->
    (elf32_dyn -> string_table -> error elf32_dyn_value) ->
    string_table -> error elf32_dyn_value*)
definition get_value_of_elf32_dyn  :: " bool \<Rightarrow> elf32_dyn \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(elf32_dyn \<Rightarrow> string_table \<Rightarrow>(((uint32),(uint32))dyn_value)error)\<Rightarrow>(elf32_dyn \<Rightarrow> string_table \<Rightarrow>(((uint32),(uint32))dyn_value)error)\<Rightarrow> string_table \<Rightarrow>(((uint32),(uint32))dyn_value)error "  where 
     " get_value_of_elf32_dyn shared_object dyn os_additional_ranges os proc stab = (
  (let tag = (nat (abs (sint(elf32_dyn_tag   dyn)))) in
    if tag = dt_null then
      error_return Null
    else if tag = dt_needed then
      (case (elf32_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf32_dyn_entry: NEEDED must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: NEEDED must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (Library str))))
    else if tag = dt_pltrelsz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_pltgot then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: PLTGOT must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: PLTGOT must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_hash then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: HASH must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: HASH must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_strtab then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: STRTAB must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: STRTAB must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_symtab then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: SYMTAB must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: SYMTAB must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_rela then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: RELA must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RELA must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_relasz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: RELASZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RELASZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_relaent then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: RELAENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RELAENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_strsz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: STRSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: STRSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_syment then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: SYMENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: SYMENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_init then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: INIT must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: INIT must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_fini then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: FINI must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: FINI must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_soname then
      (case (elf32_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf32_dyn_entry: SONAME must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: SONAME must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (SOName str))))
    else if tag = dt_rpath then
      (case (elf32_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf32_dyn_entry: RPATH must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RPATH must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (RPath str))))
    else if tag = dt_symbolic then
      error_return Null
    else if tag = dt_rel then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: REL must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: REL must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_relsz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: RELSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RELSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_relent then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: RELENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RELENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_pltrel then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: PLTREL must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: PLTREL must be a VAL'')
      ) >>= (\<lambda> r . 
        if unat r = dt_rel then
          error_return (RelType Rel)
        else if unat r = dt_rela then
          error_return (RelType RelA)
        else
          error_fail (''get_value_of_elf32_dyn_entry: PLTREL neither REL nor RELA''))
    else if tag = dt_debug then
      error_return Null
    else if tag = dt_textrel then
      error_return Null
    else if tag = dt_jmprel then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: JMPREL must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: JMPREL must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_bindnow then
      error_return Ignored
    else if tag = dt_init_array then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_fini_array then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_init_arraysz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_fini_arraysz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_runpath then
      (case (elf32_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf32_dyn_entry: RUNPATH must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: RUNPATH must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (RunPath str))))
    else if tag = dt_flags then
      (case (elf32_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf32_dyn_entry: FLAGS must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: FLAGS must be a Val'')
      ) >>= (\<lambda> flags . 
        error_return (Flags (unat flags)))
    else if tag = dt_encoding then
      if \<not> shared_object then
        error_return Ignored
      else
        (case (elf32_dyn_d_un   dyn) of
            D_Val     v => error_fail (''get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR'')
          | D_Ptr     p => error_return p
          | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR'')
        ) >>= (\<lambda> ptr . 
        error_return (Address ptr))
    else if tag = dt_preinit_arraysz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Checksum (unat sz))) (** XXX: bug in readelf does not print this as a size! *)
    else if (tag \<ge> dt_loproc) \<and> (tag \<le> dt_hiproc) then
      proc dyn stab
    else if (tag \<ge> dt_loos) \<and> (tag \<le> dt_hios) then
      os dyn stab
    else if os_additional_ranges tag then
      os dyn stab
    else
      error_fail (''get_value_of_elf32_dyn: unrecognised tag type'')))"

      
(** [get_value_of_elf64_dyn dyn os_additional_ranges os proc stab] returns the value
  * stored in a dynamic section entry [dyn], using [os_additional_ranges] and
  * [os] to decode ABI-reserved tags.  String table [stab] is used to correctly
  * decode library and run paths, etc.
  * May fail.
  *)
(*val get_value_of_elf64_dyn : bool -> elf64_dyn -> (natural -> bool) ->
  (elf64_dyn -> string_table -> error elf64_dyn_value) ->
    (elf64_dyn -> string_table -> error elf64_dyn_value) ->
    string_table -> error elf64_dyn_value*)
definition get_value_of_elf64_dyn  :: " bool \<Rightarrow> elf64_dyn \<Rightarrow>(nat \<Rightarrow> bool)\<Rightarrow>(elf64_dyn \<Rightarrow> string_table \<Rightarrow>(((Elf_Types_Local.uint64),(uint64))dyn_value)error)\<Rightarrow>(elf64_dyn \<Rightarrow> string_table \<Rightarrow>(((Elf_Types_Local.uint64),(uint64))dyn_value)error)\<Rightarrow> string_table \<Rightarrow>(((Elf_Types_Local.uint64),(uint64))dyn_value)error "  where 
     " get_value_of_elf64_dyn shared_object dyn os_additional_ranges os_dyn proc_dyn stab = (
  (let tag = (nat (abs (sint(elf64_dyn_tag   dyn)))) in
    if tag = dt_null then
      error_return Null
    else if tag = dt_needed then
      (case (elf64_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf64_dyn_entry: NEEDED must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: NEEDED must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (Library str))))
    else if tag = dt_pltrelsz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_pltgot then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: PLTGOT must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: PLTGOT must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_hash then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: HASH must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: HASH must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_strtab then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: STRTAB must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: STRTAB must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_symtab then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: SYMTAB must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: SYMTAB must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_rela then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: RELA must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RELA must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_relasz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: RELASZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RELASZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_relaent then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: RELAENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RELAENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_strsz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: STRSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: STRSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_syment then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: SYMENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: SYMENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_init then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: INIT must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: INIT must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_fini then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: FINI must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: FINI must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_soname then
      (case (elf64_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf64_dyn_entry: SONAME must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: SONAME must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (SOName str))))
    else if tag = dt_rpath then
      (case (elf64_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf64_dyn_entry: RPATH must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RPATH must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (RPath str))))
    else if tag = dt_symbolic then
      error_return Null
    else if tag = dt_rel then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: REL must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: REL must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_relsz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: RELSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RELSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_relent then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: RELENT must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RELENT must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_pltrel then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: PLTREL must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: PLTREL must be a VAL'')
      ) >>= (\<lambda> r . 
        if unat r = dt_rel then
          error_return (RelType Rel)
        else if unat r = dt_rela then
          error_return (RelType RelA)
        else
          error_fail (''get_value_of_elf64_dyn_entry: PLTREL neither REL nor RELA''))
    else if tag = dt_debug then
      error_return Null
    else if tag = dt_textrel then
      error_return Null
    else if tag = dt_jmprel then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: JMPREL must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: JMPREL must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_bindnow then
      error_return Ignored
    else if tag = dt_init_array then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_fini_array then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR'')
      ) >>= (\<lambda> ptr . 
      error_return (Address ptr))
    else if tag = dt_init_arraysz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_fini_arraysz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = dt_runpath then
      (case (elf64_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf64_dyn_entry: RUNPATH must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: RUNPATH must be a Val'')
      ) >>= (\<lambda> off . 
        (let off = (unat off) in
        String_table.get_string_at off stab >>= (\<lambda> str . 
        error_return (RunPath str))))
    else if tag = dt_flags then
      (case (elf64_dyn_d_un   dyn) of
          D_Val v     => error_return v
        | D_Ptr p     => error_fail (''get_value_of_elf64_dyn_entry: FLAGS must be a Val'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: FLAGS must be a Val'')
      ) >>= (\<lambda> flags . 
        error_return (Flags (unat flags)))
    else if tag = dt_encoding then
      if \<not> shared_object then
        error_return Ignored
      else
        (case (elf64_dyn_d_un   dyn) of
            D_Val     v => error_fail (''get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR'')
          | D_Ptr     p => error_return p
          | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR'')
        ) >>= (\<lambda> ptr . 
        error_return (Address ptr))
    else if tag = dt_preinit_arraysz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL'')
        | D_Ignored i => error_fail (''get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Checksum (unat sz))) (** XXX: bug in readelf does not print this as a size! *)
    else if (tag \<ge> dt_loproc) \<and> (tag \<le> dt_hiproc) then
      proc_dyn dyn stab
    else if (tag \<ge> dt_loos) \<and> (tag \<le> dt_hios) then
      os_dyn dyn stab
    else if os_additional_ranges tag then
      os_dyn dyn stab
    else
      error_fail (''get_value_of_elf64_dyn: unrecognised tag type'')))"

end
