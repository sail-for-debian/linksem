chapter {* Generated by Lem from abis/power64/abi_power64.lem. *}

theory "Abi_power64" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_list" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 
	 "../../lem-libs/isabelle-lib/Lem_bool" 
	 "../../lem-libs/isabelle-lib/Lem_maybe" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "Elf_interpreted_segment" 
	 "Elf_file" 

begin 

(** [abi_power64] contains top-level definition for the PowerPC64 ABI.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)

(*open import Elf_header*)
(*open import Elf_types_native_uint*)
(*open import Elf_file*)
(*open import Elf_interpreted_segment*)

(** [abi_power64_compute_program_entry_point segs entry] computes the program
  * entry point using ABI-specific conventions.  On Power64 the entry point in
  * the ELF header ([entry] here) is a pointer into a program segment that
  * contains the real entry point.  On other ABIs, e.g.
  * AArch64 and AMD64, the entry point in the ELF header [entry] is the actual
  * program entry point.
  *)
(*val abi_power64_compute_program_entry_point : list elf64_interpreted_segment -> elf64_addr -> error elf64_addr*)
definition abi_power64_compute_program_entry_point  :: "(elf64_interpreted_segment)list \<Rightarrow> Elf_Types_Local.uint64 \<Rightarrow>(Elf_Types_Local.uint64)error "  where 
     " abi_power64_compute_program_entry_point segs entry = (
  (let entry = (unat entry) in
  (let filtered = (List.filter (
      \<lambda> seg . 
        (let base = ((elf64_segment_base   seg)) in
        (let size3 = ((elf64_segment_memsz   seg)) in          
(base \<le> entry) \<and> (entry \<le> (base + size3))))
      ) segs)
  in
    (case  filtered of
        []  => error_fail (''abi_power64_compute_program_entry_point: no program segment contains the program entry point'')
      | [x] =>
        (let rebase = (entry -(elf64_segment_base   x)) in
        Byte_sequence.offset_and_cut rebase(( 8 :: nat))(elf64_segment_body   x) >>= (\<lambda> bytes . 
        Byte_sequence.read_8_bytes_le bytes >>= (\<lambda> (bytes, _) . 
        (let (b1,b2,b3,b4,b5,b6,b7,b8) = bytes in
        error_return (Elf_Types_Local.uint64_of_oct b1 b2 b3 b4 b5 b6 b7 b8)))))
      | _   => error_fail (''abi_power64_compute_program_entry_point: multiple program segments contain the program entry point'')
    ))))"

end
