chapter {* Generated by Lem from gnu_extensions/gnu_ext_section_to_segment_mapping.lem. *}

theory "Gnu_ext_section_to_segment_mapping" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 
	 "../../lem-libs/isabelle-lib/Lem_bool" 
	 "../../lem-libs/isabelle-lib/Lem_string" 
	 "Show" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Gnu_ext_program_header_table" 

begin 

(** [gnu_ext_section_to_segment_mapping] contains (GNU specific) functionality
  * relating to calculating the section to segment mapping for an ELF file.  In
  * particular, the test over whether a section is inside a segment is ABI
  * specific.  This module provides that test.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Num*)

(*open import Elf_header*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_types_native_uint*)

(*open import String*)
(*open import Show*)

(*open import Gnu_ext_program_header_table*)

(** [elf32_section_in_segment sec_hdr segment] implements the
  * ELF_SECTION_IN_SEGMENT1 macro from readelf.  Note the macro is always used
  * with [check_vma] and [strict] set to 1.
  *
  #define ELF_SECTION_IN_SEGMENT_1(sec_hdr, segment, check_vma, strict)	
  ((/* Only PT_LOAD, PT_GNU_RELRO and PT_TLS segments can contain	
       SHF_TLS sections.  */						
    ((((sec_hdr)->sh_flags & SHF_TLS) != 0)				
     && ((segment)->p_type == PT_TLS					
	 || (segment)->p_type == PT_GNU_RELRO				
	 || (segment)->p_type == PT_LOAD))				
    /* PT_TLS segment contains only SHF_TLS sections, PT_PHDR no	
       sections at all.  */						
    || (((sec_hdr)->sh_flags & SHF_TLS) == 0				
	&& (segment)->p_type != PT_TLS					
	&& (segment)->p_type != PT_PHDR))				
   /* PT_LOAD and similar segments only have SHF_ALLOC sections.  */	
   && !(((sec_hdr)->sh_flags & SHF_ALLOC) == 0				
	&& ((segment)->p_type == PT_LOAD				
	    || (segment)->p_type == PT_DYNAMIC				
	    || (segment)->p_type == PT_GNU_EH_FRAME			
	    || (segment)->p_type == PT_GNU_RELRO			
	    || (segment)->p_type == PT_GNU_STACK))			
   /* Any section besides one of type SHT_NOBITS must have file		
      offsets within the segment.  */					
   && ((sec_hdr)->sh_type == SHT_NOBITS					
       || ((bfd_vma) (sec_hdr)->sh_offset >= (segment)->p_offset	
	   && (!(strict)						
	       || ((sec_hdr)->sh_offset - (segment)->p_offset		
		   <= (segment)->p_filesz - 1))				
	   && (((sec_hdr)->sh_offset - (segment)->p_offset		
		+ ELF_SECTION_SIZE(sec_hdr, segment))			
	       <= (segment)->p_filesz)))				
   /* SHF_ALLOC sections must have VMAs within the segment.  */		
   && (!(check_vma)							
       || ((sec_hdr)->sh_flags & SHF_ALLOC) == 0			
       || ((sec_hdr)->sh_addr >= (segment)->p_vaddr			
	   && (!(strict)						
	       || ((sec_hdr)->sh_addr - (segment)->p_vaddr		
		   <= (segment)->p_memsz - 1))				
	   && (((sec_hdr)->sh_addr - (segment)->p_vaddr			
		+ ELF_SECTION_SIZE(sec_hdr, segment))			
	       <= (segment)->p_memsz)))					
   /* No zero size sections at start or end of PT_DYNAMIC.  */		
   && ((segment)->p_type != PT_DYNAMIC					
       || (sec_hdr)->sh_size != 0					
       || (segment)->p_memsz == 0					
       || (((sec_hdr)->sh_type == SHT_NOBITS				
	    || ((bfd_vma) (sec_hdr)->sh_offset > (segment)->p_offset	
	        && ((sec_hdr)->sh_offset - (segment)->p_offset		
		    < (segment)->p_filesz)))				
	   && (((sec_hdr)->sh_flags & SHF_ALLOC) == 0			
	       || ((sec_hdr)->sh_addr > (segment)->p_vaddr		
		   && ((sec_hdr)->sh_addr - (segment)->p_vaddr		
		       < (segment)->p_memsz))))))
  *
  * From [internal.h] of readelf's source code.
  *)
  
(*val elf32_section_flags : elf32_section_header_table_entry -> natural -> bool*)
definition elf32_section_flags0  :: " elf32_section_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf32_section_flags0 sec_hdr typ1 = ( \<not> ((Elf_Types_Local.uint32_land(elf32_sh_flags   sec_hdr) (Elf_Types_Local.uint32_of_nat typ1)) = (Elf_Types_Local.uint32_of_nat(( 0 :: nat)))))"

    
(*val elf64_section_flags : elf64_section_header_table_entry -> natural -> bool*)
definition elf64_section_flags0  :: " elf64_section_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf64_section_flags0 sec_hdr typ1 = ( \<not> ((Elf_Types_Local.uint64_land(elf64_sh_flags   sec_hdr) (of_int (int typ1))) = (of_int (int (( 0 :: nat))))))"

    
(*val elf32_section_of_type : elf32_section_header_table_entry -> natural -> bool*)
definition elf32_section_of_type  :: " elf32_section_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf32_section_of_type sec_hdr typ1 = ((elf32_sh_type  
  sec_hdr) = Elf_Types_Local.uint32_of_nat typ1 )"

  
(*val elf64_section_of_type : elf64_section_header_table_entry -> natural -> bool*)
definition elf64_section_of_type  :: " elf64_section_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf64_section_of_type sec_hdr typ1 = ((elf64_sh_type  
  sec_hdr) = Elf_Types_Local.uint32_of_nat typ1 )"

  
(*val elf32_segment_of_type : elf32_program_header_table_entry -> natural -> bool*)
definition elf32_segment_of_type  :: " elf32_program_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf32_segment_of_type segment typ1 = ((elf32_p_type  
  segment) = Elf_Types_Local.uint32_of_nat typ1 )"

  
(*val elf64_segment_of_type : elf64_program_header_table_entry -> natural -> bool*)
definition elf64_segment_of_type  :: " elf64_program_header_table_entry \<Rightarrow> nat \<Rightarrow> bool "  where 
     " elf64_segment_of_type segment typ1 = ((elf64_p_type  
  segment) = Elf_Types_Local.uint32_of_nat typ1 )"


(** Only PT_LOAD, PT_GNU_RELRO and PT_TLS segments can contain SHF_TLS sections
  * and PT_TLS segment contains only SHF_TLS sections, PT_PHDR no	sections at all
  *)
(*val elf32_section_in_segment1 : elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment1  :: " elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment1 sec_hdr segment = (
  (elf32_section_flags0 sec_hdr shf_tls \<and>
  (elf32_segment_of_type segment elf_pt_tls \<or>    
(elf32_segment_of_type segment elf_pt_gnu_relro \<or>
    elf32_segment_of_type segment elf_pt_load))) \<or>
  (\<not> (elf32_section_flags0 sec_hdr shf_tls)
  \<and> (\<not> (elf32_segment_of_type segment elf_pt_tls)
  \<and> \<not> (elf32_segment_of_type segment elf_pt_phdr))))"

  
(*val elf64_section_in_segment1 : elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment1  :: " elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment1 sec_hdr segment = (
  (elf64_section_flags0 sec_hdr shf_tls \<and>
  (elf64_segment_of_type segment elf_pt_tls \<or>    
(elf64_segment_of_type segment elf_pt_gnu_relro \<or>
    elf64_segment_of_type segment elf_pt_load))) \<or>
  (\<not> (elf64_section_flags0 sec_hdr shf_tls)
  \<and> (\<not> (elf64_segment_of_type segment elf_pt_tls)
  \<and> \<not> (elf64_segment_of_type segment elf_pt_phdr))))"


(** PT_LOAD and similar segments only have SHF_ALLOC sections *)

(*val elf32_section_in_segment2 : elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment2  :: " elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment2 sec_hdr segment = (
  \<not> ((\<not> (elf32_section_flags0 sec_hdr shf_alloc)) \<and>
       (elf32_segment_of_type segment elf_pt_load \<or>        
(elf32_segment_of_type segment elf_pt_dynamic \<or>        
(elf32_segment_of_type segment elf_pt_gnu_eh_frame \<or>        
(elf32_segment_of_type segment elf_pt_gnu_relro \<or>
        elf32_segment_of_type segment elf_pt_gnu_stack))))))"


(*val elf64_section_in_segment2 : elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment2  :: " elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment2 sec_hdr segment = (
  \<not> ((\<not> (elf64_section_flags0 sec_hdr shf_alloc)) \<and>
       (elf64_segment_of_type segment elf_pt_load \<or>        
(elf64_segment_of_type segment elf_pt_dynamic \<or>        
(elf64_segment_of_type segment elf_pt_gnu_eh_frame \<or>        
(elf64_segment_of_type segment elf_pt_gnu_relro \<or>
        elf64_segment_of_type segment elf_pt_gnu_stack))))))"

 
    
(** Any section besides one of type SHT_NOBITS must have file offsets within
  * the segment.
  *)

(*val elf32_sect_size : elf32_header -> elf32_section_header_table_entry -> elf32_program_header_table_entry -> natural*)
definition elf32_sect_size  :: " elf32_header \<Rightarrow> elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> nat "  where 
     " elf32_sect_size hdr sec_hdr segment = (
  if is_elf32_tbss_special sec_hdr segment then( 0 :: nat)
  else
    unat ((elf32_shentsize   hdr)))"

  
(*val elf64_sect_size : elf64_header -> elf64_section_header_table_entry -> elf64_program_header_table_entry -> natural*)
definition elf64_sect_size  :: " elf64_header \<Rightarrow> elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> nat "  where 
     " elf64_sect_size hdr sec_hdr segment = (
  if is_elf64_tbss_special sec_hdr segment then( 0 :: nat)
  else
    unat ((elf64_shentsize   hdr)))"

    
(*val elf32_section_in_segment3 : elf32_header -> elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment3  :: " elf32_header \<Rightarrow> elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment3 hdr sec_hdr segment = (
  (let sec_off = (int (unat(elf32_sh_offset    sec_hdr))) in
  (let seg_off = (int (unat(elf32_p_offset    segment))) in
  (let seg_fsz = (int (unat(elf32_p_filesz   segment))) in
  (let sec_siz = (int (elf32_sect_size hdr sec_hdr segment)) in
    elf32_section_of_type sec_hdr sht_nobits \<or>
    ((sec_off \<ge> seg_off) \<and>    
(((sec_off - seg_off) \<le> (seg_fsz -( 1 :: int))) \<and>
    ((sec_off - (seg_off + sec_siz)) \<le> seg_fsz))))))))"

  
(*val elf64_section_in_segment3 : elf64_header -> elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment3  :: " elf64_header \<Rightarrow> elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment3 hdr sec_hdr segment = (
  (let sec_off = (int (unat(elf64_sh_offset     sec_hdr))) in
  (let seg_off = (int (unat(elf64_p_offset     segment))) in
  (let seg_fsz = (int (unat(elf64_p_filesz   segment))) in
  (let sec_siz = (int (elf64_sect_size hdr sec_hdr segment)) in
    elf64_section_of_type sec_hdr sht_nobits \<or>
    ((sec_off \<ge> seg_off) \<and>    
(((sec_off - seg_off) \<le> (seg_fsz -( 1 :: int))) \<and>
    ((sec_off - (seg_off + sec_siz)) \<le> seg_fsz))))))))"

      
(** SHF_ALLOC sections must have VMAs within the segment
  *)
  
(*val elf32_section_in_segment4 : elf32_header -> elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment4  :: " elf32_header \<Rightarrow> elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment4 hdr sec_hdr segment = (
  (let sec_addr = (int (unat(elf32_sh_addr   sec_hdr))) in
  (let seg_vadr = (int (unat(elf32_p_vaddr   segment))) in
  (let seg_mmsz = (int (unat(elf32_p_memsz   segment))) in
  (let sec_size = (int (elf32_sect_size hdr sec_hdr segment)) in
    (\<not> (elf32_section_flags0 sec_hdr shf_alloc) \<or>     
(sec_addr \<ge> seg_vadr)) \<and>     
(((sec_addr - seg_vadr) \<le> (seg_mmsz -( 1 :: int))) \<and>
     ((sec_addr - (seg_vadr + sec_size)) \<le> seg_mmsz)))))))"

  
(*val elf64_section_in_segment4 : elf64_header -> elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment4  :: " elf64_header \<Rightarrow> elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment4 hdr sec_hdr segment = (
  (let sec_addr = (int (unat(elf64_sh_addr    sec_hdr))) in
  (let seg_vadr = (int (unat(elf64_p_vaddr    segment))) in
  (let seg_mmsz = (int (unat(elf64_p_memsz   segment))) in
  (let sec_size = (int (elf64_sect_size hdr sec_hdr segment)) in
     (\<not> (elf64_section_flags0 sec_hdr shf_alloc) \<or>     
(sec_addr \<ge> seg_vadr)) \<and>     
(((sec_addr - seg_vadr) \<le> (seg_mmsz -( 1 :: int))) \<and>
     ((sec_addr - (seg_vadr + sec_size)) \<le> seg_mmsz)))))))"

    
(** No zero size sections at start or end of PT_DYNAMIC *)

(*val elf32_section_in_segment5 : elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment5  :: " elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment5 sec_hdr segment = (
  (let sec_siz = (int (unat(elf32_sh_size   sec_hdr))) in
  (let seg_msz = (int (unat(elf32_p_memsz   segment))) in
  (let sec_off = (int (unat(elf32_sh_offset    sec_hdr))) in
  (let seg_off = (int (unat(elf32_p_offset    segment))) in
  (let seg_fsz = (int (unat(elf32_p_filesz   segment))) in
  (let sec_adr = (int (unat(elf32_sh_addr   sec_hdr))) in
  (let seg_vad = (int (unat(elf32_p_vaddr   segment))) in
    (\<not> (elf32_segment_of_type segment elf_pt_dynamic)) \<or> (\<not> (sec_siz =(( 0 :: int))) \<or>
    ((seg_msz =( 0 :: int)) \<or>
    ((elf32_section_of_type sec_hdr sht_nobits \<or>
      ((sec_off > seg_off) \<and>
       ((sec_off - seg_off) < seg_fsz))) \<and>
       (\<not> (elf32_section_flags0 sec_hdr shf_alloc) \<or>
        ((sec_adr > seg_vad) \<and>
         ((sec_adr - seg_vad) < seg_msz))))))))))))))"


(*val elf64_section_in_segment5 : elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment5  :: " elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment5 sec_hdr segment = (
  (let sec_siz = (int (unat(elf64_sh_size   sec_hdr))) in
  (let seg_msz = (int (unat(elf64_p_memsz   segment))) in
  (let sec_off = (int (unat(elf64_sh_offset     sec_hdr))) in
  (let seg_off = (int (unat(elf64_p_offset     segment))) in
  (let seg_fsz = (int (unat(elf64_p_filesz   segment))) in
  (let sec_adr = (int (unat(elf64_sh_addr    sec_hdr))) in
  (let seg_vad = (int (unat(elf64_p_vaddr    segment))) in
    (\<not> (elf64_segment_of_type segment elf_pt_dynamic)) \<or> (\<not> (sec_siz =(( 0 :: int))) \<or>
    ((seg_msz =( 0 :: int)) \<or>
    ((elf64_section_of_type sec_hdr sht_nobits \<or>
      ((sec_off > seg_off) \<and>
       ((sec_off - seg_off) < seg_fsz))) \<and>
       (\<not> (elf64_section_flags0 sec_hdr shf_alloc) \<or>
        ((sec_adr > seg_vad) \<and>
         ((sec_adr - seg_vad) < seg_msz))))))))))))))"


(** The final section in segment tests, bringing all the above together.
  *)

(*val elf32_section_in_segment : elf32_header -> elf32_section_header_table_entry -> elf32_program_header_table_entry -> bool*)
definition elf32_section_in_segment  :: " elf32_header \<Rightarrow> elf32_section_header_table_entry \<Rightarrow> elf32_program_header_table_entry \<Rightarrow> bool "  where 
     " elf32_section_in_segment hdr sec_hdr segment = (
  elf32_section_in_segment1 sec_hdr segment \<and>  
(elf32_section_in_segment2 sec_hdr segment \<and>  
(elf32_section_in_segment3 hdr sec_hdr segment \<and>  
(elf32_section_in_segment4 hdr sec_hdr segment \<and>
  elf32_section_in_segment5 sec_hdr segment))))"

    
(*val elf64_section_in_segment : elf64_header -> elf64_section_header_table_entry -> elf64_program_header_table_entry -> bool*)
definition elf64_section_in_segment  :: " elf64_header \<Rightarrow> elf64_section_header_table_entry \<Rightarrow> elf64_program_header_table_entry \<Rightarrow> bool "  where 
     " elf64_section_in_segment hdr sec_hdr segment = (
  elf64_section_in_segment1 sec_hdr segment \<and>  
(elf64_section_in_segment2 sec_hdr segment \<and>  
(elf64_section_in_segment3 hdr sec_hdr segment \<and>  
(elf64_section_in_segment4 hdr sec_hdr segment \<and>
  elf64_section_in_segment5 sec_hdr segment))))"

end
