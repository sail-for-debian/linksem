chapter {* Generated by Lem from elf_file.lem. *}

theory "Elf_file" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_list" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 
	 "../../lem-libs/isabelle-lib/Lem_bool" 
	 "../../lem-libs/isabelle-lib/Lem_maybe" 
	 "../../lem-libs/isabelle-lib/Lem_string" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "String_table" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 

begin 

(** Module [elf_file] packages all components of an ELF file up into a single
  * record, provides I/O routines for this record, as well as other utility
  * functions that operate on an entire ELF file.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)

(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_types_native_uint*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_program_header_table*)

(*open import String_table*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** [elf32_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
record elf32_file =
  
 elf32_file_header               ::" elf32_header "                   (** The file header. *)
   
 elf32_file_program_header_table ::" elf32_program_header_table "     (** The program header table. *)
   
 elf32_file_section_header_table ::" elf32_section_header_table "     (** The section header table. *)
   
 elf32_file_interpreted_segments ::" elf32_interpreted_segments "     (** A more usable interpretation of the file's segments. *)
   
 elf32_file_interpreted_sections ::" elf32_interpreted_sections "     (** A more usable interpretation of the file's sections. *)
   
 elf32_file_bits_and_bobs        ::" (nat * byte_sequence) list " (** The uninterpreted rubbish that may appear in gaps in the binary file. *)
   


(** [bytes_of_elf32_file f1] blits ELF file [f1] to a byte sequence, ready for
  * writing to a binary file.  Fails if the invariant on [elf32_file] mentioned
  * above is not respected.
  *)
(*val bytes_of_elf32_file : elf32_file -> error byte_sequence*)
definition bytes_of_elf32_file  :: " elf32_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf32_file ef = (
  (let endian      = (get_elf32_header_endianness(elf32_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf32_header(elf32_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf32_program_header_table endian(elf32_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf32_section_header_table endian(elf32_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf32_phoff  (elf32_file_header   ef))) in
  (let sht_off     = (unat(elf32_shoff  (elf32_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf32_file_bits_and_bobs   ef)) in
  if List.length(elf32_file_program_header_table   ef) =
    List.length(elf32_file_interpreted_segments   ef) then
    if List.length(elf32_file_section_header_table   ef) =
      List.length(elf32_file_interpreted_sections   ef) then
      (let segs_zip  = (List.zip(elf32_file_program_header_table   ef)(elf32_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf32_file_section_header_table   ef)(elf32_file_interpreted_sections   ef)) in
      (let segs_layout =        
(List.map (\<lambda> (seg, interp_seg) . 
          (unat(elf32_p_offset   seg),(elf32_segment_body   interp_seg))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf32_p_filesz   x) = (Elf_Types_Local.uint32_of_nat(( 0 :: nat))))) segs_zip))
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf32_sh_offset   sect1),(elf32_section_body   interp_sect))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf32_sh_type   x) = (Elf_Types_Local.uint32_of_nat sht_nobits))) sects_zip))
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length0 body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition0 diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length0 cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length0 body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf32_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf32_file: interpreted segments and program header table must have same length''))))))))))))"


(** [elf64_file] record captures the internal structure of an ELF32 file.
  * Invariant: length of the program header and section header tables should match
  * the length of their interpreted counterparts, and the nth element of the
  * (program/section) header table must correspond to the nth element of the
  * interpreted (segments/sections), respectively.
  *)
record elf64_file =
  
 elf64_file_header               ::" elf64_header "                   (** The file header. *)
   
 elf64_file_program_header_table ::" elf64_program_header_table "     (** The program header table. *)
   
 elf64_file_section_header_table ::" elf64_section_header_table "     (** The section header table. *)
   
 elf64_file_interpreted_segments ::" elf64_interpreted_segments "     (** A more usable interpretation of the file's segments. *)
   
 elf64_file_interpreted_sections ::" elf64_interpreted_sections "     (** A more usable interpretation of the file's sections. *)
   
 elf64_file_bits_and_bobs        ::" (nat * byte_sequence) list " (** The uninterpreted rubbish that may appear in gaps in the binary file. *)
   


(** [bytes_of_elf64_file f1] blits ELF file [f1] to a byte sequence, ready for
  * writing to a binary file.  Fails if the invariant on [elf64_file] mentioned
  * above is not respected.
  *)
(*val bytes_of_elf64_file : elf64_file -> error byte_sequence*)
definition bytes_of_elf64_file  :: " elf64_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf64_file ef = (
  (let endian      = (get_elf64_header_endianness(elf64_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf64_header(elf64_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf64_program_header_table endian(elf64_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf64_section_header_table endian(elf64_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf64_phoff  (elf64_file_header   ef))) in
  (let sht_off     = (unat(elf64_shoff  (elf64_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf64_file_bits_and_bobs   ef)) in
  if (* List.length ef.elf64_file_program_header_table =
    List.length ef.elf64_file_interpreted_segments *) True then
    if List.length(elf64_file_section_header_table   ef) =
      List.length(elf64_file_interpreted_sections   ef) then
      (let segs_zip  = (List.zip(elf64_file_program_header_table   ef)(elf64_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf64_file_section_header_table   ef)(elf64_file_interpreted_sections   ef)) in
      (let segs_layout = ([]) (*
        List.map (fun (seg, interp_seg) ->
          (natural_of_elf64_off seg.elf64_p_offset, interp_seg.elf64_segment_body)
        ) (List.filter (fun (x, _) -> x.elf64_p_filesz <> elf64_xword_of_natural 0) segs_zip) *)
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf64_sh_offset   sect1),(elf64_section_body   interp_sect))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf64_sh_type   x) = (Elf_Types_Local.uint32_of_nat sht_nobits))) sects_zip))
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length0 body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition0 diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length0 cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length0 body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf64_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf64_file: interpreted segments and program header table must have same length''))))))))))))"


(** [obtain_elf32_program_header_table hdr bs0] reads a file's program header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_program_header_table : elf32_header -> byte_sequence
  -> error elf32_program_header_table*)
definition obtain_elf32_program_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_program_header_table_entry)list)error "  where 
     " obtain_elf32_program_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let pentries    = (unat(elf32_phnum   hdr))     in
  (let pentry_size = (unat(elf32_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_return []
    else
      (let poffset = (unat(elf32_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(** [obtain_elf64_program_header_table hdr bs0] reads a file's program header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_program_header_table : elf64_header -> byte_sequence
  -> error elf64_program_header_table*)
definition obtain_elf64_program_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_program_header_table_entry)list)error "  where 
     " obtain_elf64_program_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let pentries    = (unat(elf64_phnum   hdr))     in
  (let pentry_size = (unat(elf64_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_return []
    else
      (let poffset = (unat(elf64_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(** [obtain_elf32_section_header_table hdr bs0] reads a file's section header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_section_header_table : elf32_header -> byte_sequence
  -> error elf32_section_header_table*)
definition obtain_elf32_section_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_section_header_table_entry)list)error "  where 
     " obtain_elf32_section_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let sentries    = (unat(elf32_shnum   hdr)) in
  (let sentry_size = (unat(elf32_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf32_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"


(** [obtain_elf64_section_header_table hdr bs0] reads a file's section header table
  * from byte sequence [bs0] using information gleaned from the file header [hdr].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_section_header_table : elf64_header -> byte_sequence -> error elf64_section_header_table*)
definition obtain_elf64_section_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_section_header_table_entry)list)error "  where 
     " obtain_elf64_section_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let sentries    = (unat(elf64_shnum   hdr)) in
  (let sentry_size = (unat(elf64_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf64_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"

      
(** [obtain_elf32_section_header_string_table hdr sht bs0] reads a file's section
  * header string table from byte sequence [bs0] using information gleaned from
  * the file header [hdr] and section header table [sht].
  * Fails if transcription fails.
  *)
(*val obtain_elf32_section_header_string_table : elf32_header ->
  elf32_section_header_table -> byte_sequence -> error string_table*)
definition obtain_elf32_section_header_string_table  :: " elf32_header \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " obtain_elf32_section_header_string_table hdr sht bs0 = (
  (case  Elf_Types_Local.index sht (unat(elf32_shstrndx   hdr)) of 
    None => error_fail (''no section header string table'')
    | Some x => error_return x
  ) >>= (\<lambda> sh . 
  Byte_sequence.offset_and_cut (unat(elf32_sh_offset   sh)) (unat(elf32_sh_size   sh)) bs0 >>= (\<lambda> sexact . 
  error_return (string_table_of_byte_sequence sexact))))"

      
(** [obtain_elf64_section_header_string_table hdr sht bs0] reads a file's section
  * header string table from byte sequence [bs0] using information gleaned from
  * the file header [hdr] and section header table [sht].
  * Fails if transcription fails.
  *)
(*val obtain_elf64_section_header_string_table : elf64_header ->
  elf64_section_header_table -> byte_sequence -> error string_table*)
definition obtain_elf64_section_header_string_table  :: " elf64_header \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " obtain_elf64_section_header_string_table hdr sht bs0 = (
  (case  Elf_Types_Local.index sht (unat(elf64_shstrndx   hdr)) of 
    None => error_fail (''no section header string table'')
    | Some x => error_return x
  ) >>= (\<lambda> sh . 
  Byte_sequence.offset_and_cut (unat(elf64_sh_offset   sh)) (unat(elf64_sh_size   sh)) bs0 >>= (\<lambda> sexact . 
  error_return (string_table_of_byte_sequence sexact))))"


(** [obtain_elf32_interpreted_segments pht bs0] generates the interpreted segments
  * of an ELF file from the uninterpreted program header table entries in [pht],
  * read from byte sequence [bs0].  Makes working with segments easier.
  * May fail if transcription of any segment fails.
  *)
(*val obtain_elf32_interpreted_segments : elf32_program_header_table -> byte_sequence
  -> error elf32_interpreted_segments*)
definition obtain_elf32_interpreted_segments  :: "(elf32_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_segment)list)error "  where 
     " obtain_elf32_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf32_p_offset   ph))  in
    (let size3     = (unat(elf32_p_filesz   ph)) in
      (if size3 =( 0 :: nat) then
         error_return Byte_sequence.empty
       else
         Byte_sequence.offset_and_cut offset size3 bdy) >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf32_p_vaddr   ph)) in
    (let paddr    = (unat(elf32_p_paddr   ph)) in
    (let memsz    = (unat(elf32_p_memsz   ph)) in
    (let typ1      = (unat(elf32_p_type   ph))  in
    (let align    = (unat(elf32_p_align   ph)) in
    (let flags    = (elf32_interpret_program_header_flags(elf32_p_flags   ph)) in
      if memsz < size3 then
        error_fail (''obtain_elf32_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf32_segment_body = relevant, elf32_segment_type = typ1,
 elf32_segment_size = size3, elf32_segment_memsz = memsz,
 elf32_segment_base = vaddr,
 elf32_segment_paddr = paddr, elf32_segment_align = align,
 elf32_segment_offset = offset, elf32_segment_flags = flags  |))))))))))
    ) pht )"


(** [obtain_elf64_interpreted_segments pht bs0] generates the interpreted segments
  * of an ELF file from the uninterpreted program header table entries in [pht],
  * read from byte sequence [bs0].  Makes working with segments easier.
  * May fail if transcription of any segment fails.
  *)
(*val obtain_elf64_interpreted_segments : elf64_program_header_table -> byte_sequence
  -> error elf64_interpreted_segments*)
definition obtain_elf64_interpreted_segments  :: "(elf64_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_segment)list)error "  where 
     " obtain_elf64_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf64_p_offset     ph))  in
    (let size3     = (unat(elf64_p_filesz   ph)) in
      (if size3 =( 0 :: nat) then
         error_return Byte_sequence.empty
       else
         Byte_sequence.offset_and_cut offset size3 bdy) >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf64_p_vaddr    ph)) in
    (let paddr    = (unat(elf64_p_paddr    ph)) in
    (let memsz    = (unat(elf64_p_memsz   ph)) in
    (let typ1      = (unat(elf64_p_type    ph))  in
    (let align    = (unat(elf64_p_align   ph)) in
    (let flags    = (elf64_interpret_program_header_flags(elf64_p_flags   ph)) in
      if memsz < size3 then
        error_fail (''obtain_elf64_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf64_segment_body = relevant, elf64_segment_type = typ1,
 elf64_segment_size = size3, elf64_segment_memsz = memsz,
 elf64_segment_base = vaddr, elf64_segment_paddr = paddr,
 elf64_segment_align = align,
 elf64_segment_offset = offset, elf64_segment_flags = flags  |))))))))))
    ) pht )"


(** [obtain_elf32_interpreted_section sht bs0] generates the interpreted sections
  * of an ELF file from the uninterpreted section header table entries in [sht],
  * read from byte sequence [bs0].  Makes working with sections easier.
  * May fail if transcription of any section fails.
  *)
(*val obtain_elf32_interpreted_sections : string_table -> elf32_section_header_table
  -> byte_sequence -> error elf32_interpreted_sections*)
definition obtain_elf32_interpreted_sections  :: " string_table \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_section)list)error "  where 
     " obtain_elf32_interpreted_sections shstrtab sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf32_sh_offset    sh)) in
    (let size3   = (unat(elf32_sh_size   sh)) in
    (let name1   = (unat(elf32_sh_name   sh)) in
    (let typ1    = (unat(elf32_sh_type   sh)) in
    (let filesz = (if typ1 = sht_nobits then( 0 :: nat) else size3) in
    (let flags  = (unat(elf32_sh_flags   sh)) in
    (let base   = (unat(elf32_sh_addr   sh)) in
    (let link1   = (unat(elf32_sh_link   sh)) in
    (let info   = (unat(elf32_sh_info   sh)) in
    (let align  = (unat(elf32_sh_addralign   sh)) in
    (let entry_size = (unat(elf32_sh_entsize   sh)) in
    (let name_string = ((case  (get_string_at name1 shstrtab) of Success n => n | Fail _ => ('''') )) in
      (if filesz =( 0 :: nat) then
        error_return Byte_sequence.empty
      else
        Byte_sequence.offset_and_cut offset filesz bs0) >>= (\<lambda> relevant . 
      error_return  (| elf32_section_name = name1, elf32_section_type = typ1,
 elf32_section_flags = flags, elf32_section_addr = base, elf32_section_offset = offset,
 elf32_section_size = size3,
 elf32_section_link = link1, elf32_section_info = info,
 elf32_section_align = align,
 elf32_section_entsize = entry_size, elf32_section_body = relevant,
 elf32_section_name_as_string = name_string  |))))))))))))))
  ) sht )"


(** [obtain_elf64_interpreted_section sht bs0] generates the interpreted sections
  * of an ELF file from the uninterpreted section header table entries in [sht],
  * read from byte sequence [bs0].  Makes working with sections easier.
  * May fail if transcription of any section fails.
  *)
(*val obtain_elf64_interpreted_sections : string_table -> elf64_section_header_table
  -> byte_sequence -> error elf64_interpreted_sections*)
definition obtain_elf64_interpreted_sections  :: " string_table \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_section)list)error "  where 
     " obtain_elf64_interpreted_sections shstrtab sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf64_sh_offset     sh)) in
    (let size3   = (unat(elf64_sh_size   sh)) in
    (let name1   = (unat(elf64_sh_name    sh)) in
    (let typ1    = (unat(elf64_sh_type    sh)) in
    (let filesz = (if typ1 = sht_nobits then( 0 :: nat) else size3) in
    (let flags  = (unat(elf64_sh_flags   sh)) in
    (let base   = (unat(elf64_sh_addr    sh)) in
    (let link1   = (unat(elf64_sh_link    sh)) in
    (let info   = (unat(elf64_sh_info    sh)) in
    (let align  = (unat(elf64_sh_addralign   sh)) in
    (let entry_size = (unat(elf64_sh_entsize   sh)) in
    (let name_string = ((case  (get_string_at name1 shstrtab) of Success n => n | Fail _ => ('''') )) in 
      (if filesz =( 0 :: nat) then
        error_return Byte_sequence.empty
      else
        Byte_sequence.offset_and_cut offset filesz bs0) >>= (\<lambda> relevant . 
      error_return  (| elf64_section_name = name1, elf64_section_type = typ1,
 elf64_section_flags = flags, elf64_section_addr = base, elf64_section_offset = offset,
 elf64_section_size = size3,
 elf64_section_link = link1, elf64_section_info = info,
 elf64_section_align = align,
 elf64_section_entsize = entry_size, elf64_section_body = relevant,
 elf64_section_name_as_string = name_string  |))))))))))))))
  ) sht )"


(** [find_first_not_in_range e rngs] for every pair (start, end) in [rngs], finds
  * the first element, beginning counting from [e], that does not lie between
  * a start and end value.
  *)
(*val find_first_not_in_range : natural -> list (natural * natural) -> natural*)
(*let rec find_first_not_in_range start ranges =
  match List.filter (fun (x, y) -> (Instance_Basic_classes_Ord_Num_natural.>=) start x && (Instance_Basic_classes_Ord_Num_natural.<=) start y) ranges with
    | [] -> start
    | _  -> find_first_not_in_range ((Instance_Num_NumAdd_Num_natural.+) start 1) ranges
  end*)

(** [find_first_in_range e rngs] for every pair (start, end) in [rngs], finds
  * the first element, beginning counting from [e], that lies between
  * a start and end value.
  *)
(*val find_first_in_range : natural -> list (natural * natural) -> natural*)
(*let rec find_first_in_range start ranges =
  match List.filter (fun (x, y) -> (Instance_Basic_classes_Ord_Num_natural.>=) start x && (Instance_Basic_classes_Ord_Num_natural.<=) start y) ranges with
    | [] -> find_first_in_range ((Instance_Num_NumAdd_Num_natural.+) start 1) ranges
    | _  -> start
  end*)

(** [compute_differences start max ranges] is a utility function used for calculating
  * dead spots in an ELF file not covered by any of the interpreted structure
  * that nevertheless need recording in the bits_and_bobs field of each ELF record
  * in order to maintain in-out roundtripping up to exact binary equivalence.
  *)
(*val compute_differences : natural -> natural -> list (natural * natural) -> error (list (natural * natural))*)
(*let rec compute_differences start max ranges =
  if (Instance_Basic_classes_Eq_Num_natural.=) start max then
    return []
  else if (Instance_Basic_classes_Ord_Num_natural.>) start max then
    fail compute_differences: passed maximum
  else
    let first1 = find_first_not_in_range start ranges in
      if (Instance_Basic_classes_Ord_Num_natural.>=) first1 max then
        return []
      else
        let last1 = find_first_in_range first1 ranges in
          if (Instance_Basic_classes_Ord_Num_natural.>) last1 max then
            return [(first1, max)]
          else
             tail := compute_differences last1 max ranges;
            return ((first1, last1)::tail)*)

(** [obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0] identifies and records
  * the dead spots of an ELF file not covered by any meaningful structure of the
  * ELF file format.
  *)
(*val obtain_elf32_bits_and_bobs : elf32_header -> elf32_program_header_table -> elf32_interpreted_segments
  -> elf32_section_header_table -> elf32_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf32_bits_and_bobs  :: " elf32_header \<Rightarrow>(elf32_program_header_table_entry)list \<Rightarrow>(elf32_interpreted_segment)list \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow>(elf32_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf32_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf32_ehsize   hdr)) in
  (let pht_off      = (unat(elf32_phoff   hdr)) in
  (let pht_len      = (unat(elf32_phentsize   hdr) * unat(elf32_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf32_shoff   hdr)) in
  (let sht_len      = (unat(elf32_shentsize   hdr) * unat(elf32_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf32_p_offset   seg)) in
            (let len   = ((elf32_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf32_sh_offset   sect1)) in
            (let len   = ((elf32_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          Elf_Types_Local.compute_differences(( 0 :: nat)) (Byte_sequence.length0 bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, len) . 
              Byte_sequence.offset_and_cut start (len - start) bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf32_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf32_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(** [obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0] identifies and records
  * the dead spots of an ELF file not covered by any meaningful structure of the
  * ELF file format.
  *)
(*val obtain_elf64_bits_and_bobs : elf64_header -> elf64_program_header_table -> elf64_interpreted_segments
  -> elf64_section_header_table -> elf64_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf64_bits_and_bobs  :: " elf64_header \<Rightarrow>(elf64_program_header_table_entry)list \<Rightarrow>(elf64_interpreted_segment)list \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow>(elf64_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf64_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf64_ehsize   hdr)) in
  
  (let pht_off      = (unat(elf64_phoff   hdr)) in
  (let pht_len      = (unat(elf64_phentsize   hdr) * unat(elf64_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf64_shoff   hdr)) in
  (let sht_len      = (unat(elf64_shentsize   hdr) * unat(elf64_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf64_p_offset   seg)) in
            (let len   = ((elf64_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf64_sh_offset   sect1)) in
            (let len   = ((elf64_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          Elf_Types_Local.compute_differences(( 0 :: nat)) (Byte_sequence.length0 bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, finish) . 
              Byte_sequence.offset_and_cut start (finish - start) bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf64_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf64_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(** [read_elf32_file bs0] reads an ELF32 file from byte sequence [bs0].  Fails if
  * transcription fails.
  *)
(*val read_elf32_file : byte_sequence -> error elf32_file*)
definition read_elf32_file  :: " byte_sequence \<Rightarrow>(elf32_file)error "  where 
     " read_elf32_file bs0 = (
  read_elf32_header bs0 >>= (\<lambda> (hdr, bs1) . 
  obtain_elf32_program_header_table hdr bs0 >>= (\<lambda> pht  . 
  obtain_elf32_section_header_table hdr bs0 >>= (\<lambda> sht  . 
  obtain_elf32_section_header_string_table hdr sht bs0 >>= (\<lambda> shstrtab . 
  obtain_elf32_interpreted_segments pht bs0 >>= (\<lambda> segs . 
  obtain_elf32_interpreted_sections shstrtab sht bs0 >>= (\<lambda> sects . 
  obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
  error_return (| elf32_file_header = hdr,
              elf32_file_program_header_table = pht,
              elf32_file_section_header_table = sht,
              elf32_file_interpreted_segments = segs,
              elf32_file_interpreted_sections = sects,
              elf32_file_bits_and_bobs = bits_and_bobs |)))))))))"


(** [read_elf64_file bs0] reads an ELF64 file from byte sequence [bs0].  Fails if
  * transcription fails.
  *)
(*val read_elf64_file : byte_sequence -> error elf64_file*)
definition read_elf64_file  :: " byte_sequence \<Rightarrow>(elf64_file)error "  where 
     " read_elf64_file bs0 = (
  read_elf64_header bs0 >>= (\<lambda> (hdr, bs1) . 
  obtain_elf64_program_header_table hdr bs0 >>= (\<lambda> pht  . 
  obtain_elf64_section_header_table hdr bs0 >>= (\<lambda> sht  . 
  obtain_elf64_section_header_string_table hdr sht bs0 >>= (\<lambda> shstrtab . 
  obtain_elf64_interpreted_segments pht bs0 >>= (\<lambda> segs . 
  obtain_elf64_interpreted_sections shstrtab sht bs0 >>= (\<lambda> sects . 
  obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
  error_return (| elf64_file_header = hdr,
              elf64_file_program_header_table = pht,
              elf64_file_section_header_table = sht,
              elf64_file_interpreted_segments = segs,
              elf64_file_interpreted_sections = sects,
              elf64_file_bits_and_bobs = bits_and_bobs |)))))))))"


(** [get_elf32_file_secton_header_string_table f1] returns the ELF file, [f1],
  * section header string table.
  * TODO: why is this not using obtain_elf32_section_header_string_table above?
  *)
(*val get_elf32_file_section_header_string_table : elf32_file -> error string_table*)
definition get_elf32_file_section_header_string_table  :: " elf32_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_file_section_header_string_table f3 = (
  (let hdr  = ((elf32_file_header   f3)) in
  (let sht  = ((elf32_file_section_header_table   f3)) in
  (let segs = ((elf32_file_interpreted_segments   f3)) in
  (let idx1  = (unat(elf32_shstrndx   hdr)) in
  bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx1 of
        None => error_fail (''obtain_elf32_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf32_sh_offset   sect1)) in
          (let size3   = (unat(elf32_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (String.char_of_nat 0))))))
    )))))))"


(** [get_elf64_file_secton_header_string_table f1] returns the ELF file, [f1],
  * section header string table.
  * TODO: why is this not using obtain_elf64_section_header_string_table above?
  *)
(*val get_elf64_file_section_header_string_table : elf64_file -> error string_table*)
definition get_elf64_file_section_header_string_table  :: " elf64_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_file_section_header_string_table f3 = (
  (let hdr  = ((elf64_file_header   f3)) in
  (let sht  = ((elf64_file_section_header_table   f3)) in
  (let segs = ((elf64_file_interpreted_segments   f3)) in
  (let idx1  = (unat(elf64_shstrndx   hdr)) in
  bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx1 of
        None => error_fail (''obtain_elf64_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf64_sh_offset     sect1)) in
          (let size3   = (unat(elf64_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (String.char_of_nat 0))))))
    )))))))"

    
(*val find_elf32_symbols_by_symtab_idx : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
definition find_elf32_symbols_by_symtab_idx  :: " nat \<Rightarrow> elf32_file \<Rightarrow>((elf32_symbol_table_entry)list*string_table*nat)error "  where 
     " find_elf32_symbols_by_symtab_idx sec_idx f = (
    (case  index(elf32_file_interpreted_sections   f) ( sec_idx) of
        None => error_fail (''impossible: interpreted section found but not indexable'')
        | Some sec => error_return sec
    ) >>= (\<lambda> sec .  
    (case  index(elf32_file_interpreted_sections   f) ((elf32_section_link   sec)) of
        None => error_fail (''no associated strtab'')
        | Some strs => error_return strs
    ) >>= (\<lambda> strs .  
    (let strings = (Byte_sequence.string_of_byte_sequence(elf32_section_body   strs)) in
    (let strtab = (String_table.mk_string_table strings (String.char_of_nat 0)) in
    (let endian = (get_elf32_header_endianness(elf32_file_header   f)) in
    read_elf32_symbol_table endian(elf32_section_body   sec) >>= (\<lambda> symtab . 
    error_return (symtab, strtab, sec_idx))))))))"


(*val find_elf32_symtab_by_type : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
definition find_elf32_symtab_by_type  :: " nat \<Rightarrow> elf32_file \<Rightarrow>(elf32_symbol_table*string_table*nat)error "  where 
     " find_elf32_symtab_by_type t f = (
    (let found_symtab_index = (find_index (\<lambda> sh . (elf32_section_type   sh) = t)(elf32_file_interpreted_sections   f)) in
    (case  found_symtab_index of 
        None => error_fail (''no such symtab'')
        | Some sec_idx => error_return sec_idx
    ) >>= (\<lambda> sec_idx .  find_elf32_symbols_by_symtab_idx sec_idx f)))"


(*val find_elf64_symbols_by_symtab_idx : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
definition find_elf64_symbols_by_symtab_idx  :: " nat \<Rightarrow> elf64_file \<Rightarrow>((elf64_symbol_table_entry)list*string_table*nat)error "  where 
     " find_elf64_symbols_by_symtab_idx sec_idx f = (
    (case  index(elf64_file_interpreted_sections   f) ( sec_idx) of
        None => error_fail (''impossible: interpreted section found but not indexable'')
        | Some sec => error_return sec
    ) >>= (\<lambda> sec .  
    (case  index(elf64_file_interpreted_sections   f) ((elf64_section_link   sec)) of
        None => error_fail (''no associated strtab'')
        | Some strs => error_return strs
    ) >>= (\<lambda> strs .  
    (let strings = (Byte_sequence.string_of_byte_sequence(elf64_section_body   strs)) in
    (let strtab = (String_table.mk_string_table strings (String.char_of_nat 0)) in
    (let endian = (get_elf64_header_endianness(elf64_file_header   f)) in
    read_elf64_symbol_table endian(elf64_section_body   sec) >>= (\<lambda> symtab . 
    error_return (symtab, strtab, sec_idx))))))))"


(*val find_elf64_symtab_by_type : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
definition find_elf64_symtab_by_type  :: " nat \<Rightarrow> elf64_file \<Rightarrow>(elf64_symbol_table*string_table*nat)error "  where 
     " find_elf64_symtab_by_type t f = (
    (let found_symtab_index = (find_index (\<lambda> sh . (elf64_section_type   sh) = t)(elf64_file_interpreted_sections   f)) in
    (case  found_symtab_index of 
        None => error_fail (''no such symtab'')
        | Some sec_idx => error_return sec_idx
    ) >>= (\<lambda> sec_idx .  find_elf64_symbols_by_symtab_idx sec_idx f)))"


(** [get_elf32_file_symbol_string_table f1] returns the ELF file [f1] symbol
  * string table.  May fail.
  *)
(*val get_elf32_file_symbol_string_table : elf32_file -> error string_table*)
definition get_elf32_file_symbol_string_table  :: " elf32_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_file_symbol_string_table f3 = (
  (let hdr     = ((elf32_file_header   f3)) in
  (let sht     = ((elf32_file_section_header_table   f3)) in
  (let segs    = ((elf32_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf32_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf32_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf32_sh_offset    sect1)) in
      (let size3    = (unat(elf32_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (String.char_of_nat 0))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(** [get_elf64_file_symbol_string_table f1] returns the ELF file [f1] symbol
  * string table.  May fail.
  *)
(*val get_elf64_file_symbol_string_table : elf64_file -> error string_table*)
definition get_elf64_file_symbol_string_table  :: " elf64_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_file_symbol_string_table f3 = (
  (let hdr     = ((elf64_file_header   f3)) in
  (let sht     = ((elf64_file_section_header_table   f3)) in
  (let segs    = ((elf64_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf64_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf64_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf64_sh_offset     sect1)) in
      (let size3    = (unat(elf64_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (String.char_of_nat 0))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(** [get_elf32_file_symbol_table f1] returns the ELF file [f1] symbol
  * table.  May fail.
  *)
(*val get_elf32_file_symbol_table : elf32_file -> error elf32_symbol_table*)
definition get_elf32_file_symbol_table  :: " elf32_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_file_symbol_table f3 = (
  (let hdr     = ((elf32_file_header   f3)) in
  (let sht     = ((elf32_file_section_header_table   f3)) in
  (let segs    = ((elf32_file_interpreted_segments   f3)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size3   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(** [get_elf64_file_symbol_table f1] returns the ELF file [f1] symbol
  * table.  May fail.
  *)
(*val get_elf64_file_symbol_table : elf64_file -> error elf64_symbol_table*)
definition get_elf64_file_symbol_table  :: " elf64_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_file_symbol_table f3 = (
  (let hdr     = ((elf64_file_header   f3)) in
  (let sht     = ((elf64_file_section_header_table   f3)) in
  (let segs    = ((elf64_file_interpreted_segments   f3)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size3   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(** [get_elf32_file_dynamic_symbol_table f1] returns the ELF file [f1] dynamic
  * symbol table.  May fail.
  *)
(*val get_elf32_file_dynamic_symbol_table : elf32_file -> error elf32_symbol_table*)
definition get_elf32_file_dynamic_symbol_table  :: " elf32_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let segs    = ((elf32_file_interpreted_segments   ef)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size3   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"


(** [get_elf64_file_dynamic_symbol_table f1] returns the ELF file [f1] dynamic
  * symbol table.  May fail.
  *)
(*val get_elf64_file_dynamic_symbol_table : elf64_file -> error elf64_symbol_table*)
definition get_elf64_file_dynamic_symbol_table  :: " elf64_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let segs    = ((elf64_file_interpreted_segments   ef)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size3   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size3 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"

    
(** [get_elf32_file_symbol_table_by_index f1 index] returns the ELF file [f1] 
  * symbol table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf32_symbol_table_by_index : elf32_file -> natural -> error elf32_symbol_table*)
definition get_elf32_symbol_table_by_index  :: " elf32_file \<Rightarrow> nat \<Rightarrow>(elf32_symbol_table)error "  where 
     " get_elf32_symbol_table_by_index ef link1 = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let sects   = ((elf32_file_interpreted_sections   ef)) in
  (let endian  = (get_elf32_header_endianness hdr) in
    (case  index sects (id link1) of
        None  => error_fail (''get_elf32_symbol_table_by_index: invalid index'')
      | Some sym1 =>
        read_elf32_symbol_table endian(elf32_section_body   sym1)
    ))))))"

    
(** [get_elf32_file_string_table_by_index f1 index] returns the ELF file [f1] 
  * string table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf32_string_table_by_index : elf32_file -> natural -> error string_table*)
definition get_elf32_string_table_by_index  :: " elf32_file \<Rightarrow> nat \<Rightarrow>(string_table)error "  where 
     " get_elf32_string_table_by_index ef link1 = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let sects   = ((elf32_file_interpreted_sections   ef)) in
    (case  index sects (id link1) of
        None  => error_fail (''get_elf32_string_table_by_index: invalid index'')
      | Some sym1 => error_return (mk_string_table (Byte_sequence.string_of_byte_sequence(elf32_section_body   sym1)) (String.char_of_nat 0))
    )))))"

    
(** [get_elf64_file_symbol_table_by_index f1 index] returns the ELF file [f1] 
  * symbol table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf64_symbol_table_by_index : elf64_file -> natural -> error elf64_symbol_table*)
definition get_elf64_symbol_table_by_index  :: " elf64_file \<Rightarrow> nat \<Rightarrow>(elf64_symbol_table)error "  where 
     " get_elf64_symbol_table_by_index ef link1 = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let sects   = ((elf64_file_interpreted_sections   ef)) in
  (let endian  = (get_elf64_header_endianness hdr) in
    (case  index sects (id link1) of
        None  => error_fail (''get_elf64_symbol_table_by_index: invalid index'')
      | Some sym1 =>
        read_elf64_symbol_table endian(elf64_section_body   sym1)
    ))))))"

    
(** [get_elf64_file_string_table_by_index f1 index] returns the ELF file [f1] 
  * string table that is pointed to by the section header table entry at index
  * [index].  May fail if index is out of range, or otherwise.
  *)
(*val get_elf64_string_table_by_index : elf64_file -> natural -> error string_table*)
definition get_elf64_string_table_by_index  :: " elf64_file \<Rightarrow> nat \<Rightarrow>(string_table)error "  where 
     " get_elf64_string_table_by_index ef link1 = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let sects   = ((elf64_file_interpreted_sections   ef)) in
    (case  index sects (id link1) of
        None  => error_fail (''get_elf64_string_table_by_index: invalid index'')
      | Some sym1 => error_return (mk_string_table (Byte_sequence.string_of_byte_sequence(elf64_section_body   sym1)) (String.char_of_nat 0))
    )))))"


(** [segment_provenance] records whether a segment that appears in an executable
  * process image has been derived directly from an ELF file, or was automatically
  * created when the image calculation process noticed a segment with a memory
  * size greater than its file size.
  * Really a PPCMemism and not strictly needed for the ELF model itself.
  *)
datatype segment_provenance
  = FromELF       (** Segment derived directly from the source ELF file. *)
  | AutoGenerated (** Automatically generated during process extraction as memory size is greater than file size. *)

(** [elf32_executable_process_image] is a process image for ELF32 files.  Contains
  * all that is necessary to load the executable components of an ELF32 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
type_synonym elf32_executable_process_image ="
  ( (elf32_interpreted_segment * segment_provenance)list * nat * nat)"

(** [elf64_executable_process_image] is a process image for ELF64 files.  Contains
  * all that is necessary to load the executable components of an ELF64 file
  * and begin execution.
  * XXX: (segments, provenance), entry point, machine type
  *)
type_synonym elf64_executable_process_image ="
  ( (elf64_interpreted_segment * segment_provenance)list * nat * nat)"

(** [get_elf32_executable_image f1] extracts an executable process image from an
  * executable ELF file.  May fail if extraction is impossible.
  *)
(*val get_elf32_executable_image : elf32_file -> error elf32_executable_process_image*)
definition get_elf32_executable_image  :: " elf32_file \<Rightarrow>((elf32_interpreted_segment*segment_provenance)list*nat*nat)error "  where 
     " get_elf32_executable_image f3 = (
  if is_elf32_executable_file(elf32_file_header   f3) then
    (let entr = ((elf32_entry  (elf32_file_header   f3))) in
    (let segs = ((elf32_file_interpreted_segments   f3)) in
    (let mach = ((elf32_machine  (elf32_file_header   f3))) in
      (case  List.filter (\<lambda> sg . (elf32_segment_type   sg) = elf_pt_load) segs of
          []    => error_fail (''get_elf32_executable_image: an executable ELF file must have at least one loadable segment'')
        | load  =>
            mapM (\<lambda> sg . 
              if(elf32_segment_memsz   sg) =( 0 :: nat) then
                error_return []
              else if(elf32_segment_memsz   sg) =(elf32_segment_size   sg) then
                error_return [(sg, FromELF)]
              else if(elf32_segment_size   sg) <(elf32_segment_memsz   sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                (let diff  = ((elf32_segment_memsz   sg) -(elf32_segment_size   sg)) in
                (let zeros1 = (Byte_sequence.zeros diff) in
                (let addr  = ((elf32_segment_base   sg) +(elf32_segment_size   sg)) in
                (let align = ((elf32_segment_align   sg)) in
                (let paddr = ((elf32_segment_paddr   sg)) in
                (let seg   = 
  ((| elf32_segment_body = zeros1, elf32_segment_type =(elf32_segment_type   sg),
   elf32_segment_size = diff, elf32_segment_memsz = diff,
   elf32_segment_base = addr, elf32_segment_paddr = paddr,
   elf32_segment_align = align,
   elf32_segment_offset =(elf32_segment_offset   sg), elf32_segment_flags =(elf32_segment_flags   sg)  |))
                in
                  error_return [(sg, FromELF), (seg, AutoGenerated)]))))))
              else
                error_fail (''get_elf32_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
            error_return (List.concat bs_base, unat entr, unat mach))
      ))))
  else
    error_fail (''get_elf32_executable_image: not an ELF executable file''))"


(** [get_elf64_executable_image f1] extracts an executable process image from an
  * executable ELF file.  May fail if extraction is impossible.
  *)
(*val get_elf64_executable_image : elf64_file -> error elf64_executable_process_image*)
definition get_elf64_executable_image  :: " elf64_file \<Rightarrow>((elf64_interpreted_segment*segment_provenance)list*nat*nat)error "  where 
     " get_elf64_executable_image f3 = ( 
  if is_elf64_executable_file(elf64_file_header   f3) then
    (let entr = ((elf64_entry  (elf64_file_header   f3))) in
    (let segs = ((elf64_file_interpreted_segments   f3)) in
    (let mach = ((elf64_machine  (elf64_file_header   f3))) in
      (case  List.filter (\<lambda> sg . (elf64_segment_type   sg) = elf_pt_load) segs of
          []    => error_fail (''get_elf64_executable_image: an executable ELF file must have at least one loadable segment'')
        | load  =>
            mapM (\<lambda> sg . 
              if(elf64_segment_memsz   sg) =( 0 :: nat) then
                error_return []
              else if(elf64_segment_memsz   sg) =(elf64_segment_size   sg) then
                error_return [(sg, FromELF)]
              else if(elf64_segment_size   sg) <(elf64_segment_memsz   sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                (let diff  = ((elf64_segment_memsz   sg) -(elf64_segment_size   sg)) in
                (let zeros1 = (Byte_sequence.zeros diff) in
                (let addr  = ((elf64_segment_base   sg) +(elf64_segment_size   sg)) in
                (let align = ((elf64_segment_align   sg)) in
                (let paddr = ((elf64_segment_paddr   sg)) in
                (let seg   = 
  ((| elf64_segment_body = zeros1, elf64_segment_type =(elf64_segment_type   sg),
   elf64_segment_size = diff, elf64_segment_memsz = diff,
   elf64_segment_base = addr, elf64_segment_paddr = paddr,
   elf64_segment_align = align,
   elf64_segment_offset =(elf64_segment_offset   sg), elf64_segment_flags =(elf64_segment_flags   sg)  |))
                in
                  error_return [(sg, FromELF), (seg, AutoGenerated)]))))))
              else
                error_fail (''get_elf64_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
            error_return (List.concat bs_base, unat entr, unat mach))
      ))))
  else
    error_fail (''elf64_get_executable_image: not an executable ELF file''))"


(** [global_symbol_init_info] records the name, type, size, address, chunk
  * of initialisation data (if relevant for that symbol), and binding, of every
  * global symbol in an ELF file.
  * Another PPCMemism.
  *)
type_synonym global_symbol_init_info
  =" (string * (nat * nat * nat *  byte_sequence option * nat)) list "

(** [get_elf32_file_global_symbol_init f1] extracts the global symbol init info
  * for ELF file [f1].  May fail.
  *)
(*val get_elf32_file_global_symbol_init : elf32_file -> error global_symbol_init_info*)
definition get_elf32_file_global_symbol_init  :: " elf32_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option*nat))list)error "  where 
     " get_elf32_file_global_symbol_init f3 = (
  if is_elf32_executable_file(elf32_file_header   f3) then
    (let segs   = ((elf32_file_interpreted_segments   f3)) in
    bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    get_elf32_file_symbol_table f3 >>= (\<lambda> symtab . 
    get_elf32_file_symbol_string_table f3 >>= (\<lambda> strtab . 
    Elf_symbol_table.get_elf32_symbol_image_address symtab strtab >>= (\<lambda> strs . 
      (let mapped = (mapM (\<lambda> (symbol, (typ1, size3, addr, bind)) . 
        if typ1 = Elf_symbol_table.stt_object then
          get_elf32_executable_image f3 >>= (\<lambda> (img3, entry, mach) . 
          (let chunks =            
(List.filter (\<lambda> (chunk, _) .               
(addr \<ge>(elf32_segment_base   chunk)) \<and>
                ((addr + size3) \<le> ((elf32_segment_base   chunk) +(elf32_segment_size   chunk)))
            ) img3)
          in
            (case  chunks of
                []    => error_fail (''get_elf32_global_symbol_init: global variable not present in executable image'')
              | [(x, _)]   =>
                (let rebase   = (addr -(elf32_segment_base   x)) in
                Byte_sequence.offset_and_cut rebase size3(elf32_segment_body   x) >>= (\<lambda> relevant . 
                  error_return (symbol, (typ1, size3, addr, Some relevant, bind))))
              | x # xs => error_fail (''get_elf32_global_symbol_init: invariant failed, global variable appears in multiple segments'')
            )))
        else
          error_return (symbol, (typ1, size3, addr, None, bind))) strs)
      in
        mapped))))))
  else
    error_fail (''get_elf32_file_global_symbol_init: not an executable ELF file''))"


(** [get_elf64_file_global_symbol_init f1] extracts the global symbol init info
  * for ELF file [f1].  May fail.
  *)
(*val get_elf64_file_global_symbol_init : elf64_file -> error global_symbol_init_info*)
definition get_elf64_file_global_symbol_init  :: " elf64_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option*nat))list)error "  where 
     " get_elf64_file_global_symbol_init f3 = (
  if is_elf64_executable_file(elf64_file_header   f3) then
    (let segs   = ((elf64_file_interpreted_segments   f3)) in
    bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    get_elf64_file_symbol_table f3 >>= (\<lambda> symtab . 
    get_elf64_file_symbol_string_table f3 >>= (\<lambda> strtab . 
    Elf_symbol_table.get_elf64_symbol_image_address symtab strtab >>= (\<lambda> strs . 
      (let mapped = (mapM (\<lambda> (symbol, (typ1, size3, addr, bind)) . 
        if typ1 = Elf_symbol_table.stt_object then
          get_elf64_executable_image f3 >>= (\<lambda> (img3, entry, mach) . 
          (let chunks =            
(List.filter (\<lambda> (chunk, _) .               
(addr \<ge>(elf64_segment_base   chunk)) \<and>
                ((addr + size3) \<le> ((elf64_segment_base   chunk) +(elf64_segment_size   chunk)))
            ) img3)
          in
            (case  chunks of
                []    => error_fail (''get_elf64_global_symbol_init: global variable not present in executable image'')
              | [(x, _)]   =>
                (let rebase   = (addr -(elf64_segment_base   x)) in
                Byte_sequence.offset_and_cut rebase size3(elf64_segment_body   x) >>= (\<lambda> relevant . 
                  error_return (symbol, (typ1, size3, addr, Some relevant, bind))))
              | x # xs => error_fail (''get_elf64_global_symbol_init: invariant failed, global variable appears in multiple segments'')
            )))
        else
          error_return (symbol, (typ1, size3, addr, None, bind))) strs)
      in
        mapped))))))
  else
    error_fail (''get_elf64_global_symbol_init: not an executable ELF file''))"


(** [string_of_elf32_file hdr_bdl pht_bdl sht_bdl f1] produces a string-based
  * representation of ELF file [f1] using ABI-specific print bundles [hdr_bdl],
  * [pht_bdl] and [sht_bdl].
  *)
(*val string_of_elf32_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf32_file -> string*)

(** [string_of_elf64_file hdr_bdl pht_bdl sht_bdl f1] produces a string-based
  * representation of ELF file [f1] using ABI-specific print bundles [hdr_bdl],
  * [pht_bdl] and [sht_bdl].
  *)
(*val string_of_elf64_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf64_file -> string*)

(** [flag_is_set flag v] checks whether flag [flag] is set in [v].
  * TODO: move elsewhere.  Check whether this is still being used.
  *)
(*val flag_is_set : natural -> natural -> bool*)
definition flag_is_set  :: " nat \<Rightarrow> nat \<Rightarrow> bool "  where 
     " flag_is_set flag v = ( 
    (* HACK: convert to elf64_xword first. Flags never live 
     * in objects bigger than 64 bits. *)
    Elf_Types_Local.uint64_land 
            (of_int (int v)) 
            (of_int (int flag))
    = (of_int (int flag)))"

end
