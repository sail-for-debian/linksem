chapter {* Generated by Lem from gnu_extensions/gnu_ext_dynamic.lem. *}

theory "Gnu_ext_dynamic" 

imports 
 	 Main
	 "../../lem-libs/isabelle-lib/Lem_num" 
	 "../../lem-libs/isabelle-lib/Lem_basic_classes" 
	 "../../lem-libs/isabelle-lib/Lem_bool" 
	 "../../lem-libs/isabelle-lib/Lem_string" 
	 "Show" 
	 "Error" 
	 "Elf_types_native_uint" 
	 "String_table" 
	 "Elf_dynamic" 

begin 

(** [gnu_ext_dynamic] contains GNU extension specific definitions related to the
  * .dynamic section of an ELF file.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Num*)
(*open import String*)

(*open import Error*)
(*open import Show*)
(*open import String_table*)

(*open import Elf_dynamic*)
(*open import Elf_types_native_uint*)

(** Additional dynamic entries, see LSB section 11.3.2.2.
  * All values taken from elf.c from binutils and GLIBC as the LSB does not
  * specify them.
  *
  *  98 #define OLD_DT_LOOS     0x60000000
  *  99 #define DT_LOOS         0x6000000d
  * 100 #define DT_HIOS         0x6ffff000
  * 101 #define DT_VALRNGLO     0x6ffffd00
  * 102 #define DT_VALRNGHI     0x6ffffdff
  * 103 #define DT_ADDRRNGLO    0x6ffffe00
  * 104 #define DT_ADDRRNGHI    0x6ffffeff
  * 105 #define DT_VERSYM       0x6ffffff0
  * 106 #define DT_RELACOUNT    0x6ffffff9
  * 107 #define DT_RELCOUNT     0x6ffffffa
  * 108 #define DT_FLAGS_1      0x6ffffffb
  * 109 #define DT_VERDEF       0x6ffffffc
  * 110 #define DT_VERDEFNUM    0x6ffffffd
  * 111 #define DT_VERNEED      0x6ffffffe
  * 112 #define DT_VERNEEDNUM   0x6fffffff
  * 113 #define OLD_DT_HIOS     0x6fffffff
  * 114 #define DT_LOPROC       0x70000000
  * 115 #define DT_HIPROC       0x7fffffff
  *)

definition elf_dt_gnu_addrrnghi  :: " nat "  where 
     " elf_dt_gnu_addrrnghi = ( (( 939523967 :: nat) *( 2 :: nat)) +( 1 :: nat))"
  (*0x6ffffeff*)
definition elf_dt_gnu_addrrnglo  :: " nat "  where 
     " elf_dt_gnu_addrrnglo = (( 939523840 :: nat) *( 2 :: nat))"
        (*0x6ffffe00*)
definition elf_dt_gnu_auxiliary  :: " nat "  where 
     " elf_dt_gnu_auxiliary = ( (( 1073741822 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x7ffffffd*)
definition elf_dt_gnu_filter  :: " nat "  where 
     " elf_dt_gnu_filter = ( (( 1073741823 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x7fffffff*)
(** The following is specified in the LSB document but is not present in the
  * elf.c file so taken from elf.h from GLIBC:
  *)
definition elf_dt_gnu_num  :: " nat "  where 
     " elf_dt_gnu_num = (( 32 :: nat))"
 (** ??? This should match something *)
definition elf_dt_gnu_posflag_1  :: " nat "  where 
     " elf_dt_gnu_posflag_1 = ( (( 939523838 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffdfd*)
definition elf_dt_gnu_relcount  :: " nat "  where 
     " elf_dt_gnu_relcount = (( 939524093 :: nat) *( 2 :: nat))"
       (*0x6ffffffa*)
definition elf_dt_gnu_relacount  :: " nat "  where 
     " elf_dt_gnu_relacount = ( (( 939524092 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6FFFFFF9*)
definition elf_dt_gnu_syminent  :: " nat "  where 
     " elf_dt_gnu_syminent = ( (( 939523839 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffdff*)
definition elf_dt_gnu_syminfo  :: " nat "  where 
     " elf_dt_gnu_syminfo = ( (( 939523967 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffeff*)
definition elf_dt_gnu_syminsz  :: " nat "  where 
     " elf_dt_gnu_syminsz = (( 939523839 :: nat) *( 2 :: nat))"
       (*0x6ffffdfe*)
definition elf_dt_gnu_valrnghi  :: " nat "  where 
     " elf_dt_gnu_valrnghi = ( (( 939523839 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffdff*)
definition elf_dt_gnu_valrnglo  :: " nat "  where 
     " elf_dt_gnu_valrnglo = ( (( 939523712 :: nat) *( 2 :: nat)))"
     (*0x6ffffd00*)
definition elf_dt_gnu_verdef  :: " nat "  where 
     " elf_dt_gnu_verdef = (( 939524094 :: nat) *( 2 :: nat))"
       (*0x6ffffffc*)
definition elf_dt_gnu_verdefnum  :: " nat "  where 
     " elf_dt_gnu_verdefnum = ( (( 939524094 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffffd*)
definition elf_dt_gnu_verneed  :: " nat "  where 
     " elf_dt_gnu_verneed = (( 939524095 :: nat) *( 2 :: nat))"
       (*0x6ffffffe*)
definition elf_dt_gnu_verneednum  :: " nat "  where 
     " elf_dt_gnu_verneednum = ( (( 939524095 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6fffffff*)
definition elf_dt_gnu_versym  :: " nat "  where 
     " elf_dt_gnu_versym = (( 939524088 :: nat) *( 2 :: nat))"
       (*0x6ffffff0*)

(** Not present in the LSB but turns up in real ELF files... *)

definition elf_dt_gnu_hash  :: " nat "  where 
     " elf_dt_gnu_hash = ( (( 939523962 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffef5*)
definition elf_dt_gnu_flags_1  :: " nat "  where 
     " elf_dt_gnu_flags_1 = ( (( 939524093 :: nat) *( 2 :: nat)) +( 1 :: nat))"
 (*0x6ffffffb*)
definition elf_dt_gnu_checksum  :: " nat "  where 
     " elf_dt_gnu_checksum = ( (( 939523836 :: nat) *( 2 :: nat)))"
     (* 0x6FFFFDF8 *)
definition elf_dt_gnu_prelinked  :: " nat "  where 
     " elf_dt_gnu_prelinked = ( (( 2 :: nat) *( 939523834 :: nat)) +( 1 :: nat))"
 (* 0x6FFFFDF5 *)

(** Extended DT flags for FLAGS_1 dynamic section types.  Taken from GLibC source
  * as they appear to be completely unspecified!
  *)
  
definition gnu_df_1_now  :: " nat "  where 
     " gnu_df_1_now = (( 1 :: nat))"
     (*0x00000001*)
definition gnu_df_1_global  :: " nat "  where 
     " gnu_df_1_global = (( 2 :: nat))"
     (*0x00000002*)
definition gnu_df_1_group  :: " nat "  where 
     " gnu_df_1_group = (( 4 :: nat))"
     (*0x00000004*)
definition gnu_df_1_nodelete  :: " nat "  where 
     " gnu_df_1_nodelete = (( 8 :: nat))"
     (*0x00000008*)
definition gnu_df_1_loadfltr  :: " nat "  where 
     " gnu_df_1_loadfltr = (( 16 :: nat))"
    (*0x00000010*)
definition gnu_df_1_initfirst  :: " nat "  where 
     " gnu_df_1_initfirst = (( 32 :: nat))"
    (*0x00000020*)
definition gnu_df_1_noopen  :: " nat "  where 
     " gnu_df_1_noopen = (( 64 :: nat))"
    (*0x00000040*)
definition gnu_df_1_origin  :: " nat "  where 
     " gnu_df_1_origin = (( 128 :: nat))"
   (*0x00000080*)
definition gnu_df_1_direct  :: " nat "  where 
     " gnu_df_1_direct = (( 256 :: nat))"
   (*0x00000100*)
definition gnu_df_1_trans  :: " nat "  where 
     " gnu_df_1_trans = (( 512 :: nat))"
   (*0x00000200*)
definition gnu_df_1_interpose  :: " nat "  where 
     " gnu_df_1_interpose = (( 1024 :: nat))"
  (*0x00000400*)
definition gnu_df_1_nodeflib  :: " nat "  where 
     " gnu_df_1_nodeflib = (( 2048 :: nat))"
  (*0x00000800*)
definition gnu_df_1_nodump  :: " nat "  where 
     " gnu_df_1_nodump = (( 4096 :: nat))"
  (*0x00001000*)
definition gnu_df_1_confalt  :: " nat "  where 
     " gnu_df_1_confalt = (( 8192 :: nat))"
  (*0x00002000*)
definition gnu_df_1_endfiltee  :: " nat "  where 
     " gnu_df_1_endfiltee = (( 16384 :: nat))"
 (*0x00004000*)
definition gnu_df_1_dispreldne  :: " nat "  where 
     " gnu_df_1_dispreldne = (( 32768 :: nat))"
 (*0x00008000*)
definition gnu_df_1_disprelpnd  :: " nat "  where 
     " gnu_df_1_disprelpnd = (( 65536 :: nat))"
 (*0x00010000*)

(** [gnu_string_of_dt_flag1 m] produces a string based representation of GNU
  * extensions flag_1 value [m].
  *)
(*val gnu_string_of_dt_flag_1 : natural -> string*)

(** [gnu_ext_os_additional_ranges m] checks whether dynamic section type [m]
  * lies within the ranges set aside for GNU specific functionality.
  * NB: quite ad hoc as this is not properly specified anywhere.
  *)
(*val gnu_ext_os_additional_ranges : natural -> bool*)
definition gnu_ext_os_additional_ranges  :: " nat \<Rightarrow> bool "  where 
     " gnu_ext_os_additional_ranges m = (
  if (m \<ge> elf_dt_gnu_addrrnglo) \<and> (m \<le> elf_dt_gnu_addrrnghi) then
    True
  else    
( (* ad hoc extensions go here... *)m = elf_dt_gnu_verneed) \<or>
    ((m = elf_dt_gnu_verneednum) \<or>
    ((m = elf_dt_gnu_versym) \<or>
    ((m = elf_dt_gnu_verdef) \<or>
    ((m = elf_dt_gnu_verdefnum) \<or>
    ((m = elf_dt_gnu_flags_1) \<or>
    ((m = elf_dt_gnu_relcount) \<or>
    ((m = elf_dt_gnu_relacount) \<or>
    ((m = elf_dt_gnu_checksum) \<or>    
(m = elf_dt_gnu_prelinked))))))))))"


(** [gnu_ext_tag_correspondence_of_tag0 m] produces a tag correspondence for the
  * extended GNU-specific dynamic section types [m].  Used to provide the ABI
  * specific functionality expected of the corresponding function in the elf_dynamic
  * module.
  *)
(*val gnu_ext_tag_correspondence_of_tag0 : natural -> error tag_correspondence*)
definition gnu_ext_tag_correspondence_of_tag0  :: " nat \<Rightarrow>(tag_correspondence)error "  where 
     " gnu_ext_tag_correspondence_of_tag0 m = (
  if m = elf_dt_gnu_hash then
    error_return C_Ptr
  else if m = elf_dt_gnu_flags_1 then
    error_return C_Val
  else if m = elf_dt_gnu_versym then
    error_return C_Ptr
  else if m = elf_dt_gnu_verneednum then
    error_return C_Val
  else if m = elf_dt_gnu_verneed then
    error_return C_Ptr
  else if m = elf_dt_gnu_verdef then
    error_return C_Ptr
  else if m = elf_dt_gnu_verdefnum then
    error_return C_Val
  else if m = elf_dt_gnu_relcount then
    error_return C_Val
  else if m = elf_dt_gnu_relacount then
    error_return C_Val
  else if m = elf_dt_gnu_checksum then
    error_return C_Val
  else if m = elf_dt_gnu_prelinked then
    error_return C_Val
  else
    error_fail (''gnu_ext_tag_correspondence_of_tag0: invalid dynamic tag''))"


(** [gnu_ext_tag_correspondence_of_tag m] produces a tag correspondence for the
  * extended GNU-specific dynamic section types [m].  Used to provide the ABI
  * specific functionality expected of the corresponding function in the elf_dynamic
  * module.
  * TODO: examine whether this and the function above really need separating into
  * two functions.
  *)
(*val gnu_ext_tag_correspondence_of_tag : natural -> error tag_correspondence*)
definition gnu_ext_tag_correspondence_of_tag  :: " nat \<Rightarrow>(tag_correspondence)error "  where 
     " gnu_ext_tag_correspondence_of_tag m = (
  if (m \<ge> elf_dt_gnu_addrrnglo) \<and> (m \<le> elf_dt_gnu_addrrnghi) then
    error_return C_Ptr
  else if (m \<ge> elf_dt_gnu_valrnglo) \<and> (m \<le> elf_dt_gnu_valrnghi) then
    error_return C_Val
  else if gnu_ext_os_additional_ranges m then
    gnu_ext_tag_correspondence_of_tag0 m
  else if m = elf_dt_gnu_syminsz then
    error_return C_Val (** unsure *)
  else if m = elf_dt_gnu_syminfo then
    error_return C_Ptr (** unsure *)
  else if m = elf_dt_gnu_syminent then
    error_return C_Val (** unsure *)
  else if m = elf_dt_gnu_posflag_1 then
    error_return C_Val (** unsure *)
  else if m = elf_dt_gnu_num then
    error_return C_Ignored
  else if m = elf_dt_gnu_filter then
    error_return C_Val (** unsure *)
  else if m = elf_dt_gnu_auxiliary then
    error_return C_Val (** unsure *)
  else
    error_fail ((''gnu_ext_tag_correspondence_of_tag: unrecognised GNU dynamic tag'')))"

    
(** [gnu_ext_elf32_value_of_elf32_dyn0 dyn] extracts a dynamic value from the
  * dynamic section entry [dyn] under the assumption that its type is a GNU
  * extended dynamic section type.  Fails otherwise.  Used to provide the
  * ABI-specific functionality expected of the corresponding functions in
  * elf_dynamic.lem.
  *)
(*val gnu_ext_elf32_value_of_elf32_dyn0 : elf32_dyn -> string_table -> error elf32_dyn_value*)
definition gnu_ext_elf32_value_of_elf32_dyn0  :: " elf32_dyn \<Rightarrow> string_table \<Rightarrow>(((uint32),(uint32))dyn_value)error "  where 
     " gnu_ext_elf32_value_of_elf32_dyn0 dyn stbl = (
  (let tag = (nat (abs (sint(elf32_dyn_tag   dyn)))) in
    if tag = elf_dt_gnu_hash then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: GNU_HASH must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: GNU_HASH must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_flags_1 then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: FLAGS_1 must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: FlAGS_1 must be a Val'')
      ) >>= (\<lambda> f . 
      error_return (Flags1 (unat f)))
    else if tag = elf_dt_gnu_versym then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERSYM must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERSYM must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_verdef then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERDEF must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERDEF must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_verdefnum then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERDEFNUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERDEFNUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_verneednum then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERNEEDNUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERNEEDNUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_verneed then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERNEED must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: VERNEED must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_relcount then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: RELCOUNT must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: RELCOUNT must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_relacount then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: RELACOUNT must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: RELACOUNT must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_checksum then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: CHECKSUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: CHECKSUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Checksum (unat sz)))
    else if tag = elf_dt_gnu_prelinked then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: GNU_PRELINKED must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: GNU_PRELINKED must be a Val'')
      ) >>= (\<lambda> off . 
      error_return (Timestamp (unat off)))
    else
      error_fail (''gnu_ext_elf32_value_of_elf32_dyn0: unrecognised GNU dynamic tag'')))"

      
(** [gnu_ext_elf64_value_of_elf64_dyn0 dyn] extracts a dynamic value from the
  * dynamic section entry [dyn] under the assumption that its type is a GNU
  * extended dynamic section type.  Fails otherwise.  Used to provide the
  * ABI-specific functionality expected of the corresponding functions in
  * elf_dynamic.lem.
  *)
(*val gnu_ext_elf64_value_of_elf64_dyn0 : elf64_dyn -> string_table -> error elf64_dyn_value*)
definition gnu_ext_elf64_value_of_elf64_dyn0  :: " elf64_dyn \<Rightarrow> string_table \<Rightarrow>(((Elf_Types_Local.uint64),(uint64))dyn_value)error "  where 
     " gnu_ext_elf64_value_of_elf64_dyn0 dyn stbl = (
  (let tag = (nat (abs (sint(elf64_dyn_tag   dyn)))) in
    if tag = elf_dt_gnu_hash then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: GNU_HASH must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: GNU_HASH must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_flags_1 then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: FLAGS_1 must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: FlAGS_1 must be a Val'')
      ) >>= (\<lambda> f . 
      error_return (Flags1 (unat f)))
    else if tag = elf_dt_gnu_versym then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERSYM must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERSYM must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_verdef then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERDEF must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERDEF must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_verdefnum then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf64_dyn: VERDEFNUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf64_dyn: VERDEFNUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_verneednum then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERNEEDNUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERNEEDNUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_verneed then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERNEED must be a PTR'')
        | D_Ptr     p => error_return p
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: VERNEED must be a PTR'')
      ) >>= (\<lambda> addr . 
      error_return (Address addr))
    else if tag = elf_dt_gnu_relcount then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: RELCOUNT must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: RELCOUNT must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_relacount then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: RELACOUNT must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: RELACOUNT must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Numeric (unat sz)))
    else if tag = elf_dt_gnu_checksum then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: CHECKSUM must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: CHECKSUM must be a Val'')
      ) >>= (\<lambda> sz . 
      error_return (Checksum (unat sz)))
    else if tag = elf_dt_gnu_prelinked then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: GNU_PRELINKED must be a Val'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: GNU_PRELINKED must be a Val'')
      ) >>= (\<lambda> off . 
      error_return (Timestamp (unat off)))
    else
      error_fail (''gnu_ext_elf64_value_of_elf64_dyn0: unrecognised GNU dynamic tag'')))"

      
(** [gnu_ext_elf32_value_of_elf32_dyn dyn] extracts a dynamic value from the
  * dynamic section entry [dyn] under the assumption that its type is a GNU
  * extended dynamic section type.  Fails otherwise.  Used to provide the
  * ABI-specific functionality expected of the corresponding functions in
  * elf_dynamic.lem.
  * TODO: some of these cases are missing as they have never come up in real
  * ELF files that have been processed as part of validation.  Try and find some
  * files that do actually exhibit these.
  *)
(*val gnu_ext_elf32_value_of_elf32_dyn : elf32_dyn -> string_table -> error elf32_dyn_value*)
definition gnu_ext_elf32_value_of_elf32_dyn  :: " elf32_dyn \<Rightarrow> string_table \<Rightarrow>(elf32_dyn_value)error "  where 
     " gnu_ext_elf32_value_of_elf32_dyn dyn stbl = (
  (let tag = (nat (abs (sint(elf32_dyn_tag   dyn)))) in
    if gnu_ext_os_additional_ranges tag then (* this should cover valrngs and addrrngs *)
      gnu_ext_elf32_value_of_elf32_dyn0 dyn stbl
    else if tag = elf_dt_gnu_syminsz then
      (case (elf32_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: SYMINSZ must be a VAL'')
        | D_Ignored i => error_fail (''gnu_ext_elf32_value_of_elf32_dyn: SYMINSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = elf_dt_gnu_syminfo then
      error_fail (''SYMINFO'') (* XXX: never seen in 32-bit ELF *)
    else if tag = elf_dt_gnu_syminent then
      error_fail (''SYMINENT'') (* XXX: never seen in 32-bit ELF *)
    else if tag = elf_dt_gnu_posflag_1 then
      error_fail (''POSFLAG_1'') (* XXX: never seen in 32-bit ELF *)
    else if tag = elf_dt_gnu_num then
      error_fail (''NUM'') (* XXX: never seen in 32-bit ELF *)
    else if tag = elf_dt_gnu_filter then
      error_fail (''FILTER'') (* XXX: never seen in 32-bit ELF *)
    else if tag = elf_dt_gnu_auxiliary then
      error_fail (''AUXILIARY'') (* XXX: never seen in 32-bit ELF *)
    else
      error_fail (''gnu_ext_elf32_value_of_elf32_dyn: unrecognised GNU dynamic tag'')))"

      
(** [gnu_ext_elf64_value_of_elf64_dyn dyn] extracts a dynamic value from the
  * dynamic section entry [dyn] under the assumption that its type is a GNU
  * extended dynamic section type.  Fails otherwise.  Used to provide the
  * ABI-specific functionality expected of the corresponding functions in
  * elf_dynamic.lem.
  * TODO: some of these cases are missing as they have never come up in real
  * ELF files that have been processed as part of validation.  Try and find some
  * files that do actually exhibit these.
  *)
(*val gnu_ext_elf64_value_of_elf64_dyn : elf64_dyn -> string_table -> error elf64_dyn_value*)
definition gnu_ext_elf64_value_of_elf64_dyn  :: " elf64_dyn \<Rightarrow> string_table \<Rightarrow>(elf64_dyn_value)error "  where 
     " gnu_ext_elf64_value_of_elf64_dyn dyn stbl = (
  (let tag = (nat (abs (sint(elf64_dyn_tag   dyn)))) in
    if gnu_ext_os_additional_ranges tag then (* this should cover valrngs and addrrngs *)
      gnu_ext_elf64_value_of_elf64_dyn0 dyn stbl
    else if tag = elf_dt_gnu_syminsz then
      (case (elf64_dyn_d_un   dyn) of
          D_Val     v => error_return v
        | D_Ptr     p => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: SYMINSZ must be a VAL'')
        | D_Ignored i => error_fail (''gnu_ext_elf64_value_of_elf64_dyn: SYMINSZ must be a VAL'')
      ) >>= (\<lambda> sz . 
      error_return (Size sz))
    else if tag = elf_dt_gnu_syminfo then
      error_fail (''SYMINFO'') (* XXX: fill in as seen *)
    else if tag = elf_dt_gnu_syminent then
      error_fail (''SYMINENT'') (* XXX: fill in as seen *)
    else if tag = elf_dt_gnu_posflag_1 then
      error_fail (''POSFLAG_1'') (* XXX: fill in as seen *)
    else if tag = elf_dt_gnu_num then
      error_fail (''NUM'') (* XXX: fill in as seen *)
    else if tag = elf_dt_gnu_filter then
      error_fail (''FILTER'') (* XXX: fill in as seen *)
    else if tag = elf_dt_gnu_auxiliary then
      error_fail (''AUXILIARY'') (* XXX: fill in as seen *)
    else
      error_fail (''gnu_ext_elf64_value_of_elf64_dyn: unrecognised GNU dynamic tag'')))"

    
(** [string_of_gnu_ext_dynamic_tag0 m] produces a string based representation of
  * GNU extensions dynamic tag value [m].
  *)
(*val string_of_gnu_ext_dynamic_tag0 : natural -> string*)
    
(** [string_of_gnu_ext_dynamic_tag m] produces a string based representation of
  * GNU extensions dynamic tag value [m].
  *)
(*val string_of_gnu_ext_dynamic_tag : natural -> string*)
end
